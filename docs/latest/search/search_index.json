{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 cdk8s is a software development framework for defining Kubernetes applications and reusable abstractions using familiar programming languages and rich object-oriented APIs. cdk8s generates pure Kubernetes YAML - you can use cdk8s to define applications for any Kubernetes cluster running anywhere. Read our blog or watch our CNCF webinar to learn more and see a live demo of cdk8s in action. How does it work \u00b6 cdk8s apps are programs written in one of the supported programming languages. They are structured as a tree of constructs . The root of the tree is an App construct. Within an app, users define any number of charts (classes that extend the Chart class). Each chart is synthesized into a separate Kubernetes manifest file. Charts are, in turn, composed of any number of constructs, and eventually from resources, which represent any Kubernetes resource, such as Pod , Service , Deployment , ReplicaSet , etc. cdk8s apps only define Kubernetes applications, they don\u2019t actually apply them to the cluster. When an app is executed, it synthesizes all the charts defined within the app into the dist directory, and then those charts can be applied to any Kubernetes cluster using kubectl apply -f dist/chart.k8s.yaml or a GitOps tool like Flux . cdk8s is based on the design concepts and technologies behind the AWS Cloud Development Kit , and can interoperate with AWS CDK constructs to define cloud-native applications that include both Kubernetes resources and other CDK constructs as first class citizens.","title":"Overview"},{"location":"#overview","text":"cdk8s is a software development framework for defining Kubernetes applications and reusable abstractions using familiar programming languages and rich object-oriented APIs. cdk8s generates pure Kubernetes YAML - you can use cdk8s to define applications for any Kubernetes cluster running anywhere. Read our blog or watch our CNCF webinar to learn more and see a live demo of cdk8s in action.","title":"Overview"},{"location":"#how-does-it-work","text":"cdk8s apps are programs written in one of the supported programming languages. They are structured as a tree of constructs . The root of the tree is an App construct. Within an app, users define any number of charts (classes that extend the Chart class). Each chart is synthesized into a separate Kubernetes manifest file. Charts are, in turn, composed of any number of constructs, and eventually from resources, which represent any Kubernetes resource, such as Pod , Service , Deployment , ReplicaSet , etc. cdk8s apps only define Kubernetes applications, they don\u2019t actually apply them to the cluster. When an app is executed, it synthesizes all the charts defined within the app into the dist directory, and then those charts can be applied to any Kubernetes cluster using kubectl apply -f dist/chart.k8s.yaml or a GitOps tool like Flux . cdk8s is based on the design concepts and technologies behind the AWS Cloud Development Kit , and can interoperate with AWS CDK constructs to define cloud-native applications that include both Kubernetes resources and other CDK constructs as first class citizens.","title":"How does it work"},{"location":"getting-started/","text":"Getting Started \u00b6 This guide will walk you through the following steps: Installing the cdk8s CLI. Creating a new cdk8s project in one of the supported programming languages. Define & deploy your first cdk8s application. Define a custom cdk8s construct. Install the CLI \u00b6 cdk8s has a cute little CLI that has a few useful commands. Let\u2019s start by installing the cdk8s CLI globally. We have three options for this. Homebrew brew install cdk8s npm npm install -g cdk8s-cli yarn yarn global add cdk8s-cli Prerequisites \u00b6 Set up pre-requisites based on the language you wish to write your cdk8s code in. TypeScript Node.js >= 12.13.0 Your favorite editor/IDE yarn (optional) Python Python >= 3.7.7 pipenv version 2018.11.26 or above. Your favorite editor/IDE Java Maven >= 3.6.3 Your favorite editor/IDE Go Go >= 1.16 Your favorite editor/IDE Info This Getting Started guide will help you create a Kubernetes manifest using your preferred programming language. You do not need access to a Kubernetes cluster in order to produce a manifests using cdk8s. New Project \u00b6 Now, we\u2019ll use the cdk8s init command to create a new cdk8s app: TypeScript $ mkdir hello $ cd hello $ cdk8s init typescript-app Initializing a project from the typescript-app template ... Python $ mkdir hello $ cd hello $ cdk8s init python-app Initializing a project from the python-app template ... Java $ mkdir hello $ cd hello $ cdk8s init java-app Initializing a project from the java-app template ... Go $ mkdir hello $ cd hello $ cdk8s init go-app Initializing a project from the go-app template This will perform the following: Create a new project directory Install cdk8s as a dependency Import all Kubernetes API objects Apps & Charts \u00b6 Apps are structured as a tree of constructs , which are composable units of abstraction. We will learn more about constructs soon. This initial code created by cdk8s init defines an app with a single, empty, chart. When you synthesize the app, a Kubernetes manifest YAML will be produced for each Chart in your app and will write it to the dist directory. At this point, the YAML file should be empty since we haven\u2019t defined any resources yet. Let have a look at the code: TypeScript main.ts import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); // define resources here } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); To produce and inspect the generated manifest, you can run: npm run compile && cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> Note that since TypeScript is a compiled language, we will need to compile .ts files to .js in order to execute our cdk8s app. To avoid explicitly compiling every time, you can run a watch process in the background by running: npm run watch Python main.py #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here app = App () MyChart ( app , \"hello\" ) app . synth () To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> Java src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // define resources here } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> Go main.go package main import ( \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) // define resources here return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> Importing Constructs for the Kubernetes API \u00b6 OK, now let\u2019s define some Kubernetes API objects inside our chart. Similarly to charts and apps , Kubernetes API Objects are also represented in cdk8s as constructs . These constructs are imported to your project using the cdk8s import command which will add source files to your project that include constructs that represent the Kubernetes API. Info When cdk8s init created your project it already executed cdk8s import for you, so you should see an imports directory already there. You can either commit this directory to source-control or generate it as part of your build process. Now, let\u2019s use these constructs to define a simple Kubernetes application which contains Service and a Deployment resources inspired by paulbouwer \u2018s hello-kubernetes project. TypeScript import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; // imported constructs import { KubeDeployment , KubeService , IntOrString } from './imports/k8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); const label = { app : 'hello-k8s' }; // notice that there is no assigment necessary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // atrtibutes of the resource in other parts of the code. new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port : 80 , targetPort : IntOrString.fromNumber ( 8080 ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas : 2 , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'hello-kubernetes' , image : 'paulbouwer/hello-kubernetes:1.7' , ports : [ { containerPort : 8080 } ] } ] } } } }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Now, to synthesize the app, run: npm run compile && cdk8s synth Python #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from imports import k8s class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here label = { \"app\" : \"hello-k8s\" } # notice that there is no assigment necessary when creating resources. # simply instantiating the resource is enough because it adds it to the construct tree via # the first argument, which is always the parent construct. # its a little confusing at first glance, but this is an inherent aspect of the constructs # programming model, and you will encounter it many times. # you can still perform an assignment of course, if you need to access # atrtibutes of the resource in other parts of the code. k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = 80 , target_port = k8s . IntOrString . from_number ( 8080 ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = 2 , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'hello-kubernetes' , image = 'paulbouwer/hello-kubernetes:1.7' , ports = [ k8s . ContainerPort ( container_port = 8080 )])])))) app = App () MyChart ( app , \"hello\" ) app . synth () Now, to synthesize the app, run: cdk8s synth Java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( 80 ) . targetPort ( IntOrString . fromNumber ( 8080 )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); // notice that there is no assigment neccesary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // atrtibutes of the resource in other parts of the code. new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( 8080 ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"hello-kubernetes\" ) . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( 1 ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } Now, to synthesize the app, run: cdk8s synth Go package main import ( \"example.com/hello-k8s/imports/k8s\" \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) label := map [ string ] * string { \"app\" : jsii . String ( \"hello-k8s\" )} k8s . NewKubeService ( chart , jsii . String ( \"service\" ), & k8s . KubeServiceProps { Spec : & k8s . ServiceSpec { Type : jsii . String ( \"LoadBalancer\" ), Ports : & [] * k8s . ServicePort {{ Port : jsii . Number ( 80 ), TargetPort : k8s . IntOrString_FromNumber ( jsii . Number ( 8000 )), }}, Selector : & label , }, }) // notice that there is no assigment neccesary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // atrtibutes of the resource in other parts of the code. k8s . NewKubeDeployment ( chart , jsii . String ( \"deployment\" ), & k8s . KubeDeploymentProps { Spec : & k8s . DeploymentSpec { Replicas : jsii . Number ( 2 ), Selector : & k8s . LabelSelector { MatchLabels : & label , }, Template : & k8s . PodTemplateSpec { Metadata : & k8s . ObjectMeta { Labels : & label , }, Spec : & k8s . PodSpec { Containers : & [] * k8s . Container {{ Name : jsii . String ( \"hello-kubernetes\" ), Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), Ports : & [] * k8s . ContainerPort {{ ContainerPort : jsii . Number ( 8080 )}}, }}, }, }, }, }) return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } Now, to synthesize the app, run: cdk8s synth This will be contents of hello.k8s.yaml : apiVersion : \"v1\" kind : \"Service\" metadata : name : \"hello-service-c8c17160\" spec : ports : - port : 80 targetPort : 8080 selector : app : \"hello-k8s\" type : \"LoadBalancer\" --- apiVersion : \"apps/v1\" kind : \"Deployment\" metadata : name : \"hello-deployment-c8c7fda7\" spec : replicas : 2 selector : matchLabels : app : \"hello-k8s\" template : metadata : labels : app : \"hello-k8s\" spec : containers : - image : \"paulbouwer/hello-kubernetes:1.7\" name : \"hello-kubernetes\" ports : - containerPort : 8080 The manifest synthesized by your app is ready to be applied to any Kubernetes cluster using standard tools like kubectl apply : kubectl apply -f dist/hello.k8s.yaml Abstraction through Constructs \u00b6 Constructs are the basic building block of cdk8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years. So let\u2019s create our first Kubernetes construct. We\u2019ll call it WebService and it will basically be a generalization of the hello world program. It\u2019s actually quite useful. For example, this one line will add a hello world service to our chart: TypeScript new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' }); It can also be customized through an API: new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' , containerPort : 8080 , replicas : 10 }); Python WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' ) It can also be customized through an API: WebService ( self , 'hello-k8s' , image = 'paulbouwer/hello-kubernetes:1.7' , container_port = 8080 , replicas = 10 ) Java new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . build ()); It can also be customized through an API: new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); Go NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), }) It can also be customized through an API: NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), ContainerPort : jsii . Number ( 8080 ), Replicas : jsii . Number ( 10 ), }) Here\u2019s how to implement WebService : TypeScript Create a file lib/web-service.ts (the convention is to use lib for reusable components): import { Construct } from 'constructs' ; import { Names } from 'cdk8s' ; import { KubeDeployment , KubeService , IntOrString } from '../imports/k8s' ; export interface WebServiceProps { /** * The Docker image to use for this service. */ readonly image : string ; /** * Number of replicas. * * @default 1 */ readonly replicas? : number ; /** * External port. * * @default 80 */ readonly port? : number ; /** * Internal port. * * @default 8080 */ readonly containerPort? : number ; } export class WebService extends Construct { constructor ( scope : Construct , id : string , props : WebServiceProps ) { super ( scope , id ); const port = props . port || 80 ; const containerPort = props . containerPort || 8080 ; const label = { app : Names.toDnsLabel ( this ) }; const replicas = props . replicas ?? 1 ; new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port , targetPort : IntOrString.fromNumber ( containerPort ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'app' , image : props.image , ports : [ { containerPort } ] } ] } } } }); } } Now, let\u2019s edit main.ts and use our new construct: import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; import { WebService } from './lib/web-service' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); new WebService ( this , 'hello' , { image : 'paulbouwer/hello-kubernetes:1.7' , replicas : 2 }); new WebService ( this , 'ghost' , { image : 'ghost' , containerPort : 2368 }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Python Create a file webservice.py with the following content: from constructs import Construct , Node from imports import k8s class WebService ( Construct ): def __init__ ( self , scope : Construct , id : str , * , image : str , replicas : int = 1 , port : int = 80 , container_port : int = 8080 ): super () . __init__ ( scope , id ) label = { 'app' : Node . of ( self ) . unique_id } k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = port , target_port = k8s . IntOrString . from_number ( container_port ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = replicas , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'app' , image = image , ports = [ k8s . ContainerPort ( container_port = container_port )])])))) Now, let\u2019s edit main.py and use our new construct: #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from webservice import WebService class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' , replicas = 2 ) WebService ( self , 'ghost' , image = 'ghost' , container_port = 2368 ) app = App () MyChart ( app , \"hello\" ) app . synth () Java src/main/java/com/mycompany/app/WebService.java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import java.util.Optional ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class WebService extends Construct { public WebService ( final Construct scope , final String id ) { this ( scope , id , null ); } public WebService ( final Construct scope , final String id , final WebServiceProps options ) { super ( scope , id ); final int portNumber = Optional . of ( options . getPort ()). orElse ( 80 ); final int containerPortNumber = Optional . of ( options . getContainerPort ()). orElse ( 8080 ); final int replicas = Optional . of ( options . getReplicas ()). orElse ( 1 ); final String image = options . getImage (); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( portNumber ) . targetPort ( IntOrString . fromNumber ( containerPortNumber )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( containerPortNumber ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"web\" ) . image ( image ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( replicas ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } } src/main/java/com/mycompany/app/WebServiceProps.java package com.mycompany.app ; public class WebServiceProps { private String image ; private int replicas ; private int port ; private int containerPort ; public WebServiceProps ( final String image , final int replicas , final int port , final int containerPort ) { this . image = image ; this . replicas = replicas ; this . port = port ; this . containerPort = containerPort ; } public String getImage () { return this . image ; } public int getReplicas () { return this . replicas ; } public int getPort () { return this . port ; } public int getContainerPort () { return this . containerPort ; } public static final class Builder { private String image ; private int replicas = 1 ; private int port = 80 ; private int containerPort = 8080 ; public Builder image ( String image ) { this . image = image ; return this ; } public Builder replicas ( int replicas ) { this . replicas = replicas ; return this ; } public Builder port ( int port ) { this . port = port ; return this ; } public Builder containerPort ( int containerPort ) { this . containerPort = containerPort ; return this ; } public WebServiceProps build () { return new WebServiceProps ( image , replicas , port , containerPort ); } } } src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); new WebService ( this , \"hello\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); new WebService ( this , \"ghost\" , new WebServiceProps . Builder () . image ( \"ghost\" ) . containerPort ( 2368 ) . build ()); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"web-service-java\" ); app . synth (); } } Go Create a file webservice.go with the following content: package main import ( \"example.com/hello/imports/k8s\" \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" ) type WebServiceProps struct { constructs . ConstructOptions Image * string Replicas * float64 Port * float64 ContainerPort * float64 } func NewWebService ( scope constructs . Construct , id * string , props * WebServiceProps ) constructs . Construct { var cprops constructs . ConstructOptions if props != nil { cprops = props . ConstructOptions } construct := constructs . NewConstruct ( scope , id , & cprops ) replicas := props . Replicas if replicas == nil { replicas = jsii . Number ( 1 ) } port := props . Port if port == nil { port = jsii . Number ( 80 ) } containerPort := props . ContainerPort if containerPort == nil { containerPort = jsii . Number ( 8080 ) } label := map [ string ] * string { \"app\" : constructs . Node_Of ( construct ). Id (), } k8s . NewKubeService ( construct , jsii . String ( \"service\" ), & k8s . KubeServiceProps { Spec : & k8s . ServiceSpec { Type : jsii . String ( \"LoadBalancer\" ), Ports : & [] * k8s . ServicePort {{ Port : port , TargetPort : k8s . IntOrString_FromNumber ( containerPort ), }}, Selector : & label , }, }) k8s . NewKubeDeployment ( construct , jsii . String ( \"deployment\" ), & k8s . KubeDeploymentProps { Spec : & k8s . DeploymentSpec { Replicas : replicas , Selector : & k8s . LabelSelector { MatchLabels : & label }, Template : & k8s . PodTemplateSpec { Metadata : & k8s . ObjectMeta { Labels : & label }, Spec : & k8s . PodSpec { Containers : & [] * k8s . Container {{ Name : jsii . String ( \"web\" ), Image : props . Image , Ports : & [] * k8s . ContainerPort {{ ContainerPort : containerPort }}, }}, }, }, }, }) return construct } Now, let\u2019s edit main.go and use our new construct: package main import ( \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), Replicas : jsii . Number ( 2 ), }) NewWebService ( chart , jsii . String ( \"ghost\" ), & WebServiceProps { Image : jsii . String ( \"ghost\" ), ContainerPort : jsii . Number ( 2368 ), }) return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } As you can see, we now add WebService constructs inside our chart: one that runs the paulbouwer/hello-kubernetes image and one with an installation of ghost .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"This guide will walk you through the following steps: Installing the cdk8s CLI. Creating a new cdk8s project in one of the supported programming languages. Define & deploy your first cdk8s application. Define a custom cdk8s construct.","title":"Getting Started"},{"location":"getting-started/#install-the-cli","text":"cdk8s has a cute little CLI that has a few useful commands. Let\u2019s start by installing the cdk8s CLI globally. We have three options for this. Homebrew brew install cdk8s npm npm install -g cdk8s-cli yarn yarn global add cdk8s-cli","title":"Install the CLI"},{"location":"getting-started/#prerequisites","text":"Set up pre-requisites based on the language you wish to write your cdk8s code in. TypeScript Node.js >= 12.13.0 Your favorite editor/IDE yarn (optional) Python Python >= 3.7.7 pipenv version 2018.11.26 or above. Your favorite editor/IDE Java Maven >= 3.6.3 Your favorite editor/IDE Go Go >= 1.16 Your favorite editor/IDE Info This Getting Started guide will help you create a Kubernetes manifest using your preferred programming language. You do not need access to a Kubernetes cluster in order to produce a manifests using cdk8s.","title":"Prerequisites"},{"location":"getting-started/#new-project","text":"Now, we\u2019ll use the cdk8s init command to create a new cdk8s app: TypeScript $ mkdir hello $ cd hello $ cdk8s init typescript-app Initializing a project from the typescript-app template ... Python $ mkdir hello $ cd hello $ cdk8s init python-app Initializing a project from the python-app template ... Java $ mkdir hello $ cd hello $ cdk8s init java-app Initializing a project from the java-app template ... Go $ mkdir hello $ cd hello $ cdk8s init go-app Initializing a project from the go-app template This will perform the following: Create a new project directory Install cdk8s as a dependency Import all Kubernetes API objects","title":"New Project"},{"location":"getting-started/#apps-charts","text":"Apps are structured as a tree of constructs , which are composable units of abstraction. We will learn more about constructs soon. This initial code created by cdk8s init defines an app with a single, empty, chart. When you synthesize the app, a Kubernetes manifest YAML will be produced for each Chart in your app and will write it to the dist directory. At this point, the YAML file should be empty since we haven\u2019t defined any resources yet. Let have a look at the code: TypeScript main.ts import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); // define resources here } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); To produce and inspect the generated manifest, you can run: npm run compile && cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> Note that since TypeScript is a compiled language, we will need to compile .ts files to .js in order to execute our cdk8s app. To avoid explicitly compiling every time, you can run a watch process in the background by running: npm run watch Python main.py #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here app = App () MyChart ( app , \"hello\" ) app . synth () To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> Java src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // define resources here } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> Go main.go package main import ( \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) // define resources here return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY>","title":"Apps &amp; Charts"},{"location":"getting-started/#importing-constructs-for-the-kubernetes-api","text":"OK, now let\u2019s define some Kubernetes API objects inside our chart. Similarly to charts and apps , Kubernetes API Objects are also represented in cdk8s as constructs . These constructs are imported to your project using the cdk8s import command which will add source files to your project that include constructs that represent the Kubernetes API. Info When cdk8s init created your project it already executed cdk8s import for you, so you should see an imports directory already there. You can either commit this directory to source-control or generate it as part of your build process. Now, let\u2019s use these constructs to define a simple Kubernetes application which contains Service and a Deployment resources inspired by paulbouwer \u2018s hello-kubernetes project. TypeScript import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; // imported constructs import { KubeDeployment , KubeService , IntOrString } from './imports/k8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); const label = { app : 'hello-k8s' }; // notice that there is no assigment necessary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // atrtibutes of the resource in other parts of the code. new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port : 80 , targetPort : IntOrString.fromNumber ( 8080 ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas : 2 , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'hello-kubernetes' , image : 'paulbouwer/hello-kubernetes:1.7' , ports : [ { containerPort : 8080 } ] } ] } } } }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Now, to synthesize the app, run: npm run compile && cdk8s synth Python #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from imports import k8s class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here label = { \"app\" : \"hello-k8s\" } # notice that there is no assigment necessary when creating resources. # simply instantiating the resource is enough because it adds it to the construct tree via # the first argument, which is always the parent construct. # its a little confusing at first glance, but this is an inherent aspect of the constructs # programming model, and you will encounter it many times. # you can still perform an assignment of course, if you need to access # atrtibutes of the resource in other parts of the code. k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = 80 , target_port = k8s . IntOrString . from_number ( 8080 ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = 2 , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'hello-kubernetes' , image = 'paulbouwer/hello-kubernetes:1.7' , ports = [ k8s . ContainerPort ( container_port = 8080 )])])))) app = App () MyChart ( app , \"hello\" ) app . synth () Now, to synthesize the app, run: cdk8s synth Java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( 80 ) . targetPort ( IntOrString . fromNumber ( 8080 )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); // notice that there is no assigment neccesary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // atrtibutes of the resource in other parts of the code. new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( 8080 ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"hello-kubernetes\" ) . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( 1 ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } Now, to synthesize the app, run: cdk8s synth Go package main import ( \"example.com/hello-k8s/imports/k8s\" \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) label := map [ string ] * string { \"app\" : jsii . String ( \"hello-k8s\" )} k8s . NewKubeService ( chart , jsii . String ( \"service\" ), & k8s . KubeServiceProps { Spec : & k8s . ServiceSpec { Type : jsii . String ( \"LoadBalancer\" ), Ports : & [] * k8s . ServicePort {{ Port : jsii . Number ( 80 ), TargetPort : k8s . IntOrString_FromNumber ( jsii . Number ( 8000 )), }}, Selector : & label , }, }) // notice that there is no assigment neccesary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // atrtibutes of the resource in other parts of the code. k8s . NewKubeDeployment ( chart , jsii . String ( \"deployment\" ), & k8s . KubeDeploymentProps { Spec : & k8s . DeploymentSpec { Replicas : jsii . Number ( 2 ), Selector : & k8s . LabelSelector { MatchLabels : & label , }, Template : & k8s . PodTemplateSpec { Metadata : & k8s . ObjectMeta { Labels : & label , }, Spec : & k8s . PodSpec { Containers : & [] * k8s . Container {{ Name : jsii . String ( \"hello-kubernetes\" ), Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), Ports : & [] * k8s . ContainerPort {{ ContainerPort : jsii . Number ( 8080 )}}, }}, }, }, }, }) return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } Now, to synthesize the app, run: cdk8s synth This will be contents of hello.k8s.yaml : apiVersion : \"v1\" kind : \"Service\" metadata : name : \"hello-service-c8c17160\" spec : ports : - port : 80 targetPort : 8080 selector : app : \"hello-k8s\" type : \"LoadBalancer\" --- apiVersion : \"apps/v1\" kind : \"Deployment\" metadata : name : \"hello-deployment-c8c7fda7\" spec : replicas : 2 selector : matchLabels : app : \"hello-k8s\" template : metadata : labels : app : \"hello-k8s\" spec : containers : - image : \"paulbouwer/hello-kubernetes:1.7\" name : \"hello-kubernetes\" ports : - containerPort : 8080 The manifest synthesized by your app is ready to be applied to any Kubernetes cluster using standard tools like kubectl apply : kubectl apply -f dist/hello.k8s.yaml","title":"Importing Constructs for the Kubernetes API"},{"location":"getting-started/#abstraction-through-constructs","text":"Constructs are the basic building block of cdk8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years. So let\u2019s create our first Kubernetes construct. We\u2019ll call it WebService and it will basically be a generalization of the hello world program. It\u2019s actually quite useful. For example, this one line will add a hello world service to our chart: TypeScript new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' }); It can also be customized through an API: new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' , containerPort : 8080 , replicas : 10 }); Python WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' ) It can also be customized through an API: WebService ( self , 'hello-k8s' , image = 'paulbouwer/hello-kubernetes:1.7' , container_port = 8080 , replicas = 10 ) Java new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . build ()); It can also be customized through an API: new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); Go NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), }) It can also be customized through an API: NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), ContainerPort : jsii . Number ( 8080 ), Replicas : jsii . Number ( 10 ), }) Here\u2019s how to implement WebService : TypeScript Create a file lib/web-service.ts (the convention is to use lib for reusable components): import { Construct } from 'constructs' ; import { Names } from 'cdk8s' ; import { KubeDeployment , KubeService , IntOrString } from '../imports/k8s' ; export interface WebServiceProps { /** * The Docker image to use for this service. */ readonly image : string ; /** * Number of replicas. * * @default 1 */ readonly replicas? : number ; /** * External port. * * @default 80 */ readonly port? : number ; /** * Internal port. * * @default 8080 */ readonly containerPort? : number ; } export class WebService extends Construct { constructor ( scope : Construct , id : string , props : WebServiceProps ) { super ( scope , id ); const port = props . port || 80 ; const containerPort = props . containerPort || 8080 ; const label = { app : Names.toDnsLabel ( this ) }; const replicas = props . replicas ?? 1 ; new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port , targetPort : IntOrString.fromNumber ( containerPort ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'app' , image : props.image , ports : [ { containerPort } ] } ] } } } }); } } Now, let\u2019s edit main.ts and use our new construct: import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; import { WebService } from './lib/web-service' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); new WebService ( this , 'hello' , { image : 'paulbouwer/hello-kubernetes:1.7' , replicas : 2 }); new WebService ( this , 'ghost' , { image : 'ghost' , containerPort : 2368 }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Python Create a file webservice.py with the following content: from constructs import Construct , Node from imports import k8s class WebService ( Construct ): def __init__ ( self , scope : Construct , id : str , * , image : str , replicas : int = 1 , port : int = 80 , container_port : int = 8080 ): super () . __init__ ( scope , id ) label = { 'app' : Node . of ( self ) . unique_id } k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = port , target_port = k8s . IntOrString . from_number ( container_port ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = replicas , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'app' , image = image , ports = [ k8s . ContainerPort ( container_port = container_port )])])))) Now, let\u2019s edit main.py and use our new construct: #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from webservice import WebService class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' , replicas = 2 ) WebService ( self , 'ghost' , image = 'ghost' , container_port = 2368 ) app = App () MyChart ( app , \"hello\" ) app . synth () Java src/main/java/com/mycompany/app/WebService.java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import java.util.Optional ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class WebService extends Construct { public WebService ( final Construct scope , final String id ) { this ( scope , id , null ); } public WebService ( final Construct scope , final String id , final WebServiceProps options ) { super ( scope , id ); final int portNumber = Optional . of ( options . getPort ()). orElse ( 80 ); final int containerPortNumber = Optional . of ( options . getContainerPort ()). orElse ( 8080 ); final int replicas = Optional . of ( options . getReplicas ()). orElse ( 1 ); final String image = options . getImage (); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( portNumber ) . targetPort ( IntOrString . fromNumber ( containerPortNumber )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( containerPortNumber ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"web\" ) . image ( image ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( replicas ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } } src/main/java/com/mycompany/app/WebServiceProps.java package com.mycompany.app ; public class WebServiceProps { private String image ; private int replicas ; private int port ; private int containerPort ; public WebServiceProps ( final String image , final int replicas , final int port , final int containerPort ) { this . image = image ; this . replicas = replicas ; this . port = port ; this . containerPort = containerPort ; } public String getImage () { return this . image ; } public int getReplicas () { return this . replicas ; } public int getPort () { return this . port ; } public int getContainerPort () { return this . containerPort ; } public static final class Builder { private String image ; private int replicas = 1 ; private int port = 80 ; private int containerPort = 8080 ; public Builder image ( String image ) { this . image = image ; return this ; } public Builder replicas ( int replicas ) { this . replicas = replicas ; return this ; } public Builder port ( int port ) { this . port = port ; return this ; } public Builder containerPort ( int containerPort ) { this . containerPort = containerPort ; return this ; } public WebServiceProps build () { return new WebServiceProps ( image , replicas , port , containerPort ); } } } src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); new WebService ( this , \"hello\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); new WebService ( this , \"ghost\" , new WebServiceProps . Builder () . image ( \"ghost\" ) . containerPort ( 2368 ) . build ()); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"web-service-java\" ); app . synth (); } } Go Create a file webservice.go with the following content: package main import ( \"example.com/hello/imports/k8s\" \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" ) type WebServiceProps struct { constructs . ConstructOptions Image * string Replicas * float64 Port * float64 ContainerPort * float64 } func NewWebService ( scope constructs . Construct , id * string , props * WebServiceProps ) constructs . Construct { var cprops constructs . ConstructOptions if props != nil { cprops = props . ConstructOptions } construct := constructs . NewConstruct ( scope , id , & cprops ) replicas := props . Replicas if replicas == nil { replicas = jsii . Number ( 1 ) } port := props . Port if port == nil { port = jsii . Number ( 80 ) } containerPort := props . ContainerPort if containerPort == nil { containerPort = jsii . Number ( 8080 ) } label := map [ string ] * string { \"app\" : constructs . Node_Of ( construct ). Id (), } k8s . NewKubeService ( construct , jsii . String ( \"service\" ), & k8s . KubeServiceProps { Spec : & k8s . ServiceSpec { Type : jsii . String ( \"LoadBalancer\" ), Ports : & [] * k8s . ServicePort {{ Port : port , TargetPort : k8s . IntOrString_FromNumber ( containerPort ), }}, Selector : & label , }, }) k8s . NewKubeDeployment ( construct , jsii . String ( \"deployment\" ), & k8s . KubeDeploymentProps { Spec : & k8s . DeploymentSpec { Replicas : replicas , Selector : & k8s . LabelSelector { MatchLabels : & label }, Template : & k8s . PodTemplateSpec { Metadata : & k8s . ObjectMeta { Labels : & label }, Spec : & k8s . PodSpec { Containers : & [] * k8s . Container {{ Name : jsii . String ( \"web\" ), Image : props . Image , Ports : & [] * k8s . ContainerPort {{ ContainerPort : containerPort }}, }}, }, }, }, }) return construct } Now, let\u2019s edit main.go and use our new construct: package main import ( \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), Replicas : jsii . Number ( 2 ), }) NewWebService ( chart , jsii . String ( \"ghost\" ), & WebServiceProps { Image : jsii . String ( \"ghost\" ), ContainerPort : jsii . Number ( 2368 ), }) return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } As you can see, we now add WebService constructs inside our chart: one that runs the paulbouwer/hello-kubernetes image and one with an installation of ghost .","title":"Abstraction through Constructs"},{"location":"support/","text":"Support \u00b6 Interacting with the community and the development team is a great way to contribute to the project. Please consider the following venues (in order): Search open issues Stack Overflow: cdk8s File a new issue Mailing list: cdk8s Slack: #cdk8s channel in cdk.dev","title":"Support"},{"location":"support/#support","text":"Interacting with the community and the development team is a great way to contribute to the project. Please consider the following venues (in order): Search open issues Stack Overflow: cdk8s File a new issue Mailing list: cdk8s Slack: #cdk8s channel in cdk.dev","title":"Support"},{"location":"assets/logos/readme/","text":"cdk8s Logos \u00b6 PNG SVG horizontal stacked icon horizontal stacked icon color black white","title":"cdk8s Logos"},{"location":"assets/logos/readme/#cdk8s-logos","text":"PNG SVG horizontal stacked icon horizontal stacked icon color black white","title":"cdk8s Logos"},{"location":"cli/","text":"Overview \u00b6 cdk8s is shipped with a command-line interface called cdk8s which can be used to work with cdk8s apps. The CLI is not required to use cdk8s but it includes some useful utilities.","title":"Overview"},{"location":"cli/#overview","text":"cdk8s is shipped with a command-line interface called cdk8s which can be used to work with cdk8s apps. The CLI is not required to use cdk8s but it includes some useful utilities.","title":"Overview"},{"location":"cli/import/","text":"import \u00b6 The import command generates low-level (L1) constructs for Kubernetes API objects and Custom Resources (CRDs). General Options \u00b6 Target programming language ( --language ) \u00b6 You can specify your desired language with the --language flag. For example: CLI: cdk8s import --language typescript cdk8s.yaml : language : typescript Output directory ( --output ) \u00b6 The --output (or -o ) option can be used to specify the output directory for your imports. Class name prefix ( --class-prefix ) \u00b6 For k8s imports, all imported classes will have a Kube prefix to denote that those are core Kubernetes APIs. For CRD imports, the class name will match the resource kind. You can use the --class-prefix option to specify an alternative prefix or --no-class-prefix to disable this behavior for k8s imports. Module name \u00b6 You can also override the default behavior for cdk8s importing. This will be helpful to you if you would like to name your CRD imports differently from their kind. Here is how you do it: CLI: cdk8s import example: = my_crd.yaml cdk8s.yaml : imports : - example:=my_crd.yaml If your CRD contained two kinds, Cluster and Autoscaler , you would have two imports. You could use them in this fashion: Typescript import { Cluster } from './imports/example-cluster' ; import { Autoscaler } from './imports/example-autoscaler' ; Python not yet supported Import Types \u00b6 The import command supports two types of imports: k8s : generates constructs from the core Kubernetes API CRDs: generates constructs from custom resource definitions This section describes specific behavior related to each type of import. Kubernetes APIs \u00b6 To generate constructs for all Kubernetes API objects of a certain version, use: cdk8s import k8s The import command will generate files under an \u201cimports\u201d directory inside your project with constructs for each API object in the Kubernetes spec. Note It is recommended to commit these generated files into your source control. By default, generated class names will be named KubeXyz where Xyz is the API object kind (e.g. KubeDeployment ). Kubernetes Versions \u00b6 Use the @version notation to import a specific Kubernetes version: cdk8s import k8s@1.16.0 Alternatively, you can specify your k8s import in the cdk8s.yaml config file: imports : - k8s@1.17.0 API Object Versions \u00b6 When importing the core Kubernetes API objects, cdk8s import will generate constructs both for stable APIs (e.g. v1 ) and pre-stable APIs ( v1beta1 ). To ensure compatibility across Kubernetes versions, construct classes generated for non-stable resources will include a postfix with the API level. For example, the import for k8s@1.18 includes KubeIngressV1Beta1 as the only Ingress resource. This is because Ingress has not been stabilized yet. The import for k8s@1.19 will also include an Ingress construct which represents the v1 resource. CRDs \u00b6 You can import CRDs from local files or URLs: cdk8s import my_crd.yaml Or from cdk8s.yaml : imports : - my_crd.yaml A CRD with group mygroup.io and kind Foo will be imported to the following locations: TypeScript: imports/mygroup.io.ts Python: imports/mygroup/io Importing CRDs from a cluster \u00b6 If the imported YAML is a List of CRDs, all these CRDs will be imported. This is useful, for example, to import all the CRDs from a running cluster: kubectl get crds -o json | cdk8s import /dev/stdin Yes, this works!","title":"import"},{"location":"cli/import/#import","text":"The import command generates low-level (L1) constructs for Kubernetes API objects and Custom Resources (CRDs).","title":"import"},{"location":"cli/import/#general-options","text":"","title":"General Options"},{"location":"cli/import/#target-programming-language-language","text":"You can specify your desired language with the --language flag. For example: CLI: cdk8s import --language typescript cdk8s.yaml : language : typescript","title":"Target programming language (--language)"},{"location":"cli/import/#output-directory-output","text":"The --output (or -o ) option can be used to specify the output directory for your imports.","title":"Output directory (--output)"},{"location":"cli/import/#class-name-prefix-class-prefix","text":"For k8s imports, all imported classes will have a Kube prefix to denote that those are core Kubernetes APIs. For CRD imports, the class name will match the resource kind. You can use the --class-prefix option to specify an alternative prefix or --no-class-prefix to disable this behavior for k8s imports.","title":"Class name prefix (--class-prefix)"},{"location":"cli/import/#module-name","text":"You can also override the default behavior for cdk8s importing. This will be helpful to you if you would like to name your CRD imports differently from their kind. Here is how you do it: CLI: cdk8s import example: = my_crd.yaml cdk8s.yaml : imports : - example:=my_crd.yaml If your CRD contained two kinds, Cluster and Autoscaler , you would have two imports. You could use them in this fashion: Typescript import { Cluster } from './imports/example-cluster' ; import { Autoscaler } from './imports/example-autoscaler' ; Python not yet supported","title":"Module name"},{"location":"cli/import/#import-types","text":"The import command supports two types of imports: k8s : generates constructs from the core Kubernetes API CRDs: generates constructs from custom resource definitions This section describes specific behavior related to each type of import.","title":"Import Types"},{"location":"cli/import/#kubernetes-apis","text":"To generate constructs for all Kubernetes API objects of a certain version, use: cdk8s import k8s The import command will generate files under an \u201cimports\u201d directory inside your project with constructs for each API object in the Kubernetes spec. Note It is recommended to commit these generated files into your source control. By default, generated class names will be named KubeXyz where Xyz is the API object kind (e.g. KubeDeployment ).","title":"Kubernetes APIs"},{"location":"cli/import/#crds","text":"You can import CRDs from local files or URLs: cdk8s import my_crd.yaml Or from cdk8s.yaml : imports : - my_crd.yaml A CRD with group mygroup.io and kind Foo will be imported to the following locations: TypeScript: imports/mygroup.io.ts Python: imports/mygroup/io","title":"CRDs"},{"location":"cli/init/","text":"init \u00b6 This command creates new cdk8s projects from built-in templates: cdk8s init TEMPLATE The following example will create a new TypeScript app project: mkdir my-fun-little-project cd my-fun-little-project cdk8s init typescript-app","title":"init"},{"location":"cli/init/#init","text":"This command creates new cdk8s projects from built-in templates: cdk8s init TEMPLATE The following example will create a new TypeScript app project: mkdir my-fun-little-project cd my-fun-little-project cdk8s init typescript-app","title":"init"},{"location":"cli/installation/","text":"Installation \u00b6 To install the CLI use one of the following methods: npm npm i -g cdk8s-cli yarn yarn global add cdk8s-cli Homebrew brew install cdk8s","title":"Installation"},{"location":"cli/installation/#installation","text":"To install the CLI use one of the following methods: npm npm i -g cdk8s-cli yarn yarn global add cdk8s-cli Homebrew brew install cdk8s","title":"Installation"},{"location":"cli/synth/","text":"synth \u00b6 The cdk8s synth command is a convenience command which will simply execute the application defined in cdk8s.yaml under app . For example, if your cdk8s.yaml file looks like this: app : node app.js Then, cdk8s synth will execute node app.js . Configuring synth output \u00b6 The properties of the synthesized YAML from cdk8s synth can be modified by the properties of the App construct. Things like file extensions, how API objects are distributed between files, and the output directory can all be configured in your AppProps For example: const app = new App ({ // Instead of the default \"dist\" outdir : \"output\" , // Instead of \".k8s.yaml\" outputFileExtension : \".generated.yaml\" , // Divide every resource into its own file, instead of grouping by Chart yamlOutputType : YamlOutputType.FILE_PER_RESOURCE , });","title":"synth"},{"location":"cli/synth/#synth","text":"The cdk8s synth command is a convenience command which will simply execute the application defined in cdk8s.yaml under app . For example, if your cdk8s.yaml file looks like this: app : node app.js Then, cdk8s synth will execute node app.js .","title":"synth"},{"location":"cli/synth/#configuring-synth-output","text":"The properties of the synthesized YAML from cdk8s synth can be modified by the properties of the App construct. Things like file extensions, how API objects are distributed between files, and the output directory can all be configured in your AppProps For example: const app = new App ({ // Instead of the default \"dist\" outdir : \"output\" , // Instead of \".k8s.yaml\" outputFileExtension : \".generated.yaml\" , // Divide every resource into its own file, instead of grouping by Chart yamlOutputType : YamlOutputType.FILE_PER_RESOURCE , });","title":"Configuring synth output"},{"location":"concepts/","text":"Overview \u00b6 This section discusses core concepts in cdk8s.","title":"Overview"},{"location":"concepts/#overview","text":"This section discusses core concepts in cdk8s.","title":"Overview"},{"location":"concepts/api-object/","text":"ApiObject \u00b6 An ApiObject is a construct that represents an entry in a Kubernetes manifest (level 0). In most cases, you won\u2019t use ApiObject directly but rather use classes that are imported through cdk8s import and which extend this base class. By default, when you import API objects from k8s, all class names will all be prefixed with Kube to differentiate them from the high-level APIs in cdk8s+. It is possible to customize the prefix by providing a string value to the --class-prefix flag, or by passing --no-class-prefix . (Note: if no prefix is used for k8s resources, this may lead to conflicts - see https://github.com/cdk8s-team/cdk8s/issues/140).","title":"ApiObject"},{"location":"concepts/api-object/#apiobject","text":"An ApiObject is a construct that represents an entry in a Kubernetes manifest (level 0). In most cases, you won\u2019t use ApiObject directly but rather use classes that are imported through cdk8s import and which extend this base class. By default, when you import API objects from k8s, all class names will all be prefixed with Kube to differentiate them from the high-level APIs in cdk8s+. It is possible to customize the prefix by providing a string value to the --class-prefix flag, or by passing --no-class-prefix . (Note: if no prefix is used for k8s resources, this may lead to conflicts - see https://github.com/cdk8s-team/cdk8s/issues/140).","title":"ApiObject"},{"location":"concepts/chart/","text":"Chart \u00b6 The Chart is a container that synthesizes a single Kubernetes manifest. class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns ); // add contents here } } During synthesis, charts collect all the ApiObject nodes (recursively) and emit a single YAML manifest that includes all these objects. When a chart is defined, you can specify chart-level namespace and labels . Those will be applied to all API objects defined within the chart (recursively): class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns , { namespace : 'my-namespace' , labels : { app : 'my-app' , }, }); new ApiObject ( this , 'my-object' , { apiVersion : 'v1' , kind : 'Foo' }); } } Will synthesize into: apiVersion : v1 kind : Foo metadata : namespace : my-namespace labels : app : my-app","title":"Chart"},{"location":"concepts/chart/#chart","text":"The Chart is a container that synthesizes a single Kubernetes manifest. class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns ); // add contents here } } During synthesis, charts collect all the ApiObject nodes (recursively) and emit a single YAML manifest that includes all these objects. When a chart is defined, you can specify chart-level namespace and labels . Those will be applied to all API objects defined within the chart (recursively): class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns , { namespace : 'my-namespace' , labels : { app : 'my-app' , }, }); new ApiObject ( this , 'my-object' , { apiVersion : 'v1' , kind : 'Foo' }); } } Will synthesize into: apiVersion : v1 kind : Foo metadata : namespace : my-namespace labels : app : my-app","title":"Chart"},{"location":"concepts/constructs/","text":"Constructs \u00b6 Constructs are the basic building block of cdk8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years.","title":"Constructs"},{"location":"concepts/constructs/#constructs","text":"Constructs are the basic building block of cdk8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years.","title":"Constructs"},{"location":"concepts/deps/","text":"Dependencies \u00b6 You can declare dependencies between any two cdk8s constructs using the addDependency() method. ApiObjects \u00b6 For example, you can force kubernetes to first apply a Namespace before applying the Service in the scope of that namespace: const namespace = new k8s . KubeNamespace ( chart , 'backend' ); const service = new k8s . KubeService ( chart , 'Service' , { metadata : { namespace : namespace.name }}); // declare the dependency. this is just a syntactic sugar for Node.of(service).addDependency(namespace) service . addDependency ( namespace ); cdk8s will ensure that the Namespace object is placed before the Service object in the resulting manifest: apiVersion : v1 kind : Namespace metadata : name : chart-backend-a59d2e47 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 namespace : chart-backend-a59d2e47 Charts \u00b6 You can also specify dependencies between charts, in exactly the same manner. For example, if we have a chart that provisions our namespace , we need that chart to be applied first: const namespaceChart = new Chart ( app , 'namespace' ); const applicationChart = new Chart ( app , 'application' ); // declare the dependency. this is just a syntactic sugar for Node.of(applicationChart).addDependency(namespaceChart) applicationChart . addDependency ( namespaceChart ); Running cdk8s synth will produce the following dist directory: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml Notice that the namespace chart appears first with the 0000 prefix. This will ensure that a subsequent execution of kubectl apply -f dist/ will apply the namespace first, and the application second. Custom Constructs \u00b6 The behavior above applies in the same way to custom constructs that you create or use. class Database extends Construct { constructor ( scope : Construct , name : string ) { super ( scope , name ); new k8s . KubeStatefulSet ( this , 'StatefulSet' ); new k8s . KubeConfigMap ( this , 'ConfigMap' ); } } const app = new App (); const chart = new Chart ( app , 'Chart' ); const service = new k8s . KubeService ( chart , 'Service' ) const database = new Database ( chart , 'Database' ); service . addDependency ( database ); Declaring such a dependency will cause each ApiObject in the source construct, to depend on every ApiObject in the target construct. Note that in the example above, the source construct is actually an ApiObject , which is also ok since it is essentially a construct with a single ApiObject . Note that if the source of your dependency is a custom construct, it won\u2019t have the addDependency syntactic sugar by default, so you\u2019ll have to use Node.of() . The resulting manifest will be: apiVersion : apps/v1 kind : StatefulSet metadata : name : chart-database-statefulset-4627f8e2 --- apiVersion : v1 kind : ConfigMap metadata : name : chart-database-configmap-676f8640 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 You can see that all ApiObject s of the Database construct, appear before the Service object. Things just got cool \u00b6 If you simply declare a dependency between two ApiObject s (or Constructs ), that belong to two different Chart s, cdk8s will create the chart dependency automatically for you. const namespaceChart = new Chart ( app , 'namespace' ); const applicationChart = new Chart ( app , 'application' ); const namespace = new k8s . KubeNamespace ( namespaceChart , 'namespace' ); const deployment = new k8s . KubeDeployment ( applicationChart , 'Deployment' ); // dependency between ApiObjects, not Charts! deployment . addDependency ( namespace ); Running cdk8s synth will produce the same result as if explicit chart dependencies were declared: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml This means you need not be bothered with managing chart dependencies, simply work with the ApiObject s you create, and let cdk8s infer the chart dependencies.","title":"Dependencies"},{"location":"concepts/deps/#dependencies","text":"You can declare dependencies between any two cdk8s constructs using the addDependency() method.","title":"Dependencies"},{"location":"concepts/deps/#apiobjects","text":"For example, you can force kubernetes to first apply a Namespace before applying the Service in the scope of that namespace: const namespace = new k8s . KubeNamespace ( chart , 'backend' ); const service = new k8s . KubeService ( chart , 'Service' , { metadata : { namespace : namespace.name }}); // declare the dependency. this is just a syntactic sugar for Node.of(service).addDependency(namespace) service . addDependency ( namespace ); cdk8s will ensure that the Namespace object is placed before the Service object in the resulting manifest: apiVersion : v1 kind : Namespace metadata : name : chart-backend-a59d2e47 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 namespace : chart-backend-a59d2e47","title":"ApiObjects"},{"location":"concepts/deps/#charts","text":"You can also specify dependencies between charts, in exactly the same manner. For example, if we have a chart that provisions our namespace , we need that chart to be applied first: const namespaceChart = new Chart ( app , 'namespace' ); const applicationChart = new Chart ( app , 'application' ); // declare the dependency. this is just a syntactic sugar for Node.of(applicationChart).addDependency(namespaceChart) applicationChart . addDependency ( namespaceChart ); Running cdk8s synth will produce the following dist directory: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml Notice that the namespace chart appears first with the 0000 prefix. This will ensure that a subsequent execution of kubectl apply -f dist/ will apply the namespace first, and the application second.","title":"Charts"},{"location":"concepts/deps/#custom-constructs","text":"The behavior above applies in the same way to custom constructs that you create or use. class Database extends Construct { constructor ( scope : Construct , name : string ) { super ( scope , name ); new k8s . KubeStatefulSet ( this , 'StatefulSet' ); new k8s . KubeConfigMap ( this , 'ConfigMap' ); } } const app = new App (); const chart = new Chart ( app , 'Chart' ); const service = new k8s . KubeService ( chart , 'Service' ) const database = new Database ( chart , 'Database' ); service . addDependency ( database ); Declaring such a dependency will cause each ApiObject in the source construct, to depend on every ApiObject in the target construct. Note that in the example above, the source construct is actually an ApiObject , which is also ok since it is essentially a construct with a single ApiObject . Note that if the source of your dependency is a custom construct, it won\u2019t have the addDependency syntactic sugar by default, so you\u2019ll have to use Node.of() . The resulting manifest will be: apiVersion : apps/v1 kind : StatefulSet metadata : name : chart-database-statefulset-4627f8e2 --- apiVersion : v1 kind : ConfigMap metadata : name : chart-database-configmap-676f8640 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 You can see that all ApiObject s of the Database construct, appear before the Service object.","title":"Custom Constructs"},{"location":"concepts/deps/#things-just-got-cool","text":"If you simply declare a dependency between two ApiObject s (or Constructs ), that belong to two different Chart s, cdk8s will create the chart dependency automatically for you. const namespaceChart = new Chart ( app , 'namespace' ); const applicationChart = new Chart ( app , 'application' ); const namespace = new k8s . KubeNamespace ( namespaceChart , 'namespace' ); const deployment = new k8s . KubeDeployment ( applicationChart , 'Deployment' ); // dependency between ApiObjects, not Charts! deployment . addDependency ( namespace ); Running cdk8s synth will produce the same result as if explicit chart dependencies were declared: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml This means you need not be bothered with managing chart dependencies, simply work with the ApiObject s you create, and let cdk8s infer the chart dependencies.","title":"Things just got cool"},{"location":"concepts/escape-hatches/","text":"Escape Hatches \u00b6 An \u201cescape hatch\u201d is an intentional leak in the abstraction layer. It allows users to \u201cescape the abstraction\u201d and reach out to a lower layer. Similarly, in CDKs, escape hatches are mechanisms that allow users to tweak the synthesized output when the abstraction they use does not \u201chold water\u201d. You may need to use an escape hatch in the following cases: You are using an imported API object (e.g. KubeDeployment ) and there is an issue with the schema or a bug in \u201cimport\u201d which results in an invalid manifest or missing fields (as an example see issue #140 ). You are using a high-level API (e.g. cdk8s+) which does not expose some functionality which exists in the lower-level resources. Patching API objects directly \u00b6 The ApiObject class, which is the base of all objects synthesized into a Kubernetes manifest offers an API for patching the synthesized output at the wire level using JSON Patch ( RFC-6902 ): import { JsonPatch } from 'cdk8s' ; apiObject . addJsonPatch ( JsonPatch . replace ( '/foo' , 'bar' )); apiObject . addJsonPatch ( JsonPatch . add ( '/foo/bar/0' , { bar : 123 })); During synthesis, patches are applied in-order after the API object synthesized itself. All classes generated using the CLI import command extend ApiObject , and therefore include the addJsonPatch() method. Patching API objects behind higher-level APIs \u00b6 The second use case for using escape hatches is when you are working against a higher-level construct which, for some reason, does not allow you to achieve what you need. For example, let\u2019s say you are using the Pod class from cdk8s+ and you wish to set [ enableServiceLinks ] to true . This feature is currently not supported in the cdk8s+ Pod API, so you\u2019ll want to patch the underlying KubePod and set this value. To do that, you will need to \u201cpeak\u201d into the construct tree and find the underlying API object, so you can apply the patch to it: import { Pod } from 'cdk8s-plus-22' ; import { ApiObject } from 'cdk8s' ; const pod = new Pod (...); const kubePod = ApiObject . of ( pod ); kubePod . addJsonPatch (...); The ApiObject.of() method uses capabilities of the constructs programming model to find the \u201cdefault child\u201d of a construct ( Node.of(c).defaultChild ). When a construct is initialized, it can either explicitly assign the value of Node.of(this).defaultChild = xxx or it can use the identity Default for one of its child constructs. This will automatically identify it as the default child. Tip The ApiObject.of() method recursively searches down the construct tree through child constructs called Default until it finds a child of type ApiObject . This means, for example, that ApiObject.of(apiObject) returns the same object. There could be situations where a default child is not recorded by a high-level construct. This still does not mean you are blocked from patching the underlying API objects. You can still use Node.of(x) to traverse the construct tree to obtain the child. For example, you can use Node.of(x).findChild(id) to retrieve any child by its ID.","title":"Escape Hatches"},{"location":"concepts/escape-hatches/#escape-hatches","text":"An \u201cescape hatch\u201d is an intentional leak in the abstraction layer. It allows users to \u201cescape the abstraction\u201d and reach out to a lower layer. Similarly, in CDKs, escape hatches are mechanisms that allow users to tweak the synthesized output when the abstraction they use does not \u201chold water\u201d. You may need to use an escape hatch in the following cases: You are using an imported API object (e.g. KubeDeployment ) and there is an issue with the schema or a bug in \u201cimport\u201d which results in an invalid manifest or missing fields (as an example see issue #140 ). You are using a high-level API (e.g. cdk8s+) which does not expose some functionality which exists in the lower-level resources.","title":"Escape Hatches"},{"location":"concepts/escape-hatches/#patching-api-objects-directly","text":"The ApiObject class, which is the base of all objects synthesized into a Kubernetes manifest offers an API for patching the synthesized output at the wire level using JSON Patch ( RFC-6902 ): import { JsonPatch } from 'cdk8s' ; apiObject . addJsonPatch ( JsonPatch . replace ( '/foo' , 'bar' )); apiObject . addJsonPatch ( JsonPatch . add ( '/foo/bar/0' , { bar : 123 })); During synthesis, patches are applied in-order after the API object synthesized itself. All classes generated using the CLI import command extend ApiObject , and therefore include the addJsonPatch() method.","title":"Patching API objects directly"},{"location":"concepts/escape-hatches/#patching-api-objects-behind-higher-level-apis","text":"The second use case for using escape hatches is when you are working against a higher-level construct which, for some reason, does not allow you to achieve what you need. For example, let\u2019s say you are using the Pod class from cdk8s+ and you wish to set [ enableServiceLinks ] to true . This feature is currently not supported in the cdk8s+ Pod API, so you\u2019ll want to patch the underlying KubePod and set this value. To do that, you will need to \u201cpeak\u201d into the construct tree and find the underlying API object, so you can apply the patch to it: import { Pod } from 'cdk8s-plus-22' ; import { ApiObject } from 'cdk8s' ; const pod = new Pod (...); const kubePod = ApiObject . of ( pod ); kubePod . addJsonPatch (...); The ApiObject.of() method uses capabilities of the constructs programming model to find the \u201cdefault child\u201d of a construct ( Node.of(c).defaultChild ). When a construct is initialized, it can either explicitly assign the value of Node.of(this).defaultChild = xxx or it can use the identity Default for one of its child constructs. This will automatically identify it as the default child. Tip The ApiObject.of() method recursively searches down the construct tree through child constructs called Default until it finds a child of type ApiObject . This means, for example, that ApiObject.of(apiObject) returns the same object. There could be situations where a default child is not recorded by a high-level construct. This still does not mean you are blocked from patching the underlying API objects. You can still use Node.of(x) to traverse the construct tree to obtain the child. For example, you can use Node.of(x).findChild(id) to retrieve any child by its ID.","title":"Patching API objects behind higher-level APIs"},{"location":"concepts/helm/","text":"Helm Support \u00b6 You can use the Helm construct in order to include Helm charts. In order to use this construct, you must have helm installed on your system. See Installing Helm in the Helm documentation for details. The following example adds the bitnami/redis Helm chart with sentinel containers enabled: The Bitnami helm repo needs to be added through: helm repo add bitnami https://charts.bitnami.com/bitnami class MyChart extends cdk8s . Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const redis = new Helm ( this , 'redis' , { chart : 'bitnami/redis' , values : { sentinel : { enabled : true } } }); } } The Helm construct will render the manifest from the specified chart by executing helm template . If values is specified, these values will override the default values included with the chart. The name option can be used to specify the chart\u2019s release name . If not specified, a valid and unique release name will be allocated based on the construct path. The Helm construct extends Include and inherits it\u2019s API. For example, you can use the apiObjects property to find and interact with included API objects. The following example shows how to add an annotation to the Redis master deployment: const master = redis . apiObjects . find ( o => o . name === 'foo-redis-master' ); master . metadata . addAnnotation ( 'my.annotation' , 'hey-there' );","title":"Helm Support"},{"location":"concepts/helm/#helm-support","text":"You can use the Helm construct in order to include Helm charts. In order to use this construct, you must have helm installed on your system. See Installing Helm in the Helm documentation for details. The following example adds the bitnami/redis Helm chart with sentinel containers enabled: The Bitnami helm repo needs to be added through: helm repo add bitnami https://charts.bitnami.com/bitnami class MyChart extends cdk8s . Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const redis = new Helm ( this , 'redis' , { chart : 'bitnami/redis' , values : { sentinel : { enabled : true } } }); } } The Helm construct will render the manifest from the specified chart by executing helm template . If values is specified, these values will override the default values included with the chart. The name option can be used to specify the chart\u2019s release name . If not specified, a valid and unique release name will be allocated based on the construct path. The Helm construct extends Include and inherits it\u2019s API. For example, you can use the apiObjects property to find and interact with included API objects. The following example shows how to add an annotation to the Redis master deployment: const master = redis . apiObjects . find ( o => o . name === 'foo-redis-master' ); master . metadata . addAnnotation ( 'my.annotation' , 'hey-there' );","title":"Helm Support"},{"location":"concepts/include/","text":"Include \u00b6 The Include construct can be used to include an existing manifest in a chart. The following example will include the Kubernetes Dashboard in MyChart : import { Include } from 'cdk8s' ; class MyChart extends Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const dashboard = new Include ( this , 'dashboard' , { url : 'https://raw.githubusercontent.com/kubernetes/dashboard/v2.4.0/aio/deploy/recommended.yaml' , // or url : 'dashboard.yaml' }); // ...other resources } } All API objects defined in the included manifest will be added as children ApiObject s under the Include construct\u2019s scope and can be accessed through the apiObject property: The following example queries for all the Deployment resources in the dashboard: const deploymentApiObject = dashboard . apiObjects . find ( c => c . kind === ' Deployment ); NOTE: names of included objects ( metadata.name ) are preserved. This means that if you try to include the same manifest twice into the same chart, your manifest will have duplicate definitions of the same objects.","title":"Include"},{"location":"concepts/include/#include","text":"The Include construct can be used to include an existing manifest in a chart. The following example will include the Kubernetes Dashboard in MyChart : import { Include } from 'cdk8s' ; class MyChart extends Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const dashboard = new Include ( this , 'dashboard' , { url : 'https://raw.githubusercontent.com/kubernetes/dashboard/v2.4.0/aio/deploy/recommended.yaml' , // or url : 'dashboard.yaml' }); // ...other resources } } All API objects defined in the included manifest will be added as children ApiObject s under the Include construct\u2019s scope and can be accessed through the apiObject property: The following example queries for all the Deployment resources in the dashboard: const deploymentApiObject = dashboard . apiObjects . find ( c => c . kind === ' Deployment ); NOTE: names of included objects ( metadata.name ) are preserved. This means that if you try to include the same manifest twice into the same chart, your manifest will have duplicate definitions of the same objects.","title":"Include"},{"location":"concepts/testing/","text":"Testing \u00b6 cdk8s bundles a set of test utilities under the Testing class: Testing.app() returns an App object bound to a temporary output directory. Testing.chart() returns a Chart object bound to a testing app. Testing.synth(chart) returns the Kubernetes manifest synthesized from a chart.","title":"Testing"},{"location":"concepts/testing/#testing","text":"cdk8s bundles a set of test utilities under the Testing class: Testing.app() returns an App object bound to a temporary output directory. Testing.chart() returns a Chart object bound to a testing app. Testing.synth(chart) returns the Kubernetes manifest synthesized from a chart.","title":"Testing"},{"location":"examples/","text":"cdk8s Examples Directory \u00b6 This section includes references for cdk8s and cdk8s+ examples that we have in our GitHub repository. Navigate to the example you like from the left side navigation panel.","title":"Overview"},{"location":"examples/#cdk8s-examples-directory","text":"This section includes references for cdk8s and cdk8s+ examples that we have in our GitHub repository. Navigate to the example you like from the left side navigation panel.","title":"cdk8s Examples Directory"},{"location":"examples/crd/","text":"CRDs \u00b6 Shows how to import and use Custom Resource Definitions TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"CRDs"},{"location":"examples/crd/#crds","text":"Shows how to import and use Custom Resource Definitions TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"CRDs"},{"location":"examples/hello/","text":"Hello, Kubernetes! \u00b6 Deploys hello-kubernetes as a Service behind a LoadBalancer. TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Hello, Kubernetes!"},{"location":"examples/hello/#hello-kubernetes","text":"Deploys hello-kubernetes as a Service behind a LoadBalancer. TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Hello, Kubernetes!"},{"location":"examples/plus-elasticsearch/","text":"Elasticsearch (cdk8s+) \u00b6 Creating a query service on top of Elasticsearch with cdk8s+ TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Elasticsearch (cdk8s+)"},{"location":"examples/plus-elasticsearch/#elasticsearch-cdk8s","text":"Creating a query service on top of Elasticsearch with cdk8s+ TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Elasticsearch (cdk8s+)"},{"location":"examples/plus-ingress/","text":"Ingress (cdk8s+) \u00b6 Example of using cdk8s+ Ingress resource. TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Ingress (cdk8s+)"},{"location":"examples/plus-ingress/#ingress-cdk8s","text":"Example of using cdk8s+ Ingress resource. TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Ingress (cdk8s+)"},{"location":"examples/podinfo/","text":"Podinfo \u00b6 Exploration of high-level APIs for Deployment , Service , AutoScaler and Ingress based on the podinfo project . TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Podinfo"},{"location":"examples/podinfo/#podinfo","text":"Exploration of high-level APIs for Deployment , Service , AutoScaler and Ingress based on the podinfo project . TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Podinfo"},{"location":"examples/web-service/","text":"WebService Abstraction \u00b6 Demonstrates how to make your first high-level construct which represents a web service which abstracts the hello example from earlier into a reusable piece of infrastructure. TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"WebService Abstraction"},{"location":"examples/web-service/#webservice-abstraction","text":"Demonstrates how to make your first high-level construct which represents a web service which abstracts the hello example from earlier into a reusable piece of infrastructure. TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"WebService Abstraction"},{"location":"plus/","text":"Overview \u00b6 cdk8s+ is a library with high level abstractions for authoring Kubernetes applications. Built on top of the auto-generated building blocks provided by cdk8s, this library includes a hand crafted construct for each native kubernetes object, exposing richer API\u2019s with reduced complexity. Here is an example of how we would deploy a simple nginx container, once with the low-level API (on the left), and once with the high level abstraction (on the right). cdk8s+ is vended as a separate library for each kubernetes spec version. The documentation presented here represents version 1.22.0 and is vended as the cdk8s-plus-22 library. Naming conventions \u00b6 Stable resources are represented by a construct of the same kind . For example, the io.k8s.api.core.v1.Pod resource maps to the Pod construct . Non stable resources are suffixed with their api version . For example, the io.k8s.api.networking.v1beta1.Ingress maps to the IngressV1Beta1 construct . Spec compatibility \u00b6 Per kubernetes compatibility guarantees , stable resources in this library are compatible with any spec version higher or equal to 1.22.0 . Non-stable resources are not guaranteed to be compatible, as they may be removed in future spec versions. Notice If you are deploying manifests produced by cdk8s-plus-22 onto clusters of a lower version, you might encounter some unsupported spec properties or invalid manifests. FAQ \u00b6 What\u2019s the difference between cdk8s-plus-20 , cdk8s-plus-21 , and cdk8s-plus-22 ? \u00b6 These are separately vended libraries that each target a different kubernetes version, marked by the -XX suffix. For example, cdk8s-plus-22 targets kubernetes version 1.22.0 . We offer a dedicated package per Kubernetes version to allow users to match their manifests to the Kubernetes version they are operating. This way, users are only exposed to a set of capabilities offered by their specific cluster, preventing deployment errors caused by version mismatches. For example, imagine we had published a single library for all Kubernetes versions (call it cdk8s-plus ). This library would have had support for the namespaceSelector property when configuring pod affinity rules. This property was only added in Kubernetes 1.21.0. Now imagine you operate Kubernetes 1.20.0. In such a case, you would have access to the namespaceSelector property, even though it is unsupported, and will result in a deployment failure if you use it. With a dedicated package, this property would not be available for you to (mis)use. I operate Kubernetes version 1.XX - which cdk8s+ library should I be using? \u00b6 If there is a cdk8s-plus-XX library that matches your target Kubernetes version, we recommend using it since all Kubernetes manifests generated using it will be compatible. If there is not a matching cdk8s-plus-XX library, we recommend using the closest matching version. The manifests generated by cdk8s-plus-XX may also work for older versions of Kubernetes, but you might encounter some unsupported spec properties or invalid manifests. I\u2019m using cdk8s-plus-XX - which kubernetes versions will my manifest work on? \u00b6 If you are using stable APIs (those that are not in alpha or beta), manifests generated in cdk8s-plus-XX will work in Kubernetes versions 1.XX.0 and above. Unstable APIs (which are always labeled in cdk8s+ using a suffix, e.g. IngressV1Beta1 ) may work in newer versions of Kubernetes, but it is also possible they have been removed. The manifests generated by cdk8s-plus-XX may also work for older versions of Kubernetes, but you might encounter some unsupported spec properties or invalid manifests. At a glance \u00b6 import * as kplus from 'cdk8s-plus-22' ; import * as cdk8s from 'cdk8s' ; import * as path from 'path' ; // our cdk app const app = new cdk8s . App (); // our kubernetes chart const chart = new cdk8s . Chart ( app , 'my-chart' ); // lets create a volume that contains our app. // we use a trick with a config map! const appData = new kplus . ConfigMap ( chart , 'AppData' ); appData . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appData ); // lets create a deployment to run a few instances of a pod const deployment = new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , }); // now we create a container that runs our app const appPath = '/var/lib/app' ; const port = 80 ; const container = deployment . addContainer ({ image : 'node:14.4.0-alpine3.12' , command : [ 'node' , 'index.js' , ` ${ port } ` ], port : port , workingDir : appPath , }); // make the app accessible to the container container . mount ( appPath , appVolume ); // finally, we expose the deployment as a load balancer service and make it run deployment . expose ( 8080 , { serviceType : kplus.ServiceType.LOAD_BALANCER }) // we are done, synth app . synth (); dist/my-chart.yaml apiVersion : v1 data : index.js : |- var http = require('http'); var port = process.argv[2]; //create a server object: http.createServer(function (req, res) { res.write('Hello World!'); //write a response to the client res.end(); //end the response }).listen(port); //the server object listens on port 80 kind : ConfigMap metadata : annotations : {} labels : {} name : chart-appdata-configmap-da4c63ab --- apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-deployment-pod-d4285cc9 spec : replicas : 3 selector : matchLabels : cdk8s.deployment : ChartDeploymentCFC2E30C template : metadata : annotations : {} labels : cdk8s.deployment : ChartDeploymentCFC2E30C spec : containers : - command : - node - index.js - \"80\" env : [] image : node:14.4.0-alpine3.12 name : main ports : - containerPort : 80 volumeMounts : - mountPath : /var/lib/app name : configmap-chart-appdata-configmap-da4c63ab workingDir : /var/lib/app volumes : - configMap : name : chart-appdata-configmap-da4c63ab name : configmap-chart-appdata-configmap-da4c63ab --- apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-deployment-service-pod-42f50c26 spec : externalIPs : [] ports : - port : 8080 targetPort : 80 selector : cdk8s.deployment : ChartDeploymentCFC2E30C type : LoadBalancer Getting Started \u00b6 TypeScript/JavaScript \u276f npm install cdk8s-plus-22 cdk8s import * as kplus from 'cdk8s-plus-22' ; import * as cdk8s from 'cdk8s' ; const app = new cdk8s . App (); const chart = new cdk8s . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , containers : [{ image : 'ubuntu' , }], }); app . synth (); Python \u276f pip install --pre cdk8s-plus-22 cdk8s import cdk8s_plus_22 as kplus import cdk8s app = cdk8s . App () chart = cdk8s . Chart ( app , 'Chart' ) kplus . Deployment ( chart , 'Deployment' , replicas = 1 , containers = [ kplus . ContainerProps ( image = 'ubuntu' )] ) app . synth () Java <dependency> <groupId> org.cdk8s </groupId> <artifactId> cdk8s </artifactId> <version> 1.0.0-beta.46 </version> </dependency> <dependency> <groupId> org.cdk8s </groupId> <artifactId> cdk8s-plus-22 </artifactId> <version> 1.0.0-beta.1 </version> </dependency> import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.plus22.Deployment ; import org.cdk8s.plus22.ContainerProps ; App app = new App (); Chart chart = new Chart ( app , \"Chart\" ); Deployment . Builder . create ( this , \"Deployment\" ) . replicas ( 3 ) . containers ( Arrays . asList ( ContainerProps . builder () . image ( \"ubuntu\" ) . build ())) . build (); app . synth (); Go import ( \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" \"github.com/cdk8s-team/cdk8s-plus-go/cdk8splus22\" ) app := cdk8s . NewApp ( nil ) chart := cdk8s . NewChart ( app , jsii . String ( \"ubuntu\" ), nil ) cdk8splus22 . NewDeployment ( chart , jsii . String ( \"Deployment\" ), & cdk8splus22 . DeploymentProps { Replicas : jsii . Number ( 3 ), Containers : & [] * cdk8splus22 . ContainerProps {{ Image : jsii . String ( \"ubuntu\" ), }}, }) app . Synth ()","title":"Overview"},{"location":"plus/#overview","text":"cdk8s+ is a library with high level abstractions for authoring Kubernetes applications. Built on top of the auto-generated building blocks provided by cdk8s, this library includes a hand crafted construct for each native kubernetes object, exposing richer API\u2019s with reduced complexity. Here is an example of how we would deploy a simple nginx container, once with the low-level API (on the left), and once with the high level abstraction (on the right). cdk8s+ is vended as a separate library for each kubernetes spec version. The documentation presented here represents version 1.22.0 and is vended as the cdk8s-plus-22 library.","title":"Overview"},{"location":"plus/#naming-conventions","text":"Stable resources are represented by a construct of the same kind . For example, the io.k8s.api.core.v1.Pod resource maps to the Pod construct . Non stable resources are suffixed with their api version . For example, the io.k8s.api.networking.v1beta1.Ingress maps to the IngressV1Beta1 construct .","title":"Naming conventions"},{"location":"plus/#spec-compatibility","text":"Per kubernetes compatibility guarantees , stable resources in this library are compatible with any spec version higher or equal to 1.22.0 . Non-stable resources are not guaranteed to be compatible, as they may be removed in future spec versions. Notice If you are deploying manifests produced by cdk8s-plus-22 onto clusters of a lower version, you might encounter some unsupported spec properties or invalid manifests.","title":"Spec compatibility"},{"location":"plus/#faq","text":"","title":"FAQ"},{"location":"plus/#whats-the-difference-between-cdk8s-plus-20-cdk8s-plus-21-and-cdk8s-plus-22","text":"These are separately vended libraries that each target a different kubernetes version, marked by the -XX suffix. For example, cdk8s-plus-22 targets kubernetes version 1.22.0 . We offer a dedicated package per Kubernetes version to allow users to match their manifests to the Kubernetes version they are operating. This way, users are only exposed to a set of capabilities offered by their specific cluster, preventing deployment errors caused by version mismatches. For example, imagine we had published a single library for all Kubernetes versions (call it cdk8s-plus ). This library would have had support for the namespaceSelector property when configuring pod affinity rules. This property was only added in Kubernetes 1.21.0. Now imagine you operate Kubernetes 1.20.0. In such a case, you would have access to the namespaceSelector property, even though it is unsupported, and will result in a deployment failure if you use it. With a dedicated package, this property would not be available for you to (mis)use.","title":"What's the difference between cdk8s-plus-20, cdk8s-plus-21, and cdk8s-plus-22?"},{"location":"plus/#i-operate-kubernetes-version-1xx-which-cdk8s-library-should-i-be-using","text":"If there is a cdk8s-plus-XX library that matches your target Kubernetes version, we recommend using it since all Kubernetes manifests generated using it will be compatible. If there is not a matching cdk8s-plus-XX library, we recommend using the closest matching version. The manifests generated by cdk8s-plus-XX may also work for older versions of Kubernetes, but you might encounter some unsupported spec properties or invalid manifests.","title":"I operate Kubernetes version 1.XX - which cdk8s+ library should I be using?"},{"location":"plus/#im-using-cdk8s-plus-xx-which-kubernetes-versions-will-my-manifest-work-on","text":"If you are using stable APIs (those that are not in alpha or beta), manifests generated in cdk8s-plus-XX will work in Kubernetes versions 1.XX.0 and above. Unstable APIs (which are always labeled in cdk8s+ using a suffix, e.g. IngressV1Beta1 ) may work in newer versions of Kubernetes, but it is also possible they have been removed. The manifests generated by cdk8s-plus-XX may also work for older versions of Kubernetes, but you might encounter some unsupported spec properties or invalid manifests.","title":"I'm using cdk8s-plus-XX - which kubernetes versions will my manifest work on?"},{"location":"plus/#at-a-glance","text":"import * as kplus from 'cdk8s-plus-22' ; import * as cdk8s from 'cdk8s' ; import * as path from 'path' ; // our cdk app const app = new cdk8s . App (); // our kubernetes chart const chart = new cdk8s . Chart ( app , 'my-chart' ); // lets create a volume that contains our app. // we use a trick with a config map! const appData = new kplus . ConfigMap ( chart , 'AppData' ); appData . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appData ); // lets create a deployment to run a few instances of a pod const deployment = new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , }); // now we create a container that runs our app const appPath = '/var/lib/app' ; const port = 80 ; const container = deployment . addContainer ({ image : 'node:14.4.0-alpine3.12' , command : [ 'node' , 'index.js' , ` ${ port } ` ], port : port , workingDir : appPath , }); // make the app accessible to the container container . mount ( appPath , appVolume ); // finally, we expose the deployment as a load balancer service and make it run deployment . expose ( 8080 , { serviceType : kplus.ServiceType.LOAD_BALANCER }) // we are done, synth app . synth (); dist/my-chart.yaml apiVersion : v1 data : index.js : |- var http = require('http'); var port = process.argv[2]; //create a server object: http.createServer(function (req, res) { res.write('Hello World!'); //write a response to the client res.end(); //end the response }).listen(port); //the server object listens on port 80 kind : ConfigMap metadata : annotations : {} labels : {} name : chart-appdata-configmap-da4c63ab --- apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-deployment-pod-d4285cc9 spec : replicas : 3 selector : matchLabels : cdk8s.deployment : ChartDeploymentCFC2E30C template : metadata : annotations : {} labels : cdk8s.deployment : ChartDeploymentCFC2E30C spec : containers : - command : - node - index.js - \"80\" env : [] image : node:14.4.0-alpine3.12 name : main ports : - containerPort : 80 volumeMounts : - mountPath : /var/lib/app name : configmap-chart-appdata-configmap-da4c63ab workingDir : /var/lib/app volumes : - configMap : name : chart-appdata-configmap-da4c63ab name : configmap-chart-appdata-configmap-da4c63ab --- apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-deployment-service-pod-42f50c26 spec : externalIPs : [] ports : - port : 8080 targetPort : 80 selector : cdk8s.deployment : ChartDeploymentCFC2E30C type : LoadBalancer","title":"At a glance"},{"location":"plus/#getting-started","text":"TypeScript/JavaScript \u276f npm install cdk8s-plus-22 cdk8s import * as kplus from 'cdk8s-plus-22' ; import * as cdk8s from 'cdk8s' ; const app = new cdk8s . App (); const chart = new cdk8s . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , containers : [{ image : 'ubuntu' , }], }); app . synth (); Python \u276f pip install --pre cdk8s-plus-22 cdk8s import cdk8s_plus_22 as kplus import cdk8s app = cdk8s . App () chart = cdk8s . Chart ( app , 'Chart' ) kplus . Deployment ( chart , 'Deployment' , replicas = 1 , containers = [ kplus . ContainerProps ( image = 'ubuntu' )] ) app . synth () Java <dependency> <groupId> org.cdk8s </groupId> <artifactId> cdk8s </artifactId> <version> 1.0.0-beta.46 </version> </dependency> <dependency> <groupId> org.cdk8s </groupId> <artifactId> cdk8s-plus-22 </artifactId> <version> 1.0.0-beta.1 </version> </dependency> import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.plus22.Deployment ; import org.cdk8s.plus22.ContainerProps ; App app = new App (); Chart chart = new Chart ( app , \"Chart\" ); Deployment . Builder . create ( this , \"Deployment\" ) . replicas ( 3 ) . containers ( Arrays . asList ( ContainerProps . builder () . image ( \"ubuntu\" ) . build ())) . build (); app . synth (); Go import ( \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" \"github.com/cdk8s-team/cdk8s-plus-go/cdk8splus22\" ) app := cdk8s . NewApp ( nil ) chart := cdk8s . NewChart ( app , jsii . String ( \"ubuntu\" ), nil ) cdk8splus22 . NewDeployment ( chart , jsii . String ( \"Deployment\" ), & cdk8splus22 . DeploymentProps { Replicas : jsii . Number ( 3 ), Containers : & [] * cdk8splus22 . ContainerProps {{ Image : jsii . String ( \"ubuntu\" ), }}, }) app . Synth ()","title":"Getting Started"},{"location":"plus/config-map/","text":"ConfigMap \u00b6 ConfigMap are used to store configuration data. They provide a dictionary based data structure that can be consumed in various shapes and forms. API Reference Use an existing ConfigMap \u00b6 You can reference to an existing ConfigMap like so. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-22' ; const config : kplus.IConfigMap = kplus . ConfigMap . fromConfigMapName ( 'config' ); // the 'config' constant can later be used by API's that require an IConfigMap. // for example when creating a volume. const volume = kplus . Volume . fromConfigMap ( config ); Adding data \u00b6 You can create config maps and add some data to them like so: import * as kplus from 'cdk8s-plus-22' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const config = new kplus . ConfigMap ( chart , 'Config' ); config . addData ( 'url' , 'https://my-endpoint:8080' ); Creating a volume from a directory \u00b6 Here is a nifty little trick you can use to create a volume that contains a directory on the client machine (machine that runs cdk8s synth ): import * as kplus from 'cdk8s-plus-22' ; import * as k from 'cdk8s' ; import * as path from 'path' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const appMap = new kplus . ConfigMap ( chart , 'Config' ); // add the files in the directory to the config map. // this will create a key for each file. // note that only top level files will be included, sub-directories are not yet supported. appMap . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appMap ); const mountPath = '/var/app' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , command : [ 'node' , 'app.js' ], workingDir : mountPath , }); // from here, just mount the volume to a container, and run your app! container . mount ( mountPath , appVolume );","title":"ConfigMap"},{"location":"plus/config-map/#configmap","text":"ConfigMap are used to store configuration data. They provide a dictionary based data structure that can be consumed in various shapes and forms. API Reference","title":"ConfigMap"},{"location":"plus/config-map/#use-an-existing-configmap","text":"You can reference to an existing ConfigMap like so. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-22' ; const config : kplus.IConfigMap = kplus . ConfigMap . fromConfigMapName ( 'config' ); // the 'config' constant can later be used by API's that require an IConfigMap. // for example when creating a volume. const volume = kplus . Volume . fromConfigMap ( config );","title":"Use an existing ConfigMap"},{"location":"plus/config-map/#adding-data","text":"You can create config maps and add some data to them like so: import * as kplus from 'cdk8s-plus-22' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const config = new kplus . ConfigMap ( chart , 'Config' ); config . addData ( 'url' , 'https://my-endpoint:8080' );","title":"Adding data"},{"location":"plus/config-map/#creating-a-volume-from-a-directory","text":"Here is a nifty little trick you can use to create a volume that contains a directory on the client machine (machine that runs cdk8s synth ): import * as kplus from 'cdk8s-plus-22' ; import * as k from 'cdk8s' ; import * as path from 'path' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const appMap = new kplus . ConfigMap ( chart , 'Config' ); // add the files in the directory to the config map. // this will create a key for each file. // note that only top level files will be included, sub-directories are not yet supported. appMap . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appMap ); const mountPath = '/var/app' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , command : [ 'node' , 'app.js' ], workingDir : mountPath , }); // from here, just mount the volume to a container, and run your app! container . mount ( mountPath , appVolume );","title":"Creating a volume from a directory"},{"location":"plus/container/","text":"Container \u00b6 Define containers that run in a pod using the Container class. API Reference Environment variables \u00b6 Environment variables can be added to containers using various sources, via semantically explicit API\u2019s: import * as kplus from 'cdk8s-plus-22' const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }); // explicitly use a value. container . addEnv ( 'endpoint' , kplus . EnvValue . fromValue ( 'value' )); // use a specific key from a config map. const backendsConfig = kplus . ConfigMap . fromConfigMapName ( 'backends' ); container . addEnv ( 'endpoint' , kplus . EnvValue . fromConfigMap ( backendsConfig , 'endpoint' )); // use a specific key from a secret. const credentials = kplus . Secret . fromSecretName ( 'credentials' ); container . addEnv ( 'password' , kplus . EnvValue . fromSecret ( credentials , 'password' )); Volume Mounts \u00b6 A very common capability is to mount a volume with some data onto a container. Using pure kubernetes API, this would require writing something like: kind : Pod apiVersion : v1 spec : containers : - name : main volumeMounts : - mountPath : /path/to/mount name : 'config-volume' volumes : - name : 'config-volume' configMap : name : 'config' Notice the apparent redundancy of having to specify the volume name twice. Also, if you happen to need the same mount in other pods, you would need to duplicate this configuration. This can get complex and cluttered very fast. In contrast, here is how to do this with cdk8s+ : import * as kplus from 'cdk8s-plus-22' ; const config = kplus . ConfigMap . fromConfigMapName ( 'config' ); const volume = kplus . Volume . fromConfigMap ( config ); const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }) // Cool alert: every pod that will later be configured with this container, // will automatically have access to this volume, so you don't need to explicitly add it to the pod spec!. container . mount ( '/path/to/mount' , volume ); Probes \u00b6 A Probe is a diagnostic performed periodically by the kubelet on a Container. To perform a diagnostic, the kubelet calls a Handler implemented by the container. A Probe instance can be created through one of the fromXxx static methods: Probe.fromHttpGet() Probe.fromCommand() Readiness, liveness, and startup probes can be configured at the container-level through the readiness , liveness , and startup options: new kplus . Pod ( this , 'Pod' , { containers : [ { // ... readiness : kplus.Probe.fromHttpGet ( '/ping' ), } ] }); See the API reference for details.","title":"Container"},{"location":"plus/container/#container","text":"Define containers that run in a pod using the Container class. API Reference","title":"Container"},{"location":"plus/container/#environment-variables","text":"Environment variables can be added to containers using various sources, via semantically explicit API\u2019s: import * as kplus from 'cdk8s-plus-22' const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }); // explicitly use a value. container . addEnv ( 'endpoint' , kplus . EnvValue . fromValue ( 'value' )); // use a specific key from a config map. const backendsConfig = kplus . ConfigMap . fromConfigMapName ( 'backends' ); container . addEnv ( 'endpoint' , kplus . EnvValue . fromConfigMap ( backendsConfig , 'endpoint' )); // use a specific key from a secret. const credentials = kplus . Secret . fromSecretName ( 'credentials' ); container . addEnv ( 'password' , kplus . EnvValue . fromSecret ( credentials , 'password' ));","title":"Environment variables"},{"location":"plus/container/#volume-mounts","text":"A very common capability is to mount a volume with some data onto a container. Using pure kubernetes API, this would require writing something like: kind : Pod apiVersion : v1 spec : containers : - name : main volumeMounts : - mountPath : /path/to/mount name : 'config-volume' volumes : - name : 'config-volume' configMap : name : 'config' Notice the apparent redundancy of having to specify the volume name twice. Also, if you happen to need the same mount in other pods, you would need to duplicate this configuration. This can get complex and cluttered very fast. In contrast, here is how to do this with cdk8s+ : import * as kplus from 'cdk8s-plus-22' ; const config = kplus . ConfigMap . fromConfigMapName ( 'config' ); const volume = kplus . Volume . fromConfigMap ( config ); const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }) // Cool alert: every pod that will later be configured with this container, // will automatically have access to this volume, so you don't need to explicitly add it to the pod spec!. container . mount ( '/path/to/mount' , volume );","title":"Volume Mounts"},{"location":"plus/container/#probes","text":"A Probe is a diagnostic performed periodically by the kubelet on a Container. To perform a diagnostic, the kubelet calls a Handler implemented by the container. A Probe instance can be created through one of the fromXxx static methods: Probe.fromHttpGet() Probe.fromCommand() Readiness, liveness, and startup probes can be configured at the container-level through the readiness , liveness , and startup options: new kplus . Pod ( this , 'Pod' , { containers : [ { // ... readiness : kplus.Probe.fromHttpGet ( '/ping' ), } ] }); See the API reference for details.","title":"Probes"},{"location":"plus/deployment/","text":"Deployment \u00b6 Create a deployment to govern the lifecycle and orchestration of a set of identical pods. API Reference Automatic pod selection \u00b6 When you specify pods in a deployment, you normally have to configure the appropriate labels and selectors to make the deployment control the relevant pods. This construct does this automatically. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'FrontEnds' , { containers : [ { image : 'node' } ], }); Note the resulting manifest contains a special cdk8s.deployment label that is applied to the pods, and is used as the selector for the deployment. apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-frontends-pod-a48e7f2e spec : replicas : 1 selector : matchLabels : cdk8s.deployment : ChartFrontEndsDD8A97CE template : metadata : annotations : {} labels : cdk8s.deployment : ChartFrontEndsDD8A97CE Exposing via a service \u00b6 Following up on pod selection, you can also easily create a service that will select the pods relevant to the deployment. // store the deployment to created in a constant const frontends = new kplus . Deployment ( chart , 'FrontEnds' ); // create a ClusterIP service that listens on port 9000 and redirects to port 9000 on the containers. frontends . expose ( 9000 ) Notice the resulting manifest, will have the same cdk8s.deployment magic label as the selector. This will cause the service to attach to the pods that were configured as part of the said deployment. apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-frontends-service-pod-1f70150b spec : externalIPs : [] ports : - port : 9000 selector : cdk8s.deployment : ChartFrontEndsDD8A97CE type : ClusterIP","title":"Deployment"},{"location":"plus/deployment/#deployment","text":"Create a deployment to govern the lifecycle and orchestration of a set of identical pods. API Reference","title":"Deployment"},{"location":"plus/deployment/#automatic-pod-selection","text":"When you specify pods in a deployment, you normally have to configure the appropriate labels and selectors to make the deployment control the relevant pods. This construct does this automatically. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'FrontEnds' , { containers : [ { image : 'node' } ], }); Note the resulting manifest contains a special cdk8s.deployment label that is applied to the pods, and is used as the selector for the deployment. apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-frontends-pod-a48e7f2e spec : replicas : 1 selector : matchLabels : cdk8s.deployment : ChartFrontEndsDD8A97CE template : metadata : annotations : {} labels : cdk8s.deployment : ChartFrontEndsDD8A97CE","title":"Automatic pod selection"},{"location":"plus/deployment/#exposing-via-a-service","text":"Following up on pod selection, you can also easily create a service that will select the pods relevant to the deployment. // store the deployment to created in a constant const frontends = new kplus . Deployment ( chart , 'FrontEnds' ); // create a ClusterIP service that listens on port 9000 and redirects to port 9000 on the containers. frontends . expose ( 9000 ) Notice the resulting manifest, will have the same cdk8s.deployment magic label as the selector. This will cause the service to attach to the pods that were configured as part of the said deployment. apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-frontends-service-pod-1f70150b spec : externalIPs : [] ports : - port : 9000 selector : cdk8s.deployment : ChartFrontEndsDD8A97CE type : ClusterIP","title":"Exposing via a service"},{"location":"plus/ingress/","text":"Ingress \u00b6 Ingress manages external access to services in a cluster, typically through HTTP. Ingress may provide load balancing, SSL termination and name-based virtual hosting. API Reference You must have an Ingress controller to satisfy an Ingress. Only creating an Ingress resource has no effect. The following example will route HTTP requests sent to the /hello url prefix to a service associated with a deployment of the hashicorp/http-echo image. const helloDeployment = new kplus . Deployment ( this , text , { containers : [ { image : 'hashicorp/http-echo' , args : [ '-text' , 'hello ingress' ] } ] }); const helloService = helloDeployment . expose ( 5678 ); const ingress = new Ingress ( this , 'ingress' ); ingress . addRule ( '/hello' , kplus . IngressBackend . fromService ( helloService )); You can use addHostRule(host, path, backend) to define a route that will only apply to requests with this Host header. This can be used to implement virtual hosts. The addDefaultBackend(backend) and addHostDefaultBackend(host, backend) methods can be used to define backends that will accept all requests that do not match any other rules. The TCP port used to route requests to services will be determined based on which ports are exposed by the service (e.g. through serve() ). If the service exposes multiple ports, then a port must be specified via IngressBackend.fromService(service, { port }) .","title":"Ingress"},{"location":"plus/ingress/#ingress","text":"Ingress manages external access to services in a cluster, typically through HTTP. Ingress may provide load balancing, SSL termination and name-based virtual hosting. API Reference You must have an Ingress controller to satisfy an Ingress. Only creating an Ingress resource has no effect. The following example will route HTTP requests sent to the /hello url prefix to a service associated with a deployment of the hashicorp/http-echo image. const helloDeployment = new kplus . Deployment ( this , text , { containers : [ { image : 'hashicorp/http-echo' , args : [ '-text' , 'hello ingress' ] } ] }); const helloService = helloDeployment . expose ( 5678 ); const ingress = new Ingress ( this , 'ingress' ); ingress . addRule ( '/hello' , kplus . IngressBackend . fromService ( helloService )); You can use addHostRule(host, path, backend) to define a route that will only apply to requests with this Host header. This can be used to implement virtual hosts. The addDefaultBackend(backend) and addHostDefaultBackend(host, backend) methods can be used to define backends that will accept all requests that do not match any other rules. The TCP port used to route requests to services will be determined based on which ports are exposed by the service (e.g. through serve() ). If the service exposes multiple ports, then a port must be specified via IngressBackend.fromService(service, { port }) .","title":"Ingress"},{"location":"plus/job/","text":"Job \u00b6 Jobs are a very useful concept in kubernetes deployments. They can be used for add-hoc provisioning tasks, as well as long running processing jobs. In configuration, they don\u2019t differ much from regular pods, but offer some additional properties. API Reference Delete a Job after its finished \u00b6 You can configure a TTL for the job after it finished its execution successfully. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // let's define a job spec, and set a 1 second TTL. const load = new kplus . Job ( chart , 'LoadData' , { ttlAfterFinished : kplus.Duration.seconds ( 1 ) }); // now add a container to all the pods created by this job job . addContainer ({ image : 'loader' });","title":"Job"},{"location":"plus/job/#job","text":"Jobs are a very useful concept in kubernetes deployments. They can be used for add-hoc provisioning tasks, as well as long running processing jobs. In configuration, they don\u2019t differ much from regular pods, but offer some additional properties. API Reference","title":"Job"},{"location":"plus/job/#delete-a-job-after-its-finished","text":"You can configure a TTL for the job after it finished its execution successfully. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // let's define a job spec, and set a 1 second TTL. const load = new kplus . Job ( chart , 'LoadData' , { ttlAfterFinished : kplus.Duration.seconds ( 1 ) }); // now add a container to all the pods created by this job job . addContainer ({ image : 'loader' });","title":"Delete a Job after its finished"},{"location":"plus/pod/","text":"Pod \u00b6 A pod is essentially a collection of containers. It is the most fundamental computation unit that can be provisioned. API Reference Adding Containers/Volumes \u00b6 Containers and volumes can be added to pod definition like so: import * as kplus from 'cdk8s-plus-22' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , }); const storage = kplus . Volume . fromEmptyDir ( 'storage' ); container . mount ( '/data' , storage ); const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // this will automatically add the volume as well. pod . addContainer ( container ); // but if you want to explicitly add it, simply use: pod . addVolume ( storage ); Applying a restart policy \u00b6 import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' , { restartPolicy : kplus.RestartPolicy.NEVER , }); Assigning a ServiceAccount \u00b6 import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' , { serviceAccount : kplus.ServiceAccount.fromServiceAccountName ( 'aws' ), });","title":"Pod"},{"location":"plus/pod/#pod","text":"A pod is essentially a collection of containers. It is the most fundamental computation unit that can be provisioned. API Reference","title":"Pod"},{"location":"plus/pod/#adding-containersvolumes","text":"Containers and volumes can be added to pod definition like so: import * as kplus from 'cdk8s-plus-22' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , }); const storage = kplus . Volume . fromEmptyDir ( 'storage' ); container . mount ( '/data' , storage ); const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // this will automatically add the volume as well. pod . addContainer ( container ); // but if you want to explicitly add it, simply use: pod . addVolume ( storage );","title":"Adding Containers/Volumes"},{"location":"plus/pod/#applying-a-restart-policy","text":"import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' , { restartPolicy : kplus.RestartPolicy.NEVER , });","title":"Applying a restart policy"},{"location":"plus/pod/#assigning-a-serviceaccount","text":"import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' , { serviceAccount : kplus.ServiceAccount.fromServiceAccountName ( 'aws' ), });","title":"Assigning a ServiceAccount"},{"location":"plus/pv/","text":"PersistentVolume \u00b6 A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. API Reference PV\u2019s are used by pods via the pod\u2019s volumes spec, just like regular volumes . They are not intended to be interchangable with volumes, you can think of a PersistentVolume as a specific type of volume, that is detached from a pod\u2019s lifecycle, and exist even if the pod is shutdown. The PersistentVolume construct represents a pre-existing volume in the cluster. Types \u00b6 Each type is implmented as its own construct, exposing both common properties as well as type specific ones. Currently the supported types are: AwsElasticBlockStorePersistentVolume AzureDiskPersistentVolume GCEPersistentDiskPersistentVolume For example, to create a PV from an existing AWS EBS volume: import * as kplus from 'cdk8s-plus-22' ; import * as cdk8s from 'cdk8s' ; const vol = new kplus . AwsElasticBlockStorePersistentVolume ( chart , 'Volume' , { // must exist in aws volumeId : 'vol1234' , // assign the volume to small-ebs storage class storageClassName : 'small-ebs' , // what is the volume storage storage : cdk8s.Size.gibibytes ( 50 ), }); Note that this does not actually create a new volume, it merely manifests an existing volume in AWS as a Kubernetes resource. Reserve \u00b6 See https://kubernetes.io/docs/concepts/storage/persistent-volumes/#reserving-a-persistentvolume Once the PV is defined, you can reserve it: const claim = vol . reserve (); This method creates a new PersistentVolumeClaim and performs a bi-directional binding that reserves the volume for usage. You can use the claim to mount a volume onto a container like usual: container . mount ( '/data' , kplus . Volume . fromPersistentVolumeClaim ( claim )); You can also directly mount a persistent volume, which will implicitly reserve it and create a volume from the created claim: const vol = new kplus . AwsElasticBlockStorePersistentVolume ( chart , 'Volume' , { volumeId : 'vol1234' }); container . mount ( '/data' , vol ); Bind \u00b6 Binding is a part of the reservation process, but it only creates a one directional link. You can use it to bind a PV to an existing PVC. Note however that if the PVC is not bound to the PV, there\u2019s no guarantee this volume will indeed be given that specific claim. const claim = kplus . PersistentVolumeClaim . fromClaimName ( 'claim' ); // will modify the vol resource to refer to the claim. // but no the other way around. vol . bind ( claim );","title":"PersistentVolume"},{"location":"plus/pv/#persistentvolume","text":"A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. API Reference PV\u2019s are used by pods via the pod\u2019s volumes spec, just like regular volumes . They are not intended to be interchangable with volumes, you can think of a PersistentVolume as a specific type of volume, that is detached from a pod\u2019s lifecycle, and exist even if the pod is shutdown. The PersistentVolume construct represents a pre-existing volume in the cluster.","title":"PersistentVolume"},{"location":"plus/pv/#types","text":"Each type is implmented as its own construct, exposing both common properties as well as type specific ones. Currently the supported types are: AwsElasticBlockStorePersistentVolume AzureDiskPersistentVolume GCEPersistentDiskPersistentVolume For example, to create a PV from an existing AWS EBS volume: import * as kplus from 'cdk8s-plus-22' ; import * as cdk8s from 'cdk8s' ; const vol = new kplus . AwsElasticBlockStorePersistentVolume ( chart , 'Volume' , { // must exist in aws volumeId : 'vol1234' , // assign the volume to small-ebs storage class storageClassName : 'small-ebs' , // what is the volume storage storage : cdk8s.Size.gibibytes ( 50 ), }); Note that this does not actually create a new volume, it merely manifests an existing volume in AWS as a Kubernetes resource.","title":"Types"},{"location":"plus/pv/#reserve","text":"See https://kubernetes.io/docs/concepts/storage/persistent-volumes/#reserving-a-persistentvolume Once the PV is defined, you can reserve it: const claim = vol . reserve (); This method creates a new PersistentVolumeClaim and performs a bi-directional binding that reserves the volume for usage. You can use the claim to mount a volume onto a container like usual: container . mount ( '/data' , kplus . Volume . fromPersistentVolumeClaim ( claim )); You can also directly mount a persistent volume, which will implicitly reserve it and create a volume from the created claim: const vol = new kplus . AwsElasticBlockStorePersistentVolume ( chart , 'Volume' , { volumeId : 'vol1234' }); container . mount ( '/data' , vol );","title":"Reserve"},{"location":"plus/pv/#bind","text":"Binding is a part of the reservation process, but it only creates a one directional link. You can use it to bind a PV to an existing PVC. Note however that if the PVC is not bound to the PV, there\u2019s no guarantee this volume will indeed be given that specific claim. const claim = kplus . PersistentVolumeClaim . fromClaimName ( 'claim' ); // will modify the vol resource to refer to the claim. // but no the other way around. vol . bind ( claim );","title":"Bind"},{"location":"plus/pvc/","text":"PersistentVolumeClaim \u00b6 A PersistentVolumeClaim (PVC) is a request for storage by a pod. API Reference A PersistentVolumeClaim contains the requirements of the request, and the Kubernetes control plane is responsible providing a physical volume that satisfies the claim\u2019s requirements. import * as kplus from 'cdk8s-plus-22' ; import * as cdk8s from 'cdk8s' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' }); // create the storage request const claim = new kplus . PersistentVolumeClaim ( chart , 'Claim' , { storage : cdk8s.Size.gibibytes ( 50 ), }); // mount a volume based on the request to the container // this will also add the volume itself to the pod spec. container . mount ( '/data' , kplus . Volume . fromPersistentVolumeClaim ( claim )); Storage Class \u00b6 By default, the storageClassName property of a claim is not set. This means that the backing volume can be provided by one of two methods: Dynamically provision a volume with the default storage class. If a default storage class is not configured in the cluster, the backing volume must pre-exist and not be assigned to any storage class. See Provisioning for more details. You can also provide an explicit storage class name, const claim = new kplus . PersistentVolumeClaim ( chart , 'Claim' , { storage : cdk8s.Size.gibibytes ( 50 ), storageClassName : 'large-ebs' , }); In this case, Kubernetes control plane will either locate an existing volume with the larg-ebs storage class, or dynamically provision a new using the appropriate provisioner. You can also pass in a special \"\" value, this means the volume must not be assigned to any storage class. Since all dynamically provisioend volumes belong to a storage class, setting this value effectively disables dynamic provisioning for this claim. const claim = new kplus . PersistentVolumeClaim ( chart , 'Claim' , { storage : cdk8s.Size.gibibytes ( 50 ), // disable dynamic provisioning storageClassName : \"\" , }); Bind \u00b6 Binding is a part of the reservation process, but it only creates a one directional link. You can use it to bind a PVC to an existing PV. Note however that if the PV is not bound to the PVC, there\u2019s no guarantee this claim will indeed be given to that specific volume. const claim = new kplus . PersistentVolumeClaim ( chart , 'Claim' , { storage : cdk8s.Size.gibibytes ( 50 ), }); const vol = kplus . PersistentVolume . fromPersistentVolumeName ( 'vol' ); // will modify the claim resource to refer to the volume. // but no the other way around. claim . bind ( vol );","title":"PersistentVolumeClaim"},{"location":"plus/pvc/#persistentvolumeclaim","text":"A PersistentVolumeClaim (PVC) is a request for storage by a pod. API Reference A PersistentVolumeClaim contains the requirements of the request, and the Kubernetes control plane is responsible providing a physical volume that satisfies the claim\u2019s requirements. import * as kplus from 'cdk8s-plus-22' ; import * as cdk8s from 'cdk8s' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' }); // create the storage request const claim = new kplus . PersistentVolumeClaim ( chart , 'Claim' , { storage : cdk8s.Size.gibibytes ( 50 ), }); // mount a volume based on the request to the container // this will also add the volume itself to the pod spec. container . mount ( '/data' , kplus . Volume . fromPersistentVolumeClaim ( claim ));","title":"PersistentVolumeClaim"},{"location":"plus/pvc/#storage-class","text":"By default, the storageClassName property of a claim is not set. This means that the backing volume can be provided by one of two methods: Dynamically provision a volume with the default storage class. If a default storage class is not configured in the cluster, the backing volume must pre-exist and not be assigned to any storage class. See Provisioning for more details. You can also provide an explicit storage class name, const claim = new kplus . PersistentVolumeClaim ( chart , 'Claim' , { storage : cdk8s.Size.gibibytes ( 50 ), storageClassName : 'large-ebs' , }); In this case, Kubernetes control plane will either locate an existing volume with the larg-ebs storage class, or dynamically provision a new using the appropriate provisioner. You can also pass in a special \"\" value, this means the volume must not be assigned to any storage class. Since all dynamically provisioend volumes belong to a storage class, setting this value effectively disables dynamic provisioning for this claim. const claim = new kplus . PersistentVolumeClaim ( chart , 'Claim' , { storage : cdk8s.Size.gibibytes ( 50 ), // disable dynamic provisioning storageClassName : \"\" , });","title":"Storage Class"},{"location":"plus/pvc/#bind","text":"Binding is a part of the reservation process, but it only creates a one directional link. You can use it to bind a PVC to an existing PV. Note however that if the PV is not bound to the PVC, there\u2019s no guarantee this claim will indeed be given to that specific volume. const claim = new kplus . PersistentVolumeClaim ( chart , 'Claim' , { storage : cdk8s.Size.gibibytes ( 50 ), }); const vol = kplus . PersistentVolume . fromPersistentVolumeName ( 'vol' ); // will modify the claim resource to refer to the volume. // but no the other way around. claim . bind ( vol );","title":"Bind"},{"location":"plus/secret/","text":"Secret \u00b6 Secrets are used to store confidential information. Never store such information on the definition of the pod itself. API Reference Use an existing Secret \u00b6 To reference a secret created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-22' ; const secret = kplus . Secret . fromSecretName ( 'aws-creds' ); Adding data \u00b6 To create a new secret with some data, use: import * as kplus from 'cdk8s-plus-22' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const secret = new kplus . Secret ( chart , 'Secret' ); secret . addStringData ( 'password' , 'some-encrypted-data' );","title":"Secret"},{"location":"plus/secret/#secret","text":"Secrets are used to store confidential information. Never store such information on the definition of the pod itself. API Reference","title":"Secret"},{"location":"plus/secret/#use-an-existing-secret","text":"To reference a secret created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-22' ; const secret = kplus . Secret . fromSecretName ( 'aws-creds' );","title":"Use an existing Secret"},{"location":"plus/secret/#adding-data","text":"To create a new secret with some data, use: import * as kplus from 'cdk8s-plus-22' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const secret = new kplus . Secret ( chart , 'Secret' ); secret . addStringData ( 'password' , 'some-encrypted-data' );","title":"Adding data"},{"location":"plus/service-account/","text":"ServiceAccount \u00b6 Use service accounts to provide an identity for pods. API Reference Use an existing ServiceAccount \u00b6 To reference a service account created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-22' ; const serviceAccount = kplus . ServiceAccount . fromServiceAccountName ( 'aws-service' ); Allowing access to secrets \u00b6 To create a new service account, and give it access to some secrets, use the following: import * as kplus from 'cdk8s-plus-22' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const awsCreds = kplus . Secret . fromSecretName ( 'aws-creds' ); const awsService = new kplus . ServiceAccount ( chart , 'AWS' ); // give access to the aws creds secret. awsService . addSecret ( awsCreds );","title":"ServiceAccount"},{"location":"plus/service-account/#serviceaccount","text":"Use service accounts to provide an identity for pods. API Reference","title":"ServiceAccount"},{"location":"plus/service-account/#use-an-existing-serviceaccount","text":"To reference a service account created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-22' ; const serviceAccount = kplus . ServiceAccount . fromServiceAccountName ( 'aws-service' );","title":"Use an existing ServiceAccount"},{"location":"plus/service-account/#allowing-access-to-secrets","text":"To create a new service account, and give it access to some secrets, use the following: import * as kplus from 'cdk8s-plus-22' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const awsCreds = kplus . Secret . fromSecretName ( 'aws-creds' ); const awsService = new kplus . ServiceAccount ( chart , 'AWS' ); // give access to the aws creds secret. awsService . addSecret ( awsCreds );","title":"Allowing access to secrets"},{"location":"plus/service/","text":"Service \u00b6 Use services when you want to expose a set of pods using a stable network identity. They can also be used for externalizing endpoints to clients outside of the kubernetes cluster. API Reference Selectors \u00b6 Services must be configured with selectors that tell it which pods should it serve. The most common selector method is using labels. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // this will cause the service to select all pods with the 'run: frontend' label. frontends . selectByLabel ( 'run' , 'frontend' ) Ports \u00b6 Ports that the service will listen and redirect to can be configured like so: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // make the service bind to port 9000 and redirect to port 80 on the associated containers. frontends . serve ({ port : 9000 , targetPort : 80 )","title":"Service"},{"location":"plus/service/#service","text":"Use services when you want to expose a set of pods using a stable network identity. They can also be used for externalizing endpoints to clients outside of the kubernetes cluster. API Reference","title":"Service"},{"location":"plus/service/#selectors","text":"Services must be configured with selectors that tell it which pods should it serve. The most common selector method is using labels. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // this will cause the service to select all pods with the 'run: frontend' label. frontends . selectByLabel ( 'run' , 'frontend' )","title":"Selectors"},{"location":"plus/service/#ports","text":"Ports that the service will listen and redirect to can be configured like so: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // make the service bind to port 9000 and redirect to port 80 on the associated containers. frontends . serve ({ port : 9000 , targetPort : 80 )","title":"Ports"},{"location":"plus/volume/","text":"Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. API Reference Create from a ConfigMap \u00b6 A very useful operation is to create a volume from a ConfigMap . Kubernetes will translate every key in the config map to a file, who\u2019s content is the value of the key. import * as kplus from 'cdk8s-plus-22' ; const configMap = kplus . ConfigMap . fromConfigMapName ( 'redis-config' ); const configVolume = kplus . Volume . fromConfigMap ( configMap ); Create from an EmptyDir \u00b6 The easiest way to allocate some persistent storage to your container is to create a volume from an empty directory. This volume, as the name suggests, is initially empty, and can be written to by containers who mount it. The data in the volume is preserved throughout the lifecycle of the pod, but is deleted forever as soon as the pod itself is removed. import * as kplus from 'cdk8s-plus-22' ; const data = kplus . Volume . fromEmptyDir ( configMap ); const pod = new kplus . Pod ( this , 'Pod' ); const redis = pod . addContainer ({ image : 'redis' }) // mount to the redis container. redis . mount ( '/var/lib/redis' , data );","title":"Volume"},{"location":"plus/volume/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. API Reference","title":"Volume"},{"location":"plus/volume/#create-from-a-configmap","text":"A very useful operation is to create a volume from a ConfigMap . Kubernetes will translate every key in the config map to a file, who\u2019s content is the value of the key. import * as kplus from 'cdk8s-plus-22' ; const configMap = kplus . ConfigMap . fromConfigMapName ( 'redis-config' ); const configVolume = kplus . Volume . fromConfigMap ( configMap );","title":"Create from a ConfigMap"},{"location":"plus/volume/#create-from-an-emptydir","text":"The easiest way to allocate some persistent storage to your container is to create a volume from an empty directory. This volume, as the name suggests, is initially empty, and can be written to by containers who mount it. The data in the volume is preserved throughout the lifecycle of the pod, but is deleted forever as soon as the pod itself is removed. import * as kplus from 'cdk8s-plus-22' ; const data = kplus . Volume . fromEmptyDir ( configMap ); const pod = new kplus . Pod ( this , 'Pod' ); const redis = pod . addContainer ({ image : 'redis' }) // mount to the redis container. redis . mount ( '/var/lib/redis' , data );","title":"Create from an EmptyDir"},{"location":"project/CHANGELOG/","text":"Changelog \u00b6 cdk8s is maintained via 3 repostories, each publishing their own modules. You can see each individual module changelog by visiting the releases page of each repository: cdk8s (Note that the cdk8s package is maintained in the cdk8s-team/cdk8s-core repository) cdk8s-cli cdk8s-plus","title":"Changelog"},{"location":"project/CHANGELOG/#changelog","text":"cdk8s is maintained via 3 repostories, each publishing their own modules. You can see each individual module changelog by visiting the releases page of each repository: cdk8s (Note that the cdk8s package is maintained in the cdk8s-team/cdk8s-core repository) cdk8s-cli cdk8s-plus","title":"Changelog"},{"location":"project/CONTRIBUTING/","text":"Contribution Guide \u00b6 cdk8s is licensed under Apache 2.0 and accepts contributions via GitHub pull requests. This document outlines some of the conventions on commit message formatting, contact points for developers, and other resources to help get contributions into cdk8s. You can contribute to cdk8s in many ways. Contributions of all shapes and sizes are welcome and celebrated: Reporting Issues Code Contributions RFCs We follows the CNCF Community Code of Conduct Reporting Issues \u00b6 If any part of the project has bugs or documentation mistakes, please let us know by raising an issue. We treat bugs and mistakes very seriously and believe no issue is too small. Before creating a bug report, please check that an issue reporting the same problem does not already exist. In addition, make sure you are submitting the issue to the correct repository. If you know your issue petains to a specific cdk8s package, it better belongs in the respective repository. For a list of the repositories, see Repositories An issue can either be a bug report or a feature-request . If you wish to ask a question or seek guidance, please consider one of the other support channels . Bug reports \u00b6 To make the bug report accurate and easy to understand, please try to create bug reports that are: Specific : Include as much details as possible: which version, what environment, what configuration, etc. Reproducible : Include the steps to reproduce the problem. We understand some issues might be hard to reproduce, please includes the steps that might lead to the problem. If possible, please provide a minimal code snippet that reproduces the bug. Isolated : Please try to isolate and reproduce the bug with minimum dependencies. It would significantly slow down the speed to fix a bug if too many dependencies are involved in a bug report. Unique : Do not duplicate existing bug report. Scoped : One bug per report. Do not follow up with another bug inside one report. We might ask for further information to locate a bug. A duplicated bug report will be closed. Submit a bug report here . Feature Requests \u00b6 We also accept suggestions for new features or missing capabilities as GitHub issues. The most important aspect of a suggestion issue is to provide as many details as possible about your use case and less focus on the solution. It is usually possible to support different use cases in many different ways, and we need to understand the motivation before we dive into a solution. If you wish to suggest a major change to the project, please consider to submit an RFC instead of a simple issue. An RFC also starts with a GitHub issue. Submit a suggestion here Code Contributions \u00b6 The general workflow for code contributions: Submit/find an issue in this repository Clone the relevant repo Make your code change Write tests & update docs Build & test locally Submit a pull request (Iterate) Your PR will be approved and merged Tracking issue \u00b6 All pull requests should be tracked with a GitHub issue. You should search for an existing issue or raise a new bug or suggestion . Add a comment indicating you are willing to pick it up in order to ensure no one else is currently working on it. If this is a major contribution, consider submitting an RFC to obtain feedback from the community and maintainers. Repositories \u00b6 This project consists of multiple modules, maintained and released via the following repositories: cdk8s-cli : command-line interface cdk8s-core : core library cdk8s-plus : high-level constructs for Kubernetes core. Development environment \u00b6 Prerequisites: Node.js >= 12.14.0 yarn >= 1.22.0 Prepare your environment: Fork the relevant repo and obtain a local clone. Install all dependencies: yarn install Run yarn build to build all modules. Unit tests \u00b6 Unit tests are located under the test/ directory within each module and use the jest framework. To run unit tests, execute yarn test either from the root of the repo (to unit test all modules) or from individual module directories: yarn test Out tests utilize jest snapshot testing . In case a snapshot needs to be updated, just run: yarn test -u Integration Tests \u00b6 Integration tests are executed against the latest published modules . This means that in order to execute integration tests against a development version, you\u2019lol need to yarn link your local version to this repository (all deps are at the root): $ cd cdk8s-core $ yarn link $ cd ../cdk8s $ yarn link cdk8s Now, you can run integration tests via: yarn integ Our integration tests also utilize snapshot testing. To update integration test snapshots, run: yarn integ:update Running Integration Tests \u00b6 The test directory contains integration tests for the cdk8s project. Each subdirectory represents a single test, with an entrypoint of test.sh . Tests are written as simple shell scripts and can simulate user activity. You can either run individual tests by executing their entrypoint directly (e.g. test-python-app/test.sh ) or run all tests by executing the script ./test-all.sh . Writing Integration Tests \u00b6 Create a new subdirectory with a test- prefix. Create a file named test.sh , make it executable. Test Environment: The script test.sh is executed within a temporary working directory under /tmp/xxxx/test (where xxxx is some random tmp file). See existing tests as examples on how to bring in auxiliary files to the test. Test MUST NOT install any dependencies or the cdk8s CLI. They can expect it to be available in the environment. To install dependencies from package managers, use yarn , npm , pipenv , mvn and nuget . Those programs will be shimmed to allow consuming local dependencies. Snapshot Testing \u00b6 Some integration tests utilize a simple snapshot testing mechanism. To update snapshots, run tests with: UPDATE_SNAPSHOTS=1 Or, run this from the root of the repo: yarn integ:update Docker environment for integration tests \u00b6 Due to the polyglot nature of the jsii tools used by cdk8s, the toolchain requirements are somewhat more complicated than for most projects. To help with this, you can use the jsii/superchain docker image that includes all the required tools. In order to get an interactive shell within a superchain container you can use the following command. docker run --rm --net=host -it -v $PWD:$PWD -w $PWD jsii/superchain Then once in the docker shell, you can package and execute the tests as normal. $ pip install pipenv # Currently not included in jsii docker image $ yarn build $ yarn run package $ yarn integ:update Note: this may leave some files owned as the docker root user id. These will need to be cleaned up manually. Pull Requests \u00b6 We use the PR title when we automatically generate the change log for each release. Therefore please following these guidelines to the letter: PR title : Must adhere to conventional commits . All lowercase with no period at the end of the title If this is a fix (bug) the title should describe the bug If this is a feat (feature) the title should describe the feature PR description : Describe how did you fix the bug or what changes you had to make in order to implement the feature Indicate fixes #NNN or resolves #NNN with the tracking issue number. If you had to test your change manually, describe how you tested it and paste the test results. If this is a breaking change, the last paragraph should describe the breaking change with the prefix BREAKING CHANGE: xxxxxx . Developer Certificate Of Origin (DCO) \u00b6 Every commit should be signed-off in compliance with the Developer Certificate Of Origin . You can sign your commits by using the git commit -s command. To configure automatic signoff, see git-hooks . Documentation \u00b6 Documentation is rendered from markdown using mkdocs-material and sourced from the docs directory. API documentation for cdk8s and all cdk8s-plus-* packages is auto-generated from inline docstrings during build. To test locally, install python3 deps: pip3 install -r docs/requirements.txt And then: mkdocs serve This will serve a local web server with the website. A good reference for syntax and capabilities is the mkdocs-material website. Examples \u00b6 Examples are stored under examples and organized according to programming language. Every example also has an entry under docs/examples/xxx which describes the example and includes links to the source code (on the main branch). RFCs \u00b6 An RFC (request for comments) is a document that proposes and details a change or addition to cdk8s. It also is a process for reviewing and discussing the proposal and tracking its implementation. \u201cRequest for comments\u201d means a request for discussion and oversight about the future of cdk8s from contributors and users. It is an open forum for suggestions, questions, and feedback. To create an RFC follow this process: Create an [issue][https://github.com/cdk8s-team/cdk8s/issues/new?assignees=&labels=enhancement&template=rfc.md&title=%5BRFC%5D+describe+your+RFC] which will be the tracking issue for this RFC. Title should represent the title of the RFC. Description should provide the motivation for the RFC. Create a markdown file based off of rfc/0000-template.md under the rfc/<nnnn>-<title-of-rfc> where <nnnn> is the tracking issue number and <title-of-rfc> is a symbolic name for the title. For example: rfc/0030-construct-operators.md . File a pull request with this markdown file. The title of the PR should indicate rfc: <nnnn> <same as issue title> . The RFC will be reviewed as a pull request and once merged it means it is ready for implementation. Community Meeting \u00b6 Note: Community meetings are currently on hold. We will be back soon. Keep an eye out for announcements on the #cdk8s channel in cdk.dev workspace. Join us for the cdk8s community meeting which takes place the 2nd Monday of the month at 9:00am Pacific Time . Meeting link: https://chime.aws/7929414778 Agenda Portions of this guide were adopted from the contribution guides of the AWS CDK and etcd .","title":"Contribution Guide"},{"location":"project/CONTRIBUTING/#contribution-guide","text":"cdk8s is licensed under Apache 2.0 and accepts contributions via GitHub pull requests. This document outlines some of the conventions on commit message formatting, contact points for developers, and other resources to help get contributions into cdk8s. You can contribute to cdk8s in many ways. Contributions of all shapes and sizes are welcome and celebrated: Reporting Issues Code Contributions RFCs We follows the CNCF Community Code of Conduct","title":"Contribution Guide"},{"location":"project/CONTRIBUTING/#reporting-issues","text":"If any part of the project has bugs or documentation mistakes, please let us know by raising an issue. We treat bugs and mistakes very seriously and believe no issue is too small. Before creating a bug report, please check that an issue reporting the same problem does not already exist. In addition, make sure you are submitting the issue to the correct repository. If you know your issue petains to a specific cdk8s package, it better belongs in the respective repository. For a list of the repositories, see Repositories An issue can either be a bug report or a feature-request . If you wish to ask a question or seek guidance, please consider one of the other support channels .","title":"Reporting Issues"},{"location":"project/CONTRIBUTING/#bug-reports","text":"To make the bug report accurate and easy to understand, please try to create bug reports that are: Specific : Include as much details as possible: which version, what environment, what configuration, etc. Reproducible : Include the steps to reproduce the problem. We understand some issues might be hard to reproduce, please includes the steps that might lead to the problem. If possible, please provide a minimal code snippet that reproduces the bug. Isolated : Please try to isolate and reproduce the bug with minimum dependencies. It would significantly slow down the speed to fix a bug if too many dependencies are involved in a bug report. Unique : Do not duplicate existing bug report. Scoped : One bug per report. Do not follow up with another bug inside one report. We might ask for further information to locate a bug. A duplicated bug report will be closed. Submit a bug report here .","title":"Bug reports"},{"location":"project/CONTRIBUTING/#feature-requests","text":"We also accept suggestions for new features or missing capabilities as GitHub issues. The most important aspect of a suggestion issue is to provide as many details as possible about your use case and less focus on the solution. It is usually possible to support different use cases in many different ways, and we need to understand the motivation before we dive into a solution. If you wish to suggest a major change to the project, please consider to submit an RFC instead of a simple issue. An RFC also starts with a GitHub issue. Submit a suggestion here","title":"Feature Requests"},{"location":"project/CONTRIBUTING/#code-contributions","text":"The general workflow for code contributions: Submit/find an issue in this repository Clone the relevant repo Make your code change Write tests & update docs Build & test locally Submit a pull request (Iterate) Your PR will be approved and merged","title":"Code Contributions"},{"location":"project/CONTRIBUTING/#tracking-issue","text":"All pull requests should be tracked with a GitHub issue. You should search for an existing issue or raise a new bug or suggestion . Add a comment indicating you are willing to pick it up in order to ensure no one else is currently working on it. If this is a major contribution, consider submitting an RFC to obtain feedback from the community and maintainers.","title":"Tracking issue"},{"location":"project/CONTRIBUTING/#repositories","text":"This project consists of multiple modules, maintained and released via the following repositories: cdk8s-cli : command-line interface cdk8s-core : core library cdk8s-plus : high-level constructs for Kubernetes core.","title":"Repositories"},{"location":"project/CONTRIBUTING/#development-environment","text":"Prerequisites: Node.js >= 12.14.0 yarn >= 1.22.0 Prepare your environment: Fork the relevant repo and obtain a local clone. Install all dependencies: yarn install Run yarn build to build all modules.","title":"Development environment"},{"location":"project/CONTRIBUTING/#unit-tests","text":"Unit tests are located under the test/ directory within each module and use the jest framework. To run unit tests, execute yarn test either from the root of the repo (to unit test all modules) or from individual module directories: yarn test Out tests utilize jest snapshot testing . In case a snapshot needs to be updated, just run: yarn test -u","title":"Unit tests"},{"location":"project/CONTRIBUTING/#integration-tests","text":"Integration tests are executed against the latest published modules . This means that in order to execute integration tests against a development version, you\u2019lol need to yarn link your local version to this repository (all deps are at the root): $ cd cdk8s-core $ yarn link $ cd ../cdk8s $ yarn link cdk8s Now, you can run integration tests via: yarn integ Our integration tests also utilize snapshot testing. To update integration test snapshots, run: yarn integ:update","title":"Integration Tests"},{"location":"project/CONTRIBUTING/#pull-requests","text":"We use the PR title when we automatically generate the change log for each release. Therefore please following these guidelines to the letter: PR title : Must adhere to conventional commits . All lowercase with no period at the end of the title If this is a fix (bug) the title should describe the bug If this is a feat (feature) the title should describe the feature PR description : Describe how did you fix the bug or what changes you had to make in order to implement the feature Indicate fixes #NNN or resolves #NNN with the tracking issue number. If you had to test your change manually, describe how you tested it and paste the test results. If this is a breaking change, the last paragraph should describe the breaking change with the prefix BREAKING CHANGE: xxxxxx .","title":"Pull Requests"},{"location":"project/CONTRIBUTING/#documentation","text":"Documentation is rendered from markdown using mkdocs-material and sourced from the docs directory. API documentation for cdk8s and all cdk8s-plus-* packages is auto-generated from inline docstrings during build. To test locally, install python3 deps: pip3 install -r docs/requirements.txt And then: mkdocs serve This will serve a local web server with the website. A good reference for syntax and capabilities is the mkdocs-material website.","title":"Documentation"},{"location":"project/CONTRIBUTING/#examples","text":"Examples are stored under examples and organized according to programming language. Every example also has an entry under docs/examples/xxx which describes the example and includes links to the source code (on the main branch).","title":"Examples"},{"location":"project/CONTRIBUTING/#rfcs","text":"An RFC (request for comments) is a document that proposes and details a change or addition to cdk8s. It also is a process for reviewing and discussing the proposal and tracking its implementation. \u201cRequest for comments\u201d means a request for discussion and oversight about the future of cdk8s from contributors and users. It is an open forum for suggestions, questions, and feedback. To create an RFC follow this process: Create an [issue][https://github.com/cdk8s-team/cdk8s/issues/new?assignees=&labels=enhancement&template=rfc.md&title=%5BRFC%5D+describe+your+RFC] which will be the tracking issue for this RFC. Title should represent the title of the RFC. Description should provide the motivation for the RFC. Create a markdown file based off of rfc/0000-template.md under the rfc/<nnnn>-<title-of-rfc> where <nnnn> is the tracking issue number and <title-of-rfc> is a symbolic name for the title. For example: rfc/0030-construct-operators.md . File a pull request with this markdown file. The title of the PR should indicate rfc: <nnnn> <same as issue title> . The RFC will be reviewed as a pull request and once merged it means it is ready for implementation.","title":"RFCs"},{"location":"project/CONTRIBUTING/#community-meeting","text":"Note: Community meetings are currently on hold. We will be back soon. Keep an eye out for announcements on the #cdk8s channel in cdk.dev workspace. Join us for the cdk8s community meeting which takes place the 2nd Monday of the month at 9:00am Pacific Time . Meeting link: https://chime.aws/7929414778 Agenda Portions of this guide were adopted from the contribution guides of the AWS CDK and etcd .","title":"Community Meeting"},{"location":"project/ROADMAP/","text":"Roadmap \u00b6 To see items we are working on, visit our RoadMap GitHub project . You can submit an idea here .","title":"Roadmap"},{"location":"project/ROADMAP/#roadmap","text":"To see items we are working on, visit our RoadMap GitHub project . You can submit an idea here .","title":"Roadmap"},{"location":"reference/","text":"Overview \u00b6 This section includes API reference for the various components of cdk8s: cdk8s : Core library TypeScript Python Java Go cdk8s-plus-22 : Intent-based APIs for Kubernetes resources. (spec version 1.22.0 ) TypeScript Python Java Go cdk8s-plus-21 : Intent-based APIs for Kubernetes resources. (spec version 1.21.0 ) TypeScript Python Java Go cdk8s-plus-20 : Intent-based APIs for Kubernetes resources. (spec version 1.20.0 ) TypeScript Python Java Go cdk8s-plus-17 : Intent-based APIs for Kubernetes resources. (spec version 1.17.0 ) TypeScript Python Java Go","title":"Overview"},{"location":"reference/#overview","text":"This section includes API reference for the various components of cdk8s: cdk8s : Core library TypeScript Python Java Go cdk8s-plus-22 : Intent-based APIs for Kubernetes resources. (spec version 1.22.0 ) TypeScript Python Java Go cdk8s-plus-21 : Intent-based APIs for Kubernetes resources. (spec version 1.21.0 ) TypeScript Python Java Go cdk8s-plus-20 : Intent-based APIs for Kubernetes resources. (spec version 1.20.0 ) TypeScript Python Java Go cdk8s-plus-17 : Intent-based APIs for Kubernetes resources. (spec version 1.17.0 ) TypeScript Python Java Go","title":"Overview"},{"location":"reference/cdk8s/go/","text":"cdk8s (Go) \u00b6 For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-core-go/cdk8s .","title":"Go"},{"location":"reference/cdk8s/go/#cdk8s-go","text":"For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-core-go/cdk8s .","title":"cdk8s (Go) "},{"location":"reference/cdk8s/java/","text":"cdk8s (Java) \u00b6 Constructs \u00b6 ApiObject \u00b6 Initializers \u00b6 import org.cdk8s.ApiObject ; ApiObject . Builder . create ( Construct scope , java . lang . String id ) . apiVersion ( java . lang . String ) . kind ( java . lang . String ) // .metadata(ApiObjectMetadata) . build (); scope Required \u00b6 Type: software.constructs.Construct the construct scope. id Required \u00b6 Type: java.lang.String namespace. apiVersion Required \u00b6 Type: java.lang.String API version. kind Required \u00b6 Type: java.lang.String Resource kind. metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. Methods \u00b6 addDependency \u00b6 public addDependency ( IConstruct dependencies ) dependencies Required \u00b6 Type: software.constructs.IConstruct the dependencies to add. addJsonPatch \u00b6 public addJsonPatch ( JsonPatch ops ) ops Required \u00b6 Type: org.cdk8s.JsonPatch The JSON-Patch operations to apply. toJson \u00b6 public toJson () Static Functions \u00b6 of \u00b6 import org.cdk8s.ApiObject ; ApiObject . of ( IConstruct c ) c Required \u00b6 Type: software.constructs.IConstruct The higher-level construct. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. authorization.k8s.io/v1 ). chart Required \u00b6 public Chart getChart (); Type: org.cdk8s.Chart The chart in which this object is defined. kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind. metadata Required \u00b6 public ApiObjectMetadataDefinition getMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Metadata associated with this API object. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. App \u00b6 Represents a cdk8s application. Initializers \u00b6 import org.cdk8s.App ; App . Builder . create () // .outdir(java.lang.String) // .outputFileExtension(java.lang.String) // .yamlOutputType(YamlOutputType) . build (); outdir Optional \u00b6 Type: java.lang.String Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. outputFileExtension Optional \u00b6 Type: java.lang.String Default: .k8s.yaml The file extension to use for rendered YAML files. yamlOutputType Optional \u00b6 Type: org.cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Methods \u00b6 synth \u00b6 public synth () synthYaml \u00b6 public synthYaml () Properties \u00b6 charts Required \u00b6 public java . util . List < Chart > getCharts (); Type: java.util.List< org.cdk8s.Chart > Returns all the charts in this app, sorted topologically. outdir Required \u00b6 public java . lang . String getOutdir (); Type: java.lang.String The output directory into which manifests will be synthesized. outputFileExtension Required \u00b6 public java . lang . String getOutputFileExtension (); Type: java.lang.String Default: .k8s.yaml The file extension to use for rendered YAML files. yamlOutputType Required \u00b6 public YamlOutputType getYamlOutputType (); Type: org.cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Chart \u00b6 Initializers \u00b6 import org.cdk8s.Chart ; Chart . Builder . create ( Construct scope , java . lang . String id ) // .labels(java.util.Map<java.lang.String, java.lang.String>) // .namespace(java.lang.String) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String labels Optional \u00b6 Type: java.util.Map java.lang.String > Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 Type: java.lang.String Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. Methods \u00b6 addDependency \u00b6 public addDependency ( IConstruct dependencies ) dependencies Required \u00b6 Type: software.constructs.IConstruct the dependencies to add. generateObjectName \u00b6 public generateObjectName ( ApiObject apiObject ) apiObject Required \u00b6 Type: org.cdk8s.ApiObject The API object to generate a name for. toJson \u00b6 public toJson () Static Functions \u00b6 isChart \u00b6 import org.cdk8s.Chart ; Chart . isChart ( java . lang . Object x ) x Required \u00b6 Type: java.lang.Object of \u00b6 import org.cdk8s.Chart ; Chart . of ( IConstruct c ) c Required \u00b6 Type: software.constructs.IConstruct a construct node. Properties \u00b6 labels Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Labels applied to all resources in this chart. This is an immutable copy. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String The default namespace for all objects in this chart. Helm \u00b6 Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs. Initializers \u00b6 import org.cdk8s.Helm ; Helm . Builder . create ( Construct scope , java . lang . String id ) . chart ( java . lang . String ) // .helmExecutable(java.lang.String) // .helmFlags(java.util.List<java.lang.String>) // .releaseName(java.lang.String) // .values(java.util.Map<java.lang.String, java.lang.Object>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String chart Required \u00b6 Type: java.lang.String The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helmExecutable Optional \u00b6 Type: java.lang.String Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helmFlags Optional \u00b6 Type: java.util.List< java.lang.String > Default: [] Additional flags to add to the helm execution. releaseName Optional \u00b6 Type: java.lang.String Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 Type: java.util.Map java.lang.Object > Default: If no values are specified, chart will use the defaults. Values to pass to the chart. Properties \u00b6 releaseName Required \u00b6 public java . lang . String getReleaseName (); Type: java.lang.String The helm release name. Include \u00b6 Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest. Initializers \u00b6 import org.cdk8s.Include ; Include . Builder . create ( Construct scope , java . lang . String id ) . url ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String url Required \u00b6 Type: java.lang.String Local file path or URL which includes a Kubernetes YAML manifest. Properties \u00b6 apiObjects Required \u00b6 public java . util . List < ApiObject > getApiObjects (); Type: java.util.List< org.cdk8s.ApiObject > Returns all the included API objects. Structs \u00b6 ApiObjectMetadata \u00b6 Metadata associated with this object. Initializer \u00b6 import org.cdk8s.ApiObjectMetadata ; ApiObjectMetadata . builder () // .annotations(java.util.Map<java.lang.String, java.lang.String>) // .finalizers(java.util.List<java.lang.String>) // .labels(java.util.Map<java.lang.String, java.lang.String>) // .name(java.lang.String) // .namespace(java.lang.String) // .ownerReferences(java.util.List<OwnerReference>) . build (); annotations Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getAnnotations (); Type: java.util.Map java.lang.String > Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations finalizers Optional \u00b6 public java . util . List < java . lang . String > getFinalizers (); Type: java.util.List< java.lang.String > Default: No finalizers. Namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order. Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/ labels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces ownerReferences Optional \u00b6 public java . util . List < OwnerReference > getOwnerReferences (); Type: java.util.List< org.cdk8s.OwnerReference > Default: automatically set by Kubernetes List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. Kubernetes sets the value of this field automatically for objects that are dependents of other objects like ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers. You can also configure these relationships manually by changing the value of this field. However, you usually don\u2019t need to and can allow Kubernetes to automatically manage the relationships. https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/ ApiObjectProps \u00b6 Options for defining API objects. Initializer \u00b6 import org.cdk8s.ApiObjectProps ; ApiObjectProps . builder () . apiVersion ( java . lang . String ) . kind ( java . lang . String ) // .metadata(ApiObjectMetadata) . build (); apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String API version. kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Resource kind. metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. AppProps \u00b6 Initializer \u00b6 import org.cdk8s.AppProps ; AppProps . builder () // .outdir(java.lang.String) // .outputFileExtension(java.lang.String) // .yamlOutputType(YamlOutputType) . build (); outdir Optional \u00b6 public java . lang . String getOutdir (); Type: java.lang.String Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. outputFileExtension Optional \u00b6 public java . lang . String getOutputFileExtension (); Type: java.lang.String Default: .k8s.yaml The file extension to use for rendered YAML files. yamlOutputType Optional \u00b6 public YamlOutputType getYamlOutputType (); Type: org.cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. ChartProps \u00b6 Initializer \u00b6 import org.cdk8s.ChartProps ; ChartProps . builder () // .labels(java.util.Map<java.lang.String, java.lang.String>) // .namespace(java.lang.String) . build (); labels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. GroupVersionKind \u00b6 Initializer \u00b6 import org.cdk8s.GroupVersionKind ; GroupVersionKind . builder () . apiVersion ( java . lang . String ) . kind ( java . lang . String ) . build (); apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. authorization.k8s.io/v1 ). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind. HelmProps \u00b6 Options for Helm . Initializer \u00b6 import org.cdk8s.HelmProps ; HelmProps . builder () . chart ( java . lang . String ) // .helmExecutable(java.lang.String) // .helmFlags(java.util.List<java.lang.String>) // .releaseName(java.lang.String) // .values(java.util.Map<java.lang.String, java.lang.Object>) . build (); chart Required \u00b6 public java . lang . String getChart (); Type: java.lang.String The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helmExecutable Optional \u00b6 public java . lang . String getHelmExecutable (); Type: java.lang.String Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helmFlags Optional \u00b6 public java . util . List < java . lang . String > getHelmFlags (); Type: java.util.List< java.lang.String > Default: [] Additional flags to add to the helm execution. releaseName Optional \u00b6 public java . lang . String getReleaseName (); Type: java.lang.String Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 public java . util . Map < java . lang . String , java . lang . Object > getValues (); Type: java.util.Map java.lang.Object > Default: If no values are specified, chart will use the defaults. Values to pass to the chart. IncludeProps \u00b6 Initializer \u00b6 import org.cdk8s.IncludeProps ; IncludeProps . builder () . url ( java . lang . String ) . build (); url Required \u00b6 public java . lang . String getUrl (); Type: java.lang.String Local file path or URL which includes a Kubernetes YAML manifest. NameOptions \u00b6 Options for name generation. Initializer \u00b6 import org.cdk8s.NameOptions ; NameOptions . builder () // .delimiter(java.lang.String) // .extra(java.util.List<java.lang.String>) // .includeHash(java.lang.Boolean) // .maxLen(java.lang.Number) . build (); delimiter Optional \u00b6 public java . lang . String getDelimiter (); Type: java.lang.String Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 public java . util . List < java . lang . String > getExtra (); Type: java.util.List< java.lang.String > Default: [] use the construct path components Extra components to include in the name. includeHash Optional \u00b6 public java . lang . Boolean getIncludeHash (); Type: java.lang.Boolean Default: true Include a short hash as last part of the name. maxLen Optional \u00b6 public java . lang . Number getMaxLen (); Type: java.lang.Number Default: 63 Maximum allowed length for the name. OwnerReference \u00b6 OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field. Initializer \u00b6 import org.cdk8s.OwnerReference ; OwnerReference . builder () . apiVersion ( java . lang . String ) . kind ( java . lang . String ) . name ( java . lang . String ) . uid ( java . lang . String ) // .blockOwnerDeletion(java.lang.Boolean) // .controller(java.lang.Boolean) . build (); apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String API version of the referent. kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Kind of the referent. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of the referent. http://kubernetes.io/docs/user-guide/identifiers#names uid Required \u00b6 public java . lang . String getUid (); Type: java.lang.String UID of the referent. http://kubernetes.io/docs/user-guide/identifiers#uids blockOwnerDeletion Optional \u00b6 public java . lang . Boolean getBlockOwnerDeletion (); Type: java.lang.Boolean Default: false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. If true, AND if the owner has the \u201cforegroundDeletion\u201d finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. controller Optional \u00b6 public java . lang . Boolean getController (); Type: java.lang.Boolean If true, this reference points to the managing controller. SizeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import org.cdk8s.SizeConversionOptions ; SizeConversionOptions . builder () // .rounding(SizeRoundingBehavior) . build (); rounding Optional \u00b6 public SizeRoundingBehavior getRounding (); Type: org.cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. TimeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import org.cdk8s.TimeConversionOptions ; TimeConversionOptions . builder () // .integral(java.lang.Boolean) . build (); integral Optional \u00b6 public java . lang . Boolean getIntegral (); Type: java.lang.Boolean Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Classes \u00b6 ApiObjectMetadataDefinition \u00b6 Object metadata. Initializers \u00b6 import org.cdk8s.ApiObjectMetadataDefinition ; ApiObjectMetadataDefinition . Builder . create () // .annotations(java.util.Map<java.lang.String, java.lang.String>) // .finalizers(java.util.List<java.lang.String>) // .labels(java.util.Map<java.lang.String, java.lang.String>) // .name(java.lang.String) // .namespace(java.lang.String) // .ownerReferences(java.util.List<OwnerReference>) . build (); annotations Optional \u00b6 Type: java.util.Map java.lang.String > Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations finalizers Optional \u00b6 Type: java.util.List< java.lang.String > Default: No finalizers. Namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order. Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/ labels Optional \u00b6 Type: java.util.Map java.lang.String > Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 Type: java.lang.String Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 Type: java.lang.String Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces ownerReferences Optional \u00b6 Type: java.util.List< org.cdk8s.OwnerReference > Default: automatically set by Kubernetes List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. Kubernetes sets the value of this field automatically for objects that are dependents of other objects like ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers. You can also configure these relationships manually by changing the value of this field. However, you usually don\u2019t need to and can allow Kubernetes to automatically manage the relationships. https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/ Methods \u00b6 add \u00b6 public add ( java . lang . String key , java . lang . Object value ) key Required \u00b6 Type: java.lang.String Metadata key. value Required \u00b6 Type: java.lang.Object Metadata value. addAnnotation \u00b6 public addAnnotation ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addFinalizers \u00b6 public addFinalizers ( java . lang . String finalizers ) finalizers Required \u00b6 Type: java.lang.String the finalizers. addLabel \u00b6 public addLabel ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addOwnerReference \u00b6 public addOwnerReference ( OwnerReference owner ) owner Required \u00b6 Type: org.cdk8s.OwnerReference the owner. getLabel \u00b6 public getLabel ( java . lang . String key ) key Required \u00b6 Type: java.lang.String the label. toJson \u00b6 public toJson () Properties \u00b6 name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String The object\u2019s namespace. DependencyGraph \u00b6 Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph. Initializers \u00b6 import org.cdk8s.DependencyGraph ; new DependencyGraph ( Node node ); node Required \u00b6 Type: software.constructs.Node Methods \u00b6 topology \u00b6 public topology () Properties \u00b6 root Required \u00b6 public DependencyVertex getRoot (); Type: org.cdk8s.DependencyVertex Returns the root of the graph. Note that this vertex will always have null as its .value since it is an artifical root that binds all the connected spaces of the graph. DependencyVertex \u00b6 Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter. Initializers \u00b6 import org.cdk8s.DependencyVertex ; new DependencyVertex (); new DependencyVertex ( IConstruct value ); value Optional \u00b6 Type: software.constructs.IConstruct Methods \u00b6 addChild \u00b6 public addChild ( DependencyVertex dep ) dep Required \u00b6 Type: org.cdk8s.DependencyVertex The dependency. topology \u00b6 public topology () Properties \u00b6 inbound Required \u00b6 public java . util . List < DependencyVertex > getInbound (); Type: java.util.List< org.cdk8s.DependencyVertex > Returns the parents of the vertex (i.e dependants). outbound Required \u00b6 public java . util . List < DependencyVertex > getOutbound (); Type: java.util.List< org.cdk8s.DependencyVertex > Returns the children of the vertex (i.e dependencies). value Optional \u00b6 public IConstruct getValue (); Type: software.constructs.IConstruct Returns the IConstruct this graph vertex represents. null in case this is the root of the graph. Duration \u00b6 Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. Methods \u00b6 toDays \u00b6 public toDays () public toDays ( TimeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.TimeConversionOptions toHours \u00b6 public toHours () public toHours ( TimeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.TimeConversionOptions toHumanString \u00b6 public toHumanString () toIsoString \u00b6 public toIsoString () toMilliseconds \u00b6 public toMilliseconds () public toMilliseconds ( TimeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.TimeConversionOptions toMinutes \u00b6 public toMinutes () public toMinutes ( TimeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.TimeConversionOptions toSeconds \u00b6 public toSeconds () public toSeconds ( TimeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.TimeConversionOptions Static Functions \u00b6 days \u00b6 import org.cdk8s.Duration ; Duration . days ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number the amount of Days the Duration will represent. hours \u00b6 import org.cdk8s.Duration ; Duration . hours ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number the amount of Hours the Duration will represent. millis \u00b6 import org.cdk8s.Duration ; Duration . millis ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number the amount of Milliseconds the Duration will represent. minutes \u00b6 import org.cdk8s.Duration ; Duration . minutes ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number the amount of Minutes the Duration will represent. parse \u00b6 import org.cdk8s.Duration ; Duration . parse ( java . lang . String duration ) duration Required \u00b6 Type: java.lang.String an ISO-formtted duration to be parsed. seconds \u00b6 import org.cdk8s.Duration ; Duration . seconds ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number the amount of Seconds the Duration will represent. JsonPatch \u00b6 Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc. Static Functions \u00b6 add \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . add ( java . lang . String path , java . lang . Object value ) path Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.Object apply \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . apply ( java . lang . Object document , JsonPatch ops ) document Required \u00b6 Type: java.lang.Object The document to patch. ops Required \u00b6 Type: org.cdk8s.JsonPatch The operations to apply. copy \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . copy ( java . lang . String from , java . lang . String path ) from Required \u00b6 Type: java.lang.String path Required \u00b6 Type: java.lang.String move \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . move ( java . lang . String from , java . lang . String path ) from Required \u00b6 Type: java.lang.String path Required \u00b6 Type: java.lang.String remove \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . remove ( java . lang . String path ) path Required \u00b6 Type: java.lang.String replace \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . replace ( java . lang . String path , java . lang . Object value ) path Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.Object test \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . test ( java . lang . String path , java . lang . Object value ) path Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.Object Lazy \u00b6 Methods \u00b6 produce \u00b6 public produce () Static Functions \u00b6 any \u00b6 import org.cdk8s.Lazy ; Lazy . any ( IAnyProducer producer ) producer Required \u00b6 Type: org.cdk8s.IAnyProducer Names \u00b6 Utilities for generating unique and stable names. Static Functions \u00b6 toDnsLabel \u00b6 import org.cdk8s.Names ; Names . toDnsLabel ( Construct scope ) Names . toDnsLabel ( Construct scope , NameOptions options ) scope Required \u00b6 Type: software.constructs.Construct The construct for which to render the DNS label. options Optional \u00b6 Type: org.cdk8s.NameOptions Name options. toLabelValue \u00b6 import org.cdk8s.Names ; Names . toLabelValue ( Construct scope ) Names . toLabelValue ( Construct scope , NameOptions options ) scope Required \u00b6 Type: software.constructs.Construct The construct for which to render the DNS label. options Optional \u00b6 Type: org.cdk8s.NameOptions Name options. Size \u00b6 Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible. Methods \u00b6 toGibibytes \u00b6 public toGibibytes () public toGibibytes ( SizeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.SizeConversionOptions toKibibytes \u00b6 public toKibibytes () public toKibibytes ( SizeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.SizeConversionOptions toMebibytes \u00b6 public toMebibytes () public toMebibytes ( SizeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.SizeConversionOptions toPebibytes \u00b6 public toPebibytes () public toPebibytes ( SizeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.SizeConversionOptions toTebibytes \u00b6 public toTebibytes () public toTebibytes ( SizeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.SizeConversionOptions Static Functions \u00b6 gibibytes \u00b6 import org.cdk8s.Size ; Size . gibibytes ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number kibibytes \u00b6 import org.cdk8s.Size ; Size . kibibytes ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number mebibytes \u00b6 import org.cdk8s.Size ; Size . mebibytes ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number pebibyte \u00b6 import org.cdk8s.Size ; Size . pebibyte ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number tebibytes \u00b6 import org.cdk8s.Size ; Size . tebibytes ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number Testing \u00b6 Testing utilities for cdk8s applications. Static Functions \u00b6 app \u00b6 import org.cdk8s.Testing ; Testing . app () Testing . app ( AppProps props ) props Optional \u00b6 Type: org.cdk8s.AppProps chart \u00b6 import org.cdk8s.Testing ; Testing . chart () synth \u00b6 import org.cdk8s.Testing ; Testing . synth ( Chart chart ) chart Required \u00b6 Type: org.cdk8s.Chart Yaml \u00b6 YAML utilities. Static Functions \u00b6 ~~ formatObjects ~~ \u00b6 import org.cdk8s.Yaml ; Yaml . formatObjects ( java . util . List < java . lang . Object > docs ) docs Required \u00b6 Type: java.util.List< java.lang.Object > load \u00b6 import org.cdk8s.Yaml ; Yaml . load ( java . lang . String urlOrFile ) urlOrFile Required \u00b6 Type: java.lang.String a URL of a file path to load from. save \u00b6 import org.cdk8s.Yaml ; Yaml . save ( java . lang . String filePath , java . util . List < java . lang . Object > docs ) filePath Required \u00b6 Type: java.lang.String The output path. docs Required \u00b6 Type: java.util.List< java.lang.Object > The set of objects. stringify \u00b6 import org.cdk8s.Yaml ; Yaml . stringify ( java . lang . Object docs ) docs Required \u00b6 Type: java.lang.Object A set of objects to convert to YAML. tmp \u00b6 import org.cdk8s.Yaml ; Yaml . tmp ( java . util . List < java . lang . Object > docs ) docs Required \u00b6 Type: java.util.List< java.lang.Object > the set of documents to save. Protocols \u00b6 IAnyProducer \u00b6 Implemented By: org.cdk8s.IAnyProducer Methods \u00b6 produce \u00b6 public produce () Enums \u00b6 SizeRoundingBehavior \u00b6 Rounding behaviour when converting between units of Size . FAIL \u00b6 Fail the conversion if the result is not an integer. FLOOR \u00b6 If the result is not an integer, round it to the closest integer less than the result. NONE \u00b6 Don\u2019t round. Return even if the result is a fraction. YamlOutputType \u00b6 The method to divide YAML output into files. FILE_PER_APP \u00b6 All resources are output into a single YAML file. FILE_PER_CHART \u00b6 Resources are split into seperate files by chart. FILE_PER_RESOURCE \u00b6 Each resource is output to its own file. FOLDER_PER_CHART_FILE_PER_RESOURCE \u00b6 Each chart in its own folder and each resource in its own file.","title":"Java"},{"location":"reference/cdk8s/java/#cdk8s-java","text":"","title":"cdk8s (Java) "},{"location":"reference/cdk8s/java/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s/java/#apiobject","text":"","title":"ApiObject "},{"location":"reference/cdk8s/java/#app","text":"Represents a cdk8s application.","title":"App "},{"location":"reference/cdk8s/java/#chart","text":"","title":"Chart "},{"location":"reference/cdk8s/java/#helm","text":"Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs.","title":"Helm "},{"location":"reference/cdk8s/java/#include","text":"Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest.","title":"Include "},{"location":"reference/cdk8s/java/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s/java/#apiobjectmetadata","text":"Metadata associated with this object.","title":"ApiObjectMetadata "},{"location":"reference/cdk8s/java/#apiobjectprops","text":"Options for defining API objects.","title":"ApiObjectProps "},{"location":"reference/cdk8s/java/#appprops","text":"","title":"AppProps "},{"location":"reference/cdk8s/java/#chartprops","text":"","title":"ChartProps "},{"location":"reference/cdk8s/java/#groupversionkind","text":"","title":"GroupVersionKind "},{"location":"reference/cdk8s/java/#helmprops","text":"Options for Helm .","title":"HelmProps "},{"location":"reference/cdk8s/java/#includeprops","text":"","title":"IncludeProps "},{"location":"reference/cdk8s/java/#nameoptions","text":"Options for name generation.","title":"NameOptions "},{"location":"reference/cdk8s/java/#ownerreference","text":"OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.","title":"OwnerReference "},{"location":"reference/cdk8s/java/#sizeconversionoptions","text":"Options for how to convert time to a different unit.","title":"SizeConversionOptions "},{"location":"reference/cdk8s/java/#timeconversionoptions","text":"Options for how to convert time to a different unit.","title":"TimeConversionOptions "},{"location":"reference/cdk8s/java/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s/java/#apiobjectmetadatadefinition","text":"Object metadata.","title":"ApiObjectMetadataDefinition "},{"location":"reference/cdk8s/java/#dependencygraph","text":"Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph.","title":"DependencyGraph "},{"location":"reference/cdk8s/java/#dependencyvertex","text":"Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter.","title":"DependencyVertex "},{"location":"reference/cdk8s/java/#duration","text":"Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative.","title":"Duration "},{"location":"reference/cdk8s/java/#jsonpatch","text":"Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc.","title":"JsonPatch "},{"location":"reference/cdk8s/java/#lazy","text":"","title":"Lazy "},{"location":"reference/cdk8s/java/#names","text":"Utilities for generating unique and stable names.","title":"Names "},{"location":"reference/cdk8s/java/#size","text":"Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible.","title":"Size "},{"location":"reference/cdk8s/java/#testing","text":"Testing utilities for cdk8s applications.","title":"Testing "},{"location":"reference/cdk8s/java/#yaml","text":"YAML utilities.","title":"Yaml "},{"location":"reference/cdk8s/java/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s/java/#ianyproducer","text":"Implemented By: org.cdk8s.IAnyProducer","title":"IAnyProducer "},{"location":"reference/cdk8s/java/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s/java/#sizeroundingbehavior","text":"Rounding behaviour when converting between units of Size .","title":"SizeRoundingBehavior "},{"location":"reference/cdk8s/java/#yamloutputtype","text":"The method to divide YAML output into files.","title":"YamlOutputType "},{"location":"reference/cdk8s/python/","text":"cdk8s (Python) \u00b6 Constructs \u00b6 ApiObject \u00b6 Initializers \u00b6 import cdk8s cdk8s . ApiObject ( scope : Construct , id : str , api_version : str , kind : str , metadata : ApiObjectMetadata = None ) scope Required \u00b6 Type: constructs.Construct the construct scope. id Required \u00b6 Type: str namespace. api_version Required \u00b6 Type: str API version. kind Required \u00b6 Type: str Resource kind. metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. Methods \u00b6 add_dependency \u00b6 def add_dependency ( dependencies : IConstruct ) dependencies Required \u00b6 Type: constructs.IConstruct the dependencies to add. add_json_patch \u00b6 def add_json_patch ( ops : JsonPatch ) ops Required \u00b6 Type: cdk8s.JsonPatch The JSON-Patch operations to apply. to_json \u00b6 def to_json () Static Functions \u00b6 of \u00b6 import cdk8s cdk8s . ApiObject . of ( c : IConstruct ) c Required \u00b6 Type: constructs.IConstruct The higher-level construct. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. authorization.k8s.io/v1 ). chart Required \u00b6 chart : Chart Type: cdk8s.Chart The chart in which this object is defined. kind Required \u00b6 kind : str Type: str The object kind. metadata Required \u00b6 metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Metadata associated with this API object. name Required \u00b6 name : str Type: str The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. App \u00b6 Represents a cdk8s application. Initializers \u00b6 import cdk8s cdk8s . App ( outdir : str = None , output_file_extension : str = None , yaml_output_type : YamlOutputType = None ) outdir Optional \u00b6 Type: str Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. output_file_extension Optional \u00b6 Type: str Default: .k8s.yaml The file extension to use for rendered YAML files. yaml_output_type Optional \u00b6 Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Methods \u00b6 synth \u00b6 def synth () synth_yaml \u00b6 def synth_yaml () Properties \u00b6 charts Required \u00b6 charts : typing . List [ Chart ] Type: typing.List[ cdk8s.Chart ] Returns all the charts in this app, sorted topologically. outdir Required \u00b6 outdir : str Type: str The output directory into which manifests will be synthesized. output_file_extension Required \u00b6 output_file_extension : str Type: str Default: .k8s.yaml The file extension to use for rendered YAML files. yaml_output_type Required \u00b6 yaml_output_type : YamlOutputType Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Chart \u00b6 Initializers \u00b6 import cdk8s cdk8s . Chart ( scope : Construct , id : str , labels : typing . Mapping [ str ] = None , namespace : str = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str labels Optional \u00b6 Type: typing.Mapping[ str ] Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 Type: str Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. Methods \u00b6 add_dependency \u00b6 def add_dependency ( dependencies : IConstruct ) dependencies Required \u00b6 Type: constructs.IConstruct the dependencies to add. generate_object_name \u00b6 def generate_object_name ( api_object : ApiObject ) api_object Required \u00b6 Type: cdk8s.ApiObject The API object to generate a name for. to_json \u00b6 def to_json () Static Functions \u00b6 is_chart \u00b6 import cdk8s cdk8s . Chart . is_chart ( x : typing . Any ) x Required \u00b6 Type: typing.Any of \u00b6 import cdk8s cdk8s . Chart . of ( c : IConstruct ) c Required \u00b6 Type: constructs.IConstruct a construct node. Properties \u00b6 labels Required \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Labels applied to all resources in this chart. This is an immutable copy. namespace Optional \u00b6 namespace : str Type: str The default namespace for all objects in this chart. Helm \u00b6 Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs. Initializers \u00b6 import cdk8s cdk8s . Helm ( scope : Construct , id : str , chart : str , helm_executable : str = None , helm_flags : typing . List [ str ] = None , release_name : str = None , values : typing . Mapping [ typing . Any ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str chart Required \u00b6 Type: str The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helm_executable Optional \u00b6 Type: str Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helm_flags Optional \u00b6 Type: typing.List[ str ] Default: [] Additional flags to add to the helm execution. release_name Optional \u00b6 Type: str Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 Type: typing.Mapping[ typing.Any ] Default: If no values are specified, chart will use the defaults. Values to pass to the chart. Properties \u00b6 release_name Required \u00b6 release_name : str Type: str The helm release name. Include \u00b6 Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest. Initializers \u00b6 import cdk8s cdk8s . Include ( scope : Construct , id : str , url : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str url Required \u00b6 Type: str Local file path or URL which includes a Kubernetes YAML manifest. Properties \u00b6 api_objects Required \u00b6 api_objects : typing . List [ ApiObject ] Type: typing.List[ cdk8s.ApiObject ] Returns all the included API objects. Structs \u00b6 ApiObjectMetadata \u00b6 Metadata associated with this object. Initializer \u00b6 import cdk8s cdk8s . ApiObjectMetadata ( annotations : typing . Mapping [ str ] = None , finalizers : typing . List [ str ] = None , labels : typing . Mapping [ str ] = None , name : str = None , namespace : str = None , owner_references : typing . List [ OwnerReference ] = None ) annotations Optional \u00b6 annotations : typing . Mapping [ str ] Type: typing.Mapping[ str ] Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations finalizers Optional \u00b6 finalizers : typing . List [ str ] Type: typing.List[ str ] Default: No finalizers. Namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order. Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/ labels Optional \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 name : str Type: str Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 namespace : str Type: str Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces owner_references Optional \u00b6 owner_references : typing . List [ OwnerReference ] Type: typing.List[ cdk8s.OwnerReference ] Default: automatically set by Kubernetes List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. Kubernetes sets the value of this field automatically for objects that are dependents of other objects like ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers. You can also configure these relationships manually by changing the value of this field. However, you usually don\u2019t need to and can allow Kubernetes to automatically manage the relationships. https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/ ApiObjectProps \u00b6 Options for defining API objects. Initializer \u00b6 import cdk8s cdk8s . ApiObjectProps ( api_version : str , kind : str , metadata : ApiObjectMetadata = None ) api_version Required \u00b6 api_version : str Type: str API version. kind Required \u00b6 kind : str Type: str Resource kind. metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. AppProps \u00b6 Initializer \u00b6 import cdk8s cdk8s . AppProps ( outdir : str = None , output_file_extension : str = None , yaml_output_type : YamlOutputType = None ) outdir Optional \u00b6 outdir : str Type: str Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. output_file_extension Optional \u00b6 output_file_extension : str Type: str Default: .k8s.yaml The file extension to use for rendered YAML files. yaml_output_type Optional \u00b6 yaml_output_type : YamlOutputType Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. ChartProps \u00b6 Initializer \u00b6 import cdk8s cdk8s . ChartProps ( labels : typing . Mapping [ str ] = None , namespace : str = None ) labels Optional \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 namespace : str Type: str Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. GroupVersionKind \u00b6 Initializer \u00b6 import cdk8s cdk8s . GroupVersionKind ( api_version : str , kind : str ) api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. authorization.k8s.io/v1 ). kind Required \u00b6 kind : str Type: str The object kind. HelmProps \u00b6 Options for Helm . Initializer \u00b6 import cdk8s cdk8s . HelmProps ( chart : str , helm_executable : str = None , helm_flags : typing . List [ str ] = None , release_name : str = None , values : typing . Mapping [ typing . Any ] = None ) chart Required \u00b6 chart : str Type: str The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helm_executable Optional \u00b6 helm_executable : str Type: str Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helm_flags Optional \u00b6 helm_flags : typing . List [ str ] Type: typing.List[ str ] Default: [] Additional flags to add to the helm execution. release_name Optional \u00b6 release_name : str Type: str Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 values : typing . Mapping [ typing . Any ] Type: typing.Mapping[ typing.Any ] Default: If no values are specified, chart will use the defaults. Values to pass to the chart. IncludeProps \u00b6 Initializer \u00b6 import cdk8s cdk8s . IncludeProps ( url : str ) url Required \u00b6 url : str Type: str Local file path or URL which includes a Kubernetes YAML manifest. NameOptions \u00b6 Options for name generation. Initializer \u00b6 import cdk8s cdk8s . NameOptions ( delimiter : str = None , extra : typing . List [ str ] = None , include_hash : bool = None , max_len : typing . Union [ int , float ] = None ) delimiter Optional \u00b6 delimiter : str Type: str Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 extra : typing . List [ str ] Type: typing.List[ str ] Default: [] use the construct path components Extra components to include in the name. include_hash Optional \u00b6 include_hash : bool Type: bool Default: true Include a short hash as last part of the name. max_len Optional \u00b6 max_len : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 63 Maximum allowed length for the name. OwnerReference \u00b6 OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field. Initializer \u00b6 import cdk8s cdk8s . OwnerReference ( api_version : str , kind : str , name : str , uid : str , block_owner_deletion : bool = None , controller : bool = None ) api_version Required \u00b6 api_version : str Type: str API version of the referent. kind Required \u00b6 kind : str Type: str Kind of the referent. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds name Required \u00b6 name : str Type: str Name of the referent. http://kubernetes.io/docs/user-guide/identifiers#names uid Required \u00b6 uid : str Type: str UID of the referent. http://kubernetes.io/docs/user-guide/identifiers#uids block_owner_deletion Optional \u00b6 block_owner_deletion : bool Type: bool Default: false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. If true, AND if the owner has the \u201cforegroundDeletion\u201d finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. controller Optional \u00b6 controller : bool Type: bool If true, this reference points to the managing controller. SizeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import cdk8s cdk8s . SizeConversionOptions ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 rounding : SizeRoundingBehavior Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. TimeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import cdk8s cdk8s . TimeConversionOptions ( integral : bool = None ) integral Optional \u00b6 integral : bool Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Classes \u00b6 ApiObjectMetadataDefinition \u00b6 Object metadata. Initializers \u00b6 import cdk8s cdk8s . ApiObjectMetadataDefinition ( annotations : typing . Mapping [ str ] = None , finalizers : typing . List [ str ] = None , labels : typing . Mapping [ str ] = None , name : str = None , namespace : str = None , owner_references : typing . List [ OwnerReference ] = None ) annotations Optional \u00b6 Type: typing.Mapping[ str ] Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations finalizers Optional \u00b6 Type: typing.List[ str ] Default: No finalizers. Namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order. Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/ labels Optional \u00b6 Type: typing.Mapping[ str ] Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 Type: str Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 Type: str Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces owner_references Optional \u00b6 Type: typing.List[ cdk8s.OwnerReference ] Default: automatically set by Kubernetes List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. Kubernetes sets the value of this field automatically for objects that are dependents of other objects like ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers. You can also configure these relationships manually by changing the value of this field. However, you usually don\u2019t need to and can allow Kubernetes to automatically manage the relationships. https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/ Methods \u00b6 add \u00b6 def add ( key : str , value : typing . Any ) key Required \u00b6 Type: str Metadata key. value Required \u00b6 Type: typing.Any Metadata value. add_annotation \u00b6 def add_annotation ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_finalizers \u00b6 def add_finalizers ( finalizers : str ) finalizers Required \u00b6 Type: str the finalizers. add_label \u00b6 def add_label ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_owner_reference \u00b6 def add_owner_reference ( api_version : str , kind : str , name : str , uid : str , block_owner_deletion : bool = None , controller : bool = None ) api_version Required \u00b6 Type: str API version of the referent. kind Required \u00b6 Type: str Kind of the referent. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds name Required \u00b6 Type: str Name of the referent. http://kubernetes.io/docs/user-guide/identifiers#names uid Required \u00b6 Type: str UID of the referent. http://kubernetes.io/docs/user-guide/identifiers#uids block_owner_deletion Optional \u00b6 Type: bool Default: false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. If true, AND if the owner has the \u201cforegroundDeletion\u201d finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. controller Optional \u00b6 Type: bool If true, this reference points to the managing controller. get_label \u00b6 def get_label ( key : str ) key Required \u00b6 Type: str the label. to_json \u00b6 def to_json () Properties \u00b6 name Optional \u00b6 name : str Type: str The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. namespace Optional \u00b6 namespace : str Type: str The object\u2019s namespace. DependencyGraph \u00b6 Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph. Initializers \u00b6 import cdk8s cdk8s . DependencyGraph ( node : Node ) node Required \u00b6 Type: constructs.Node Methods \u00b6 topology \u00b6 def topology () Properties \u00b6 root Required \u00b6 root : DependencyVertex Type: cdk8s.DependencyVertex Returns the root of the graph. Note that this vertex will always have null as its .value since it is an artifical root that binds all the connected spaces of the graph. DependencyVertex \u00b6 Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter. Initializers \u00b6 import cdk8s cdk8s . DependencyVertex ( value : IConstruct = None ) value Optional \u00b6 Type: constructs.IConstruct Methods \u00b6 add_child \u00b6 def add_child ( dep : DependencyVertex ) dep Required \u00b6 Type: cdk8s.DependencyVertex The dependency. topology \u00b6 def topology () Properties \u00b6 inbound Required \u00b6 inbound : typing . List [ DependencyVertex ] Type: typing.List[ cdk8s.DependencyVertex ] Returns the parents of the vertex (i.e dependants). outbound Required \u00b6 outbound : typing . List [ DependencyVertex ] Type: typing.List[ cdk8s.DependencyVertex ] Returns the children of the vertex (i.e dependencies). value Optional \u00b6 value : IConstruct Type: constructs.IConstruct Returns the IConstruct this graph vertex represents. null in case this is the root of the graph. Duration \u00b6 Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. Methods \u00b6 to_days \u00b6 def to_days ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. to_hours \u00b6 def to_hours ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. to_human_string \u00b6 def to_human_string () to_iso_string \u00b6 def to_iso_string () to_milliseconds \u00b6 def to_milliseconds ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. to_minutes \u00b6 def to_minutes ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. to_seconds \u00b6 def to_seconds ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Static Functions \u00b6 days \u00b6 import cdk8s cdk8s . Duration . days ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Days the Duration will represent. hours \u00b6 import cdk8s cdk8s . Duration . hours ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Hours the Duration will represent. millis \u00b6 import cdk8s cdk8s . Duration . millis ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Milliseconds the Duration will represent. minutes \u00b6 import cdk8s cdk8s . Duration . minutes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Minutes the Duration will represent. parse \u00b6 import cdk8s cdk8s . Duration . parse ( duration : str ) duration Required \u00b6 Type: str an ISO-formtted duration to be parsed. seconds \u00b6 import cdk8s cdk8s . Duration . seconds ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Seconds the Duration will represent. JsonPatch \u00b6 Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc. Static Functions \u00b6 add \u00b6 import cdk8s cdk8s . JsonPatch . add ( path : str , value : typing . Any ) path Required \u00b6 Type: str value Required \u00b6 Type: typing.Any apply \u00b6 import cdk8s cdk8s . JsonPatch . apply ( document : typing . Any , ops : JsonPatch ) document Required \u00b6 Type: typing.Any The document to patch. ops Required \u00b6 Type: cdk8s.JsonPatch The operations to apply. copy \u00b6 import cdk8s cdk8s . JsonPatch . copy ( from : str , path : str ) from Required \u00b6 Type: str path Required \u00b6 Type: str move \u00b6 import cdk8s cdk8s . JsonPatch . move ( from : str , path : str ) from Required \u00b6 Type: str path Required \u00b6 Type: str remove \u00b6 import cdk8s cdk8s . JsonPatch . remove ( path : str ) path Required \u00b6 Type: str replace \u00b6 import cdk8s cdk8s . JsonPatch . replace ( path : str , value : typing . Any ) path Required \u00b6 Type: str value Required \u00b6 Type: typing.Any test \u00b6 import cdk8s cdk8s . JsonPatch . test ( path : str , value : typing . Any ) path Required \u00b6 Type: str value Required \u00b6 Type: typing.Any Lazy \u00b6 Methods \u00b6 produce \u00b6 def produce () Static Functions \u00b6 any \u00b6 import cdk8s cdk8s . Lazy . any ( producer : IAnyProducer ) producer Required \u00b6 Type: cdk8s.IAnyProducer Names \u00b6 Utilities for generating unique and stable names. Static Functions \u00b6 to_dns_label \u00b6 import cdk8s cdk8s . Names . to_dns_label ( scope : Construct , delimiter : str = None , extra : typing . List [ str ] = None , include_hash : bool = None , max_len : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct The construct for which to render the DNS label. delimiter Optional \u00b6 Type: str Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 Type: typing.List[ str ] Default: [] use the construct path components Extra components to include in the name. include_hash Optional \u00b6 Type: bool Default: true Include a short hash as last part of the name. max_len Optional \u00b6 Type: typing.Union[int, float] Default: 63 Maximum allowed length for the name. to_label_value \u00b6 import cdk8s cdk8s . Names . to_label_value ( scope : Construct , delimiter : str = None , extra : typing . List [ str ] = None , include_hash : bool = None , max_len : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct The construct for which to render the DNS label. delimiter Optional \u00b6 Type: str Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 Type: typing.List[ str ] Default: [] use the construct path components Extra components to include in the name. include_hash Optional \u00b6 Type: bool Default: true Include a short hash as last part of the name. max_len Optional \u00b6 Type: typing.Union[int, float] Default: 63 Maximum allowed length for the name. Size \u00b6 Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible. Methods \u00b6 to_gibibytes \u00b6 def to_gibibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. to_kibibytes \u00b6 def to_kibibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. to_mebibytes \u00b6 def to_mebibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. to_pebibytes \u00b6 def to_pebibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. to_tebibytes \u00b6 def to_tebibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. Static Functions \u00b6 gibibytes \u00b6 import cdk8s cdk8s . Size . gibibytes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] kibibytes \u00b6 import cdk8s cdk8s . Size . kibibytes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] mebibytes \u00b6 import cdk8s cdk8s . Size . mebibytes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] pebibyte \u00b6 import cdk8s cdk8s . Size . pebibyte ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] tebibytes \u00b6 import cdk8s cdk8s . Size . tebibytes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] Testing \u00b6 Testing utilities for cdk8s applications. Static Functions \u00b6 app \u00b6 import cdk8s cdk8s . Testing . app ( outdir : str = None , output_file_extension : str = None , yaml_output_type : YamlOutputType = None ) outdir Optional \u00b6 Type: str Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. output_file_extension Optional \u00b6 Type: str Default: .k8s.yaml The file extension to use for rendered YAML files. yaml_output_type Optional \u00b6 Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. chart \u00b6 import cdk8s cdk8s . Testing . chart () synth \u00b6 import cdk8s cdk8s . Testing . synth ( chart : Chart ) chart Required \u00b6 Type: cdk8s.Chart Yaml \u00b6 YAML utilities. Static Functions \u00b6 ~~ format_objects ~~ \u00b6 import cdk8s cdk8s . Yaml . format_objects ( docs : typing . List [ typing . Any ] ) docs Required \u00b6 Type: typing.List[ typing.Any ] load \u00b6 import cdk8s cdk8s . Yaml . load ( url_or_file : str ) url_or_file Required \u00b6 Type: str a URL of a file path to load from. save \u00b6 import cdk8s cdk8s . Yaml . save ( file_path : str , docs : typing . List [ typing . Any ] ) file_path Required \u00b6 Type: str The output path. docs Required \u00b6 Type: typing.List[ typing.Any ] The set of objects. stringify \u00b6 import cdk8s cdk8s . Yaml . stringify ( docs : typing . Any ) docs Required \u00b6 Type: typing.Any A set of objects to convert to YAML. tmp \u00b6 import cdk8s cdk8s . Yaml . tmp ( docs : typing . List [ typing . Any ] ) docs Required \u00b6 Type: typing.List[ typing.Any ] the set of documents to save. Protocols \u00b6 IAnyProducer \u00b6 Implemented By: cdk8s.IAnyProducer Methods \u00b6 produce \u00b6 def produce () Enums \u00b6 SizeRoundingBehavior \u00b6 Rounding behaviour when converting between units of Size . FAIL \u00b6 Fail the conversion if the result is not an integer. FLOOR \u00b6 If the result is not an integer, round it to the closest integer less than the result. NONE \u00b6 Don\u2019t round. Return even if the result is a fraction. YamlOutputType \u00b6 The method to divide YAML output into files. FILE_PER_APP \u00b6 All resources are output into a single YAML file. FILE_PER_CHART \u00b6 Resources are split into seperate files by chart. FILE_PER_RESOURCE \u00b6 Each resource is output to its own file. FOLDER_PER_CHART_FILE_PER_RESOURCE \u00b6 Each chart in its own folder and each resource in its own file.","title":"Python"},{"location":"reference/cdk8s/python/#cdk8s-python","text":"","title":"cdk8s (Python) "},{"location":"reference/cdk8s/python/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s/python/#apiobject","text":"","title":"ApiObject "},{"location":"reference/cdk8s/python/#app","text":"Represents a cdk8s application.","title":"App "},{"location":"reference/cdk8s/python/#chart","text":"","title":"Chart "},{"location":"reference/cdk8s/python/#helm","text":"Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs.","title":"Helm "},{"location":"reference/cdk8s/python/#include","text":"Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest.","title":"Include "},{"location":"reference/cdk8s/python/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s/python/#apiobjectmetadata","text":"Metadata associated with this object.","title":"ApiObjectMetadata "},{"location":"reference/cdk8s/python/#apiobjectprops","text":"Options for defining API objects.","title":"ApiObjectProps "},{"location":"reference/cdk8s/python/#appprops","text":"","title":"AppProps "},{"location":"reference/cdk8s/python/#chartprops","text":"","title":"ChartProps "},{"location":"reference/cdk8s/python/#groupversionkind","text":"","title":"GroupVersionKind "},{"location":"reference/cdk8s/python/#helmprops","text":"Options for Helm .","title":"HelmProps "},{"location":"reference/cdk8s/python/#includeprops","text":"","title":"IncludeProps "},{"location":"reference/cdk8s/python/#nameoptions","text":"Options for name generation.","title":"NameOptions "},{"location":"reference/cdk8s/python/#ownerreference","text":"OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.","title":"OwnerReference "},{"location":"reference/cdk8s/python/#sizeconversionoptions","text":"Options for how to convert time to a different unit.","title":"SizeConversionOptions "},{"location":"reference/cdk8s/python/#timeconversionoptions","text":"Options for how to convert time to a different unit.","title":"TimeConversionOptions "},{"location":"reference/cdk8s/python/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s/python/#apiobjectmetadatadefinition","text":"Object metadata.","title":"ApiObjectMetadataDefinition "},{"location":"reference/cdk8s/python/#dependencygraph","text":"Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph.","title":"DependencyGraph "},{"location":"reference/cdk8s/python/#dependencyvertex","text":"Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter.","title":"DependencyVertex "},{"location":"reference/cdk8s/python/#duration","text":"Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative.","title":"Duration "},{"location":"reference/cdk8s/python/#jsonpatch","text":"Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc.","title":"JsonPatch "},{"location":"reference/cdk8s/python/#lazy","text":"","title":"Lazy "},{"location":"reference/cdk8s/python/#names","text":"Utilities for generating unique and stable names.","title":"Names "},{"location":"reference/cdk8s/python/#size","text":"Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible.","title":"Size "},{"location":"reference/cdk8s/python/#testing","text":"Testing utilities for cdk8s applications.","title":"Testing "},{"location":"reference/cdk8s/python/#yaml","text":"YAML utilities.","title":"Yaml "},{"location":"reference/cdk8s/python/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s/python/#ianyproducer","text":"Implemented By: cdk8s.IAnyProducer","title":"IAnyProducer "},{"location":"reference/cdk8s/python/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s/python/#sizeroundingbehavior","text":"Rounding behaviour when converting between units of Size .","title":"SizeRoundingBehavior "},{"location":"reference/cdk8s/python/#yamloutputtype","text":"The method to divide YAML output into files.","title":"YamlOutputType "},{"location":"reference/cdk8s/typescript/","text":"cdk8s (TypeScript) \u00b6 Constructs \u00b6 ApiObject \u00b6 Initializers \u00b6 import { ApiObject } from 'cdk8s' new ApiObject ( scope : Construct , id : string , props : ApiObjectProps ) scope Required \u00b6 Type: constructs.Construct the construct scope. id Required \u00b6 Type: string namespace. props Required \u00b6 Type: cdk8s.ApiObjectProps options. Methods \u00b6 addDependency \u00b6 public addDependency ( dependencies : IConstruct ) dependencies Required \u00b6 Type: constructs.IConstruct the dependencies to add. addJsonPatch \u00b6 public addJsonPatch ( ops : JsonPatch ) ops Required \u00b6 Type: cdk8s.JsonPatch The JSON-Patch operations to apply. toJson \u00b6 public toJson () Static Functions \u00b6 of \u00b6 import { ApiObject } from 'cdk8s' ApiObject . of ( c : IConstruct ) c Required \u00b6 Type: constructs.IConstruct The higher-level construct. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. authorization.k8s.io/v1 ). chart Required \u00b6 public readonly chart : Chart ; Type: cdk8s.Chart The chart in which this object is defined. kind Required \u00b6 public readonly kind : string ; Type: string The object kind. metadata Required \u00b6 public readonly metadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Metadata associated with this API object. name Required \u00b6 public readonly name : string ; Type: string The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. App \u00b6 Represents a cdk8s application. Initializers \u00b6 import { App } from 'cdk8s' new App ( props? : AppProps ) props Optional \u00b6 Type: cdk8s.AppProps configuration options. Methods \u00b6 synth \u00b6 public synth () synthYaml \u00b6 public synthYaml () Properties \u00b6 charts Required \u00b6 public readonly charts : Chart []; Type: cdk8s.Chart [] Returns all the charts in this app, sorted topologically. outdir Required \u00b6 public readonly outdir : string ; Type: string The output directory into which manifests will be synthesized. outputFileExtension Required \u00b6 public readonly outputFileExtension : string ; Type: string Default: .k8s.yaml The file extension to use for rendered YAML files. yamlOutputType Required \u00b6 public readonly yamlOutputType : YamlOutputType ; Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Chart \u00b6 Initializers \u00b6 import { Chart } from 'cdk8s' new Chart ( scope : Construct , id : string , props? : ChartProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s.ChartProps Methods \u00b6 addDependency \u00b6 public addDependency ( dependencies : IConstruct ) dependencies Required \u00b6 Type: constructs.IConstruct the dependencies to add. generateObjectName \u00b6 public generateObjectName ( apiObject : ApiObject ) apiObject Required \u00b6 Type: cdk8s.ApiObject The API object to generate a name for. toJson \u00b6 public toJson () Static Functions \u00b6 isChart \u00b6 import { Chart } from 'cdk8s' Chart . isChart ( x : any ) x Required \u00b6 Type: any of \u00b6 import { Chart } from 'cdk8s' Chart . of ( c : IConstruct ) c Required \u00b6 Type: constructs.IConstruct a construct node. Properties \u00b6 labels Required \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Labels applied to all resources in this chart. This is an immutable copy. namespace Optional \u00b6 public readonly namespace : string ; Type: string The default namespace for all objects in this chart. Helm \u00b6 Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs. Initializers \u00b6 import { Helm } from 'cdk8s' new Helm ( scope : Construct , id : string , props : HelmProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s.HelmProps Properties \u00b6 releaseName Required \u00b6 public readonly releaseName : string ; Type: string The helm release name. Include \u00b6 Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest. Initializers \u00b6 import { Include } from 'cdk8s' new Include ( scope : Construct , id : string , props : IncludeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s.IncludeProps Properties \u00b6 apiObjects Required \u00b6 public readonly apiObjects : ApiObject []; Type: cdk8s.ApiObject [] Returns all the included API objects. Structs \u00b6 ApiObjectMetadata \u00b6 Metadata associated with this object. Initializer \u00b6 import { ApiObjectMetadata } from 'cdk8s' const apiObjectMetadata : ApiObjectMetadata = { ... } annotations Optional \u00b6 public readonly annotations : {[ key : string ] : string }; Type: {[ key: string ]: string } Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations finalizers Optional \u00b6 public readonly finalizers : string []; Type: string [] Default: No finalizers. Namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order. Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/ labels Optional \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 public readonly name : string ; Type: string Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 public readonly namespace : string ; Type: string Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces ownerReferences Optional \u00b6 public readonly ownerReferences : OwnerReference []; Type: cdk8s.OwnerReference [] Default: automatically set by Kubernetes List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. Kubernetes sets the value of this field automatically for objects that are dependents of other objects like ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers. You can also configure these relationships manually by changing the value of this field. However, you usually don\u2019t need to and can allow Kubernetes to automatically manage the relationships. https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/ ApiObjectProps \u00b6 Options for defining API objects. Initializer \u00b6 import { ApiObjectProps } from 'cdk8s' const apiObjectProps : ApiObjectProps = { ... } apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string API version. kind Required \u00b6 public readonly kind : string ; Type: string Resource kind. metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. AppProps \u00b6 Initializer \u00b6 import { AppProps } from 'cdk8s' const appProps : AppProps = { ... } outdir Optional \u00b6 public readonly outdir : string ; Type: string Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. outputFileExtension Optional \u00b6 public readonly outputFileExtension : string ; Type: string Default: .k8s.yaml The file extension to use for rendered YAML files. yamlOutputType Optional \u00b6 public readonly yamlOutputType : YamlOutputType ; Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. ChartProps \u00b6 Initializer \u00b6 import { ChartProps } from 'cdk8s' const chartProps : ChartProps = { ... } labels Optional \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 public readonly namespace : string ; Type: string Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. GroupVersionKind \u00b6 Initializer \u00b6 import { GroupVersionKind } from 'cdk8s' const groupVersionKind : GroupVersionKind = { ... } apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. authorization.k8s.io/v1 ). kind Required \u00b6 public readonly kind : string ; Type: string The object kind. HelmProps \u00b6 Options for Helm . Initializer \u00b6 import { HelmProps } from 'cdk8s' const helmProps : HelmProps = { ... } chart Required \u00b6 public readonly chart : string ; Type: string The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helmExecutable Optional \u00b6 public readonly helmExecutable : string ; Type: string Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helmFlags Optional \u00b6 public readonly helmFlags : string []; Type: string [] Default: [] Additional flags to add to the helm execution. releaseName Optional \u00b6 public readonly releaseName : string ; Type: string Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 public readonly values : {[ key : string ] : any }; Type: {[ key: string ]: any } Default: If no values are specified, chart will use the defaults. Values to pass to the chart. IncludeProps \u00b6 Initializer \u00b6 import { IncludeProps } from 'cdk8s' const includeProps : IncludeProps = { ... } url Required \u00b6 public readonly url : string ; Type: string Local file path or URL which includes a Kubernetes YAML manifest. NameOptions \u00b6 Options for name generation. Initializer \u00b6 import { NameOptions } from 'cdk8s' const nameOptions : NameOptions = { ... } delimiter Optional \u00b6 public readonly delimiter : string ; Type: string Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 public readonly extra : string []; Type: string [] Default: [] use the construct path components Extra components to include in the name. includeHash Optional \u00b6 public readonly includeHash : boolean ; Type: boolean Default: true Include a short hash as last part of the name. maxLen Optional \u00b6 public readonly maxLen : number ; Type: number Default: 63 Maximum allowed length for the name. OwnerReference \u00b6 OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field. Initializer \u00b6 import { OwnerReference } from 'cdk8s' const ownerReference : OwnerReference = { ... } apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string API version of the referent. kind Required \u00b6 public readonly kind : string ; Type: string Kind of the referent. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds name Required \u00b6 public readonly name : string ; Type: string Name of the referent. http://kubernetes.io/docs/user-guide/identifiers#names uid Required \u00b6 public readonly uid : string ; Type: string UID of the referent. http://kubernetes.io/docs/user-guide/identifiers#uids blockOwnerDeletion Optional \u00b6 public readonly blockOwnerDeletion : boolean ; Type: boolean Default: false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. If true, AND if the owner has the \u201cforegroundDeletion\u201d finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. controller Optional \u00b6 public readonly controller : boolean ; Type: boolean If true, this reference points to the managing controller. SizeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import { SizeConversionOptions } from 'cdk8s' const sizeConversionOptions : SizeConversionOptions = { ... } rounding Optional \u00b6 public readonly rounding : SizeRoundingBehavior ; Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. TimeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import { TimeConversionOptions } from 'cdk8s' const timeConversionOptions : TimeConversionOptions = { ... } integral Optional \u00b6 public readonly integral : boolean ; Type: boolean Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Classes \u00b6 ApiObjectMetadataDefinition \u00b6 Object metadata. Initializers \u00b6 import { ApiObjectMetadataDefinition } from 'cdk8s' new ApiObjectMetadataDefinition ( options? : ApiObjectMetadata ) options Optional \u00b6 Type: cdk8s.ApiObjectMetadata Methods \u00b6 add \u00b6 public add ( key : string , value : any ) key Required \u00b6 Type: string Metadata key. value Required \u00b6 Type: any Metadata value. addAnnotation \u00b6 public addAnnotation ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addFinalizers \u00b6 public addFinalizers ( finalizers : string ) finalizers Required \u00b6 Type: string the finalizers. addLabel \u00b6 public addLabel ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addOwnerReference \u00b6 public addOwnerReference ( owner : OwnerReference ) owner Required \u00b6 Type: cdk8s.OwnerReference the owner. getLabel \u00b6 public getLabel ( key : string ) key Required \u00b6 Type: string the label. toJson \u00b6 public toJson () Properties \u00b6 name Optional \u00b6 public readonly name : string ; Type: string The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. namespace Optional \u00b6 public readonly namespace : string ; Type: string The object\u2019s namespace. DependencyGraph \u00b6 Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph. Initializers \u00b6 import { DependencyGraph } from 'cdk8s' new DependencyGraph ( node : Node ) node Required \u00b6 Type: constructs.Node Methods \u00b6 topology \u00b6 public topology () Properties \u00b6 root Required \u00b6 public readonly root : DependencyVertex ; Type: cdk8s.DependencyVertex Returns the root of the graph. Note that this vertex will always have null as its .value since it is an artifical root that binds all the connected spaces of the graph. DependencyVertex \u00b6 Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter. Initializers \u00b6 import { DependencyVertex } from 'cdk8s' new DependencyVertex ( value? : IConstruct ) value Optional \u00b6 Type: constructs.IConstruct Methods \u00b6 addChild \u00b6 public addChild ( dep : DependencyVertex ) dep Required \u00b6 Type: cdk8s.DependencyVertex The dependency. topology \u00b6 public topology () Properties \u00b6 inbound Required \u00b6 public readonly inbound : DependencyVertex []; Type: cdk8s.DependencyVertex [] Returns the parents of the vertex (i.e dependants). outbound Required \u00b6 public readonly outbound : DependencyVertex []; Type: cdk8s.DependencyVertex [] Returns the children of the vertex (i.e dependencies). value Optional \u00b6 public readonly value : IConstruct ; Type: constructs.IConstruct Returns the IConstruct this graph vertex represents. null in case this is the root of the graph. Duration \u00b6 Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. Methods \u00b6 toDays \u00b6 public toDays ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions toHours \u00b6 public toHours ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions toHumanString \u00b6 public toHumanString () toIsoString \u00b6 public toIsoString () toMilliseconds \u00b6 public toMilliseconds ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions toMinutes \u00b6 public toMinutes ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions toSeconds \u00b6 public toSeconds ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions Static Functions \u00b6 days \u00b6 import { Duration } from 'cdk8s' Duration . days ( amount : number ) amount Required \u00b6 Type: number the amount of Days the Duration will represent. hours \u00b6 import { Duration } from 'cdk8s' Duration . hours ( amount : number ) amount Required \u00b6 Type: number the amount of Hours the Duration will represent. millis \u00b6 import { Duration } from 'cdk8s' Duration . millis ( amount : number ) amount Required \u00b6 Type: number the amount of Milliseconds the Duration will represent. minutes \u00b6 import { Duration } from 'cdk8s' Duration . minutes ( amount : number ) amount Required \u00b6 Type: number the amount of Minutes the Duration will represent. parse \u00b6 import { Duration } from 'cdk8s' Duration . parse ( duration : string ) duration Required \u00b6 Type: string an ISO-formtted duration to be parsed. seconds \u00b6 import { Duration } from 'cdk8s' Duration . seconds ( amount : number ) amount Required \u00b6 Type: number the amount of Seconds the Duration will represent. JsonPatch \u00b6 Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc. Static Functions \u00b6 add \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . add ( path : string , value : any ) path Required \u00b6 Type: string value Required \u00b6 Type: any apply \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . apply ( document : any , ops : JsonPatch ) document Required \u00b6 Type: any The document to patch. ops Required \u00b6 Type: cdk8s.JsonPatch The operations to apply. copy \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . copy ( from : string , path : string ) from Required \u00b6 Type: string path Required \u00b6 Type: string move \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . move ( from : string , path : string ) from Required \u00b6 Type: string path Required \u00b6 Type: string remove \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . remove ( path : string ) path Required \u00b6 Type: string replace \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . replace ( path : string , value : any ) path Required \u00b6 Type: string value Required \u00b6 Type: any test \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . test ( path : string , value : any ) path Required \u00b6 Type: string value Required \u00b6 Type: any Lazy \u00b6 Methods \u00b6 produce \u00b6 public produce () Static Functions \u00b6 any \u00b6 import { Lazy } from 'cdk8s' Lazy . any ( producer : IAnyProducer ) producer Required \u00b6 Type: cdk8s.IAnyProducer Names \u00b6 Utilities for generating unique and stable names. Static Functions \u00b6 toDnsLabel \u00b6 import { Names } from 'cdk8s' Names . toDnsLabel ( scope : Construct , options? : NameOptions ) scope Required \u00b6 Type: constructs.Construct The construct for which to render the DNS label. options Optional \u00b6 Type: cdk8s.NameOptions Name options. toLabelValue \u00b6 import { Names } from 'cdk8s' Names . toLabelValue ( scope : Construct , options? : NameOptions ) scope Required \u00b6 Type: constructs.Construct The construct for which to render the DNS label. options Optional \u00b6 Type: cdk8s.NameOptions Name options. Size \u00b6 Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible. Methods \u00b6 toGibibytes \u00b6 public toGibibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions toKibibytes \u00b6 public toKibibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions toMebibytes \u00b6 public toMebibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions toPebibytes \u00b6 public toPebibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions toTebibytes \u00b6 public toTebibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions Static Functions \u00b6 gibibytes \u00b6 import { Size } from 'cdk8s' Size . gibibytes ( amount : number ) amount Required \u00b6 Type: number kibibytes \u00b6 import { Size } from 'cdk8s' Size . kibibytes ( amount : number ) amount Required \u00b6 Type: number mebibytes \u00b6 import { Size } from 'cdk8s' Size . mebibytes ( amount : number ) amount Required \u00b6 Type: number pebibyte \u00b6 import { Size } from 'cdk8s' Size . pebibyte ( amount : number ) amount Required \u00b6 Type: number tebibytes \u00b6 import { Size } from 'cdk8s' Size . tebibytes ( amount : number ) amount Required \u00b6 Type: number Testing \u00b6 Testing utilities for cdk8s applications. Static Functions \u00b6 app \u00b6 import { Testing } from 'cdk8s' Testing . app ( props? : AppProps ) props Optional \u00b6 Type: cdk8s.AppProps chart \u00b6 import { Testing } from 'cdk8s' Testing . chart () synth \u00b6 import { Testing } from 'cdk8s' Testing . synth ( chart : Chart ) chart Required \u00b6 Type: cdk8s.Chart Yaml \u00b6 YAML utilities. Static Functions \u00b6 ~~ formatObjects ~~ \u00b6 import { Yaml } from 'cdk8s' Yaml . formatObjects ( docs : any []) docs Required \u00b6 Type: any [] load \u00b6 import { Yaml } from 'cdk8s' Yaml . load ( urlOrFile : string ) urlOrFile Required \u00b6 Type: string a URL of a file path to load from. save \u00b6 import { Yaml } from 'cdk8s' Yaml . save ( filePath : string , docs : any []) filePath Required \u00b6 Type: string The output path. docs Required \u00b6 Type: any [] The set of objects. stringify \u00b6 import { Yaml } from 'cdk8s' Yaml . stringify ( docs : any ) docs Required \u00b6 Type: any A set of objects to convert to YAML. tmp \u00b6 import { Yaml } from 'cdk8s' Yaml . tmp ( docs : any []) docs Required \u00b6 Type: any [] the set of documents to save. Protocols \u00b6 IAnyProducer \u00b6 Implemented By: cdk8s.IAnyProducer Methods \u00b6 produce \u00b6 public produce () Enums \u00b6 SizeRoundingBehavior \u00b6 Rounding behaviour when converting between units of Size . FAIL \u00b6 Fail the conversion if the result is not an integer. FLOOR \u00b6 If the result is not an integer, round it to the closest integer less than the result. NONE \u00b6 Don\u2019t round. Return even if the result is a fraction. YamlOutputType \u00b6 The method to divide YAML output into files. FILE_PER_APP \u00b6 All resources are output into a single YAML file. FILE_PER_CHART \u00b6 Resources are split into seperate files by chart. FILE_PER_RESOURCE \u00b6 Each resource is output to its own file. FOLDER_PER_CHART_FILE_PER_RESOURCE \u00b6 Each chart in its own folder and each resource in its own file.","title":"TypeScript"},{"location":"reference/cdk8s/typescript/#cdk8s-typescript","text":"","title":"cdk8s (TypeScript) "},{"location":"reference/cdk8s/typescript/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s/typescript/#apiobject","text":"","title":"ApiObject "},{"location":"reference/cdk8s/typescript/#app","text":"Represents a cdk8s application.","title":"App "},{"location":"reference/cdk8s/typescript/#chart","text":"","title":"Chart "},{"location":"reference/cdk8s/typescript/#helm","text":"Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs.","title":"Helm "},{"location":"reference/cdk8s/typescript/#include","text":"Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest.","title":"Include "},{"location":"reference/cdk8s/typescript/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s/typescript/#apiobjectmetadata","text":"Metadata associated with this object.","title":"ApiObjectMetadata "},{"location":"reference/cdk8s/typescript/#apiobjectprops","text":"Options for defining API objects.","title":"ApiObjectProps "},{"location":"reference/cdk8s/typescript/#appprops","text":"","title":"AppProps "},{"location":"reference/cdk8s/typescript/#chartprops","text":"","title":"ChartProps "},{"location":"reference/cdk8s/typescript/#groupversionkind","text":"","title":"GroupVersionKind "},{"location":"reference/cdk8s/typescript/#helmprops","text":"Options for Helm .","title":"HelmProps "},{"location":"reference/cdk8s/typescript/#includeprops","text":"","title":"IncludeProps "},{"location":"reference/cdk8s/typescript/#nameoptions","text":"Options for name generation.","title":"NameOptions "},{"location":"reference/cdk8s/typescript/#ownerreference","text":"OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.","title":"OwnerReference "},{"location":"reference/cdk8s/typescript/#sizeconversionoptions","text":"Options for how to convert time to a different unit.","title":"SizeConversionOptions "},{"location":"reference/cdk8s/typescript/#timeconversionoptions","text":"Options for how to convert time to a different unit.","title":"TimeConversionOptions "},{"location":"reference/cdk8s/typescript/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s/typescript/#apiobjectmetadatadefinition","text":"Object metadata.","title":"ApiObjectMetadataDefinition "},{"location":"reference/cdk8s/typescript/#dependencygraph","text":"Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph.","title":"DependencyGraph "},{"location":"reference/cdk8s/typescript/#dependencyvertex","text":"Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter.","title":"DependencyVertex "},{"location":"reference/cdk8s/typescript/#duration","text":"Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative.","title":"Duration "},{"location":"reference/cdk8s/typescript/#jsonpatch","text":"Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc.","title":"JsonPatch "},{"location":"reference/cdk8s/typescript/#lazy","text":"","title":"Lazy "},{"location":"reference/cdk8s/typescript/#names","text":"Utilities for generating unique and stable names.","title":"Names "},{"location":"reference/cdk8s/typescript/#size","text":"Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible.","title":"Size "},{"location":"reference/cdk8s/typescript/#testing","text":"Testing utilities for cdk8s applications.","title":"Testing "},{"location":"reference/cdk8s/typescript/#yaml","text":"YAML utilities.","title":"Yaml "},{"location":"reference/cdk8s/typescript/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s/typescript/#ianyproducer","text":"Implemented By: cdk8s.IAnyProducer","title":"IAnyProducer "},{"location":"reference/cdk8s/typescript/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s/typescript/#sizeroundingbehavior","text":"Rounding behaviour when converting between units of Size .","title":"SizeRoundingBehavior "},{"location":"reference/cdk8s/typescript/#yamloutputtype","text":"The method to divide YAML output into files.","title":"YamlOutputType "},{"location":"reference/cdk8s-plus-17/go/","text":"cdk8s-plus-17 (Go) \u00b6 For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-17-go/cdk8splus17 .","title":"Go"},{"location":"reference/cdk8s-plus-17/go/#cdk8s-plus-17-go","text":"For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-17-go/cdk8splus17 .","title":"cdk8s-plus-17 (Go) "},{"location":"reference/cdk8s-plus-17/java/","text":"cdk8s-plus-17 (Java) \u00b6 Constructs \u00b6 ConfigMap \u00b6 Implements: org.cdk8s.plus17.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import org.cdk8s.plus17.ConfigMap ; ConfigMap . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addData \u00b6 public addData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addDirectory \u00b6 public addDirectory ( java . lang . String localDir ) public addDirectory ( java . lang . String localDir , AddDirectoryOptions options ) localDir Required \u00b6 Type: java.lang.String A path to a local directory. options Optional \u00b6 Type: org.cdk8s.plus17.AddDirectoryOptions Options. addFile \u00b6 public addFile ( java . lang . String localFile ) public addFile ( java . lang . String localFile , java . lang . String key ) localFile Required \u00b6 Type: java.lang.String The path to the local file. key Optional \u00b6 Type: java.lang.String The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import org.cdk8s.plus17.ConfigMap ; ConfigMap . fromConfigMapName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the config map to import. Properties \u00b6 binaryData Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . Deployment \u00b6 Implements: org.cdk8s.plus17.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import org.cdk8s.plus17.Deployment ; Deployment . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .defaultSelector(java.lang.Boolean) // .replicas(java.lang.Number) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. defaultSelector Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus17.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus17.Volume expose \u00b6 public expose ( java . lang . Number port ) public expose ( java . lang . Number port , ExposeOptions options ) port Required \u00b6 Type: java.lang.Number The port number the service will bind to. options Optional \u00b6 Type: org.cdk8s.plus17.ExposeOptions Options to determine details of the service and port exposed. selectByLabel \u00b6 public selectByLabel ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus17.Container > The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabelSelector (); Type: java.util.Map java.lang.String > The labels this deployment will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount The service account used to run this pod. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import org.cdk8s.plus17.IngressV1Beta1 ; IngressV1Beta1 . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .defaultBackend(IngressV1Beta1Backend) // .rules(java.util.List<IngressV1Beta1Rule>) // .tls(java.util.List<IngressV1Beta1Tls>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 Type: org.cdk8s.plus17.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.IngressV1Beta1Rule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.IngressV1Beta1Tls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( IngressV1Beta1Backend backend ) backend Required \u00b6 Type: org.cdk8s.plus17.IngressV1Beta1Backend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( java . lang . String host , IngressV1Beta1Backend backend ) host Required \u00b6 Type: java.lang.String The host name to match. backend Required \u00b6 Type: org.cdk8s.plus17.IngressV1Beta1Backend The backend to route to. addHostRule \u00b6 public addHostRule ( java . lang . String host , java . lang . String path , IngressV1Beta1Backend backend ) host Required \u00b6 Type: java.lang.String The host name. path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus17.IngressV1Beta1Backend The backend to route requests to. addRule \u00b6 public addRule ( java . lang . String path , IngressV1Beta1Backend backend ) path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus17.IngressV1Beta1Backend The backend to route requests to. addRules \u00b6 public addRules ( IngressV1Beta1Rule rules ) rules Required \u00b6 Type: org.cdk8s.plus17.IngressV1Beta1Rule The rules to add. addTls \u00b6 public addTls ( java . util . List < IngressV1Beta1Tls > tls ) tls Required \u00b6 Type: java.util.List< org.cdk8s.plus17.IngressV1Beta1Tls > Job \u00b6 Implements: org.cdk8s.plus17.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import org.cdk8s.plus17.Job ; Job . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. activeDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus17.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus17.Volume Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus17.Container > The containers belonging to the pod. Use addContainer to add containers. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > The volumes associated with this pod. Use addVolume to add volumes. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Number of retries before marking failed. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount The service account used to run this pod. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration TTL before the job is deleted after it is finished. Pod \u00b6 Implements: org.cdk8s.plus17.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import org.cdk8s.plus17.Pod ; Pod . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus17.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus17.Volume Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus17.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount The service account used to run this pod. Resource \u00b6 Implements: org.cdk8s.plus17.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import org.cdk8s.plus17.Resource ; Resource . Builder . create ( Construct scope , java . lang . String id ) // .nodeFactory(INodeFactory) . build (); scope Required \u00b6 Type: software.constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: java.lang.String The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . nodeFactory Optional \u00b6 Type: software.constructs.INodeFactory Default: the default Node is associated A factory for attaching Node s to the construct. Properties \u00b6 metadata Required \u00b6 public ApiObjectMetadataDefinition getMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this API object. Secret \u00b6 Implements: org.cdk8s.plus17.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import org.cdk8s.plus17.Secret ; Secret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. stringData Optional \u00b6 Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 addStringData \u00b6 public addStringData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String Key. value Required \u00b6 Type: java.lang.String Value. getStringData \u00b6 public getStringData ( java . lang . String key ) key Required \u00b6 Type: java.lang.String Key. Static Functions \u00b6 fromSecretName \u00b6 import org.cdk8s.plus17.Secret ; Secret . fromSecretName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the secret to reference. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import org.cdk8s.plus17.Service ; Service . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .type(ServiceType) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.ServicePort > The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: org.cdk8s.plus17.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 addDeployment \u00b6 public addDeployment ( Deployment deployment , java . lang . Number port ) public addDeployment ( Deployment deployment , java . lang . Number port , ServicePortOptions options ) deployment Required \u00b6 Type: org.cdk8s.plus17.Deployment The deployment to expose. port Required \u00b6 Type: java.lang.Number The external port. options Optional \u00b6 Type: org.cdk8s.plus17.ServicePortOptions Optional settings for the port. addSelector \u00b6 public addSelector ( java . lang . String label , java . lang . String value ) label Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. serve \u00b6 public serve ( java . lang . Number port ) public serve ( java . lang . Number port , ServicePortOptions options ) port Required \u00b6 Type: java.lang.Number The port definition. options Optional \u00b6 Type: org.cdk8s.plus17.ServicePortOptions Properties \u00b6 ports Required \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus17.ServicePort > Ports for this service. Use serve() to expose additional service ports. selector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getSelector (); Type: java.util.Map java.lang.String > Returns the labels which are used to select pods for this service. type Required \u00b6 public ServiceType getType (); Type: org.cdk8s.plus17.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: org.cdk8s.plus17.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import org.cdk8s.plus17.ServiceAccount ; ServiceAccount . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .secrets(java.util.List<ISecret>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 addSecret \u00b6 public addSecret ( ISecret secret ) secret Required \u00b6 Type: org.cdk8s.plus17.ISecret The secret. Static Functions \u00b6 fromServiceAccountName \u00b6 import org.cdk8s.plus17.ServiceAccount ; ServiceAccount . fromServiceAccountName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the service account resource. Properties \u00b6 secrets Required \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus17.ISecret > List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . StatefulSet \u00b6 Implements: org.cdk8s.plus17.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import org.cdk8s.plus17.StatefulSet ; StatefulSet . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . service ( Service ) // .defaultSelector(java.lang.Boolean) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 Type: org.cdk8s.plus17.Service Service to associate with the statefulset. defaultSelector Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . podManagementPolicy Optional \u00b6 Type: org.cdk8s.plus17.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus17.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus17.Volume selectByLabel \u00b6 public selectByLabel ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus17.Container > The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabelSelector (); Type: java.util.Map java.lang.String > The labels this statefulset will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podManagementPolicy Required \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus17.PodManagementPolicy Management policy to use for the set. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount The service account used to run this pod. Structs \u00b6 AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import org.cdk8s.plus17.AddDirectoryOptions ; AddDirectoryOptions . builder () // .exclude(java.util.List<java.lang.String>) // .keyPrefix(java.lang.String) . build (); exclude Optional \u00b6 public java . util . List < java . lang . String > getExclude (); Type: java.util.List< java.lang.String > Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public java . lang . String getKeyPrefix (); Type: java.lang.String Default: \u201c\u201d A prefix to add to all keys in the config map. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import org.cdk8s.plus17.CommandProbeOptions ; CommandProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import org.cdk8s.plus17.ConfigMapProps ; ConfigMapProps . builder () // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import org.cdk8s.plus17.ConfigMapVolumeOptions ; ConfigMapVolumeOptions . builder () // .defaultMode(java.lang.Number) // .items(java.util.Map<java.lang.String, PathMapping>) // .name(java.lang.String) // .optional(java.lang.Boolean) . build (); defaultMode Optional \u00b6 public java . lang . Number getDefaultMode (); Type: java.lang.Number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public java . util . Map < java . lang . String , PathMapping > getItems (); Type: java.util.Map \u0002klzzwxh:3194\u0003 > Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import org.cdk8s.plus17.ContainerProps ; ContainerProps . builder () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .env(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .readiness(Probe) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String Docker image name. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnv (); Type: java.util.Map \u0002klzzwxh:3175\u0003 > Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 public Probe getLiveness (); Type: org.cdk8s.plus17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 public Probe getReadiness (); Type: org.cdk8s.plus17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 public Probe getStartup (); Type: org.cdk8s.plus17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public java . util . List < VolumeMount > getVolumeMounts (); Type: java.util.List< org.cdk8s.plus17.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. DeploymentProps \u00b6 Properties for initialization of Deployment . Initializer \u00b6 import org.cdk8s.plus17.DeploymentProps ; DeploymentProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .defaultSelector(java.lang.Boolean) // .replicas(java.lang.Number) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. defaultSelector Optional \u00b6 public java . lang . Boolean getDefaultSelector (); Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import org.cdk8s.plus17.EmptyDirVolumeOptions ; EmptyDirVolumeOptions . builder () // .medium(EmptyDirMedium) // .sizeLimit(Size) . build (); medium Optional \u00b6 public EmptyDirMedium getMedium (); Type: org.cdk8s.plus17.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public Size getSizeLimit (); Type: org.cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import org.cdk8s.plus17.EnvValueFromConfigMapOptions ; EnvValueFromConfigMapOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import org.cdk8s.plus17.EnvValueFromProcessOptions ; EnvValueFromProcessOptions . builder () // .required(java.lang.Boolean) . build (); required Optional \u00b6 public java . lang . Boolean getRequired (); Type: java.lang.Boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import org.cdk8s.plus17.EnvValueFromSecretOptions ; EnvValueFromSecretOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the Secret or its key must be defined. ExposeOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import org.cdk8s.plus17.ExposeOptions ; ExposeOptions . builder () // .name(java.lang.String) // .protocol(Protocol) // .serviceType(ServiceType) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus17.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import org.cdk8s.plus17.HttpGetProbeOptions ; HttpGetProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) // .port(java.lang.Number) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import org.cdk8s.plus17.IngressV1Beta1Props ; IngressV1Beta1Props . builder () // .metadata(ApiObjectMetadata) // .defaultBackend(IngressV1Beta1Backend) // .rules(java.util.List<IngressV1Beta1Rule>) // .tls(java.util.List<IngressV1Beta1Tls>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public IngressV1Beta1Backend getDefaultBackend (); Type: org.cdk8s.plus17.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public java . util . List < IngressV1Beta1Rule > getRules (); Type: java.util.List< org.cdk8s.plus17.IngressV1Beta1Rule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public java . util . List < IngressV1Beta1Tls > getTls (); Type: java.util.List< org.cdk8s.plus17.IngressV1Beta1Tls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import org.cdk8s.plus17.IngressV1Beta1Rule ; IngressV1Beta1Rule . builder () . backend ( IngressV1Beta1Backend ) // .host(java.lang.String) // .path(java.lang.String) . build (); backend Required \u00b6 public IngressV1Beta1Backend getBackend (); Type: org.cdk8s.plus17.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public java . lang . String getPath (); Type: java.lang.String Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import org.cdk8s.plus17.IngressV1Beta1Tls ; IngressV1Beta1Tls . builder () // .hosts(java.util.List<java.lang.String>) // .secret(ISecret) . build (); hosts Optional \u00b6 public java . util . List < java . lang . String > getHosts (); Type: java.util.List< java.lang.String > Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus17.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for initialization of Job . Initializer \u00b6 import org.cdk8s.plus17.JobProps ; JobProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. MountOptions \u00b6 Options for mounts. Initializer \u00b6 import org.cdk8s.plus17.MountOptions ; MountOptions . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import org.cdk8s.plus17.PathMapping ; PathMapping . builder () . path ( java . lang . String ) // .mode(java.lang.Number) . build (); path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public java . lang . Number getMode (); Type: java.lang.Number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PodProps \u00b6 Properties for initialization of Pod . Initializer \u00b6 import org.cdk8s.plus17.PodProps ; PodProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSpecProps \u00b6 Properties of a PodSpec . Initializer \u00b6 import org.cdk8s.plus17.PodSpecProps ; PodSpecProps . builder () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Initializer \u00b6 import org.cdk8s.plus17.PodTemplateProps ; PodTemplateProps . builder () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . build (); containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import org.cdk8s.plus17.ProbeOptions ; ProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import org.cdk8s.plus17.ResourceProps ; ResourceProps . builder () // .metadata(ApiObjectMetadata) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. SecretProps \u00b6 Initializer \u00b6 import org.cdk8s.plus17.SecretProps ; SecretProps . builder () // .metadata(ApiObjectMetadata) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. stringData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getStringData (); Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public java . lang . String getType (); Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import org.cdk8s.plus17.SecretValue ; SecretValue . builder () . key ( java . lang . String ) . secret ( ISecret ) . build (); key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String The JSON key. secret Required \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus17.ISecret The secret. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Initializer \u00b6 import org.cdk8s.plus17.ServiceAccountProps ; ServiceAccountProps . builder () // .metadata(ApiObjectMetadata) // .secrets(java.util.List<ISecret>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus17.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import org.cdk8s.plus17.ServiceIngressV1BetaBackendOptions ; ServiceIngressV1BetaBackendOptions . builder () // .port(java.lang.Number) . build (); port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import org.cdk8s.plus17.ServicePort ; ServicePort . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . port ( java . lang . Number ) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import org.cdk8s.plus17.ServicePortOptions ; ServicePortOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import org.cdk8s.plus17.ServiceProps ; ServiceProps . builder () // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .type(ServiceType) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public java . util . List < java . lang . String > getExternalIPs (); Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public java . util . List < java . lang . String > getLoadBalancerSourceRanges (); Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus17.ServicePort > The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 public ServiceType getType (); Type: org.cdk8s.plus17.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import org.cdk8s.plus17.StatefulSetProps ; StatefulSetProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . service ( Service ) // .defaultSelector(java.lang.Boolean) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 public Service getService (); Type: org.cdk8s.plus17.Service Service to associate with the statefulset. defaultSelector Optional \u00b6 public java . lang . Boolean getDefaultSelector (); Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . podManagementPolicy Optional \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus17.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import org.cdk8s.plus17.VolumeMount ; VolumeMount . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . path ( java . lang . String ) . volume ( Volume ) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public Volume getVolume (); Type: org.cdk8s.plus17.Volume The volume to mount. Classes \u00b6 Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import org.cdk8s.plus17.Container ; Container . Builder . create () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .env(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .readiness(Probe) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 Type: java.lang.String Docker image name. args Optional \u00b6 Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: java.util.Map \u0002klzzwxh:2775\u0003 > Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 Type: org.cdk8s.plus17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: org.cdk8s.plus17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: java.lang.Number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: org.cdk8s.plus17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: org.cdk8s.plus17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 addEnv \u00b6 public addEnv ( java . lang . String name , EnvValue value ) name Required \u00b6 Type: java.lang.String The variable name. value Required \u00b6 Type: org.cdk8s.plus17.EnvValue The variable value. mount \u00b6 public mount ( java . lang . String path , Volume volume ) public mount ( java . lang . String path , Volume volume , MountOptions options ) path Required \u00b6 Type: java.lang.String The desired path in the container. volume Required \u00b6 Type: org.cdk8s.plus17.Volume The volume to mount. options Optional \u00b6 Type: org.cdk8s.plus17.MountOptions Properties \u00b6 env Required \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnv (); Type: java.util.Map \u0002klzzwxh:2730\u0003 > The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String The container image. imagePullPolicy Required \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus17.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public java . util . List < VolumeMount > getMounts (); Type: java.util.List< org.cdk8s.plus17.VolumeMount > Volume mounts configured for this container. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the container. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Arguments to the entrypoint. command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Entrypoint array (the command to execute when the container starts). port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port this container exposes. workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String The working directory inside the container. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus17.EnvValue ; EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key ) EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key , EnvValueFromConfigMapOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus17.IConfigMap The config map. key Required \u00b6 Type: java.lang.String The key to extract the value from. options Optional \u00b6 Type: org.cdk8s.plus17.EnvValueFromConfigMapOptions Additional options. fromProcess \u00b6 import org.cdk8s.plus17.EnvValue ; EnvValue . fromProcess ( java . lang . String key ) EnvValue . fromProcess ( java . lang . String key , EnvValueFromProcessOptions options ) key Required \u00b6 Type: java.lang.String The key to read. options Optional \u00b6 Type: org.cdk8s.plus17.EnvValueFromProcessOptions Additional options. fromSecretValue \u00b6 import org.cdk8s.plus17.EnvValue ; EnvValue . fromSecretValue ( SecretValue secretValue ) EnvValue . fromSecretValue ( SecretValue secretValue , EnvValueFromSecretOptions options ) secretValue Required \u00b6 Type: org.cdk8s.plus17.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: org.cdk8s.plus17.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import org.cdk8s.plus17.EnvValue ; EnvValue . fromValue ( java . lang . String value ) value Required \u00b6 Type: java.lang.String The value. Properties \u00b6 value Optional \u00b6 public java . lang . Object getValue (); Type: java.lang.Object valueFrom Optional \u00b6 public java . lang . Object getValueFrom (); Type: java.lang.Object IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromService \u00b6 import org.cdk8s.plus17.IngressV1Beta1Backend ; IngressV1Beta1Backend . fromService ( Service service ) IngressV1Beta1Backend . fromService ( Service service , ServiceIngressV1BetaBackendOptions options ) service Required \u00b6 Type: org.cdk8s.plus17.Service The service object. options Optional \u00b6 Type: org.cdk8s.plus17.ServiceIngressV1BetaBackendOptions PodSpec \u00b6 Implements: org.cdk8s.plus17.IPodSpec Provides read/write capabilities ontop of a PodSpecProps . Initializers \u00b6 import org.cdk8s.plus17.PodSpec ; PodSpec . Builder . create () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus17.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus17.Volume Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus17.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount The service account used to run this pod. PodTemplate \u00b6 Implements: org.cdk8s.plus17.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Initializers \u00b6 import org.cdk8s.plus17.PodTemplate ; PodTemplate . Builder . create () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . build (); containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. Properties \u00b6 podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializers \u00b6 import org.cdk8s.plus17.Probe ; new Probe (); Static Functions \u00b6 fromCommand \u00b6 import org.cdk8s.plus17.Probe ; Probe . fromCommand ( java . util . List < java . lang . String > command ) Probe . fromCommand ( java . util . List < java . lang . String > command , CommandProbeOptions options ) command Required \u00b6 Type: java.util.List< java.lang.String > The command to execute. options Optional \u00b6 Type: org.cdk8s.plus17.CommandProbeOptions Options. fromHttpGet \u00b6 import org.cdk8s.plus17.Probe ; Probe . fromHttpGet ( java . lang . String path ) Probe . fromHttpGet ( java . lang . String path , HttpGetProbeOptions options ) path Required \u00b6 Type: java.lang.String The URL path to hit. options Optional \u00b6 Type: org.cdk8s.plus17.HttpGetProbeOptions Options. Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializers \u00b6 import org.cdk8s.plus17.Volume ; new Volume ( java . lang . String name , java . lang . Object config ); name Required \u00b6 Type: java.lang.String config Required \u00b6 Type: java.lang.Object Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus17.Volume ; Volume . fromConfigMap ( IConfigMap configMap ) Volume . fromConfigMap ( IConfigMap configMap , ConfigMapVolumeOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus17.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: org.cdk8s.plus17.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import org.cdk8s.plus17.Volume ; Volume . fromEmptyDir ( java . lang . String name ) Volume . fromEmptyDir ( java . lang . String name , EmptyDirVolumeOptions options ) name Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus17.EmptyDirVolumeOptions Additional options. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Protocols \u00b6 IConfigMap \u00b6 Extends: org.cdk8s.plus17.IResource Implemented By: org.cdk8s.plus17.ConfigMap , org.cdk8s.plus17.IConfigMap Represents a config map. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IPodSpec \u00b6 Implemented By: org.cdk8s.plus17.Deployment , org.cdk8s.plus17.Job , org.cdk8s.plus17.Pod , org.cdk8s.plus17.PodSpec , org.cdk8s.plus17.PodTemplate , org.cdk8s.plus17.StatefulSet , org.cdk8s.plus17.IPodSpec , org.cdk8s.plus17.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus17.ContainerProps The container. addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus17.Volume The volume. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus17.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount The service account used to run this pod. IPodTemplate \u00b6 Extends: org.cdk8s.plus17.IPodSpec Implemented By: org.cdk8s.plus17.Deployment , org.cdk8s.plus17.Job , org.cdk8s.plus17.PodTemplate , org.cdk8s.plus17.StatefulSet , org.cdk8s.plus17.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus17.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount The service account used to run this pod. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. IResource \u00b6 Implemented By: org.cdk8s.plus17.ConfigMap , org.cdk8s.plus17.Deployment , org.cdk8s.plus17.IngressV1Beta1 , org.cdk8s.plus17.Job , org.cdk8s.plus17.Pod , org.cdk8s.plus17.Resource , org.cdk8s.plus17.Secret , org.cdk8s.plus17.Service , org.cdk8s.plus17.ServiceAccount , org.cdk8s.plus17.StatefulSet , org.cdk8s.plus17.IConfigMap , org.cdk8s.plus17.IResource , org.cdk8s.plus17.ISecret , org.cdk8s.plus17.IServiceAccount Represents a resource. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. ISecret \u00b6 Extends: org.cdk8s.plus17.IResource Implemented By: org.cdk8s.plus17.Secret , org.cdk8s.plus17.ISecret Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: org.cdk8s.plus17.IResource Implemented By: org.cdk8s.plus17.ServiceAccount , org.cdk8s.plus17.IServiceAccount Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. Enums \u00b6 EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"Java"},{"location":"reference/cdk8s-plus-17/java/#cdk8s-plus-17-java","text":"","title":"cdk8s-plus-17 (Java) "},{"location":"reference/cdk8s-plus-17/java/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-17/java/#configmap","text":"Implements: org.cdk8s.plus17.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-17/java/#deployment","text":"Implements: org.cdk8s.plus17.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-17/java/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-17/java/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-17/java/#job","text":"Implements: org.cdk8s.plus17.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-17/java/#pod","text":"Implements: org.cdk8s.plus17.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-17/java/#resource","text":"Implements: org.cdk8s.plus17.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-17/java/#secret","text":"Implements: org.cdk8s.plus17.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-17/java/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-17/java/#serviceaccount","text":"Implements: org.cdk8s.plus17.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-17/java/#statefulset","text":"Implements: org.cdk8s.plus17.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-17/java/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-17/java/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-17/java/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-17/java/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-17/java/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-17/java/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-17/java/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-17/java/#deploymentprops","text":"Properties for initialization of Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-17/java/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-17/java/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-17/java/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-17/java/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-17/java/#exposeoptions","text":"Options for exposing a deployment via a service.","title":"ExposeOptions "},{"location":"reference/cdk8s-plus-17/java/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-17/java/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-17/java/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-17/java/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-17/java/#jobprops","text":"Properties for initialization of Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-17/java/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-17/java/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-17/java/#podprops","text":"Properties for initialization of Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-17/java/#podspecprops","text":"Properties of a PodSpec .","title":"PodSpecProps "},{"location":"reference/cdk8s-plus-17/java/#podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec.","title":"PodTemplateProps "},{"location":"reference/cdk8s-plus-17/java/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-17/java/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-17/java/#secretprops","text":"","title":"SecretProps "},{"location":"reference/cdk8s-plus-17/java/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-17/java/#serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-17/java/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-17/java/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-17/java/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-17/java/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-17/java/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-17/java/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-17/java/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-17/java/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-17/java/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-17/java/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-17/java/#podspec","text":"Implements: org.cdk8s.plus17.IPodSpec Provides read/write capabilities ontop of a PodSpecProps .","title":"PodSpec "},{"location":"reference/cdk8s-plus-17/java/#podtemplate","text":"Implements: org.cdk8s.plus17.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps .","title":"PodTemplate "},{"location":"reference/cdk8s-plus-17/java/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-17/java/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-17/java/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-17/java/#iconfigmap","text":"Extends: org.cdk8s.plus17.IResource Implemented By: org.cdk8s.plus17.ConfigMap , org.cdk8s.plus17.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-17/java/#ipodspec","text":"Implemented By: org.cdk8s.plus17.Deployment , org.cdk8s.plus17.Job , org.cdk8s.plus17.Pod , org.cdk8s.plus17.PodSpec , org.cdk8s.plus17.PodTemplate , org.cdk8s.plus17.StatefulSet , org.cdk8s.plus17.IPodSpec , org.cdk8s.plus17.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"IPodSpec "},{"location":"reference/cdk8s-plus-17/java/#ipodtemplate","text":"Extends: org.cdk8s.plus17.IPodSpec Implemented By: org.cdk8s.plus17.Deployment , org.cdk8s.plus17.Job , org.cdk8s.plus17.PodTemplate , org.cdk8s.plus17.StatefulSet , org.cdk8s.plus17.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"IPodTemplate "},{"location":"reference/cdk8s-plus-17/java/#iresource","text":"Implemented By: org.cdk8s.plus17.ConfigMap , org.cdk8s.plus17.Deployment , org.cdk8s.plus17.IngressV1Beta1 , org.cdk8s.plus17.Job , org.cdk8s.plus17.Pod , org.cdk8s.plus17.Resource , org.cdk8s.plus17.Secret , org.cdk8s.plus17.Service , org.cdk8s.plus17.ServiceAccount , org.cdk8s.plus17.StatefulSet , org.cdk8s.plus17.IConfigMap , org.cdk8s.plus17.IResource , org.cdk8s.plus17.ISecret , org.cdk8s.plus17.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-17/java/#isecret","text":"Extends: org.cdk8s.plus17.IResource Implemented By: org.cdk8s.plus17.Secret , org.cdk8s.plus17.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-17/java/#iserviceaccount","text":"Extends: org.cdk8s.plus17.IResource Implemented By: org.cdk8s.plus17.ServiceAccount , org.cdk8s.plus17.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-17/java/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-17/java/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-17/java/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-17/java/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-17/java/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-17/java/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-17/java/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-17/java/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-17/python/","text":"cdk8s-plus-17 (Python) \u00b6 Constructs \u00b6 ConfigMap \u00b6 Implements: cdk8s_plus_17.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ConfigMap ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . Methods \u00b6 add_binary_data \u00b6 def add_binary_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_data \u00b6 def add_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_directory \u00b6 def add_directory ( local_dir : str , exclude : typing . List [ str ] = None , key_prefix : str = None ) local_dir Required \u00b6 Type: str A path to a local directory. exclude Optional \u00b6 Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. add_file \u00b6 def add_file ( local_file : str , key : str = None ) local_file Required \u00b6 Type: str The path to the local file. key Optional \u00b6 Type: str The ConfigMap key (default to the file name). Static Functions \u00b6 from_config_map_name \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ConfigMap . from_config_map_name ( name : str ) name Required \u00b6 Type: str The name of the config map to import. Properties \u00b6 binary_data Required \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . Deployment \u00b6 Implements: cdk8s_plus_17.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Deployment ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , default_selector : bool = None , replicas : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. default_selector Optional \u00b6 Type: bool Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume expose \u00b6 def expose ( port : typing . Union [ int , float ], name : str = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) port Required \u00b6 Type: typing.Union[int, float] The port number the service will bind to. name Optional \u00b6 Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL protocol Optional \u00b6 Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 Type: cdk8s_plus_17.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. select_by_label \u00b6 def select_by_label ( key : str , value : str ) key Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. label_selector Required \u00b6 label_selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] The labels this deployment will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . IngressV1Beta1 ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , default_backend : IngressV1Beta1Backend = None , rules : typing . List [ IngressV1Beta1Rule ] = None , tls : typing . List [ IngressV1Beta1Tls ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_17.IngressV1Beta1Rule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: typing.List[ cdk8s_plus_17.IngressV1Beta1Tls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 add_default_backend \u00b6 def add_default_backend ( backend : IngressV1Beta1Backend ) backend Required \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend The backend to use for requests that do not match any rule. add_host_default_backend \u00b6 def add_host_default_backend ( host : str , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: str The host name to match. backend Required \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend The backend to route to. add_host_rule \u00b6 def add_host_rule ( host : str , path : str , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: str The host name. path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend The backend to route requests to. add_rule \u00b6 def add_rule ( path : str , backend : IngressV1Beta1Backend ) path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend The backend to route requests to. add_rules \u00b6 def add_rules ( backend : IngressV1Beta1Backend , host : str = None , path : str = None ) backend Required \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. add_tls \u00b6 def add_tls ( tls : typing . List [ IngressV1Beta1Tls ] ) tls Required \u00b6 Type: typing.List[ cdk8s_plus_17.IngressV1Beta1Tls ] Job \u00b6 Implements: cdk8s_plus_17.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Job ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. active_deadline Optional \u00b6 Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Number of retries before marking failed. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration TTL before the job is deleted after it is finished. Pod \u00b6 Implements: cdk8s_plus_17.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Pod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. Resource \u00b6 Implements: cdk8s_plus_17.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Resource ( scope : Construct , id : str , node_factory : INodeFactory = None ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: str The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . node_factory Optional \u00b6 Type: constructs.INodeFactory Default: the default Node is associated A factory for attaching Node s to the construct. Properties \u00b6 metadata Required \u00b6 metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 name : str Type: str The name of this API object. Secret \u00b6 Implements: cdk8s_plus_17.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Secret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , string_data : typing . Mapping [ str ] = None , type : str = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. string_data Optional \u00b6 Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 add_string_data \u00b6 def add_string_data ( key : str , value : str ) key Required \u00b6 Type: str Key. value Required \u00b6 Type: str Value. get_string_data \u00b6 def get_string_data ( key : str ) key Required \u00b6 Type: str Key. Static Functions \u00b6 from_secret_name \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Secret . from_secret_name ( name : str ) name Required \u00b6 Type: str The name of the secret to reference. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Service ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: cdk8s_plus_17.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 add_deployment \u00b6 def add_deployment ( deployment : Deployment , port : typing . Union [ int , float ], name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) deployment Required \u00b6 Type: cdk8s_plus_17.Deployment The deployment to expose. port Required \u00b6 Type: typing.Union[int, float] The external port. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. add_selector \u00b6 def add_selector ( label : str , value : str ) label Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. serve \u00b6 def serve ( port : typing . Union [ int , float ], name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) port Required \u00b6 Type: typing.Union[int, float] The port definition. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. Properties \u00b6 ports Required \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_17.ServicePort ] Ports for this service. Use serve() to expose additional service ports. selector Required \u00b6 selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] Returns the labels which are used to select pods for this service. type Required \u00b6 type : ServiceType Type: cdk8s_plus_17.ServiceType Determines how the Service is exposed. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str The IP address of the service and is usually assigned randomly by the master. external_name Optional \u00b6 external_name : str Type: str The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s_plus_17.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServiceAccount ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , secrets : typing . List [ ISecret ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 add_secret \u00b6 def add_secret ( secret : ISecret ) secret Required \u00b6 Type: cdk8s_plus_17.ISecret The secret. Static Functions \u00b6 from_service_account_name \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServiceAccount . from_service_account_name ( name : str ) name Required \u00b6 Type: str The name of the service account resource. Properties \u00b6 secrets Required \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_17.ISecret ] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . StatefulSet \u00b6 Implements: cdk8s_plus_17.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . StatefulSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , service : Service , default_selector : bool = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 Type: cdk8s_plus_17.Service Service to associate with the statefulset. default_selector Optional \u00b6 Type: bool Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . pod_management_policy Optional \u00b6 Type: cdk8s_plus_17.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume select_by_label \u00b6 def select_by_label ( key : str , value : str ) key Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. label_selector Required \u00b6 label_selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] The labels this statefulset will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. pod_management_policy Required \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_17.PodManagementPolicy Management policy to use for the set. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. Structs \u00b6 AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . AddDirectoryOptions ( exclude : typing . List [ str ] = None , key_prefix : str = None ) exclude Optional \u00b6 exclude : typing . List [ str ] Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 key_prefix : str Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . CommandProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ConfigMapProps ( metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ConfigMapVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 default_mode : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 items : typing . Mapping [ PathMapping ] Type: typing.Mapping[ cdk8s_plus_17.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. optional Optional \u00b6 optional : bool Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ContainerProps ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 image : str Type: str Docker image name. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 env : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 liveness : Probe Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 name : str Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 readiness : Probe Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 startup : Probe Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 volume_mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 working_dir : str Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. DeploymentProps \u00b6 Properties for initialization of Deployment . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . DeploymentProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , default_selector : bool = None , replicas : typing . Union [ int , float ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. default_selector Optional \u00b6 default_selector : bool Type: bool Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EmptyDirVolumeOptions ( medium : EmptyDirMedium = None , size_limit : Size = None ) medium Optional \u00b6 medium : EmptyDirMedium Type: cdk8s_plus_17.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 size_limit : Size Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValueFromConfigMapOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValueFromProcessOptions ( required : bool = None ) required Optional \u00b6 required : bool Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValueFromSecretOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the Secret or its key must be defined. ExposeOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ExposeOptions ( name : str = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_17.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . HttpGetProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . IngressV1Beta1Props ( metadata : ApiObjectMetadata = None , default_backend : IngressV1Beta1Backend = None , rules : typing . List [ IngressV1Beta1Rule ] = None , tls : typing . List [ IngressV1Beta1Tls ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 default_backend : IngressV1Beta1Backend Type: cdk8s_plus_17.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 rules : typing . List [ IngressV1Beta1Rule ] Type: typing.List[ cdk8s_plus_17.IngressV1Beta1Rule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 tls : typing . List [ IngressV1Beta1Tls ] Type: typing.List[ cdk8s_plus_17.IngressV1Beta1Tls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . IngressV1Beta1Rule ( backend : IngressV1Beta1Backend , host : str = None , path : str = None ) backend Required \u00b6 backend : IngressV1Beta1Backend Type: cdk8s_plus_17.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 host : str Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 path : str Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . IngressV1Beta1Tls ( hosts : typing . List [ str ] = None , secret : ISecret = None ) hosts Optional \u00b6 hosts : typing . List [ str ] Type: typing.List[ str ] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 secret : ISecret Type: cdk8s_plus_17.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for initialization of Job . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . JobProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. MountOptions \u00b6 Options for mounts. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . MountOptions ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PathMapping ( path : str , mode : typing . Union [ int , float ] = None ) path Required \u00b6 path : str Type: str The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 mode : typing . Union [ int , float ] Type: typing.Union[int, float] Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PodProps \u00b6 Properties for initialization of Pod . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PodProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSpecProps \u00b6 Properties of a PodSpec . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PodSpecProps ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PodTemplateProps ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None ) containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ResourceProps ( metadata : ApiObjectMetadata = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. SecretProps \u00b6 Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . SecretProps ( metadata : ApiObjectMetadata = None , string_data : typing . Mapping [ str ] = None , type : str = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. string_data Optional \u00b6 string_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 type : str Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . SecretValue ( key : str , secret : ISecret ) key Required \u00b6 key : str Type: str The JSON key. secret Required \u00b6 secret : ISecret Type: cdk8s_plus_17.ISecret The secret. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServiceAccountProps ( metadata : ApiObjectMetadata = None , secrets : typing . List [ ISecret ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_17.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServiceIngressV1BetaBackendOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServicePort ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServicePortOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServiceProps ( metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 external_i_ps : typing . List [ str ] Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 external_name : str Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 load_balancer_source_ranges : typing . List [ str ] Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_17.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 type : ServiceType Type: cdk8s_plus_17.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . StatefulSetProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , service : Service , default_selector : bool = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 service : Service Type: cdk8s_plus_17.Service Service to associate with the statefulset. default_selector Optional \u00b6 default_selector : bool Type: bool Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . pod_management_policy Optional \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_17.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . VolumeMount ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None , path : str , volume : Volume ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. path Required \u00b6 path : str Type: str Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 volume : Volume Type: cdk8s_plus_17.Volume The volume to mount. Classes \u00b6 Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 add_env \u00b6 def add_env ( name : str , value : EnvValue ) name Required \u00b6 Type: str The variable name. value Required \u00b6 Type: cdk8s_plus_17.EnvValue The variable value. mount \u00b6 def mount ( path : str , volume : Volume , propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) path Required \u00b6 Type: str The desired path in the container. volume Required \u00b6 Type: cdk8s_plus_17.Volume The volume to mount. propagation Optional \u00b6 Type: cdk8s_plus_17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. Properties \u00b6 env Required \u00b6 env : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 image : str Type: str The container image. image_pull_policy Required \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_17.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_17.VolumeMount ] Volume mounts configured for this container. name Required \u00b6 name : str Type: str The name of the container. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Arguments to the entrypoint. command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port this container exposes. working_dir Optional \u00b6 working_dir : str Type: str The working directory inside the container. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValue . from_config_map ( config_map : IConfigMap , key : str , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_17.IConfigMap The config map. key Required \u00b6 Type: str The key to extract the value from. optional Optional \u00b6 Type: bool Default: false Specify whether the ConfigMap or its key must be defined. from_process \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValue . from_process ( key : str , required : bool = None ) key Required \u00b6 Type: str The key to read. required Optional \u00b6 Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. from_secret_value \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValue . from_secret_value ( key : str , secret : ISecret , optional : bool = None ) key Required \u00b6 Type: str The JSON key. secret Required \u00b6 Type: cdk8s_plus_17.ISecret The secret. optional Optional \u00b6 Type: bool Default: false Specify whether the Secret or its key must be defined. from_value \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValue . from_value ( value : str ) value Required \u00b6 Type: str The value. Properties \u00b6 value Optional \u00b6 value : typing . Any Type: typing.Any value_from Optional \u00b6 value_from : typing . Any Type: typing.Any IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 from_service \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . IngressV1Beta1Backend . from_service ( service : Service , port : typing . Union [ int , float ] = None ) service Required \u00b6 Type: cdk8s_plus_17.Service The service object. port Optional \u00b6 Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. PodSpec \u00b6 Implements: cdk8s_plus_17.IPodSpec Provides read/write capabilities ontop of a PodSpecProps . Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PodSpec ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. PodTemplate \u00b6 Implements: cdk8s_plus_17.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PodTemplate ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None ) containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. Properties \u00b6 pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Probe () Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Probe . from_command ( command : typing . List [ str ], failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) command Required \u00b6 Type: typing.List[ str ] The command to execute. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes from_http_get \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Probe . from_http_get ( path : str , failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) path Required \u00b6 Type: str The URL path to hit. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Volume ( name : str , config : typing . Any ) name Required \u00b6 Type: str config Required \u00b6 Type: typing.Any Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Volume . from_config_map ( config_map : IConfigMap , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_17.IConfigMap The config map to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. from_empty_dir \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Volume . from_empty_dir ( name : str , medium : EmptyDirMedium = None , size_limit : Size = None ) name Required \u00b6 Type: str medium Optional \u00b6 Type: cdk8s_plus_17.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. Properties \u00b6 name Required \u00b6 name : str Type: str Protocols \u00b6 IConfigMap \u00b6 Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.ConfigMap , cdk8s_plus_17.IConfigMap Represents a config map. Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IPodSpec \u00b6 Implemented By: cdk8s_plus_17.Deployment , cdk8s_plus_17.Job , cdk8s_plus_17.Pod , cdk8s_plus_17.PodSpec , cdk8s_plus_17.PodTemplate , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IPodSpec , cdk8s_plus_17.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume The volume. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. IPodTemplate \u00b6 Extends: cdk8s_plus_17.IPodSpec Implemented By: cdk8s_plus_17.Deployment , cdk8s_plus_17.Job , cdk8s_plus_17.PodTemplate , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. IResource \u00b6 Implemented By: cdk8s_plus_17.ConfigMap , cdk8s_plus_17.Deployment , cdk8s_plus_17.IngressV1Beta1 , cdk8s_plus_17.Job , cdk8s_plus_17.Pod , cdk8s_plus_17.Resource , cdk8s_plus_17.Secret , cdk8s_plus_17.Service , cdk8s_plus_17.ServiceAccount , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IConfigMap , cdk8s_plus_17.IResource , cdk8s_plus_17.ISecret , cdk8s_plus_17.IServiceAccount Represents a resource. Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.Secret , cdk8s_plus_17.ISecret Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.ServiceAccount , cdk8s_plus_17.IServiceAccount Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. Enums \u00b6 EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"Python"},{"location":"reference/cdk8s-plus-17/python/#cdk8s-plus-17-python","text":"","title":"cdk8s-plus-17 (Python) "},{"location":"reference/cdk8s-plus-17/python/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-17/python/#configmap","text":"Implements: cdk8s_plus_17.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-17/python/#deployment","text":"Implements: cdk8s_plus_17.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-17/python/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-17/python/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-17/python/#job","text":"Implements: cdk8s_plus_17.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-17/python/#pod","text":"Implements: cdk8s_plus_17.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-17/python/#resource","text":"Implements: cdk8s_plus_17.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-17/python/#secret","text":"Implements: cdk8s_plus_17.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-17/python/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-17/python/#serviceaccount","text":"Implements: cdk8s_plus_17.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-17/python/#statefulset","text":"Implements: cdk8s_plus_17.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-17/python/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-17/python/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-17/python/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-17/python/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-17/python/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-17/python/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-17/python/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-17/python/#deploymentprops","text":"Properties for initialization of Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-17/python/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-17/python/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-17/python/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-17/python/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-17/python/#exposeoptions","text":"Options for exposing a deployment via a service.","title":"ExposeOptions "},{"location":"reference/cdk8s-plus-17/python/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-17/python/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-17/python/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-17/python/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-17/python/#jobprops","text":"Properties for initialization of Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-17/python/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-17/python/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-17/python/#podprops","text":"Properties for initialization of Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-17/python/#podspecprops","text":"Properties of a PodSpec .","title":"PodSpecProps "},{"location":"reference/cdk8s-plus-17/python/#podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec.","title":"PodTemplateProps "},{"location":"reference/cdk8s-plus-17/python/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-17/python/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-17/python/#secretprops","text":"","title":"SecretProps "},{"location":"reference/cdk8s-plus-17/python/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-17/python/#serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-17/python/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-17/python/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-17/python/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-17/python/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-17/python/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-17/python/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-17/python/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-17/python/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-17/python/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-17/python/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-17/python/#podspec","text":"Implements: cdk8s_plus_17.IPodSpec Provides read/write capabilities ontop of a PodSpecProps .","title":"PodSpec "},{"location":"reference/cdk8s-plus-17/python/#podtemplate","text":"Implements: cdk8s_plus_17.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps .","title":"PodTemplate "},{"location":"reference/cdk8s-plus-17/python/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-17/python/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-17/python/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-17/python/#iconfigmap","text":"Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.ConfigMap , cdk8s_plus_17.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-17/python/#ipodspec","text":"Implemented By: cdk8s_plus_17.Deployment , cdk8s_plus_17.Job , cdk8s_plus_17.Pod , cdk8s_plus_17.PodSpec , cdk8s_plus_17.PodTemplate , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IPodSpec , cdk8s_plus_17.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"IPodSpec "},{"location":"reference/cdk8s-plus-17/python/#ipodtemplate","text":"Extends: cdk8s_plus_17.IPodSpec Implemented By: cdk8s_plus_17.Deployment , cdk8s_plus_17.Job , cdk8s_plus_17.PodTemplate , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"IPodTemplate "},{"location":"reference/cdk8s-plus-17/python/#iresource","text":"Implemented By: cdk8s_plus_17.ConfigMap , cdk8s_plus_17.Deployment , cdk8s_plus_17.IngressV1Beta1 , cdk8s_plus_17.Job , cdk8s_plus_17.Pod , cdk8s_plus_17.Resource , cdk8s_plus_17.Secret , cdk8s_plus_17.Service , cdk8s_plus_17.ServiceAccount , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IConfigMap , cdk8s_plus_17.IResource , cdk8s_plus_17.ISecret , cdk8s_plus_17.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-17/python/#isecret","text":"Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.Secret , cdk8s_plus_17.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-17/python/#iserviceaccount","text":"Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.ServiceAccount , cdk8s_plus_17.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-17/python/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-17/python/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-17/python/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-17/python/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-17/python/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-17/python/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-17/python/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-17/python/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-17/typescript/","text":"cdk8s-plus-17 (TypeScript) \u00b6 Constructs \u00b6 ConfigMap \u00b6 Implements: cdk8s-plus-17.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import { ConfigMap } from 'cdk8s-plus-17' new ConfigMap ( scope : Construct , id : string , props? : ConfigMapProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.ConfigMapProps Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addData \u00b6 public addData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addDirectory \u00b6 public addDirectory ( localDir : string , options? : AddDirectoryOptions ) localDir Required \u00b6 Type: string A path to a local directory. options Optional \u00b6 Type: cdk8s-plus-17.AddDirectoryOptions Options. addFile \u00b6 public addFile ( localFile : string , key? : string ) localFile Required \u00b6 Type: string The path to the local file. key Optional \u00b6 Type: string The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import { ConfigMap } from 'cdk8s-plus-17' ConfigMap . fromConfigMapName ( name : string ) name Required \u00b6 Type: string The name of the config map to import. Properties \u00b6 binaryData Required \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . Deployment \u00b6 Implements: cdk8s-plus-17.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import { Deployment } from 'cdk8s-plus-17' new Deployment ( scope : Construct , id : string , props? : DeploymentProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.DeploymentProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume expose \u00b6 public expose ( port : number , options? : ExposeOptions ) port Required \u00b6 Type: number The port number the service will bind to. options Optional \u00b6 Type: cdk8s-plus-17.ExposeOptions Options to determine details of the service and port exposed. selectByLabel \u00b6 public selectByLabel ( key : string , value : string ) key Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public readonly labelSelector : {[ key : string ] : string }; Type: {[ key: string ]: string } The labels this deployment will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import { IngressV1Beta1 } from 'cdk8s-plus-17' new IngressV1Beta1 ( scope : Construct , id : string , props? : IngressV1Beta1Props ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Props Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( backend : IngressV1Beta1Backend ) backend Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Backend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( host : string , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: string The host name to match. backend Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Backend The backend to route to. addHostRule \u00b6 public addHostRule ( host : string , path : string , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: string The host name. path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Backend The backend to route requests to. addRule \u00b6 public addRule ( path : string , backend : IngressV1Beta1Backend ) path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Backend The backend to route requests to. addRules \u00b6 public addRules ( rules : IngressV1Beta1Rule ) rules Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Rule The rules to add. addTls \u00b6 public addTls ( tls : IngressV1Beta1Tls []) tls Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Tls [] Job \u00b6 Implements: cdk8s-plus-17.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import { Job } from 'cdk8s-plus-17' new Job ( scope : Construct , id : string , props? : JobProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.JobProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Number of retries before marking failed. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration TTL before the job is deleted after it is finished. Pod \u00b6 Implements: cdk8s-plus-17.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import { Pod } from 'cdk8s-plus-17' new Pod ( scope : Construct , id : string , props? : PodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.PodProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. Resource \u00b6 Implements: cdk8s-plus-17.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import { Resource } from 'cdk8s-plus-17' new Resource ( scope : Construct , id : string , options? : ConstructOptions ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: string The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . options Optional \u00b6 Type: constructs.ConstructOptions Options. Properties \u00b6 metadata Required \u00b6 public readonly metadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public readonly name : string ; Type: string The name of this API object. Secret \u00b6 Implements: cdk8s-plus-17.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import { Secret } from 'cdk8s-plus-17' new Secret ( scope : Construct , id : string , props? : SecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.SecretProps Methods \u00b6 addStringData \u00b6 public addStringData ( key : string , value : string ) key Required \u00b6 Type: string Key. value Required \u00b6 Type: string Value. getStringData \u00b6 public getStringData ( key : string ) key Required \u00b6 Type: string Key. Static Functions \u00b6 fromSecretName \u00b6 import { Secret } from 'cdk8s-plus-17' Secret . fromSecretName ( name : string ) name Required \u00b6 Type: string The name of the secret to reference. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import { Service } from 'cdk8s-plus-17' new Service ( scope : Construct , id : string , props? : ServiceProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.ServiceProps Methods \u00b6 addDeployment \u00b6 public addDeployment ( deployment : Deployment , port : number , options? : ServicePortOptions ) deployment Required \u00b6 Type: cdk8s-plus-17.Deployment The deployment to expose. port Required \u00b6 Type: number The external port. options Optional \u00b6 Type: cdk8s-plus-17.ServicePortOptions Optional settings for the port. addSelector \u00b6 public addSelector ( label : string , value : string ) label Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. serve \u00b6 public serve ( port : number , options? : ServicePortOptions ) port Required \u00b6 Type: number The port definition. options Optional \u00b6 Type: cdk8s-plus-17.ServicePortOptions Properties \u00b6 ports Required \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-17.ServicePort [] Ports for this service. Use serve() to expose additional service ports. selector Required \u00b6 public readonly selector : {[ key : string ] : string }; Type: {[ key: string ]: string } Returns the labels which are used to select pods for this service. type Required \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-17.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public readonly externalName : string ; Type: string The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s-plus-17.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import { ServiceAccount } from 'cdk8s-plus-17' new ServiceAccount ( scope : Construct , id : string , props? : ServiceAccountProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.ServiceAccountProps Methods \u00b6 addSecret \u00b6 public addSecret ( secret : ISecret ) secret Required \u00b6 Type: cdk8s-plus-17.ISecret The secret. Static Functions \u00b6 fromServiceAccountName \u00b6 import { ServiceAccount } from 'cdk8s-plus-17' ServiceAccount . fromServiceAccountName ( name : string ) name Required \u00b6 Type: string The name of the service account resource. Properties \u00b6 secrets Required \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-17.ISecret [] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . StatefulSet \u00b6 Implements: cdk8s-plus-17.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import { StatefulSet } from 'cdk8s-plus-17' new StatefulSet ( scope : Construct , id : string , props : StatefulSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-17.StatefulSetProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume selectByLabel \u00b6 public selectByLabel ( key : string , value : string ) key Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public readonly labelSelector : {[ key : string ] : string }; Type: {[ key: string ]: string } The labels this statefulset will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podManagementPolicy Required \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-17.PodManagementPolicy Management policy to use for the set. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. Structs \u00b6 AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import { AddDirectoryOptions } from 'cdk8s-plus-17' const addDirectoryOptions : AddDirectoryOptions = { ... } exclude Optional \u00b6 public readonly exclude : string []; Type: string [] Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public readonly keyPrefix : string ; Type: string Default: \u201c\u201d A prefix to add to all keys in the config map. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import { CommandProbeOptions } from 'cdk8s-plus-17' const commandProbeOptions : CommandProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import { ConfigMapProps } from 'cdk8s-plus-17' const configMapProps : ConfigMapProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import { ConfigMapVolumeOptions } from 'cdk8s-plus-17' const configMapVolumeOptions : ConfigMapVolumeOptions = { ... } defaultMode Optional \u00b6 public readonly defaultMode : number ; Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public readonly items : {[ key : string ] : PathMapping }; Type: {[ key: string ]: cdk8s-plus-17.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import { ContainerProps } from 'cdk8s-plus-17' const containerProps : ContainerProps = { ... } image Required \u00b6 public readonly image : string ; Type: string Docker image name. args Optional \u00b6 public readonly args : string []; Type: string [] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public readonly command : string []; Type: string [] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 public readonly env : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-17.EnvValue } Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 public readonly liveness : Probe ; Type: cdk8s-plus-17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public readonly name : string ; Type: string Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 public readonly port : number ; Type: number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 public readonly readiness : Probe ; Type: cdk8s-plus-17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 public readonly startup : Probe ; Type: cdk8s-plus-17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public readonly volumeMounts : VolumeMount []; Type: cdk8s-plus-17.VolumeMount [] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public readonly workingDir : string ; Type: string Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. DeploymentProps \u00b6 Properties for initialization of Deployment . Initializer \u00b6 import { DeploymentProps } from 'cdk8s-plus-17' const deploymentProps : DeploymentProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. defaultSelector Optional \u00b6 public readonly defaultSelector : boolean ; Type: boolean Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import { EmptyDirVolumeOptions } from 'cdk8s-plus-17' const emptyDirVolumeOptions : EmptyDirVolumeOptions = { ... } medium Optional \u00b6 public readonly medium : EmptyDirMedium ; Type: cdk8s-plus-17.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public readonly sizeLimit : Size ; Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import { EnvValueFromConfigMapOptions } from 'cdk8s-plus-17' const envValueFromConfigMapOptions : EnvValueFromConfigMapOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import { EnvValueFromProcessOptions } from 'cdk8s-plus-17' const envValueFromProcessOptions : EnvValueFromProcessOptions = { ... } required Optional \u00b6 public readonly required : boolean ; Type: boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import { EnvValueFromSecretOptions } from 'cdk8s-plus-17' const envValueFromSecretOptions : EnvValueFromSecretOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the Secret or its key must be defined. ExposeOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import { ExposeOptions } from 'cdk8s-plus-17' const exposeOptions : ExposeOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-17.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import { HttpGetProbeOptions } from 'cdk8s-plus-17' const httpGetProbeOptions : HttpGetProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import { IngressV1Beta1Props } from 'cdk8s-plus-17' const ingressV1Beta1Props : IngressV1Beta1Props = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public readonly defaultBackend : IngressV1Beta1Backend ; Type: cdk8s-plus-17.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public readonly rules : IngressV1Beta1Rule []; Type: cdk8s-plus-17.IngressV1Beta1Rule [] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public readonly tls : IngressV1Beta1Tls []; Type: cdk8s-plus-17.IngressV1Beta1Tls [] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import { IngressV1Beta1Rule } from 'cdk8s-plus-17' const ingressV1Beta1Rule : IngressV1Beta1Rule = { ... } backend Required \u00b6 public readonly backend : IngressV1Beta1Backend ; Type: cdk8s-plus-17.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public readonly host : string ; Type: string Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public readonly path : string ; Type: string Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import { IngressV1Beta1Tls } from 'cdk8s-plus-17' const ingressV1Beta1Tls : IngressV1Beta1Tls = { ... } hosts Optional \u00b6 public readonly hosts : string []; Type: string [] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-17.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for initialization of Job . Initializer \u00b6 import { JobProps } from 'cdk8s-plus-17' const jobProps : JobProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. MountOptions \u00b6 Options for mounts. Initializer \u00b6 import { MountOptions } from 'cdk8s-plus-17' const mountOptions : MountOptions = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import { PathMapping } from 'cdk8s-plus-17' const pathMapping : PathMapping = { ... } path Required \u00b6 public readonly path : string ; Type: string The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public readonly mode : number ; Type: number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PodProps \u00b6 Properties for initialization of Pod . Initializer \u00b6 import { PodProps } from 'cdk8s-plus-17' const podProps : PodProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSpecProps \u00b6 Properties of a PodSpec . Initializer \u00b6 import { PodSpecProps } from 'cdk8s-plus-17' const podSpecProps : PodSpecProps = { ... } containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Initializer \u00b6 import { PodTemplateProps } from 'cdk8s-plus-17' const podTemplateProps : PodTemplateProps = { ... } containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import { ProbeOptions } from 'cdk8s-plus-17' const probeOptions : ProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import { ResourceProps } from 'cdk8s-plus-17' const resourceProps : ResourceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. SecretProps \u00b6 Initializer \u00b6 import { SecretProps } from 'cdk8s-plus-17' const secretProps : SecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. stringData Optional \u00b6 public readonly stringData : {[ key : string ] : string }; Type: {[ key: string ]: string } stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public readonly type : string ; Type: string Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import { SecretValue } from 'cdk8s-plus-17' const secretValue : SecretValue = { ... } key Required \u00b6 public readonly key : string ; Type: string The JSON key. secret Required \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-17.ISecret The secret. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Initializer \u00b6 import { ServiceAccountProps } from 'cdk8s-plus-17' const serviceAccountProps : ServiceAccountProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-17.ISecret [] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import { ServiceIngressV1BetaBackendOptions } from 'cdk8s-plus-17' const serviceIngressV1BetaBackendOptions : ServiceIngressV1BetaBackendOptions = { ... } port Optional \u00b6 public readonly port : number ; Type: number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import { ServicePort } from 'cdk8s-plus-17' const servicePort : ServicePort = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public readonly port : number ; Type: number The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import { ServicePortOptions } from 'cdk8s-plus-17' const servicePortOptions : ServicePortOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import { ServiceProps } from 'cdk8s-plus-17' const serviceProps : ServiceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public readonly externalIPs : string []; Type: string [] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public readonly externalName : string ; Type: string Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public readonly loadBalancerSourceRanges : string []; Type: string [] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-17.ServicePort [] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-17.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import { StatefulSetProps } from 'cdk8s-plus-17' const statefulSetProps : StatefulSetProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 public readonly service : Service ; Type: cdk8s-plus-17.Service Service to associate with the statefulset. defaultSelector Optional \u00b6 public readonly defaultSelector : boolean ; Type: boolean Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . podManagementPolicy Optional \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-17.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import { VolumeMount } from 'cdk8s-plus-17' const volumeMount : VolumeMount = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. path Required \u00b6 public readonly path : string ; Type: string Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public readonly volume : Volume ; Type: cdk8s-plus-17.Volume The volume to mount. Classes \u00b6 Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import { Container } from 'cdk8s-plus-17' new Container ( props : ContainerProps ) props Required \u00b6 Type: cdk8s-plus-17.ContainerProps Methods \u00b6 addEnv \u00b6 public addEnv ( name : string , value : EnvValue ) name Required \u00b6 Type: string The variable name. value Required \u00b6 Type: cdk8s-plus-17.EnvValue The variable value. mount \u00b6 public mount ( path : string , volume : Volume , options? : MountOptions ) path Required \u00b6 Type: string The desired path in the container. volume Required \u00b6 Type: cdk8s-plus-17.Volume The volume to mount. options Optional \u00b6 Type: cdk8s-plus-17.MountOptions Properties \u00b6 env Required \u00b6 public readonly env : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-17.EnvValue } The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 public readonly image : string ; Type: string The container image. imagePullPolicy Required \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-17.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public readonly mounts : VolumeMount []; Type: cdk8s-plus-17.VolumeMount [] Volume mounts configured for this container. name Required \u00b6 public readonly name : string ; Type: string The name of the container. args Optional \u00b6 public readonly args : string []; Type: string [] Arguments to the entrypoint. command Optional \u00b6 public readonly command : string []; Type: string [] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 public readonly port : number ; Type: number The port this container exposes. workingDir Optional \u00b6 public readonly workingDir : string ; Type: string The working directory inside the container. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import { EnvValue } from 'cdk8s-plus-17' EnvValue . fromConfigMap ( configMap : IConfigMap , key : string , options? : EnvValueFromConfigMapOptions ) configMap Required \u00b6 Type: cdk8s-plus-17.IConfigMap The config map. key Required \u00b6 Type: string The key to extract the value from. options Optional \u00b6 Type: cdk8s-plus-17.EnvValueFromConfigMapOptions Additional options. fromProcess \u00b6 import { EnvValue } from 'cdk8s-plus-17' EnvValue . fromProcess ( key : string , options? : EnvValueFromProcessOptions ) key Required \u00b6 Type: string The key to read. options Optional \u00b6 Type: cdk8s-plus-17.EnvValueFromProcessOptions Additional options. fromSecretValue \u00b6 import { EnvValue } from 'cdk8s-plus-17' EnvValue . fromSecretValue ( secretValue : SecretValue , options? : EnvValueFromSecretOptions ) secretValue Required \u00b6 Type: cdk8s-plus-17.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: cdk8s-plus-17.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import { EnvValue } from 'cdk8s-plus-17' EnvValue . fromValue ( value : string ) value Required \u00b6 Type: string The value. Properties \u00b6 value Optional \u00b6 public readonly value : any ; Type: any valueFrom Optional \u00b6 public readonly valueFrom : any ; Type: any IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromService \u00b6 import { IngressV1Beta1Backend } from 'cdk8s-plus-17' IngressV1Beta1Backend . fromService ( service : Service , options? : ServiceIngressV1BetaBackendOptions ) service Required \u00b6 Type: cdk8s-plus-17.Service The service object. options Optional \u00b6 Type: cdk8s-plus-17.ServiceIngressV1BetaBackendOptions PodSpec \u00b6 Implements: cdk8s-plus-17.IPodSpec Provides read/write capabilities ontop of a PodSpecProps . Initializers \u00b6 import { PodSpec } from 'cdk8s-plus-17' new PodSpec ( props? : PodSpecProps ) props Optional \u00b6 Type: cdk8s-plus-17.PodSpecProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. PodTemplate \u00b6 Implements: cdk8s-plus-17.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Initializers \u00b6 import { PodTemplate } from 'cdk8s-plus-17' new PodTemplate ( props? : PodTemplateProps ) props Optional \u00b6 Type: cdk8s-plus-17.PodTemplateProps Properties \u00b6 podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializers \u00b6 import { Probe } from 'cdk8s-plus-17' new Probe () Static Functions \u00b6 fromCommand \u00b6 import { Probe } from 'cdk8s-plus-17' Probe . fromCommand ( command : string [], options? : CommandProbeOptions ) command Required \u00b6 Type: string [] The command to execute. options Optional \u00b6 Type: cdk8s-plus-17.CommandProbeOptions Options. fromHttpGet \u00b6 import { Probe } from 'cdk8s-plus-17' Probe . fromHttpGet ( path : string , options? : HttpGetProbeOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-17.HttpGetProbeOptions Options. Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializers \u00b6 import { Volume } from 'cdk8s-plus-17' new Volume ( name : string , config : any ) name Required \u00b6 Type: string config Required \u00b6 Type: any Static Functions \u00b6 fromConfigMap \u00b6 import { Volume } from 'cdk8s-plus-17' Volume . fromConfigMap ( configMap : IConfigMap , options? : ConfigMapVolumeOptions ) configMap Required \u00b6 Type: cdk8s-plus-17.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-17.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import { Volume } from 'cdk8s-plus-17' Volume . fromEmptyDir ( name : string , options? : EmptyDirVolumeOptions ) name Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-17.EmptyDirVolumeOptions Additional options. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string Protocols \u00b6 IConfigMap \u00b6 Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.ConfigMap , cdk8s-plus-17.IConfigMap Represents a config map. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IPodSpec \u00b6 Implemented By: cdk8s-plus-17.Deployment , cdk8s-plus-17.Job , cdk8s-plus-17.Pod , cdk8s-plus-17.PodSpec , cdk8s-plus-17.PodTemplate , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IPodSpec , cdk8s-plus-17.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps The container. addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume The volume. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. IPodTemplate \u00b6 Extends: cdk8s-plus-17.IPodSpec Implemented By: cdk8s-plus-17.Deployment , cdk8s-plus-17.Job , cdk8s-plus-17.PodTemplate , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. IResource \u00b6 Implemented By: cdk8s-plus-17.ConfigMap , cdk8s-plus-17.Deployment , cdk8s-plus-17.IngressV1Beta1 , cdk8s-plus-17.Job , cdk8s-plus-17.Pod , cdk8s-plus-17.Resource , cdk8s-plus-17.Secret , cdk8s-plus-17.Service , cdk8s-plus-17.ServiceAccount , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IConfigMap , cdk8s-plus-17.IResource , cdk8s-plus-17.ISecret , cdk8s-plus-17.IServiceAccount Represents a resource. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.Secret , cdk8s-plus-17.ISecret Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.ServiceAccount , cdk8s-plus-17.IServiceAccount Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. Enums \u00b6 EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"TypeScript"},{"location":"reference/cdk8s-plus-17/typescript/#cdk8s-plus-17-typescript","text":"","title":"cdk8s-plus-17 (TypeScript) "},{"location":"reference/cdk8s-plus-17/typescript/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-17/typescript/#configmap","text":"Implements: cdk8s-plus-17.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-17/typescript/#deployment","text":"Implements: cdk8s-plus-17.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-17/typescript/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-17/typescript/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-17/typescript/#job","text":"Implements: cdk8s-plus-17.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-17/typescript/#pod","text":"Implements: cdk8s-plus-17.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-17/typescript/#resource","text":"Implements: cdk8s-plus-17.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-17/typescript/#secret","text":"Implements: cdk8s-plus-17.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-17/typescript/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-17/typescript/#serviceaccount","text":"Implements: cdk8s-plus-17.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-17/typescript/#statefulset","text":"Implements: cdk8s-plus-17.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-17/typescript/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-17/typescript/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-17/typescript/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-17/typescript/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-17/typescript/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-17/typescript/#deploymentprops","text":"Properties for initialization of Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-17/typescript/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-17/typescript/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-17/typescript/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-17/typescript/#exposeoptions","text":"Options for exposing a deployment via a service.","title":"ExposeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-17/typescript/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-17/typescript/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-17/typescript/#jobprops","text":"Properties for initialization of Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-17/typescript/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-17/typescript/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-17/typescript/#podprops","text":"Properties for initialization of Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-17/typescript/#podspecprops","text":"Properties of a PodSpec .","title":"PodSpecProps "},{"location":"reference/cdk8s-plus-17/typescript/#podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec.","title":"PodTemplateProps "},{"location":"reference/cdk8s-plus-17/typescript/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-17/typescript/#secretprops","text":"","title":"SecretProps "},{"location":"reference/cdk8s-plus-17/typescript/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-17/typescript/#serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-17/typescript/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-17/typescript/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-17/typescript/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-17/typescript/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-17/typescript/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-17/typescript/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-17/typescript/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-17/typescript/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-17/typescript/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-17/typescript/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-17/typescript/#podspec","text":"Implements: cdk8s-plus-17.IPodSpec Provides read/write capabilities ontop of a PodSpecProps .","title":"PodSpec "},{"location":"reference/cdk8s-plus-17/typescript/#podtemplate","text":"Implements: cdk8s-plus-17.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps .","title":"PodTemplate "},{"location":"reference/cdk8s-plus-17/typescript/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-17/typescript/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-17/typescript/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-17/typescript/#iconfigmap","text":"Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.ConfigMap , cdk8s-plus-17.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-17/typescript/#ipodspec","text":"Implemented By: cdk8s-plus-17.Deployment , cdk8s-plus-17.Job , cdk8s-plus-17.Pod , cdk8s-plus-17.PodSpec , cdk8s-plus-17.PodTemplate , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IPodSpec , cdk8s-plus-17.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"IPodSpec "},{"location":"reference/cdk8s-plus-17/typescript/#ipodtemplate","text":"Extends: cdk8s-plus-17.IPodSpec Implemented By: cdk8s-plus-17.Deployment , cdk8s-plus-17.Job , cdk8s-plus-17.PodTemplate , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"IPodTemplate "},{"location":"reference/cdk8s-plus-17/typescript/#iresource","text":"Implemented By: cdk8s-plus-17.ConfigMap , cdk8s-plus-17.Deployment , cdk8s-plus-17.IngressV1Beta1 , cdk8s-plus-17.Job , cdk8s-plus-17.Pod , cdk8s-plus-17.Resource , cdk8s-plus-17.Secret , cdk8s-plus-17.Service , cdk8s-plus-17.ServiceAccount , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IConfigMap , cdk8s-plus-17.IResource , cdk8s-plus-17.ISecret , cdk8s-plus-17.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-17/typescript/#isecret","text":"Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.Secret , cdk8s-plus-17.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-17/typescript/#iserviceaccount","text":"Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.ServiceAccount , cdk8s-plus-17.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-17/typescript/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-17/typescript/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-17/typescript/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-17/typescript/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-17/typescript/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-17/typescript/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-17/typescript/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-17/typescript/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-20/go/","text":"cdk8s-plus-20 (Go) \u00b6 For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus20 .","title":"Go"},{"location":"reference/cdk8s-plus-20/go/#cdk8s-plus-20-go","text":"For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus20 .","title":"cdk8s-plus-20 (Go) "},{"location":"reference/cdk8s-plus-20/java/","text":"cdk8s-plus-20 (Java) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Initializers \u00b6 import org.cdk8s.plus20.AbstractPod ; AbstractPod . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps cont ) cont Required \u00b6 Type: org.cdk8s.plus20.ContainerProps addHostAlias \u00b6 public addHostAlias ( HostAlias hostAlias ) hostAlias Required \u00b6 Type: org.cdk8s.plus20.HostAlias addInitContainer \u00b6 public addInitContainer ( ContainerProps cont ) cont Required \u00b6 Type: org.cdk8s.plus20.ContainerProps addVolume \u00b6 public addVolume ( Volume vol ) vol Required \u00b6 Type: org.cdk8s.plus20.Volume Properties \u00b6 automountServiceAccountToken Required \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus20.Container > dns Required \u00b6 public PodDns getDns (); Type: org.cdk8s.plus20.PodDns hostAliases Required \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus20.HostAlias > initContainers Required \u00b6 public java . util . List < Container > getInitContainers (); Type: java.util.List< org.cdk8s.plus20.Container > securityContext Required \u00b6 public PodSecurityContext getSecurityContext (); Type: org.cdk8s.plus20.PodSecurityContext volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus20.DockerConfigSecret restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import org.cdk8s.plus20.AwsElasticBlockStorePersistentVolume ; AwsElasticBlockStorePersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . volumeId ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 Type: java.lang.String Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. volumeId Required \u00b6 public java . lang . String getVolumeId (); Type: java.lang.String Volume id of this volume. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import org.cdk8s.plus20.AzureDiskPersistentVolume ; AzureDiskPersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . diskName ( java . lang . String ) . diskUri ( java . lang . String ) // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 Type: java.lang.String The Name of the data disk in the blob storage. diskUri Required \u00b6 Type: java.lang.String The URI the data disk in the blob storage. cachingMode Optional \u00b6 Type: org.cdk8s.plus20.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: org.cdk8s.plus20.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. Properties \u00b6 azureKind Required \u00b6 public AzureDiskPersistentVolumeKind getAzureKind (); Type: org.cdk8s.plus20.AzureDiskPersistentVolumeKind Azure kind of this volume. cachingMode Required \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus20.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. diskName Required \u00b6 public java . lang . String getDiskName (); Type: java.lang.String Disk name of this volume. diskUri Required \u00b6 public java . lang . String getDiskUri (); Type: java.lang.String Disk URI of this volume. fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import org.cdk8s.plus20.BasicAuthSecret ; BasicAuthSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . password ( java . lang . String ) . username ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 Type: java.lang.String The password or token for authentication. username Required \u00b6 Type: java.lang.String The user name for authentication. ClusterRole \u00b6 Implements: org.cdk8s.plus20.IClusterRole , org.cdk8s.plus20.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import org.cdk8s.plus20.ClusterRole ; ClusterRole . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .aggregationLabels(java.util.Map<java.lang.String, java.lang.String>) // .rules(java.util.List<ClusterRolePolicyRule>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 Type: java.util.Map java.lang.String > Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ClusterRolePolicyRule > Default: [] A list of rules the role should allow. Methods \u00b6 aggregate \u00b6 public aggregate ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String allow \u00b6 public allow ( java . util . List < java . lang . String > verbs , IApiEndpoint endpoints ) verbs Required \u00b6 Type: java.util.List< java.lang.String > endpoints Required \u00b6 Type: org.cdk8s.plus20.IApiEndpoint The endpoints(s) to apply to. allowCreate \u00b6 public allowCreate ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus20.IApiEndpoint The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus20.IApiEndpoint The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus20.IApiEndpoint The resource(s) to apply to. allowGet \u00b6 public allowGet ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus20.IApiEndpoint The resource(s) to apply to. allowList \u00b6 public allowList ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus20.IApiEndpoint The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus20.IApiEndpoint The resource(s) to apply to. allowRead \u00b6 public allowRead ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus20.IApiEndpoint The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus20.IApiEndpoint The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus20.IApiEndpoint The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus20.IApiEndpoint The resource(s) to apply to. bind \u00b6 public bind ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus20.ISubject a list of subjects to bind to. bindInNamespace \u00b6 public bindInNamespace ( java . lang . String namespace , ISubject subjects ) namespace Required \u00b6 Type: java.lang.String the namespace to limit permissions to. subjects Required \u00b6 Type: org.cdk8s.plus20.ISubject a list of subjects to bind to. combine \u00b6 public combine ( ClusterRole rol ) rol Required \u00b6 Type: org.cdk8s.plus20.ClusterRole Static Functions \u00b6 fromClusterRoleName \u00b6 import org.cdk8s.plus20.ClusterRole ; ClusterRole . fromClusterRoleName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the role resource. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public java . util . List < ClusterRolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus20.ClusterRolePolicyRule > Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import org.cdk8s.plus20.ClusterRoleBinding ; ClusterRoleBinding . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) . role ( IClusterRole ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: org.cdk8s.plus20.IClusterRole The role to bind to. Methods \u00b6 addSubjects \u00b6 public addSubjects ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus20.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public IClusterRole getRole (); Type: org.cdk8s.plus20.IClusterRole subjects Required \u00b6 public java . util . List < ISubject > getSubjects (); Type: java.util.List< org.cdk8s.plus20.ISubject > ConfigMap \u00b6 Implements: org.cdk8s.plus20.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import org.cdk8s.plus20.ConfigMap ; ConfigMap . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) // .immutable(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addData \u00b6 public addData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addDirectory \u00b6 public addDirectory ( java . lang . String localDir ) public addDirectory ( java . lang . String localDir , AddDirectoryOptions options ) localDir Required \u00b6 Type: java.lang.String A path to a local directory. options Optional \u00b6 Type: org.cdk8s.plus20.AddDirectoryOptions Options. addFile \u00b6 public addFile ( java . lang . String localFile ) public addFile ( java . lang . String localFile , java . lang . String key ) localFile Required \u00b6 Type: java.lang.String The path to the local file. key Optional \u00b6 Type: java.lang.String The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import org.cdk8s.plus20.ConfigMap ; ConfigMap . fromConfigMapName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the config map to import. Properties \u00b6 binaryData Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Whether or not this config map is immutable. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import org.cdk8s.plus20.DaemonSet ; DaemonSet . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .minReadySeconds(java.lang.Number) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReadySeconds Optional \u00b6 Type: java.lang.Number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Properties \u00b6 minReadySeconds Required \u00b6 public java . lang . Number getMinReadySeconds (); Type: java.lang.Number resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import org.cdk8s.plus20.Deployment ; Deployment . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .minReady(Duration) // .progressDeadline(Duration) // .replicas(java.lang.Number) // .strategy(DeploymentStrategy) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReady Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 Type: org.cdk8s.plus20.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. Methods \u00b6 exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeDeploymentViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The ingress path to register under. options Optional \u00b6 Type: org.cdk8s.plus20.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService () public exposeViaService ( ExposeDeploymentViaServiceOptions options ) options Optional \u00b6 Type: org.cdk8s.plus20.ExposeDeploymentViaServiceOptions Options to determine details of the service and port exposed. Properties \u00b6 minReady Required \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progressDeadline Required \u00b6 public Duration getProgressDeadline (); Type: org.cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public DeploymentStrategy getStrategy (); Type: org.cdk8s.plus20.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import org.cdk8s.plus20.DockerConfigSecret ; DockerConfigSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . data ( java . util . Map < java . lang . String , java . lang . Object > ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 Type: java.util.Map java.lang.Object > JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import org.cdk8s.plus20.GCEPersistentDiskPersistentVolume ; GCEPersistentDiskPersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . pdName ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 Type: java.lang.String Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. pdName Required \u00b6 public java . lang . String getPdName (); Type: java.lang.String PD resource in GCE of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Partition of this volume. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import org.cdk8s.plus20.IngressV1Beta1 ; IngressV1Beta1 . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .defaultBackend(IngressV1Beta1Backend) // .rules(java.util.List<IngressV1Beta1Rule>) // .tls(java.util.List<IngressV1Beta1Tls>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 Type: org.cdk8s.plus20.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.IngressV1Beta1Rule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.IngressV1Beta1Tls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( IngressV1Beta1Backend backend ) backend Required \u00b6 Type: org.cdk8s.plus20.IngressV1Beta1Backend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( java . lang . String host , IngressV1Beta1Backend backend ) host Required \u00b6 Type: java.lang.String The host name to match. backend Required \u00b6 Type: org.cdk8s.plus20.IngressV1Beta1Backend The backend to route to. addHostRule \u00b6 public addHostRule ( java . lang . String host , java . lang . String path , IngressV1Beta1Backend backend ) host Required \u00b6 Type: java.lang.String The host name. path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus20.IngressV1Beta1Backend The backend to route requests to. addRule \u00b6 public addRule ( java . lang . String path , IngressV1Beta1Backend backend ) path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus20.IngressV1Beta1Backend The backend to route requests to. addRules \u00b6 public addRules ( IngressV1Beta1Rule rules ) rules Required \u00b6 Type: org.cdk8s.plus20.IngressV1Beta1Rule The rules to add. addTls \u00b6 public addTls ( java . util . List < IngressV1Beta1Tls > tls ) tls Required \u00b6 Type: java.util.List< org.cdk8s.plus20.IngressV1Beta1Tls > Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import org.cdk8s.plus20.Job ; Job . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. activeDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Number of retries before marking failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration TTL before the job is deleted after it is finished. PersistentVolume \u00b6 Implements: org.cdk8s.plus20.IPersistentVolume , org.cdk8s.plus20.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import org.cdk8s.plus20.PersistentVolume ; PersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 asVolume \u00b6 public asVolume () bind \u00b6 public bind ( IPersistentVolumeClaim claim ) claim Required \u00b6 Type: org.cdk8s.plus20.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 public reserve () Static Functions \u00b6 fromPersistentVolumeName \u00b6 import org.cdk8s.plus20.PersistentVolume ; PersistentVolume . fromPersistentVolumeName ( java . lang . String volumeName ) volumeName Required \u00b6 Type: java.lang.String The name of the pv to reference. Properties \u00b6 mode Required \u00b6 public PersistentVolumeMode getMode (); Type: org.cdk8s.plus20.PersistentVolumeMode Volume mode of this volume. reclaimPolicy Required \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus20.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus20.PersistentVolumeAccessMode > Access modes requirement of this claim. claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus20.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Mount options of this volume. storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Storage size of this volume. storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: org.cdk8s.plus20.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import org.cdk8s.plus20.PersistentVolumeClaim ; PersistentVolumeClaim . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .storage(Size) // .storageClassName(java.lang.String) // .volume(IPersistentVolume) // .volumeMode(PersistentVolumeMode) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.PersistentVolumeAccessMode > Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 Type: org.cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 Type: org.cdk8s.plus20.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 Type: org.cdk8s.plus20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 bind \u00b6 public bind ( IPersistentVolume vol ) vol Required \u00b6 Type: org.cdk8s.plus20.IPersistentVolume The PV to bind to. Static Functions \u00b6 fromClaimName \u00b6 import org.cdk8s.plus20.PersistentVolumeClaim ; PersistentVolumeClaim . fromClaimName ( java . lang . String claimName ) claimName Required \u00b6 Type: java.lang.String The name of the pvc to reference. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. volumeMode Required \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus20.PersistentVolumeMode Volume mode requirement of this claim. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus20.PersistentVolumeAccessMode > Access modes requirement of this claim. storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Storage requirement of this claim. storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Storage class requirment of this claim. volume Optional \u00b6 public IPersistentVolume getVolume (); Type: org.cdk8s.plus20.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import org.cdk8s.plus20.Pod ; Pod . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Resource \u00b6 Implements: org.cdk8s.plus20.IResource , org.cdk8s.plus20.IApiResource , org.cdk8s.plus20.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import org.cdk8s.plus20.Resource ; Resource . Builder . create ( Construct scope , java . lang . String id ) // .nodeFactory(INodeFactory) . build (); scope Required \u00b6 Type: software.constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: java.lang.String The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . nodeFactory Optional \u00b6 Type: software.constructs.INodeFactory Default: the default Node is associated A factory for attaching Node s to the construct. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 public ApiObjectMetadataDefinition getMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this API object. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. resourceName Optional \u00b6 public java . lang . String getResourceName (); Type: java.lang.String The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: org.cdk8s.plus20.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import org.cdk8s.plus20.Role ; Role . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .rules(java.util.List<RolePolicyRule>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.RolePolicyRule > Default: [] A list of rules the role should allow. Methods \u00b6 allow \u00b6 public allow ( java . util . List < java . lang . String > verbs , IApiResource resources ) verbs Required \u00b6 Type: java.util.List< java.lang.String > resources Required \u00b6 Type: org.cdk8s.plus20.IApiResource The resource(s) to apply to. allowCreate \u00b6 public allowCreate ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus20.IApiResource The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus20.IApiResource The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus20.IApiResource The resource(s) to apply to. allowGet \u00b6 public allowGet ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus20.IApiResource The resource(s) to apply to. allowList \u00b6 public allowList ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus20.IApiResource The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus20.IApiResource The resource(s) to apply to. allowRead \u00b6 public allowRead ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus20.IApiResource The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus20.IApiResource The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus20.IApiResource The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus20.IApiResource The resource(s) to apply to. bind \u00b6 public bind ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus20.ISubject a list of subjects to bind to. Static Functions \u00b6 fromRoleName \u00b6 import org.cdk8s.plus20.Role ; Role . fromRoleName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the role resource. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public java . util . List < RolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus20.RolePolicyRule > Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import org.cdk8s.plus20.RoleBinding ; RoleBinding . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) . role ( IRole ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: org.cdk8s.plus20.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. Methods \u00b6 addSubjects \u00b6 public addSubjects ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus20.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public IRole getRole (); Type: org.cdk8s.plus20.IRole subjects Required \u00b6 public java . util . List < ISubject > getSubjects (); Type: java.util.List< org.cdk8s.plus20.ISubject > Secret \u00b6 Implements: org.cdk8s.plus20.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import org.cdk8s.plus20.Secret ; Secret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 addStringData \u00b6 public addStringData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String Key. value Required \u00b6 Type: java.lang.String Value. getStringData \u00b6 public getStringData ( java . lang . String key ) key Required \u00b6 Type: java.lang.String Key. Static Functions \u00b6 fromSecretName \u00b6 import org.cdk8s.plus20.Secret ; Secret . fromSecretName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the secret to reference. Properties \u00b6 immutable Required \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Whether or not the secret is immutable. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import org.cdk8s.plus20.Service ; Service . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .type(ServiceType) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ServicePort > The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: org.cdk8s.plus20.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 addDeployment \u00b6 public addDeployment ( Deployment depl ) public addDeployment ( Deployment depl , AddDeploymentOptions options ) depl Required \u00b6 Type: org.cdk8s.plus20.Deployment The deployment to expose. options Optional \u00b6 Type: org.cdk8s.plus20.AddDeploymentOptions Optional settings for the port. addSelector \u00b6 public addSelector ( java . lang . String label , java . lang . String value ) label Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeServiceViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The path to expose the service under. options Optional \u00b6 Type: org.cdk8s.plus20.ExposeServiceViaIngressOptions Additional options. serve \u00b6 public serve ( java . lang . Number port ) public serve ( java . lang . Number port , ServicePortOptions options ) port Required \u00b6 Type: java.lang.Number The port definition. options Optional \u00b6 Type: org.cdk8s.plus20.ServicePortOptions Properties \u00b6 ports Required \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus20.ServicePort > Ports for this service. Use serve() to expose additional service ports. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. selector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getSelector (); Type: java.util.Map java.lang.String > Returns the labels which are used to select pods for this service. type Required \u00b6 public ServiceType getType (); Type: org.cdk8s.plus20.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: org.cdk8s.plus20.IServiceAccount , org.cdk8s.plus20.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import org.cdk8s.plus20.ServiceAccount ; ServiceAccount . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountToken(java.lang.Boolean) // .secrets(java.util.List<ISecret>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 addSecret \u00b6 public addSecret ( ISecret secr ) secr Required \u00b6 Type: org.cdk8s.plus20.ISecret The secret. Static Functions \u00b6 fromServiceAccountName \u00b6 import org.cdk8s.plus20.ServiceAccount ; ServiceAccount . fromServiceAccountName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the service account resource. Properties \u00b6 automountToken Required \u00b6 public java . lang . Boolean getAutomountToken (); Type: java.lang.Boolean Whether or not a token is automatically mounted for this service account. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus20.ISecret > List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import org.cdk8s.plus20.ServiceAccountTokenSecret ; ServiceAccountTokenSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . serviceAccount ( IServiceAccount ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 Type: org.cdk8s.plus20.IServiceAccount The service account to store a secret for. SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import org.cdk8s.plus20.SshAuthSecret ; SshAuthSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . sshPrivateKey ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 Type: java.lang.String The SSH private key to use. StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import org.cdk8s.plus20.StatefulSet ; StatefulSet . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) . service ( Service ) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) // .strategy(StatefulSetUpdateStrategy) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. service Required \u00b6 Type: org.cdk8s.plus20.Service Service to associate with the statefulset. podManagementPolicy Optional \u00b6 Type: org.cdk8s.plus20.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 Type: org.cdk8s.plus20.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. Properties \u00b6 podManagementPolicy Required \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus20.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public StatefulSetUpdateStrategy getStrategy (); Type: org.cdk8s.plus20.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import org.cdk8s.plus20.TlsSecret ; TlsSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . tlsCert ( java . lang . String ) . tlsKey ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 Type: java.lang.String The TLS cert. tlsKey Required \u00b6 Type: java.lang.String The TLS key. Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import org.cdk8s.plus20.Workload ; Workload . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. Methods \u00b6 select \u00b6 public select ( LabelSelector selectors ) selectors Required \u00b6 Type: org.cdk8s.plus20.LabelSelector Properties \u00b6 matchExpressions Required \u00b6 public java . util . List < LabelSelectorRequirement > getMatchExpressions (); Type: java.util.List< org.cdk8s.plus20.LabelSelectorRequirement > The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. matchLabels Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getMatchLabels (); Type: java.util.Map java.lang.String > The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import org.cdk8s.plus20.AbstractPodProps ; AbstractPodProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus20.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import org.cdk8s.plus20.AddDeploymentOptions ; AddDeploymentOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) // .port(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import org.cdk8s.plus20.AddDirectoryOptions ; AddDirectoryOptions . builder () // .exclude(java.util.List<java.lang.String>) // .keyPrefix(java.lang.String) . build (); exclude Optional \u00b6 public java . util . List < java . lang . String > getExclude (); Type: java.util.List< java.lang.String > Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public java . lang . String getKeyPrefix (); Type: java.lang.String Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import org.cdk8s.plus20.ApiResourceOptions ; ApiResourceOptions . builder () . apiGroup ( java . lang . String ) . resourceType ( java . lang . String ) . build (); apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import org.cdk8s.plus20.AwsElasticBlockStorePersistentVolumeProps ; AwsElasticBlockStorePersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . volumeId ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus20.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 public java . lang . String getVolumeId (); Type: java.lang.String Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import org.cdk8s.plus20.AwsElasticBlockStoreVolumeOptions ; AwsElasticBlockStoreVolumeOptions . builder () // .fsType(java.lang.String) // .name(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import org.cdk8s.plus20.AzureDiskPersistentVolumeProps ; AzureDiskPersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . diskName ( java . lang . String ) . diskUri ( java . lang . String ) // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus20.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 public java . lang . String getDiskName (); Type: java.lang.String The Name of the data disk in the blob storage. diskUri Required \u00b6 public java . lang . String getDiskUri (); Type: java.lang.String The URI the data disk in the blob storage. cachingMode Optional \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus20.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public AzureDiskPersistentVolumeKind getKind (); Type: org.cdk8s.plus20.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import org.cdk8s.plus20.AzureDiskVolumeOptions ; AzureDiskVolumeOptions . builder () // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .name(java.lang.String) // .readOnly(java.lang.Boolean) . build (); cachingMode Optional \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus20.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public AzureDiskPersistentVolumeKind getKind (); Type: org.cdk8s.plus20.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import org.cdk8s.plus20.BasicAuthSecretProps ; BasicAuthSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . password ( java . lang . String ) . username ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 public java . lang . String getPassword (); Type: java.lang.String The password or token for authentication. username Required \u00b6 public java . lang . String getUsername (); Type: java.lang.String The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import org.cdk8s.plus20.ClusterRoleBindingProps ; ClusterRoleBindingProps . builder () // .metadata(ApiObjectMetadata) . role ( IClusterRole ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public IClusterRole getRole (); Type: org.cdk8s.plus20.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import org.cdk8s.plus20.ClusterRolePolicyRule ; ClusterRolePolicyRule . builder () . endpoints ( java . util . List < IApiEndpoint > ) . verbs ( java . util . List < java . lang . String > ) . build (); endpoints Required \u00b6 public java . util . List < IApiEndpoint > getEndpoints (); Type: java.util.List< org.cdk8s.plus20.IApiEndpoint > Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 public java . util . List < java . lang . String > getVerbs (); Type: java.util.List< java.lang.String > Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import org.cdk8s.plus20.ClusterRoleProps ; ClusterRoleProps . builder () // .metadata(ApiObjectMetadata) // .aggregationLabels(java.util.Map<java.lang.String, java.lang.String>) // .rules(java.util.List<ClusterRolePolicyRule>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getAggregationLabels (); Type: java.util.Map java.lang.String > Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 public java . util . List < ClusterRolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus20.ClusterRolePolicyRule > Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import org.cdk8s.plus20.CommandProbeOptions ; CommandProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import org.cdk8s.plus20.CommonSecretProps ; CommonSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import org.cdk8s.plus20.ConfigMapProps ; ConfigMapProps . builder () // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) // .immutable(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import org.cdk8s.plus20.ConfigMapVolumeOptions ; ConfigMapVolumeOptions . builder () // .defaultMode(java.lang.Number) // .items(java.util.Map<java.lang.String, PathMapping>) // .name(java.lang.String) // .optional(java.lang.Boolean) . build (); defaultMode Optional \u00b6 public java . lang . Number getDefaultMode (); Type: java.lang.Number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public java . util . Map < java . lang . String , PathMapping > getItems (); Type: java.util.Map \u0002klzzwxh:8312\u0003 > Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import org.cdk8s.plus20.ContainerLifecycle ; ContainerLifecycle . builder () // .postStart(Handler) // .preStop(Handler) . build (); postStart Optional \u00b6 public Handler getPostStart (); Type: org.cdk8s.plus20.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. preStop Optional \u00b6 public Handler getPreStop (); Type: org.cdk8s.plus20.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import org.cdk8s.plus20.ContainerProps ; ContainerProps . builder () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .env(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .lifecycle(ContainerLifecycle) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .readiness(Probe) // .resources(ContainerResources) // .securityContext(ContainerSecurityContextProps) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String Docker image name. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnv (); Type: java.util.Map \u0002klzzwxh:8285\u0003 > Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 public ContainerLifecycle getLifecycle (); Type: org.cdk8s.plus20.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 public Probe getLiveness (); Type: org.cdk8s.plus20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 public Probe getReadiness (); Type: org.cdk8s.plus20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 public ContainerResources getResources (); Type: org.cdk8s.plus20.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 public ContainerSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus20.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 public Probe getStartup (); Type: org.cdk8s.plus20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public java . util . List < VolumeMount > getVolumeMounts (); Type: java.util.List< org.cdk8s.plus20.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import org.cdk8s.plus20.ContainerResources ; ContainerResources . builder () . cpu ( CpuResources ) . memory ( MemoryResources ) . build (); cpu Required \u00b6 public CpuResources getCpu (); Type: org.cdk8s.plus20.CpuResources memory Required \u00b6 public MemoryResources getMemory (); Type: org.cdk8s.plus20.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import org.cdk8s.plus20.ContainerSecurityContextProps ; ContainerSecurityContextProps . builder () // .ensureNonRoot(java.lang.Boolean) // .group(java.lang.Number) // .privileged(java.lang.Boolean) // .readOnlyRootFilesystem(java.lang.Boolean) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. privileged Optional \u00b6 public java . lang . Boolean getPrivileged (); Type: java.lang.Boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 public java . lang . Boolean getReadOnlyRootFilesystem (); Type: java.lang.Boolean Default: false Whether this container has a read-only root filesystem. user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import org.cdk8s.plus20.CpuResources ; CpuResources . builder () . limit ( Cpu ) . request ( Cpu ) . build (); limit Required \u00b6 public Cpu getLimit (); Type: org.cdk8s.plus20.Cpu request Required \u00b6 public Cpu getRequest (); Type: org.cdk8s.plus20.Cpu DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import org.cdk8s.plus20.DaemonSetProps ; DaemonSetProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .minReadySeconds(java.lang.Number) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus20.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReadySeconds Optional \u00b6 public java . lang . Number getMinReadySeconds (); Type: java.lang.Number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import org.cdk8s.plus20.DeploymentProps ; DeploymentProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .minReady(Duration) // .progressDeadline(Duration) // .replicas(java.lang.Number) // .strategy(DeploymentStrategy) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus20.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReady Optional \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 public Duration getProgressDeadline (); Type: org.cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 public DeploymentStrategy getStrategy (); Type: org.cdk8s.plus20.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import org.cdk8s.plus20.DeploymentStrategyRollingUpdateOptions ; DeploymentStrategyRollingUpdateOptions . builder () // .maxSurge(PercentOrAbsolute) // .maxUnavailable(PercentOrAbsolute) . build (); maxSurge Optional \u00b6 public PercentOrAbsolute getMaxSurge (); Type: org.cdk8s.plus20.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. maxUnavailable Optional \u00b6 public PercentOrAbsolute getMaxUnavailable (); Type: org.cdk8s.plus20.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import org.cdk8s.plus20.DnsOption ; DnsOption . builder () . name ( java . lang . String ) // .value(java.lang.String) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Option name. value Optional \u00b6 public java . lang . String getValue (); Type: java.lang.String Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import org.cdk8s.plus20.DockerConfigSecretProps ; DockerConfigSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . data ( java . util . Map < java . lang . String , java . lang . Object > ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 public java . util . Map < java . lang . String , java . lang . Object > getData (); Type: java.util.Map java.lang.Object > JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import org.cdk8s.plus20.EmptyDirVolumeOptions ; EmptyDirVolumeOptions . builder () // .medium(EmptyDirMedium) // .sizeLimit(Size) . build (); medium Optional \u00b6 public EmptyDirMedium getMedium (); Type: org.cdk8s.plus20.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public Size getSizeLimit (); Type: org.cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import org.cdk8s.plus20.EnvValueFromConfigMapOptions ; EnvValueFromConfigMapOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import org.cdk8s.plus20.EnvValueFromFieldRefOptions ; EnvValueFromFieldRefOptions . builder () // .apiVersion(java.lang.String) // .key(java.lang.String) . build (); apiVersion Optional \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String Version of the schema the FieldPath is written in terms of. key Optional \u00b6 public java . lang . String getKey (); Type: java.lang.String The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import org.cdk8s.plus20.EnvValueFromProcessOptions ; EnvValueFromProcessOptions . builder () // .required(java.lang.Boolean) . build (); required Optional \u00b6 public java . lang . Boolean getRequired (); Type: java.lang.Boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import org.cdk8s.plus20.EnvValueFromResourceOptions ; EnvValueFromResourceOptions . builder () // .container(Container) // .divisor(java.lang.String) . build (); container Optional \u00b6 public Container getContainer (); Type: org.cdk8s.plus20.Container The container to select the value from. divisor Optional \u00b6 public java . lang . String getDivisor (); Type: java.lang.String The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import org.cdk8s.plus20.EnvValueFromSecretOptions ; EnvValueFromSecretOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import org.cdk8s.plus20.ExposeDeploymentViaIngressOptions ; ExposeDeploymentViaIngressOptions . builder () // .name(java.lang.String) // .port(java.lang.Number) // .protocol(Protocol) // .serviceType(ServiceType) // .targetPort(java.lang.Number) // .ingress(IngressV1Beta1) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus20.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 public IngressV1Beta1 getIngress (); Type: org.cdk8s.plus20.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import org.cdk8s.plus20.ExposeDeploymentViaServiceOptions ; ExposeDeploymentViaServiceOptions . builder () // .name(java.lang.String) // .port(java.lang.Number) // .protocol(Protocol) // .serviceType(ServiceType) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus20.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import org.cdk8s.plus20.ExposeServiceViaIngressOptions ; ExposeServiceViaIngressOptions . builder () // .ingress(IngressV1Beta1) . build (); ingress Optional \u00b6 public IngressV1Beta1 getIngress (); Type: org.cdk8s.plus20.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import org.cdk8s.plus20.GCEPersistentDiskPersistentVolumeProps ; GCEPersistentDiskPersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . pdName ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus20.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 public java . lang . String getPdName (); Type: java.lang.String Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import org.cdk8s.plus20.GCEPersistentDiskVolumeOptions ; GCEPersistentDiskVolumeOptions . builder () // .fsType(java.lang.String) // .name(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GroupProps \u00b6 Properties for Group . Initializer \u00b6 import org.cdk8s.plus20.GroupProps ; GroupProps . builder () . name ( java . lang . String ) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the group. HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import org.cdk8s.plus20.HandlerFromHttpGetOptions ; HandlerFromHttpGetOptions . builder () // .port(java.lang.Number) . build (); port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import org.cdk8s.plus20.HandlerFromTcpSocketOptions ; HandlerFromTcpSocketOptions . builder () // .host(java.lang.String) // .port(java.lang.Number) . build (); host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import org.cdk8s.plus20.HostAlias ; HostAlias . builder () . hostnames ( java . util . List < java . lang . String > ) . ip ( java . lang . String ) . build (); hostnames Required \u00b6 public java . util . List < java . lang . String > getHostnames (); Type: java.util.List< java.lang.String > Hostnames for the chosen IP address. ip Required \u00b6 public java . lang . String getIp (); Type: java.lang.String IP address of the host file entry. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import org.cdk8s.plus20.HttpGetProbeOptions ; HttpGetProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) // .port(java.lang.Number) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import org.cdk8s.plus20.IngressV1Beta1Props ; IngressV1Beta1Props . builder () // .metadata(ApiObjectMetadata) // .defaultBackend(IngressV1Beta1Backend) // .rules(java.util.List<IngressV1Beta1Rule>) // .tls(java.util.List<IngressV1Beta1Tls>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public IngressV1Beta1Backend getDefaultBackend (); Type: org.cdk8s.plus20.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public java . util . List < IngressV1Beta1Rule > getRules (); Type: java.util.List< org.cdk8s.plus20.IngressV1Beta1Rule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public java . util . List < IngressV1Beta1Tls > getTls (); Type: java.util.List< org.cdk8s.plus20.IngressV1Beta1Tls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import org.cdk8s.plus20.IngressV1Beta1Rule ; IngressV1Beta1Rule . builder () . backend ( IngressV1Beta1Backend ) // .host(java.lang.String) // .path(java.lang.String) . build (); backend Required \u00b6 public IngressV1Beta1Backend getBackend (); Type: org.cdk8s.plus20.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public java . lang . String getPath (); Type: java.lang.String Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import org.cdk8s.plus20.IngressV1Beta1Tls ; IngressV1Beta1Tls . builder () // .hosts(java.util.List<java.lang.String>) // .secret(ISecret) . build (); hosts Optional \u00b6 public java . util . List < java . lang . String > getHosts (); Type: java.util.List< java.lang.String > Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus20.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import org.cdk8s.plus20.JobProps ; JobProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus20.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import org.cdk8s.plus20.LabelSelectorRequirement ; LabelSelectorRequirement . builder () . key ( java . lang . String ) . operator ( LabelSelectorRequirementOperator ) // .values(java.util.List<java.lang.String>) . build (); key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String The label key that the selector applies to. operator Required \u00b6 public LabelSelectorRequirementOperator getOperator (); Type: org.cdk8s.plus20.LabelSelectorRequirementOperator Represents a key\u2019s relationship to a set of values. values Optional \u00b6 public java . util . List < java . lang . String > getValues (); Type: java.util.List< java.lang.String > An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import org.cdk8s.plus20.MemoryResources ; MemoryResources . builder () . limit ( Size ) . request ( Size ) . build (); limit Required \u00b6 public Size getLimit (); Type: org.cdk8s.Size request Required \u00b6 public Size getRequest (); Type: org.cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import org.cdk8s.plus20.MountOptions ; MountOptions . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus20.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import org.cdk8s.plus20.PathMapping ; PathMapping . builder () . path ( java . lang . String ) // .mode(java.lang.Number) . build (); path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public java . lang . Number getMode (); Type: java.lang.Number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import org.cdk8s.plus20.PersistentVolumeClaimProps ; PersistentVolumeClaimProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .storage(Size) // .storageClassName(java.lang.String) // .volume(IPersistentVolume) // .volumeMode(PersistentVolumeMode) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus20.PersistentVolumeAccessMode > Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 public IPersistentVolume getVolume (); Type: org.cdk8s.plus20.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import org.cdk8s.plus20.PersistentVolumeClaimVolumeOptions ; PersistentVolumeClaimVolumeOptions . builder () // .name(java.lang.String) // .readOnly(java.lang.Boolean) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: Derived from the PVC name. The volume name. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import org.cdk8s.plus20.PersistentVolumeProps ; PersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus20.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import org.cdk8s.plus20.PodDnsProps ; PodDnsProps . builder () // .hostname(java.lang.String) // .hostnameAsFQDN(java.lang.Boolean) // .nameservers(java.util.List<java.lang.String>) // .options(java.util.List<DnsOption>) // .policy(DnsPolicy) // .searches(java.util.List<java.lang.String>) // .subdomain(java.lang.String) . build (); hostname Optional \u00b6 public java . lang . String getHostname (); Type: java.lang.String Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 public java . lang . Boolean getHostnameAsFQDN (); Type: java.lang.Boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 public java . util . List < java . lang . String > getNameservers (); Type: java.util.List< java.lang.String > A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 public java . util . List < DnsOption > getOptions (); Type: java.util.List< org.cdk8s.plus20.DnsOption > List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 public DnsPolicy getPolicy (); Type: org.cdk8s.plus20.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 public java . util . List < java . lang . String > getSearches (); Type: java.util.List< java.lang.String > A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 public java . lang . String getSubdomain (); Type: java.lang.String Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import org.cdk8s.plus20.PodProps ; PodProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus20.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import org.cdk8s.plus20.PodSecurityContextProps ; PodSecurityContextProps . builder () // .ensureNonRoot(java.lang.Boolean) // .fsGroup(java.lang.Number) // .fsGroupChangePolicy(FsGroupChangePolicy) // .group(java.lang.Number) // .sysctls(java.util.List<Sysctl>) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 public java . lang . Number getFsGroup (); Type: java.lang.Number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 public FsGroupChangePolicy getFsGroupChangePolicy (); Type: org.cdk8s.plus20.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 public java . util . List < Sysctl > getSysctls (); Type: java.util.List< org.cdk8s.plus20.Sysctl > Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import org.cdk8s.plus20.ProbeOptions ; ProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import org.cdk8s.plus20.ResourceProps ; ResourceProps . builder () // .metadata(ApiObjectMetadata) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import org.cdk8s.plus20.RoleBindingProps ; RoleBindingProps . builder () // .metadata(ApiObjectMetadata) . role ( IRole ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public IRole getRole (); Type: org.cdk8s.plus20.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import org.cdk8s.plus20.RolePolicyRule ; RolePolicyRule . builder () . resources ( java . util . List < IApiResource > ) . verbs ( java . util . List < java . lang . String > ) . build (); resources Required \u00b6 public java . util . List < IApiResource > getResources (); Type: java.util.List< org.cdk8s.plus20.IApiResource > Resources this rule applies to. verbs Required \u00b6 public java . util . List < java . lang . String > getVerbs (); Type: java.util.List< java.lang.String > Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import org.cdk8s.plus20.RoleProps ; RoleProps . builder () // .metadata(ApiObjectMetadata) // .rules(java.util.List<RolePolicyRule>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 public java . util . List < RolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus20.RolePolicyRule > Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import org.cdk8s.plus20.SecretProps ; SecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getStringData (); Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public java . lang . String getType (); Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import org.cdk8s.plus20.SecretValue ; SecretValue . builder () . key ( java . lang . String ) . secret ( ISecret ) . build (); key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String The JSON key. secret Required \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus20.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import org.cdk8s.plus20.SecretVolumeOptions ; SecretVolumeOptions . builder () // .defaultMode(java.lang.Number) // .items(java.util.Map<java.lang.String, PathMapping>) // .name(java.lang.String) // .optional(java.lang.Boolean) . build (); defaultMode Optional \u00b6 public java . lang . Number getDefaultMode (); Type: java.lang.Number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public java . util . Map < java . lang . String , PathMapping > getItems (); Type: java.util.Map \u0002klzzwxh:7609\u0003 > Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import org.cdk8s.plus20.ServiceAccountProps ; ServiceAccountProps . builder () // .metadata(ApiObjectMetadata) // .automountToken(java.lang.Boolean) // .secrets(java.util.List<ISecret>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 public java . lang . Boolean getAutomountToken (); Type: java.lang.Boolean Default: true Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus20.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import org.cdk8s.plus20.ServiceAccountTokenSecretProps ; ServiceAccountTokenSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . serviceAccount ( IServiceAccount ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount The service account to store a secret for. ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import org.cdk8s.plus20.ServiceIngressV1BetaBackendOptions ; ServiceIngressV1BetaBackendOptions . builder () // .port(java.lang.Number) . build (); port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import org.cdk8s.plus20.ServicePort ; ServicePort . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . port ( java . lang . Number ) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import org.cdk8s.plus20.ServicePortOptions ; ServicePortOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import org.cdk8s.plus20.ServiceProps ; ServiceProps . builder () // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .type(ServiceType) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public java . util . List < java . lang . String > getExternalIPs (); Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public java . util . List < java . lang . String > getLoadBalancerSourceRanges (); Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus20.ServicePort > The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 public ServiceType getType (); Type: org.cdk8s.plus20.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import org.cdk8s.plus20.SshAuthSecretProps ; SshAuthSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . sshPrivateKey ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 public java . lang . String getSshPrivateKey (); Type: java.lang.String The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import org.cdk8s.plus20.StatefulSetProps ; StatefulSetProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) . service ( Service ) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) // .strategy(StatefulSetUpdateStrategy) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus20.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. service Required \u00b6 public Service getService (); Type: org.cdk8s.plus20.Service Service to associate with the statefulset. podManagementPolicy Optional \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus20.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 public StatefulSetUpdateStrategy getStrategy (); Type: org.cdk8s.plus20.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import org.cdk8s.plus20.StatefulSetUpdateStrategyRollingUpdateOptions ; StatefulSetUpdateStrategyRollingUpdateOptions . builder () // .partition(java.lang.Number) . build (); partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import org.cdk8s.plus20.Sysctl ; Sysctl . builder () . name ( java . lang . String ) . value ( java . lang . String ) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of a property to set. value Required \u00b6 public java . lang . String getValue (); Type: java.lang.String Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import org.cdk8s.plus20.TcpSocketProbeOptions ; TcpSocketProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) // .host(java.lang.String) // .port(java.lang.Number) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import org.cdk8s.plus20.TlsSecretProps ; TlsSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . tlsCert ( java . lang . String ) . tlsKey ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 public java . lang . String getTlsCert (); Type: java.lang.String The TLS cert. tlsKey Required \u00b6 public java . lang . String getTlsKey (); Type: java.lang.String The TLS key. UserProps \u00b6 Properties for User . Initializer \u00b6 import org.cdk8s.plus20.UserProps ; UserProps . builder () . name ( java . lang . String ) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the user. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import org.cdk8s.plus20.VolumeMount ; VolumeMount . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . path ( java . lang . String ) . volume ( Volume ) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus20.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public Volume getVolume (); Type: org.cdk8s.plus20.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import org.cdk8s.plus20.WorkloadProps ; WorkloadProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus20.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. Classes \u00b6 ApiResource \u00b6 Implements: org.cdk8s.plus20.IApiResource , org.cdk8s.plus20.IApiEndpoint Represents information about an API resource type. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 custom \u00b6 import org.cdk8s.plus20.ApiResource ; ApiResource . custom ( ApiResourceOptions options ) options Required \u00b6 Type: org.cdk8s.plus20.ApiResourceOptions Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for Ingress. JOBS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for Job. LEASES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: org.cdk8s.plus20.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import org.cdk8s.plus20.Container ; Container . Builder . create () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .env(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .lifecycle(ContainerLifecycle) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .readiness(Probe) // .resources(ContainerResources) // .securityContext(ContainerSecurityContextProps) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 Type: java.lang.String Docker image name. args Optional \u00b6 Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: java.util.Map \u0002klzzwxh:7165\u0003 > Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 Type: org.cdk8s.plus20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: org.cdk8s.plus20.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: org.cdk8s.plus20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: java.lang.Number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: org.cdk8s.plus20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: org.cdk8s.plus20.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 Type: org.cdk8s.plus20.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: org.cdk8s.plus20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 addEnv \u00b6 public addEnv ( java . lang . String name , EnvValue value ) name Required \u00b6 Type: java.lang.String The variable name. value Required \u00b6 Type: org.cdk8s.plus20.EnvValue The variable value. mount \u00b6 public mount ( java . lang . String path , IStorage storage ) public mount ( java . lang . String path , IStorage storage , MountOptions options ) path Required \u00b6 Type: java.lang.String The desired path in the container. storage Required \u00b6 Type: org.cdk8s.plus20.IStorage The storage to mount. options Optional \u00b6 Type: org.cdk8s.plus20.MountOptions Properties \u00b6 env Required \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnv (); Type: java.util.Map \u0002klzzwxh:7110\u0003 > The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String The container image. imagePullPolicy Required \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus20.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public java . util . List < VolumeMount > getMounts (); Type: java.util.List< org.cdk8s.plus20.VolumeMount > Volume mounts configured for this container. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the container. securityContext Required \u00b6 public ContainerSecurityContext getSecurityContext (); Type: org.cdk8s.plus20.ContainerSecurityContext The security context of the container. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Arguments to the entrypoint. command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Entrypoint array (the command to execute when the container starts). port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port this container exposes. resources Optional \u00b6 public ContainerResources getResources (); Type: org.cdk8s.plus20.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import org.cdk8s.plus20.ContainerSecurityContext ; ContainerSecurityContext . Builder . create () // .ensureNonRoot(java.lang.Boolean) // .group(java.lang.Number) // .privileged(java.lang.Boolean) // .readOnlyRootFilesystem(java.lang.Boolean) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 Type: java.lang.Boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. privileged Optional \u00b6 Type: java.lang.Boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 Type: java.lang.Boolean Default: false Whether this container has a read-only root filesystem. user Optional \u00b6 Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensureNonRoot Required \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean privileged Required \u00b6 public java . lang . Boolean getPrivileged (); Type: java.lang.Boolean readOnlyRootFilesystem Required \u00b6 public java . lang . Boolean getReadOnlyRootFilesystem (); Type: java.lang.Boolean group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import org.cdk8s.plus20.Cpu ; Cpu . millis ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number units \u00b6 import org.cdk8s.plus20.Cpu ; Cpu . units ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number Properties \u00b6 amount Required \u00b6 public java . lang . String getAmount (); Type: java.lang.String DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import org.cdk8s.plus20.DeploymentStrategy ; DeploymentStrategy . recreate () rollingUpdate \u00b6 import org.cdk8s.plus20.DeploymentStrategy ; DeploymentStrategy . rollingUpdate () DeploymentStrategy . rollingUpdate ( DeploymentStrategyRollingUpdateOptions options ) options Optional \u00b6 Type: org.cdk8s.plus20.DeploymentStrategyRollingUpdateOptions EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus20.EnvValue ; EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key ) EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key , EnvValueFromConfigMapOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus20.IConfigMap The config map. key Required \u00b6 Type: java.lang.String The key to extract the value from. options Optional \u00b6 Type: org.cdk8s.plus20.EnvValueFromConfigMapOptions Additional options. fromFieldRef \u00b6 import org.cdk8s.plus20.EnvValue ; EnvValue . fromFieldRef ( EnvFieldPaths fieldPath ) EnvValue . fromFieldRef ( EnvFieldPaths fieldPath , EnvValueFromFieldRefOptions options ) fieldPath Required \u00b6 Type: org.cdk8s.plus20.EnvFieldPaths : The field reference. options Optional \u00b6 Type: org.cdk8s.plus20.EnvValueFromFieldRefOptions : Additional options. fromProcess \u00b6 import org.cdk8s.plus20.EnvValue ; EnvValue . fromProcess ( java . lang . String key ) EnvValue . fromProcess ( java . lang . String key , EnvValueFromProcessOptions options ) key Required \u00b6 Type: java.lang.String The key to read. options Optional \u00b6 Type: org.cdk8s.plus20.EnvValueFromProcessOptions Additional options. fromResource \u00b6 import org.cdk8s.plus20.EnvValue ; EnvValue . fromResource ( ResourceFieldPaths resource ) EnvValue . fromResource ( ResourceFieldPaths resource , EnvValueFromResourceOptions options ) resource Required \u00b6 Type: org.cdk8s.plus20.ResourceFieldPaths : Resource to select the value from. options Optional \u00b6 Type: org.cdk8s.plus20.EnvValueFromResourceOptions : Additional options. fromSecretValue \u00b6 import org.cdk8s.plus20.EnvValue ; EnvValue . fromSecretValue ( SecretValue secretValue ) EnvValue . fromSecretValue ( SecretValue secretValue , EnvValueFromSecretOptions options ) secretValue Required \u00b6 Type: org.cdk8s.plus20.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: org.cdk8s.plus20.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import org.cdk8s.plus20.EnvValue ; EnvValue . fromValue ( java . lang . String value ) value Required \u00b6 Type: java.lang.String The value. Properties \u00b6 value Optional \u00b6 public java . lang . Object getValue (); Type: java.lang.Object valueFrom Optional \u00b6 public java . lang . Object getValueFrom (); Type: java.lang.Object Group \u00b6 Implements: org.cdk8s.plus20.ISubject Represents a group. Initializers \u00b6 import org.cdk8s.plus20.Group ; Group . Builder . create () . name ( java . lang . String ) . build (); name Required \u00b6 Type: java.lang.String The name of the group. Properties \u00b6 kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of the object being referenced. apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 fromCommand \u00b6 import org.cdk8s.plus20.Handler ; Handler . fromCommand ( java . util . List < java . lang . String > command ) command Required \u00b6 Type: java.util.List< java.lang.String > The command to execute. fromHttpGet \u00b6 import org.cdk8s.plus20.Handler ; Handler . fromHttpGet ( java . lang . String path ) Handler . fromHttpGet ( java . lang . String path , HandlerFromHttpGetOptions options ) path Required \u00b6 Type: java.lang.String The URL path to hit. options Optional \u00b6 Type: org.cdk8s.plus20.HandlerFromHttpGetOptions Options. fromTcpSocket \u00b6 import org.cdk8s.plus20.Handler ; Handler . fromTcpSocket () Handler . fromTcpSocket ( HandlerFromTcpSocketOptions options ) options Optional \u00b6 Type: org.cdk8s.plus20.HandlerFromTcpSocketOptions Options. IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromService \u00b6 import org.cdk8s.plus20.IngressV1Beta1Backend ; IngressV1Beta1Backend . fromService ( Service serv ) IngressV1Beta1Backend . fromService ( Service serv , ServiceIngressV1BetaBackendOptions options ) serv Required \u00b6 Type: org.cdk8s.plus20.Service The service object. options Optional \u00b6 Type: org.cdk8s.plus20.ServiceIngressV1BetaBackendOptions LabelSelector \u00b6 A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors Static Functions \u00b6 doesNotExist \u00b6 import org.cdk8s.plus20.LabelSelector ; LabelSelector . doesNotExist ( java . lang . String key ) key Required \u00b6 Type: java.lang.String exists \u00b6 import org.cdk8s.plus20.LabelSelector ; LabelSelector . exists ( java . lang . String key ) key Required \u00b6 Type: java.lang.String in \u00b6 import org.cdk8s.plus20.LabelSelector ; LabelSelector . in ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > is \u00b6 import org.cdk8s.plus20.LabelSelector ; LabelSelector . is ( java . lang . String key , java . lang . String value ) LabelSelector . is ( java . lang . String key , java . lang . String value , java . lang . Boolean applyToTemplate ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String applyToTemplate Optional \u00b6 Type: java.lang.Boolean notIn \u00b6 import org.cdk8s.plus20.LabelSelector ; LabelSelector . notIn ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > Properties \u00b6 applyToTemplate Required \u00b6 public java . lang . Boolean getApplyToTemplate (); Type: java.lang.Boolean key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String operator Optional \u00b6 public LabelSelectorRequirementOperator getOperator (); Type: org.cdk8s.plus20.LabelSelectorRequirementOperator values Optional \u00b6 public java . util . List < java . lang . String > getValues (); Type: java.util.List< java.lang.String > NonApiResource \u00b6 Implements: org.cdk8s.plus20.IApiEndpoint Factory for creating non api resources. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 of \u00b6 import org.cdk8s.plus20.NonApiResource ; NonApiResource . of ( java . lang . String url ) url Required \u00b6 Type: java.lang.String PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 isZero \u00b6 public isZero () Static Functions \u00b6 absolute \u00b6 import org.cdk8s.plus20.PercentOrAbsolute ; PercentOrAbsolute . absolute ( java . lang . Number num ) num Required \u00b6 Type: java.lang.Number percent \u00b6 import org.cdk8s.plus20.PercentOrAbsolute ; PercentOrAbsolute . percent ( java . lang . Number percent ) percent Required \u00b6 Type: java.lang.Number Properties \u00b6 value Required \u00b6 public java . lang . Object getValue (); Type: java.lang.Object PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import org.cdk8s.plus20.PodDns ; PodDns . Builder . create () // .hostname(java.lang.String) // .hostnameAsFQDN(java.lang.Boolean) // .nameservers(java.util.List<java.lang.String>) // .options(java.util.List<DnsOption>) // .policy(DnsPolicy) // .searches(java.util.List<java.lang.String>) // .subdomain(java.lang.String) . build (); hostname Optional \u00b6 Type: java.lang.String Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 Type: java.lang.Boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 Type: java.util.List< java.lang.String > A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.DnsOption > List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 Type: org.cdk8s.plus20.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 Type: java.util.List< java.lang.String > A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 Type: java.lang.String Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. Methods \u00b6 addNameserver \u00b6 public addNameserver ( java . lang . String nameservers ) nameservers Required \u00b6 Type: java.lang.String addOption \u00b6 public addOption ( DnsOption options ) options Required \u00b6 Type: org.cdk8s.plus20.DnsOption addSearch \u00b6 public addSearch ( java . lang . String searches ) searches Required \u00b6 Type: java.lang.String Properties \u00b6 hostnameAsFQDN Required \u00b6 public java . lang . Boolean getHostnameAsFQDN (); Type: java.lang.Boolean Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 public java . util . List < java . lang . String > getNameservers (); Type: java.util.List< java.lang.String > Nameservers defined for this pod. options Required \u00b6 public java . util . List < DnsOption > getOptions (); Type: java.util.List< org.cdk8s.plus20.DnsOption > Custom dns options defined for this pod. policy Required \u00b6 public DnsPolicy getPolicy (); Type: org.cdk8s.plus20.DnsPolicy The DNS policy of this pod. searches Required \u00b6 public java . util . List < java . lang . String > getSearches (); Type: java.util.List< java.lang.String > Search domains defined for this pod. hostname Optional \u00b6 public java . lang . String getHostname (); Type: java.lang.String The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 public java . lang . String getSubdomain (); Type: java.lang.String The configured subdomain of the pod. PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import org.cdk8s.plus20.PodSecurityContext ; PodSecurityContext . Builder . create () // .ensureNonRoot(java.lang.Boolean) // .fsGroup(java.lang.Number) // .fsGroupChangePolicy(FsGroupChangePolicy) // .group(java.lang.Number) // .sysctls(java.util.List<Sysctl>) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 Type: java.lang.Boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 Type: java.lang.Number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 Type: org.cdk8s.plus20.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.Sysctl > Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensureNonRoot Required \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean fsGroupChangePolicy Required \u00b6 public FsGroupChangePolicy getFsGroupChangePolicy (); Type: org.cdk8s.plus20.FsGroupChangePolicy sysctls Required \u00b6 public java . util . List < Sysctl > getSysctls (); Type: java.util.List< org.cdk8s.plus20.Sysctl > fsGroup Optional \u00b6 public java . lang . Number getFsGroup (); Type: java.lang.Number group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 fromCommand \u00b6 import org.cdk8s.plus20.Probe ; Probe . fromCommand ( java . util . List < java . lang . String > command ) Probe . fromCommand ( java . util . List < java . lang . String > command , CommandProbeOptions options ) command Required \u00b6 Type: java.util.List< java.lang.String > The command to execute. options Optional \u00b6 Type: org.cdk8s.plus20.CommandProbeOptions Options. fromHttpGet \u00b6 import org.cdk8s.plus20.Probe ; Probe . fromHttpGet ( java . lang . String path ) Probe . fromHttpGet ( java . lang . String path , HttpGetProbeOptions options ) path Required \u00b6 Type: java.lang.String The URL path to hit. options Optional \u00b6 Type: org.cdk8s.plus20.HttpGetProbeOptions Options. fromTcpSocket \u00b6 import org.cdk8s.plus20.Probe ; Probe . fromTcpSocket () Probe . fromTcpSocket ( TcpSocketProbeOptions options ) options Optional \u00b6 Type: org.cdk8s.plus20.TcpSocketProbeOptions Options. StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 onDelete \u00b6 import org.cdk8s.plus20.StatefulSetUpdateStrategy ; StatefulSetUpdateStrategy . onDelete () rollingUpdate \u00b6 import org.cdk8s.plus20.StatefulSetUpdateStrategy ; StatefulSetUpdateStrategy . rollingUpdate () StatefulSetUpdateStrategy . rollingUpdate ( StatefulSetUpdateStrategyRollingUpdateOptions options ) options Optional \u00b6 Type: org.cdk8s.plus20.StatefulSetUpdateStrategyRollingUpdateOptions User \u00b6 Implements: org.cdk8s.plus20.ISubject Represents a user. Initializers \u00b6 import org.cdk8s.plus20.User ; User . Builder . create () . name ( java . lang . String ) . build (); name Required \u00b6 Type: java.lang.String The name of the user. Properties \u00b6 kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of the object being referenced. apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Volume \u00b6 Implements: org.cdk8s.plus20.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 asVolume \u00b6 public asVolume () Static Functions \u00b6 fromAwsElasticBlockStore \u00b6 import org.cdk8s.plus20.Volume ; Volume . fromAwsElasticBlockStore ( java . lang . String volumeId ) Volume . fromAwsElasticBlockStore ( java . lang . String volumeId , AwsElasticBlockStoreVolumeOptions options ) volumeId Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus20.AwsElasticBlockStoreVolumeOptions fromAzureDisk \u00b6 import org.cdk8s.plus20.Volume ; Volume . fromAzureDisk ( java . lang . String diskName , java . lang . String diskUri ) Volume . fromAzureDisk ( java . lang . String diskName , java . lang . String diskUri , AzureDiskVolumeOptions options ) diskName Required \u00b6 Type: java.lang.String diskUri Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus20.AzureDiskVolumeOptions fromConfigMap \u00b6 import org.cdk8s.plus20.Volume ; Volume . fromConfigMap ( IConfigMap configMap ) Volume . fromConfigMap ( IConfigMap configMap , ConfigMapVolumeOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus20.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: org.cdk8s.plus20.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import org.cdk8s.plus20.Volume ; Volume . fromEmptyDir ( java . lang . String name ) Volume . fromEmptyDir ( java . lang . String name , EmptyDirVolumeOptions options ) name Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus20.EmptyDirVolumeOptions Additional options. fromGcePersistentDisk \u00b6 import org.cdk8s.plus20.Volume ; Volume . fromGcePersistentDisk ( java . lang . String pdName ) Volume . fromGcePersistentDisk ( java . lang . String pdName , GCEPersistentDiskVolumeOptions options ) pdName Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus20.GCEPersistentDiskVolumeOptions fromPersistentVolumeClaim \u00b6 import org.cdk8s.plus20.Volume ; Volume . fromPersistentVolumeClaim ( IPersistentVolumeClaim claim ) Volume . fromPersistentVolumeClaim ( IPersistentVolumeClaim claim , PersistentVolumeClaimVolumeOptions options ) claim Required \u00b6 Type: org.cdk8s.plus20.IPersistentVolumeClaim options Optional \u00b6 Type: org.cdk8s.plus20.PersistentVolumeClaimVolumeOptions fromSecret \u00b6 import org.cdk8s.plus20.Volume ; Volume . fromSecret ( ISecret secr ) Volume . fromSecret ( ISecret secr , SecretVolumeOptions options ) secr Required \u00b6 Type: org.cdk8s.plus20.ISecret The secret to use to populate the volume. options Optional \u00b6 Type: org.cdk8s.plus20.SecretVolumeOptions Options. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: org.cdk8s.plus20.AbstractPod , org.cdk8s.plus20.ApiResource , org.cdk8s.plus20.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus20.AzureDiskPersistentVolume , org.cdk8s.plus20.BasicAuthSecret , org.cdk8s.plus20.ClusterRole , org.cdk8s.plus20.ClusterRoleBinding , org.cdk8s.plus20.ConfigMap , org.cdk8s.plus20.DaemonSet , org.cdk8s.plus20.Deployment , org.cdk8s.plus20.DockerConfigSecret , org.cdk8s.plus20.GCEPersistentDiskPersistentVolume , org.cdk8s.plus20.IngressV1Beta1 , org.cdk8s.plus20.Job , org.cdk8s.plus20.NonApiResource , org.cdk8s.plus20.PersistentVolume , org.cdk8s.plus20.PersistentVolumeClaim , org.cdk8s.plus20.Pod , org.cdk8s.plus20.Resource , org.cdk8s.plus20.Role , org.cdk8s.plus20.RoleBinding , org.cdk8s.plus20.Secret , org.cdk8s.plus20.Service , org.cdk8s.plus20.ServiceAccount , org.cdk8s.plus20.ServiceAccountTokenSecret , org.cdk8s.plus20.SshAuthSecret , org.cdk8s.plus20.StatefulSet , org.cdk8s.plus20.TlsSecret , org.cdk8s.plus20.Workload , org.cdk8s.plus20.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () IApiResource \u00b6 Implemented By: org.cdk8s.plus20.AbstractPod , org.cdk8s.plus20.ApiResource , org.cdk8s.plus20.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus20.AzureDiskPersistentVolume , org.cdk8s.plus20.BasicAuthSecret , org.cdk8s.plus20.ClusterRole , org.cdk8s.plus20.ClusterRoleBinding , org.cdk8s.plus20.ConfigMap , org.cdk8s.plus20.DaemonSet , org.cdk8s.plus20.Deployment , org.cdk8s.plus20.DockerConfigSecret , org.cdk8s.plus20.GCEPersistentDiskPersistentVolume , org.cdk8s.plus20.IngressV1Beta1 , org.cdk8s.plus20.Job , org.cdk8s.plus20.PersistentVolume , org.cdk8s.plus20.PersistentVolumeClaim , org.cdk8s.plus20.Pod , org.cdk8s.plus20.Resource , org.cdk8s.plus20.Role , org.cdk8s.plus20.RoleBinding , org.cdk8s.plus20.Secret , org.cdk8s.plus20.Service , org.cdk8s.plus20.ServiceAccount , org.cdk8s.plus20.ServiceAccountTokenSecret , org.cdk8s.plus20.SshAuthSecret , org.cdk8s.plus20.StatefulSet , org.cdk8s.plus20.TlsSecret , org.cdk8s.plus20.Workload , org.cdk8s.plus20.IApiResource Represents a resource or collection of resources. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resourceName Optional \u00b6 public java . lang . String getResourceName (); Type: java.lang.String The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.ClusterRole , org.cdk8s.plus20.IClusterRole Represents a cluster-level role. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IConfigMap \u00b6 Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.ConfigMap , org.cdk8s.plus20.IConfigMap Represents a config map. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IPersistentVolume \u00b6 Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus20.AzureDiskPersistentVolume , org.cdk8s.plus20.GCEPersistentDiskPersistentVolume , org.cdk8s.plus20.PersistentVolume , org.cdk8s.plus20.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.PersistentVolumeClaim , org.cdk8s.plus20.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IResource \u00b6 Implemented By: org.cdk8s.plus20.AbstractPod , org.cdk8s.plus20.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus20.AzureDiskPersistentVolume , org.cdk8s.plus20.BasicAuthSecret , org.cdk8s.plus20.ClusterRole , org.cdk8s.plus20.ClusterRoleBinding , org.cdk8s.plus20.ConfigMap , org.cdk8s.plus20.DaemonSet , org.cdk8s.plus20.Deployment , org.cdk8s.plus20.DockerConfigSecret , org.cdk8s.plus20.GCEPersistentDiskPersistentVolume , org.cdk8s.plus20.IngressV1Beta1 , org.cdk8s.plus20.Job , org.cdk8s.plus20.PersistentVolume , org.cdk8s.plus20.PersistentVolumeClaim , org.cdk8s.plus20.Pod , org.cdk8s.plus20.Resource , org.cdk8s.plus20.Role , org.cdk8s.plus20.RoleBinding , org.cdk8s.plus20.Secret , org.cdk8s.plus20.Service , org.cdk8s.plus20.ServiceAccount , org.cdk8s.plus20.ServiceAccountTokenSecret , org.cdk8s.plus20.SshAuthSecret , org.cdk8s.plus20.StatefulSet , org.cdk8s.plus20.TlsSecret , org.cdk8s.plus20.Workload , org.cdk8s.plus20.IClusterRole , org.cdk8s.plus20.IConfigMap , org.cdk8s.plus20.IPersistentVolume , org.cdk8s.plus20.IPersistentVolumeClaim , org.cdk8s.plus20.IResource , org.cdk8s.plus20.IRole , org.cdk8s.plus20.ISecret , org.cdk8s.plus20.IServiceAccount Represents a resource. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IRole \u00b6 Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.ClusterRole , org.cdk8s.plus20.Role , org.cdk8s.plus20.IRole A reference to any Role or ClusterRole. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. ISecret \u00b6 Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.BasicAuthSecret , org.cdk8s.plus20.DockerConfigSecret , org.cdk8s.plus20.Secret , org.cdk8s.plus20.ServiceAccountTokenSecret , org.cdk8s.plus20.SshAuthSecret , org.cdk8s.plus20.TlsSecret , org.cdk8s.plus20.ISecret Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.ServiceAccount , org.cdk8s.plus20.IServiceAccount Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IStorage \u00b6 Implemented By: org.cdk8s.plus20.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus20.AzureDiskPersistentVolume , org.cdk8s.plus20.GCEPersistentDiskPersistentVolume , org.cdk8s.plus20.PersistentVolume , org.cdk8s.plus20.Volume , org.cdk8s.plus20.IStorage Represents a piece of storage in the cluster. Methods \u00b6 asVolume \u00b6 public asVolume () ISubject \u00b6 Implemented By: org.cdk8s.plus20.Group , org.cdk8s.plus20.ServiceAccount , org.cdk8s.plus20.User , org.cdk8s.plus20.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Properties \u00b6 kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of the object being referenced. apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. LabelSelectorRequirementOperator \u00b6 Possible operators. IN \u00b6 In. NOT_IN \u00b6 NotIn. EXISTS \u00b6 Exists. DOES_NOT_EXIST \u00b6 DoesNotExist. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"Java"},{"location":"reference/cdk8s-plus-20/java/#cdk8s-plus-20-java","text":"","title":"cdk8s-plus-20 (Java) "},{"location":"reference/cdk8s-plus-20/java/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-20/java/#abstractpod","text":"","title":"AbstractPod "},{"location":"reference/cdk8s-plus-20/java/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-20/java/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-20/java/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-20/java/#clusterrole","text":"Implements: org.cdk8s.plus20.IClusterRole , org.cdk8s.plus20.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-20/java/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-20/java/#configmap","text":"Implements: org.cdk8s.plus20.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-20/java/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-20/java/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-20/java/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-20/java/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-20/java/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-20/java/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-20/java/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-20/java/#persistentvolume","text":"Implements: org.cdk8s.plus20.IPersistentVolume , org.cdk8s.plus20.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-20/java/#persistentvolumeclaim","text":"Implements: org.cdk8s.plus20.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-20/java/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-20/java/#resource","text":"Implements: org.cdk8s.plus20.IResource , org.cdk8s.plus20.IApiResource , org.cdk8s.plus20.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-20/java/#role","text":"Implements: org.cdk8s.plus20.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-20/java/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-20/java/#secret","text":"Implements: org.cdk8s.plus20.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-20/java/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-20/java/#serviceaccount","text":"Implements: org.cdk8s.plus20.IServiceAccount , org.cdk8s.plus20.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-20/java/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-20/java/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-20/java/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-20/java/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-20/java/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-20/java/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-20/java/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-20/java/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-20/java/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-20/java/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-20/java/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-20/java/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-20/java/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-20/java/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-20/java/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-20/java/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-20/java/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-20/java/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-20/java/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-20/java/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-20/java/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-20/java/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-20/java/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-20/java/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-20/java/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-20/java/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-20/java/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-20/java/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-20/java/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-20/java/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-20/java/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-20/java/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-20/java/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-20/java/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-20/java/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-20/java/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-20/java/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-20/java/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-20/java/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-20/java/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-20/java/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-20/java/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-20/java/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-20/java/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-20/java/#groupprops","text":"Properties for Group .","title":"GroupProps "},{"location":"reference/cdk8s-plus-20/java/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-20/java/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-20/java/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-20/java/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-20/java/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-20/java/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-20/java/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-20/java/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-20/java/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-20/java/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-20/java/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-20/java/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-20/java/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-20/java/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-20/java/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-20/java/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-20/java/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-20/java/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-20/java/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-20/java/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-20/java/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-20/java/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-20/java/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-20/java/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-20/java/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-20/java/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-20/java/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-20/java/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-20/java/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-20/java/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-20/java/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-20/java/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-20/java/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-20/java/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-20/java/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-20/java/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-20/java/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-20/java/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-20/java/#userprops","text":"Properties for User .","title":"UserProps "},{"location":"reference/cdk8s-plus-20/java/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-20/java/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-20/java/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-20/java/#apiresource","text":"Implements: org.cdk8s.plus20.IApiResource , org.cdk8s.plus20.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-20/java/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-20/java/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-20/java/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-20/java/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-20/java/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-20/java/#group","text":"Implements: org.cdk8s.plus20.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-20/java/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-20/java/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-20/java/#labelselector","text":"A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors","title":"LabelSelector "},{"location":"reference/cdk8s-plus-20/java/#nonapiresource","text":"Implements: org.cdk8s.plus20.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-20/java/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-20/java/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-20/java/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-20/java/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-20/java/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-20/java/#user","text":"Implements: org.cdk8s.plus20.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-20/java/#volume","text":"Implements: org.cdk8s.plus20.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-20/java/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-20/java/#iapiendpoint","text":"Implemented By: org.cdk8s.plus20.AbstractPod , org.cdk8s.plus20.ApiResource , org.cdk8s.plus20.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus20.AzureDiskPersistentVolume , org.cdk8s.plus20.BasicAuthSecret , org.cdk8s.plus20.ClusterRole , org.cdk8s.plus20.ClusterRoleBinding , org.cdk8s.plus20.ConfigMap , org.cdk8s.plus20.DaemonSet , org.cdk8s.plus20.Deployment , org.cdk8s.plus20.DockerConfigSecret , org.cdk8s.plus20.GCEPersistentDiskPersistentVolume , org.cdk8s.plus20.IngressV1Beta1 , org.cdk8s.plus20.Job , org.cdk8s.plus20.NonApiResource , org.cdk8s.plus20.PersistentVolume , org.cdk8s.plus20.PersistentVolumeClaim , org.cdk8s.plus20.Pod , org.cdk8s.plus20.Resource , org.cdk8s.plus20.Role , org.cdk8s.plus20.RoleBinding , org.cdk8s.plus20.Secret , org.cdk8s.plus20.Service , org.cdk8s.plus20.ServiceAccount , org.cdk8s.plus20.ServiceAccountTokenSecret , org.cdk8s.plus20.SshAuthSecret , org.cdk8s.plus20.StatefulSet , org.cdk8s.plus20.TlsSecret , org.cdk8s.plus20.Workload , org.cdk8s.plus20.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-20/java/#iapiresource","text":"Implemented By: org.cdk8s.plus20.AbstractPod , org.cdk8s.plus20.ApiResource , org.cdk8s.plus20.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus20.AzureDiskPersistentVolume , org.cdk8s.plus20.BasicAuthSecret , org.cdk8s.plus20.ClusterRole , org.cdk8s.plus20.ClusterRoleBinding , org.cdk8s.plus20.ConfigMap , org.cdk8s.plus20.DaemonSet , org.cdk8s.plus20.Deployment , org.cdk8s.plus20.DockerConfigSecret , org.cdk8s.plus20.GCEPersistentDiskPersistentVolume , org.cdk8s.plus20.IngressV1Beta1 , org.cdk8s.plus20.Job , org.cdk8s.plus20.PersistentVolume , org.cdk8s.plus20.PersistentVolumeClaim , org.cdk8s.plus20.Pod , org.cdk8s.plus20.Resource , org.cdk8s.plus20.Role , org.cdk8s.plus20.RoleBinding , org.cdk8s.plus20.Secret , org.cdk8s.plus20.Service , org.cdk8s.plus20.ServiceAccount , org.cdk8s.plus20.ServiceAccountTokenSecret , org.cdk8s.plus20.SshAuthSecret , org.cdk8s.plus20.StatefulSet , org.cdk8s.plus20.TlsSecret , org.cdk8s.plus20.Workload , org.cdk8s.plus20.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-20/java/#iclusterrole","text":"Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.ClusterRole , org.cdk8s.plus20.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-20/java/#iconfigmap","text":"Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.ConfigMap , org.cdk8s.plus20.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-20/java/#ipersistentvolume","text":"Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus20.AzureDiskPersistentVolume , org.cdk8s.plus20.GCEPersistentDiskPersistentVolume , org.cdk8s.plus20.PersistentVolume , org.cdk8s.plus20.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-20/java/#ipersistentvolumeclaim","text":"Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.PersistentVolumeClaim , org.cdk8s.plus20.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-20/java/#iresource","text":"Implemented By: org.cdk8s.plus20.AbstractPod , org.cdk8s.plus20.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus20.AzureDiskPersistentVolume , org.cdk8s.plus20.BasicAuthSecret , org.cdk8s.plus20.ClusterRole , org.cdk8s.plus20.ClusterRoleBinding , org.cdk8s.plus20.ConfigMap , org.cdk8s.plus20.DaemonSet , org.cdk8s.plus20.Deployment , org.cdk8s.plus20.DockerConfigSecret , org.cdk8s.plus20.GCEPersistentDiskPersistentVolume , org.cdk8s.plus20.IngressV1Beta1 , org.cdk8s.plus20.Job , org.cdk8s.plus20.PersistentVolume , org.cdk8s.plus20.PersistentVolumeClaim , org.cdk8s.plus20.Pod , org.cdk8s.plus20.Resource , org.cdk8s.plus20.Role , org.cdk8s.plus20.RoleBinding , org.cdk8s.plus20.Secret , org.cdk8s.plus20.Service , org.cdk8s.plus20.ServiceAccount , org.cdk8s.plus20.ServiceAccountTokenSecret , org.cdk8s.plus20.SshAuthSecret , org.cdk8s.plus20.StatefulSet , org.cdk8s.plus20.TlsSecret , org.cdk8s.plus20.Workload , org.cdk8s.plus20.IClusterRole , org.cdk8s.plus20.IConfigMap , org.cdk8s.plus20.IPersistentVolume , org.cdk8s.plus20.IPersistentVolumeClaim , org.cdk8s.plus20.IResource , org.cdk8s.plus20.IRole , org.cdk8s.plus20.ISecret , org.cdk8s.plus20.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-20/java/#irole","text":"Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.ClusterRole , org.cdk8s.plus20.Role , org.cdk8s.plus20.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-20/java/#isecret","text":"Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.BasicAuthSecret , org.cdk8s.plus20.DockerConfigSecret , org.cdk8s.plus20.Secret , org.cdk8s.plus20.ServiceAccountTokenSecret , org.cdk8s.plus20.SshAuthSecret , org.cdk8s.plus20.TlsSecret , org.cdk8s.plus20.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-20/java/#iserviceaccount","text":"Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.ServiceAccount , org.cdk8s.plus20.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-20/java/#istorage","text":"Implemented By: org.cdk8s.plus20.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus20.AzureDiskPersistentVolume , org.cdk8s.plus20.GCEPersistentDiskPersistentVolume , org.cdk8s.plus20.PersistentVolume , org.cdk8s.plus20.Volume , org.cdk8s.plus20.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-20/java/#isubject","text":"Implemented By: org.cdk8s.plus20.Group , org.cdk8s.plus20.ServiceAccount , org.cdk8s.plus20.User , org.cdk8s.plus20.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"ISubject "},{"location":"reference/cdk8s-plus-20/java/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-20/java/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-20/java/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-20/java/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-20/java/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-20/java/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-20/java/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-20/java/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-20/java/#labelselectorrequirementoperator","text":"Possible operators.","title":"LabelSelectorRequirementOperator "},{"location":"reference/cdk8s-plus-20/java/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-20/java/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-20/java/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-20/java/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-20/java/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-20/java/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-20/java/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-20/java/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-20/java/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-20/python/","text":"cdk8s-plus-20 (Python) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . AbstractPod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_20.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_20.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_20.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_20.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_20.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_20.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_host_alias \u00b6 def add_host_alias ( hostnames : typing . List [ str ], ip : str ) hostnames Required \u00b6 Type: typing.List[ str ] Hostnames for the chosen IP address. ip Required \u00b6 Type: str IP address of the host file entry. add_init_container \u00b6 def add_init_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_20.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_20.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_20.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_20.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_20.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( vol : Volume ) vol Required \u00b6 Type: cdk8s_plus_20.Volume Properties \u00b6 automount_service_account_token Required \u00b6 automount_service_account_token : bool Type: bool containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_20.Container ] dns Required \u00b6 dns : PodDns Type: cdk8s_plus_20.PodDns host_aliases Required \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_20.HostAlias ] init_containers Required \u00b6 init_containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_20.Container ] security_context Required \u00b6 security_context : PodSecurityContext Type: cdk8s_plus_20.PodSecurityContext volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_20.DockerConfigSecret restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . AwsElasticBlockStorePersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , volume_id : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volume_id Required \u00b6 Type: str Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. volume_id Required \u00b6 volume_id : str Type: str Volume id of this volume. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . AzureDiskPersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. disk_name Required \u00b6 Type: str The Name of the data disk in the blob storage. disk_uri Required \u00b6 Type: str The URI the data disk in the blob storage. caching_mode Optional \u00b6 Type: cdk8s_plus_20.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: cdk8s_plus_20.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. read_only Optional \u00b6 Type: bool Default: false Force the ReadOnly setting in VolumeMounts. Properties \u00b6 azure_kind Required \u00b6 azure_kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_20.AzureDiskPersistentVolumeKind Azure kind of this volume. caching_mode Required \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_20.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. disk_name Required \u00b6 disk_name : str Type: str Disk name of this volume. disk_uri Required \u00b6 disk_uri : str Type: str Disk URI of this volume. fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . BasicAuthSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , password : str , username : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 Type: str The password or token for authentication. username Required \u00b6 Type: str The user name for authentication. ClusterRole \u00b6 Implements: cdk8s_plus_20.IClusterRole , cdk8s_plus_20.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ClusterRole ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , aggregation_labels : typing . Mapping [ str ] = None , rules : typing . List [ ClusterRolePolicyRule ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregation_labels Optional \u00b6 Type: typing.Mapping[ str ] Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ClusterRolePolicyRule ] Default: [] A list of rules the role should allow. Methods \u00b6 aggregate \u00b6 def aggregate ( key : str , value : str ) key Required \u00b6 Type: str value Required \u00b6 Type: str allow \u00b6 def allow ( verbs : typing . List [ str ], endpoints : IApiEndpoint ) verbs Required \u00b6 Type: typing.List[ str ] endpoints Required \u00b6 Type: cdk8s_plus_20.IApiEndpoint The endpoints(s) to apply to. allow_create \u00b6 def allow_create ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_20.IApiEndpoint The resource(s) to apply to. allow_delete \u00b6 def allow_delete ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_20.IApiEndpoint The resource(s) to apply to. allow_delete_collection \u00b6 def allow_delete_collection ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_20.IApiEndpoint The resource(s) to apply to. allow_get \u00b6 def allow_get ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_20.IApiEndpoint The resource(s) to apply to. allow_list \u00b6 def allow_list ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_20.IApiEndpoint The resource(s) to apply to. allow_patch \u00b6 def allow_patch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_20.IApiEndpoint The resource(s) to apply to. allow_read \u00b6 def allow_read ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_20.IApiEndpoint The resource(s) to apply to. allow_read_write \u00b6 def allow_read_write ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_20.IApiEndpoint The resource(s) to apply to. allow_update \u00b6 def allow_update ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_20.IApiEndpoint The resource(s) to apply to. allow_watch \u00b6 def allow_watch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_20.IApiEndpoint The resource(s) to apply to. bind \u00b6 def bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_20.ISubject a list of subjects to bind to. bind_in_namespace \u00b6 def bind_in_namespace ( namespace : str , subjects : ISubject ) namespace Required \u00b6 Type: str the namespace to limit permissions to. subjects Required \u00b6 Type: cdk8s_plus_20.ISubject a list of subjects to bind to. combine \u00b6 def combine ( rol : ClusterRole ) rol Required \u00b6 Type: cdk8s_plus_20.ClusterRole Static Functions \u00b6 from_cluster_role_name \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ClusterRole . from_cluster_role_name ( name : str ) name Required \u00b6 Type: str The name of the role resource. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 rules : typing . List [ ClusterRolePolicyRule ] Type: typing.List[ cdk8s_plus_20.ClusterRolePolicyRule ] Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ClusterRoleBinding ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , role : IClusterRole ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: cdk8s_plus_20.IClusterRole The role to bind to. Methods \u00b6 add_subjects \u00b6 def add_subjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_20.ISubject The subjects to add. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 role : IClusterRole Type: cdk8s_plus_20.IClusterRole subjects Required \u00b6 subjects : typing . List [ ISubject ] Type: typing.List[ cdk8s_plus_20.ISubject ] ConfigMap \u00b6 Implements: cdk8s_plus_20.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ConfigMap ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None , immutable : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Methods \u00b6 add_binary_data \u00b6 def add_binary_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_data \u00b6 def add_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_directory \u00b6 def add_directory ( local_dir : str , exclude : typing . List [ str ] = None , key_prefix : str = None ) local_dir Required \u00b6 Type: str A path to a local directory. exclude Optional \u00b6 Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. add_file \u00b6 def add_file ( local_file : str , key : str = None ) local_file Required \u00b6 Type: str The path to the local file. key Optional \u00b6 Type: str The ConfigMap key (default to the file name). Static Functions \u00b6 from_config_map_name \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ConfigMap . from_config_map_name ( name : str ) name Required \u00b6 Type: str The name of the config map to import. Properties \u00b6 binary_data Required \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 immutable : bool Type: bool Whether or not this config map is immutable. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . DaemonSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , min_ready_seconds : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_20.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. min_ready_seconds Optional \u00b6 Type: typing.Union[int, float] Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Properties \u00b6 min_ready_seconds Required \u00b6 min_ready_seconds : typing . Union [ int , float ] Type: typing.Union[int, float] resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Deployment ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , min_ready : Duration = None , progress_deadline : Duration = None , replicas : typing . Union [ int , float ] = None , strategy : DeploymentStrategy = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_20.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. min_ready Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progress_deadline Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 Type: cdk8s_plus_20.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. Methods \u00b6 expose_via_ingress \u00b6 def expose_via_ingress ( path : str , name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None , ingress : IngressV1Beta1 = None ) path Required \u00b6 Type: str The ingress path to register under. name Optional \u00b6 Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 Type: cdk8s_plus_20.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 Type: cdk8s_plus_20.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. expose_via_service \u00b6 def expose_via_service ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 Type: cdk8s_plus_20.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. Properties \u00b6 min_ready Required \u00b6 min_ready : Duration Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progress_deadline Required \u00b6 progress_deadline : Duration Type: cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 strategy : DeploymentStrategy Type: cdk8s_plus_20.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . DockerConfigSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , data : typing . Mapping [ typing . Any ] ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 Type: typing.Mapping[ typing.Any ] JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . GCEPersistentDiskPersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , pd_name : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pd_name Required \u00b6 Type: str Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. pd_name Required \u00b6 pd_name : str Type: str PD resource in GCE of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Partition of this volume. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . IngressV1Beta1 ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , default_backend : IngressV1Beta1Backend = None , rules : typing . List [ IngressV1Beta1Rule ] = None , tls : typing . List [ IngressV1Beta1Tls ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 Type: cdk8s_plus_20.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_20.IngressV1Beta1Rule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: typing.List[ cdk8s_plus_20.IngressV1Beta1Tls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 add_default_backend \u00b6 def add_default_backend ( backend : IngressV1Beta1Backend ) backend Required \u00b6 Type: cdk8s_plus_20.IngressV1Beta1Backend The backend to use for requests that do not match any rule. add_host_default_backend \u00b6 def add_host_default_backend ( host : str , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: str The host name to match. backend Required \u00b6 Type: cdk8s_plus_20.IngressV1Beta1Backend The backend to route to. add_host_rule \u00b6 def add_host_rule ( host : str , path : str , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: str The host name. path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_20.IngressV1Beta1Backend The backend to route requests to. add_rule \u00b6 def add_rule ( path : str , backend : IngressV1Beta1Backend ) path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_20.IngressV1Beta1Backend The backend to route requests to. add_rules \u00b6 def add_rules ( backend : IngressV1Beta1Backend , host : str = None , path : str = None ) backend Required \u00b6 Type: cdk8s_plus_20.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. add_tls \u00b6 def add_tls ( tls : typing . List [ IngressV1Beta1Tls ] ) tls Required \u00b6 Type: typing.List[ cdk8s_plus_20.IngressV1Beta1Tls ] Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Job ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_20.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. active_deadline Optional \u00b6 Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Number of retries before marking failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration TTL before the job is deleted after it is finished. PersistentVolume \u00b6 Implements: cdk8s_plus_20.IPersistentVolume , cdk8s_plus_20.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 as_volume \u00b6 def as_volume () bind \u00b6 def bind ( claim : IPersistentVolumeClaim ) claim Required \u00b6 Type: cdk8s_plus_20.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 def reserve () Static Functions \u00b6 from_persistent_volume_name \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PersistentVolume . from_persistent_volume_name ( volume_name : str ) volume_name Required \u00b6 Type: str The name of the pv to reference. Properties \u00b6 mode Required \u00b6 mode : PersistentVolumeMode Type: cdk8s_plus_20.PersistentVolumeMode Volume mode of this volume. reclaim_policy Required \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_20.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_20.PersistentVolumeAccessMode ] Access modes requirement of this claim. claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_20.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Mount options of this volume. storage Optional \u00b6 storage : Size Type: cdk8s.Size Storage size of this volume. storage_class_name Optional \u00b6 storage_class_name : str Type: str Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: cdk8s_plus_20.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PersistentVolumeClaim ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , storage : Size = None , storage_class_name : str = None , volume : IPersistentVolume = None , volume_mode : PersistentVolumeMode = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.PersistentVolumeAccessMode ] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 Type: cdk8s_plus_20.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volume_mode Optional \u00b6 Type: cdk8s_plus_20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 bind \u00b6 def bind ( vol : IPersistentVolume ) vol Required \u00b6 Type: cdk8s_plus_20.IPersistentVolume The PV to bind to. Static Functions \u00b6 from_claim_name \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PersistentVolumeClaim . from_claim_name ( claim_name : str ) claim_name Required \u00b6 Type: str The name of the pvc to reference. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. volume_mode Required \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_20.PersistentVolumeMode Volume mode requirement of this claim. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_20.PersistentVolumeAccessMode ] Access modes requirement of this claim. storage Optional \u00b6 storage : Size Type: cdk8s.Size Storage requirement of this claim. storage_class_name Optional \u00b6 storage_class_name : str Type: str Storage class requirment of this claim. volume Optional \u00b6 volume : IPersistentVolume Type: cdk8s_plus_20.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Pod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_20.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Resource \u00b6 Implements: cdk8s_plus_20.IResource , cdk8s_plus_20.IApiResource , cdk8s_plus_20.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Resource ( scope : Construct , id : str , node_factory : INodeFactory = None ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: str The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . node_factory Optional \u00b6 Type: constructs.INodeFactory Default: the default Node is associated A factory for attaching Node s to the construct. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 name : str Type: str The name of this API object. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. resource_name Optional \u00b6 resource_name : str Type: str The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: cdk8s_plus_20.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Role ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , rules : typing . List [ RolePolicyRule ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_20.RolePolicyRule ] Default: [] A list of rules the role should allow. Methods \u00b6 allow \u00b6 def allow ( verbs : typing . List [ str ], resources : IApiResource ) verbs Required \u00b6 Type: typing.List[ str ] resources Required \u00b6 Type: cdk8s_plus_20.IApiResource The resource(s) to apply to. allow_create \u00b6 def allow_create ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_20.IApiResource The resource(s) to apply to. allow_delete \u00b6 def allow_delete ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_20.IApiResource The resource(s) to apply to. allow_delete_collection \u00b6 def allow_delete_collection ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_20.IApiResource The resource(s) to apply to. allow_get \u00b6 def allow_get ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_20.IApiResource The resource(s) to apply to. allow_list \u00b6 def allow_list ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_20.IApiResource The resource(s) to apply to. allow_patch \u00b6 def allow_patch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_20.IApiResource The resource(s) to apply to. allow_read \u00b6 def allow_read ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_20.IApiResource The resource(s) to apply to. allow_read_write \u00b6 def allow_read_write ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_20.IApiResource The resource(s) to apply to. allow_update \u00b6 def allow_update ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_20.IApiResource The resource(s) to apply to. allow_watch \u00b6 def allow_watch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_20.IApiResource The resource(s) to apply to. bind \u00b6 def bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_20.ISubject a list of subjects to bind to. Static Functions \u00b6 from_role_name \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Role . from_role_name ( name : str ) name Required \u00b6 Type: str The name of the role resource. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 rules : typing . List [ RolePolicyRule ] Type: typing.List[ cdk8s_plus_20.RolePolicyRule ] Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . RoleBinding ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , role : IRole ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: cdk8s_plus_20.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. Methods \u00b6 add_subjects \u00b6 def add_subjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_20.ISubject The subjects to add. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 role : IRole Type: cdk8s_plus_20.IRole subjects Required \u00b6 subjects : typing . List [ ISubject ] Type: typing.List[ cdk8s_plus_20.ISubject ] Secret \u00b6 Implements: cdk8s_plus_20.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Secret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , string_data : typing . Mapping [ str ] = None , type : str = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. string_data Optional \u00b6 Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 add_string_data \u00b6 def add_string_data ( key : str , value : str ) key Required \u00b6 Type: str Key. value Required \u00b6 Type: str Value. get_string_data \u00b6 def get_string_data ( key : str ) key Required \u00b6 Type: str Key. Static Functions \u00b6 from_secret_name \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Secret . from_secret_name ( name : str ) name Required \u00b6 Type: str The name of the secret to reference. Properties \u00b6 immutable Required \u00b6 immutable : bool Type: bool Whether or not the secret is immutable. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Service ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: cdk8s_plus_20.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 add_deployment \u00b6 def add_deployment ( depl : Deployment , name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None ) depl Required \u00b6 Type: cdk8s_plus_20.Deployment The deployment to expose. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the first container of the deployment. The port number the service will bind to. add_selector \u00b6 def add_selector ( label : str , value : str ) label Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. expose_via_ingress \u00b6 def expose_via_ingress ( path : str , ingress : IngressV1Beta1 = None ) path Required \u00b6 Type: str The path to expose the service under. ingress Optional \u00b6 Type: cdk8s_plus_20.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. serve \u00b6 def serve ( port : typing . Union [ int , float ], name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) port Required \u00b6 Type: typing.Union[int, float] The port definition. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. Properties \u00b6 ports Required \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_20.ServicePort ] Ports for this service. Use serve() to expose additional service ports. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. selector Required \u00b6 selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] Returns the labels which are used to select pods for this service. type Required \u00b6 type : ServiceType Type: cdk8s_plus_20.ServiceType Determines how the Service is exposed. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str The IP address of the service and is usually assigned randomly by the master. external_name Optional \u00b6 external_name : str Type: str The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s_plus_20.IServiceAccount , cdk8s_plus_20.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ServiceAccount ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_token : bool = None , secrets : typing . List [ ISecret ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_token Optional \u00b6 Type: bool Default: true Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 add_secret \u00b6 def add_secret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s_plus_20.ISecret The secret. Static Functions \u00b6 from_service_account_name \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ServiceAccount . from_service_account_name ( name : str ) name Required \u00b6 Type: str The name of the service account resource. Properties \u00b6 automount_token Required \u00b6 automount_token : bool Type: bool Whether or not a token is automatically mounted for this service account. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_20.ISecret ] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ServiceAccountTokenSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , service_account : IServiceAccount ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. service_account Required \u00b6 Type: cdk8s_plus_20.IServiceAccount The service account to store a secret for. SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . SshAuthSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , ssh_private_key : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ssh_private_key Required \u00b6 Type: str The SSH private key to use. StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . StatefulSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , service : Service , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None , strategy : StatefulSetUpdateStrategy = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_20.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. service Required \u00b6 Type: cdk8s_plus_20.Service Service to associate with the statefulset. pod_management_policy Optional \u00b6 Type: cdk8s_plus_20.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 Type: cdk8s_plus_20.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. Properties \u00b6 pod_management_policy Required \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_20.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 strategy : StatefulSetUpdateStrategy Type: cdk8s_plus_20.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . TlsSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , tls_cert : str , tls_key : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tls_cert Required \u00b6 Type: str The TLS cert. tls_key Required \u00b6 Type: str The TLS key. Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Workload ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_20.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. Methods \u00b6 select \u00b6 def select ( selectors : LabelSelector ) selectors Required \u00b6 Type: cdk8s_plus_20.LabelSelector Properties \u00b6 match_expressions Required \u00b6 match_expressions : typing . List [ LabelSelectorRequirement ] Type: typing.List[ cdk8s_plus_20.LabelSelectorRequirement ] The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. match_labels Required \u00b6 match_labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . AbstractPodProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_20.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . AddDeploymentOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . AddDirectoryOptions ( exclude : typing . List [ str ] = None , key_prefix : str = None ) exclude Optional \u00b6 exclude : typing . List [ str ] Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 key_prefix : str Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ApiResourceOptions ( api_group : str , resource_type : str ) api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . AwsElasticBlockStorePersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , volume_id : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_20.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volume_id Required \u00b6 volume_id : str Type: str Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . AwsElasticBlockStoreVolumeOptions ( fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . AzureDiskPersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_20.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. disk_name Required \u00b6 disk_name : str Type: str The Name of the data disk in the blob storage. disk_uri Required \u00b6 disk_uri : str Type: str The URI the data disk in the blob storage. caching_mode Optional \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_20.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_20.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. read_only Optional \u00b6 read_only : bool Type: bool Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . AzureDiskVolumeOptions ( caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , name : str = None , read_only : bool = None ) caching_mode Optional \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_20.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_20.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. read_only Optional \u00b6 read_only : bool Type: bool Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . BasicAuthSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , password : str , username : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 password : str Type: str The password or token for authentication. username Required \u00b6 username : str Type: str The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ClusterRoleBindingProps ( metadata : ApiObjectMetadata = None , role : IClusterRole ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 role : IClusterRole Type: cdk8s_plus_20.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ClusterRolePolicyRule ( endpoints : typing . List [ IApiEndpoint ], verbs : typing . List [ str ] ) endpoints Required \u00b6 endpoints : typing . List [ IApiEndpoint ] Type: typing.List[ cdk8s_plus_20.IApiEndpoint ] Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 verbs : typing . List [ str ] Type: typing.List[ str ] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ClusterRoleProps ( metadata : ApiObjectMetadata = None , aggregation_labels : typing . Mapping [ str ] = None , rules : typing . List [ ClusterRolePolicyRule ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregation_labels Optional \u00b6 aggregation_labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 rules : typing . List [ ClusterRolePolicyRule ] Type: typing.List[ cdk8s_plus_20.ClusterRolePolicyRule ] Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . CommandProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . CommonSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ConfigMapProps ( metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None , immutable : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ConfigMapVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 default_mode : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 items : typing . Mapping [ PathMapping ] Type: typing.Mapping[ cdk8s_plus_20.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. optional Optional \u00b6 optional : bool Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ContainerLifecycle ( post_start : Handler = None , pre_stop : Handler = None ) post_start Optional \u00b6 post_start : Handler Type: cdk8s_plus_20.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. pre_stop Optional \u00b6 pre_stop : Handler Type: cdk8s_plus_20.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ContainerProps ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 image : str Type: str Docker image name. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 env : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_20.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 lifecycle : ContainerLifecycle Type: cdk8s_plus_20.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 liveness : Probe Type: cdk8s_plus_20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 name : str Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 readiness : Probe Type: cdk8s_plus_20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 resources : ContainerResources Type: cdk8s_plus_20.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 security_context : ContainerSecurityContextProps Type: cdk8s_plus_20.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 startup : Probe Type: cdk8s_plus_20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 volume_mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_20.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 working_dir : str Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ContainerResources ( cpu : CpuResources , memory : MemoryResources ) cpu Required \u00b6 cpu : CpuResources Type: cdk8s_plus_20.CpuResources memory Required \u00b6 memory : MemoryResources Type: cdk8s_plus_20.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ContainerSecurityContextProps ( ensure_non_root : bool = None , group : typing . Union [ int , float ] = None , privileged : bool = None , read_only_root_filesystem : bool = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 ensure_non_root : bool Type: bool Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. privileged Optional \u00b6 privileged : bool Type: bool Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. read_only_root_filesystem Optional \u00b6 read_only_root_filesystem : bool Type: bool Default: false Whether this container has a read-only root filesystem. user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . CpuResources ( limit : Cpu , request : Cpu ) limit Required \u00b6 limit : Cpu Type: cdk8s_plus_20.Cpu request Required \u00b6 request : Cpu Type: cdk8s_plus_20.Cpu DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . DaemonSetProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , min_ready_seconds : typing . Union [ int , float ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_20.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. min_ready_seconds Optional \u00b6 min_ready_seconds : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . DeploymentProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , min_ready : Duration = None , progress_deadline : Duration = None , replicas : typing . Union [ int , float ] = None , strategy : DeploymentStrategy = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_20.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. min_ready Optional \u00b6 min_ready : Duration Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progress_deadline Optional \u00b6 progress_deadline : Duration Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 strategy : DeploymentStrategy Type: cdk8s_plus_20.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . DeploymentStrategyRollingUpdateOptions ( max_surge : PercentOrAbsolute = None , max_unavailable : PercentOrAbsolute = None ) max_surge Optional \u00b6 max_surge : PercentOrAbsolute Type: cdk8s_plus_20.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. max_unavailable Optional \u00b6 max_unavailable : PercentOrAbsolute Type: cdk8s_plus_20.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . DnsOption ( name : str , value : str = None ) name Required \u00b6 name : str Type: str Option name. value Optional \u00b6 value : str Type: str Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . DockerConfigSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , data : typing . Mapping [ typing . Any ] ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 data : typing . Mapping [ typing . Any ] Type: typing.Mapping[ typing.Any ] JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EmptyDirVolumeOptions ( medium : EmptyDirMedium = None , size_limit : Size = None ) medium Optional \u00b6 medium : EmptyDirMedium Type: cdk8s_plus_20.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 size_limit : Size Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValueFromConfigMapOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValueFromFieldRefOptions ( api_version : str = None , key : str = None ) api_version Optional \u00b6 api_version : str Type: str Version of the schema the FieldPath is written in terms of. key Optional \u00b6 key : str Type: str The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValueFromProcessOptions ( required : bool = None ) required Optional \u00b6 required : bool Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValueFromResourceOptions ( container : Container = None , divisor : str = None ) container Optional \u00b6 container : Container Type: cdk8s_plus_20.Container The container to select the value from. divisor Optional \u00b6 divisor : str Type: str The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValueFromSecretOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ExposeDeploymentViaIngressOptions ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None , ingress : IngressV1Beta1 = None ) name Optional \u00b6 name : str Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_20.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 ingress : IngressV1Beta1 Type: cdk8s_plus_20.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ExposeDeploymentViaServiceOptions ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_20.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ExposeServiceViaIngressOptions ( ingress : IngressV1Beta1 = None ) ingress Optional \u00b6 ingress : IngressV1Beta1 Type: cdk8s_plus_20.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . GCEPersistentDiskPersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , pd_name : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_20.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pd_name Required \u00b6 pd_name : str Type: str Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . GCEPersistentDiskVolumeOptions ( fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GroupProps \u00b6 Properties for Group . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . GroupProps ( name : str ) name Required \u00b6 name : str Type: str The name of the group. HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . HandlerFromHttpGetOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . HandlerFromTcpSocketOptions ( host : str = None , port : typing . Union [ int , float ] = None ) host Optional \u00b6 host : str Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . HostAlias ( hostnames : typing . List [ str ], ip : str ) hostnames Required \u00b6 hostnames : typing . List [ str ] Type: typing.List[ str ] Hostnames for the chosen IP address. ip Required \u00b6 ip : str Type: str IP address of the host file entry. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . HttpGetProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . IngressV1Beta1Props ( metadata : ApiObjectMetadata = None , default_backend : IngressV1Beta1Backend = None , rules : typing . List [ IngressV1Beta1Rule ] = None , tls : typing . List [ IngressV1Beta1Tls ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 default_backend : IngressV1Beta1Backend Type: cdk8s_plus_20.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 rules : typing . List [ IngressV1Beta1Rule ] Type: typing.List[ cdk8s_plus_20.IngressV1Beta1Rule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 tls : typing . List [ IngressV1Beta1Tls ] Type: typing.List[ cdk8s_plus_20.IngressV1Beta1Tls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . IngressV1Beta1Rule ( backend : IngressV1Beta1Backend , host : str = None , path : str = None ) backend Required \u00b6 backend : IngressV1Beta1Backend Type: cdk8s_plus_20.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 host : str Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 path : str Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . IngressV1Beta1Tls ( hosts : typing . List [ str ] = None , secret : ISecret = None ) hosts Optional \u00b6 hosts : typing . List [ str ] Type: typing.List[ str ] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 secret : ISecret Type: cdk8s_plus_20.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . JobProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_20.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . LabelSelectorRequirement ( key : str , operator : LabelSelectorRequirementOperator , values : typing . List [ str ] = None ) key Required \u00b6 key : str Type: str The label key that the selector applies to. operator Required \u00b6 operator : LabelSelectorRequirementOperator Type: cdk8s_plus_20.LabelSelectorRequirementOperator Represents a key\u2019s relationship to a set of values. values Optional \u00b6 values : typing . List [ str ] Type: typing.List[ str ] An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . MemoryResources ( limit : Size , request : Size ) limit Required \u00b6 limit : Size Type: cdk8s.Size request Required \u00b6 request : Size Type: cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . MountOptions ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_20.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PathMapping ( path : str , mode : typing . Union [ int , float ] = None ) path Required \u00b6 path : str Type: str The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 mode : typing . Union [ int , float ] Type: typing.Union[int, float] Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PersistentVolumeClaimProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , storage : Size = None , storage_class_name : str = None , volume : IPersistentVolume = None , volume_mode : PersistentVolumeMode = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_20.PersistentVolumeAccessMode ] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 volume : IPersistentVolume Type: cdk8s_plus_20.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PersistentVolumeClaimVolumeOptions ( name : str = None , read_only : bool = None ) name Optional \u00b6 name : str Type: str Default: Derived from the PVC name. The volume name. read_only Optional \u00b6 read_only : bool Type: bool Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_20.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PodDnsProps ( hostname : str = None , hostname_as_fqd_n : bool = None , nameservers : typing . List [ str ] = None , options : typing . List [ DnsOption ] = None , policy : DnsPolicy = None , searches : typing . List [ str ] = None , subdomain : str = None ) hostname Optional \u00b6 hostname : str Type: str Default: Set to a system-defined value. Specifies the hostname of the Pod. hostname_as_fqd_n Optional \u00b6 hostname_as_fqd_n : bool Type: bool Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 nameservers : typing . List [ str ] Type: typing.List[ str ] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 options : typing . List [ DnsOption ] Type: typing.List[ cdk8s_plus_20.DnsOption ] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 policy : DnsPolicy Type: cdk8s_plus_20.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 searches : typing . List [ str ] Type: typing.List[ str ] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 subdomain : str Type: str Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PodProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_20.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PodSecurityContextProps ( ensure_non_root : bool = None , fs_group : typing . Union [ int , float ] = None , fs_group_change_policy : FsGroupChangePolicy = None , group : typing . Union [ int , float ] = None , sysctls : typing . List [ Sysctl ] = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 ensure_non_root : bool Type: bool Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fs_group Optional \u00b6 fs_group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fs_group_change_policy Optional \u00b6 fs_group_change_policy : FsGroupChangePolicy Type: cdk8s_plus_20.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 sysctls : typing . List [ Sysctl ] Type: typing.List[ cdk8s_plus_20.Sysctl ] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ResourceProps ( metadata : ApiObjectMetadata = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . RoleBindingProps ( metadata : ApiObjectMetadata = None , role : IRole ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 role : IRole Type: cdk8s_plus_20.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . RolePolicyRule ( resources : typing . List [ IApiResource ], verbs : typing . List [ str ] ) resources Required \u00b6 resources : typing . List [ IApiResource ] Type: typing.List[ cdk8s_plus_20.IApiResource ] Resources this rule applies to. verbs Required \u00b6 verbs : typing . List [ str ] Type: typing.List[ str ] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . RoleProps ( metadata : ApiObjectMetadata = None , rules : typing . List [ RolePolicyRule ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 rules : typing . List [ RolePolicyRule ] Type: typing.List[ cdk8s_plus_20.RolePolicyRule ] Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . SecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , string_data : typing . Mapping [ str ] = None , type : str = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. string_data Optional \u00b6 string_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 type : str Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . SecretValue ( key : str , secret : ISecret ) key Required \u00b6 key : str Type: str The JSON key. secret Required \u00b6 secret : ISecret Type: cdk8s_plus_20.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . SecretVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 default_mode : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 items : typing . Mapping [ PathMapping ] Type: typing.Mapping[ cdk8s_plus_20.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. optional Optional \u00b6 optional : bool Type: bool Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ServiceAccountProps ( metadata : ApiObjectMetadata = None , automount_token : bool = None , secrets : typing . List [ ISecret ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_token Optional \u00b6 automount_token : bool Type: bool Default: true Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_20.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ServiceAccountTokenSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , service_account : IServiceAccount ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. service_account Required \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount The service account to store a secret for. ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ServiceIngressV1BetaBackendOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ServicePort ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ServicePortOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ServiceProps ( metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 external_i_ps : typing . List [ str ] Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 external_name : str Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 load_balancer_source_ranges : typing . List [ str ] Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_20.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 type : ServiceType Type: cdk8s_plus_20.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . SshAuthSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , ssh_private_key : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ssh_private_key Required \u00b6 ssh_private_key : str Type: str The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . StatefulSetProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , service : Service , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None , strategy : StatefulSetUpdateStrategy = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_20.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. service Required \u00b6 service : Service Type: cdk8s_plus_20.Service Service to associate with the statefulset. pod_management_policy Optional \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_20.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 strategy : StatefulSetUpdateStrategy Type: cdk8s_plus_20.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . StatefulSetUpdateStrategyRollingUpdateOptions ( partition : typing . Union [ int , float ] = None ) partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Sysctl ( name : str , value : str ) name Required \u00b6 name : str Type: str Name of a property to set. value Required \u00b6 value : str Type: str Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . TcpSocketProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , host : str = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 host : str Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . TlsSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , tls_cert : str , tls_key : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tls_cert Required \u00b6 tls_cert : str Type: str The TLS cert. tls_key Required \u00b6 tls_key : str Type: str The TLS key. UserProps \u00b6 Properties for User . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . UserProps ( name : str ) name Required \u00b6 name : str Type: str The name of the user. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . VolumeMount ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None , path : str , volume : Volume ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_20.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 path : str Type: str Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 volume : Volume Type: cdk8s_plus_20.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . WorkloadProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_20.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. Classes \u00b6 ApiResource \u00b6 Implements: cdk8s_plus_20.IApiResource , cdk8s_plus_20.IApiEndpoint Represents information about an API resource type. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Static Functions \u00b6 custom \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ApiResource . custom ( api_group : str , resource_type : str ) api_group Required \u00b6 Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for Ingress. JOBS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for Job. LEASES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: cdk8s_plus_20.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_20.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_20.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_20.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_20.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_20.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 add_env \u00b6 def add_env ( name : str , value : EnvValue ) name Required \u00b6 Type: str The variable name. value Required \u00b6 Type: cdk8s_plus_20.EnvValue The variable value. mount \u00b6 def mount ( path : str , storage : IStorage , propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) path Required \u00b6 Type: str The desired path in the container. storage Required \u00b6 Type: cdk8s_plus_20.IStorage The storage to mount. propagation Optional \u00b6 Type: cdk8s_plus_20.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. Properties \u00b6 env Required \u00b6 env : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_20.EnvValue ] The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 image : str Type: str The container image. image_pull_policy Required \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_20.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_20.VolumeMount ] Volume mounts configured for this container. name Required \u00b6 name : str Type: str The name of the container. security_context Required \u00b6 security_context : ContainerSecurityContext Type: cdk8s_plus_20.ContainerSecurityContext The security context of the container. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Arguments to the entrypoint. command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port this container exposes. resources Optional \u00b6 resources : ContainerResources Type: cdk8s_plus_20.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ working_dir Optional \u00b6 working_dir : str Type: str The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ContainerSecurityContext ( ensure_non_root : bool = None , group : typing . Union [ int , float ] = None , privileged : bool = None , read_only_root_filesystem : bool = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 Type: bool Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. privileged Optional \u00b6 Type: bool Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. read_only_root_filesystem Optional \u00b6 Type: bool Default: false Whether this container has a read-only root filesystem. user Optional \u00b6 Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensure_non_root Required \u00b6 ensure_non_root : bool Type: bool privileged Required \u00b6 privileged : bool Type: bool read_only_root_filesystem Required \u00b6 read_only_root_filesystem : bool Type: bool group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Cpu . millis ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] units \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Cpu . units ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] Properties \u00b6 amount Required \u00b6 amount : str Type: str DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . DeploymentStrategy . recreate () rolling_update \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . DeploymentStrategy . rolling_update ( max_surge : PercentOrAbsolute = None , max_unavailable : PercentOrAbsolute = None ) max_surge Optional \u00b6 Type: cdk8s_plus_20.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. max_unavailable Optional \u00b6 Type: cdk8s_plus_20.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValue . from_config_map ( config_map : IConfigMap , key : str , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_20.IConfigMap The config map. key Required \u00b6 Type: str The key to extract the value from. optional Optional \u00b6 Type: bool Default: false Specify whether the ConfigMap or its key must be defined. from_field_ref \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValue . from_field_ref ( field_path : EnvFieldPaths , api_version : str = None , key : str = None ) field_path Required \u00b6 Type: cdk8s_plus_20.EnvFieldPaths : The field reference. api_version Optional \u00b6 Type: str Version of the schema the FieldPath is written in terms of. key Optional \u00b6 Type: str The key to select the pod label or annotation. from_process \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValue . from_process ( key : str , required : bool = None ) key Required \u00b6 Type: str The key to read. required Optional \u00b6 Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. from_resource \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValue . from_resource ( resource : ResourceFieldPaths , container : Container = None , divisor : str = None ) resource Required \u00b6 Type: cdk8s_plus_20.ResourceFieldPaths : Resource to select the value from. container Optional \u00b6 Type: cdk8s_plus_20.Container The container to select the value from. divisor Optional \u00b6 Type: str The output format of the exposed resource. from_secret_value \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValue . from_secret_value ( key : str , secret : ISecret , optional : bool = None ) key Required \u00b6 Type: str The JSON key. secret Required \u00b6 Type: cdk8s_plus_20.ISecret The secret. optional Optional \u00b6 Type: bool Default: false Specify whether the Secret or its key must be defined. from_value \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValue . from_value ( value : str ) value Required \u00b6 Type: str The value. Properties \u00b6 value Optional \u00b6 value : typing . Any Type: typing.Any value_from Optional \u00b6 value_from : typing . Any Type: typing.Any Group \u00b6 Implements: cdk8s_plus_20.ISubject Represents a group. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Group ( name : str ) name Required \u00b6 Type: str The name of the group. Properties \u00b6 kind Required \u00b6 kind : str Type: str Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 name : str Type: str Name of the object being referenced. api_group Optional \u00b6 api_group : str Type: str APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Handler . from_command ( command : typing . List [ str ] ) command Required \u00b6 Type: typing.List[ str ] The command to execute. from_http_get \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Handler . from_http_get ( path : str , port : typing . Union [ int , float ] = None ) path Required \u00b6 Type: str The URL path to hit. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. from_tcp_socket \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Handler . from_tcp_socket ( host : str = None , port : typing . Union [ int , float ] = None ) host Optional \u00b6 Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 from_service \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . IngressV1Beta1Backend . from_service ( serv : Service , port : typing . Union [ int , float ] = None ) serv Required \u00b6 Type: cdk8s_plus_20.Service The service object. port Optional \u00b6 Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. LabelSelector \u00b6 A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors Static Functions \u00b6 does_not_exist \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . LabelSelector . does_not_exist ( key : str ) key Required \u00b6 Type: str exists \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . LabelSelector . exists ( key : str ) key Required \u00b6 Type: str in \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . LabelSelector . in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] is \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . LabelSelector . is ( key : str , value : str , apply_to_template : bool = None ) key Required \u00b6 Type: str value Required \u00b6 Type: str apply_to_template Optional \u00b6 Type: bool not_in \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . LabelSelector . not_in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] Properties \u00b6 apply_to_template Required \u00b6 apply_to_template : bool Type: bool key Required \u00b6 key : str Type: str operator Optional \u00b6 operator : LabelSelectorRequirementOperator Type: cdk8s_plus_20.LabelSelectorRequirementOperator values Optional \u00b6 values : typing . List [ str ] Type: typing.List[ str ] NonApiResource \u00b6 Implements: cdk8s_plus_20.IApiEndpoint Factory for creating non api resources. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Static Functions \u00b6 of \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . NonApiResource . of ( url : str ) url Required \u00b6 Type: str PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 is_zero \u00b6 def is_zero () Static Functions \u00b6 absolute \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PercentOrAbsolute . absolute ( num : typing . Union [ int , float ] ) num Required \u00b6 Type: typing.Union[int, float] percent \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PercentOrAbsolute . percent ( percent : typing . Union [ int , float ] ) percent Required \u00b6 Type: typing.Union[int, float] Properties \u00b6 value Required \u00b6 value : typing . Any Type: typing.Any PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PodDns ( hostname : str = None , hostname_as_fqd_n : bool = None , nameservers : typing . List [ str ] = None , options : typing . List [ DnsOption ] = None , policy : DnsPolicy = None , searches : typing . List [ str ] = None , subdomain : str = None ) hostname Optional \u00b6 Type: str Default: Set to a system-defined value. Specifies the hostname of the Pod. hostname_as_fqd_n Optional \u00b6 Type: bool Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 Type: typing.List[ str ] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 Type: typing.List[ cdk8s_plus_20.DnsOption ] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 Type: cdk8s_plus_20.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 Type: typing.List[ str ] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 Type: str Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. Methods \u00b6 add_nameserver \u00b6 def add_nameserver ( nameservers : str ) nameservers Required \u00b6 Type: str add_option \u00b6 def add_option ( name : str , value : str = None ) name Required \u00b6 Type: str Option name. value Optional \u00b6 Type: str Default: No value. Option value. add_search \u00b6 def add_search ( searches : str ) searches Required \u00b6 Type: str Properties \u00b6 hostname_as_fqd_n Required \u00b6 hostname_as_fqd_n : bool Type: bool Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 nameservers : typing . List [ str ] Type: typing.List[ str ] Nameservers defined for this pod. options Required \u00b6 options : typing . List [ DnsOption ] Type: typing.List[ cdk8s_plus_20.DnsOption ] Custom dns options defined for this pod. policy Required \u00b6 policy : DnsPolicy Type: cdk8s_plus_20.DnsPolicy The DNS policy of this pod. searches Required \u00b6 searches : typing . List [ str ] Type: typing.List[ str ] Search domains defined for this pod. hostname Optional \u00b6 hostname : str Type: str The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 subdomain : str Type: str The configured subdomain of the pod. PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PodSecurityContext ( ensure_non_root : bool = None , fs_group : typing . Union [ int , float ] = None , fs_group_change_policy : FsGroupChangePolicy = None , group : typing . Union [ int , float ] = None , sysctls : typing . List [ Sysctl ] = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 Type: bool Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fs_group Optional \u00b6 Type: typing.Union[int, float] Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fs_group_change_policy Optional \u00b6 Type: cdk8s_plus_20.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 Type: typing.List[ cdk8s_plus_20.Sysctl ] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensure_non_root Required \u00b6 ensure_non_root : bool Type: bool fs_group_change_policy Required \u00b6 fs_group_change_policy : FsGroupChangePolicy Type: cdk8s_plus_20.FsGroupChangePolicy sysctls Required \u00b6 sysctls : typing . List [ Sysctl ] Type: typing.List[ cdk8s_plus_20.Sysctl ] fs_group Optional \u00b6 fs_group : typing . Union [ int , float ] Type: typing.Union[int, float] group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Probe . from_command ( command : typing . List [ str ], failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) command Required \u00b6 Type: typing.List[ str ] The command to execute. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes from_http_get \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Probe . from_http_get ( path : str , failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) path Required \u00b6 Type: str The URL path to hit. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. from_tcp_socket \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Probe . from_tcp_socket ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , host : str = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 on_delete \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . StatefulSetUpdateStrategy . on_delete () rolling_update \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . StatefulSetUpdateStrategy . rolling_update ( partition : typing . Union [ int , float ] = None ) partition Optional \u00b6 Type: typing.Union[int, float] Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions User \u00b6 Implements: cdk8s_plus_20.ISubject Represents a user. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . User ( name : str ) name Required \u00b6 Type: str The name of the user. Properties \u00b6 kind Required \u00b6 kind : str Type: str Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 name : str Type: str Name of the object being referenced. api_group Optional \u00b6 api_group : str Type: str APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Volume \u00b6 Implements: cdk8s_plus_20.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 as_volume \u00b6 def as_volume () Static Functions \u00b6 from_aws_elastic_block_store \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Volume . from_aws_elastic_block_store ( volume_id : str , fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) volume_id Required \u00b6 Type: str fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 Type: str Default: auto-generated The volume name. partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore from_azure_disk \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Volume . from_azure_disk ( disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , name : str = None , read_only : bool = None ) disk_name Required \u00b6 Type: str disk_uri Required \u00b6 Type: str caching_mode Optional \u00b6 Type: cdk8s_plus_20.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: cdk8s_plus_20.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 Type: str Default: auto-generated The volume name. read_only Optional \u00b6 Type: bool Default: false Force the ReadOnly setting in VolumeMounts. from_config_map \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Volume . from_config_map ( config_map : IConfigMap , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_20.IConfigMap The config map to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_20.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. from_empty_dir \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Volume . from_empty_dir ( name : str , medium : EmptyDirMedium = None , size_limit : Size = None ) name Required \u00b6 Type: str medium Optional \u00b6 Type: cdk8s_plus_20.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. from_gce_persistent_disk \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Volume . from_gce_persistent_disk ( pd_name : str , fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) pd_name Required \u00b6 Type: str fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 Type: str Default: auto-generated The volume name. partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore from_persistent_volume_claim \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Volume . from_persistent_volume_claim ( claim : IPersistentVolumeClaim , name : str = None , read_only : bool = None ) claim Required \u00b6 Type: cdk8s_plus_20.IPersistentVolumeClaim name Optional \u00b6 Type: str Default: Derived from the PVC name. The volume name. read_only Optional \u00b6 Type: bool Default: false Will force the ReadOnly setting in VolumeMounts. from_secret \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Volume . from_secret ( secr : ISecret , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) secr Required \u00b6 Type: cdk8s_plus_20.ISecret The secret to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_20.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the secret or its keys must be defined. Properties \u00b6 name Required \u00b6 name : str Type: str Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: cdk8s_plus_20.AbstractPod , cdk8s_plus_20.ApiResource , cdk8s_plus_20.AwsElasticBlockStorePersistentVolume , cdk8s_plus_20.AzureDiskPersistentVolume , cdk8s_plus_20.BasicAuthSecret , cdk8s_plus_20.ClusterRole , cdk8s_plus_20.ClusterRoleBinding , cdk8s_plus_20.ConfigMap , cdk8s_plus_20.DaemonSet , cdk8s_plus_20.Deployment , cdk8s_plus_20.DockerConfigSecret , cdk8s_plus_20.GCEPersistentDiskPersistentVolume , cdk8s_plus_20.IngressV1Beta1 , cdk8s_plus_20.Job , cdk8s_plus_20.NonApiResource , cdk8s_plus_20.PersistentVolume , cdk8s_plus_20.PersistentVolumeClaim , cdk8s_plus_20.Pod , cdk8s_plus_20.Resource , cdk8s_plus_20.Role , cdk8s_plus_20.RoleBinding , cdk8s_plus_20.Secret , cdk8s_plus_20.Service , cdk8s_plus_20.ServiceAccount , cdk8s_plus_20.ServiceAccountTokenSecret , cdk8s_plus_20.SshAuthSecret , cdk8s_plus_20.StatefulSet , cdk8s_plus_20.TlsSecret , cdk8s_plus_20.Workload , cdk8s_plus_20.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () IApiResource \u00b6 Implemented By: cdk8s_plus_20.AbstractPod , cdk8s_plus_20.ApiResource , cdk8s_plus_20.AwsElasticBlockStorePersistentVolume , cdk8s_plus_20.AzureDiskPersistentVolume , cdk8s_plus_20.BasicAuthSecret , cdk8s_plus_20.ClusterRole , cdk8s_plus_20.ClusterRoleBinding , cdk8s_plus_20.ConfigMap , cdk8s_plus_20.DaemonSet , cdk8s_plus_20.Deployment , cdk8s_plus_20.DockerConfigSecret , cdk8s_plus_20.GCEPersistentDiskPersistentVolume , cdk8s_plus_20.IngressV1Beta1 , cdk8s_plus_20.Job , cdk8s_plus_20.PersistentVolume , cdk8s_plus_20.PersistentVolumeClaim , cdk8s_plus_20.Pod , cdk8s_plus_20.Resource , cdk8s_plus_20.Role , cdk8s_plus_20.RoleBinding , cdk8s_plus_20.Secret , cdk8s_plus_20.Service , cdk8s_plus_20.ServiceAccount , cdk8s_plus_20.ServiceAccountTokenSecret , cdk8s_plus_20.SshAuthSecret , cdk8s_plus_20.StatefulSet , cdk8s_plus_20.TlsSecret , cdk8s_plus_20.Workload , cdk8s_plus_20.IApiResource Represents a resource or collection of resources. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resource_name Optional \u00b6 resource_name : str Type: str The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.ClusterRole , cdk8s_plus_20.IClusterRole Represents a cluster-level role. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IConfigMap \u00b6 Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.ConfigMap , cdk8s_plus_20.IConfigMap Represents a config map. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IPersistentVolume \u00b6 Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.AwsElasticBlockStorePersistentVolume , cdk8s_plus_20.AzureDiskPersistentVolume , cdk8s_plus_20.GCEPersistentDiskPersistentVolume , cdk8s_plus_20.PersistentVolume , cdk8s_plus_20.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.PersistentVolumeClaim , cdk8s_plus_20.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IResource \u00b6 Implemented By: cdk8s_plus_20.AbstractPod , cdk8s_plus_20.AwsElasticBlockStorePersistentVolume , cdk8s_plus_20.AzureDiskPersistentVolume , cdk8s_plus_20.BasicAuthSecret , cdk8s_plus_20.ClusterRole , cdk8s_plus_20.ClusterRoleBinding , cdk8s_plus_20.ConfigMap , cdk8s_plus_20.DaemonSet , cdk8s_plus_20.Deployment , cdk8s_plus_20.DockerConfigSecret , cdk8s_plus_20.GCEPersistentDiskPersistentVolume , cdk8s_plus_20.IngressV1Beta1 , cdk8s_plus_20.Job , cdk8s_plus_20.PersistentVolume , cdk8s_plus_20.PersistentVolumeClaim , cdk8s_plus_20.Pod , cdk8s_plus_20.Resource , cdk8s_plus_20.Role , cdk8s_plus_20.RoleBinding , cdk8s_plus_20.Secret , cdk8s_plus_20.Service , cdk8s_plus_20.ServiceAccount , cdk8s_plus_20.ServiceAccountTokenSecret , cdk8s_plus_20.SshAuthSecret , cdk8s_plus_20.StatefulSet , cdk8s_plus_20.TlsSecret , cdk8s_plus_20.Workload , cdk8s_plus_20.IClusterRole , cdk8s_plus_20.IConfigMap , cdk8s_plus_20.IPersistentVolume , cdk8s_plus_20.IPersistentVolumeClaim , cdk8s_plus_20.IResource , cdk8s_plus_20.IRole , cdk8s_plus_20.ISecret , cdk8s_plus_20.IServiceAccount Represents a resource. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IRole \u00b6 Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.ClusterRole , cdk8s_plus_20.Role , cdk8s_plus_20.IRole A reference to any Role or ClusterRole. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.BasicAuthSecret , cdk8s_plus_20.DockerConfigSecret , cdk8s_plus_20.Secret , cdk8s_plus_20.ServiceAccountTokenSecret , cdk8s_plus_20.SshAuthSecret , cdk8s_plus_20.TlsSecret , cdk8s_plus_20.ISecret Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.ServiceAccount , cdk8s_plus_20.IServiceAccount Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IStorage \u00b6 Implemented By: cdk8s_plus_20.AwsElasticBlockStorePersistentVolume , cdk8s_plus_20.AzureDiskPersistentVolume , cdk8s_plus_20.GCEPersistentDiskPersistentVolume , cdk8s_plus_20.PersistentVolume , cdk8s_plus_20.Volume , cdk8s_plus_20.IStorage Represents a piece of storage in the cluster. Methods \u00b6 as_volume \u00b6 def as_volume () ISubject \u00b6 Implemented By: cdk8s_plus_20.Group , cdk8s_plus_20.ServiceAccount , cdk8s_plus_20.User , cdk8s_plus_20.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Properties \u00b6 kind Required \u00b6 kind : str Type: str Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 name : str Type: str Name of the object being referenced. api_group Optional \u00b6 api_group : str Type: str APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 namespace : str Type: str Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. LabelSelectorRequirementOperator \u00b6 Possible operators. IN \u00b6 In. NOT_IN \u00b6 NotIn. EXISTS \u00b6 Exists. DOES_NOT_EXIST \u00b6 DoesNotExist. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"Python"},{"location":"reference/cdk8s-plus-20/python/#cdk8s-plus-20-python","text":"","title":"cdk8s-plus-20 (Python) "},{"location":"reference/cdk8s-plus-20/python/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-20/python/#abstractpod","text":"","title":"AbstractPod "},{"location":"reference/cdk8s-plus-20/python/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-20/python/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-20/python/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-20/python/#clusterrole","text":"Implements: cdk8s_plus_20.IClusterRole , cdk8s_plus_20.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-20/python/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-20/python/#configmap","text":"Implements: cdk8s_plus_20.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-20/python/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-20/python/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-20/python/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-20/python/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-20/python/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-20/python/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-20/python/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-20/python/#persistentvolume","text":"Implements: cdk8s_plus_20.IPersistentVolume , cdk8s_plus_20.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-20/python/#persistentvolumeclaim","text":"Implements: cdk8s_plus_20.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-20/python/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-20/python/#resource","text":"Implements: cdk8s_plus_20.IResource , cdk8s_plus_20.IApiResource , cdk8s_plus_20.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-20/python/#role","text":"Implements: cdk8s_plus_20.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-20/python/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-20/python/#secret","text":"Implements: cdk8s_plus_20.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-20/python/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-20/python/#serviceaccount","text":"Implements: cdk8s_plus_20.IServiceAccount , cdk8s_plus_20.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-20/python/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-20/python/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-20/python/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-20/python/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-20/python/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-20/python/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-20/python/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-20/python/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-20/python/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-20/python/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-20/python/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-20/python/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-20/python/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-20/python/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-20/python/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-20/python/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-20/python/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-20/python/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-20/python/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-20/python/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-20/python/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-20/python/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-20/python/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-20/python/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-20/python/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-20/python/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-20/python/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-20/python/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-20/python/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-20/python/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-20/python/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-20/python/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-20/python/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-20/python/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-20/python/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-20/python/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-20/python/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-20/python/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-20/python/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-20/python/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-20/python/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-20/python/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-20/python/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-20/python/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-20/python/#groupprops","text":"Properties for Group .","title":"GroupProps "},{"location":"reference/cdk8s-plus-20/python/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-20/python/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-20/python/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-20/python/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-20/python/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-20/python/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-20/python/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-20/python/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-20/python/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-20/python/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-20/python/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-20/python/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-20/python/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-20/python/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-20/python/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-20/python/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-20/python/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-20/python/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-20/python/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-20/python/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-20/python/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-20/python/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-20/python/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-20/python/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-20/python/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-20/python/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-20/python/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-20/python/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-20/python/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-20/python/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-20/python/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-20/python/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-20/python/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-20/python/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-20/python/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-20/python/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-20/python/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-20/python/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-20/python/#userprops","text":"Properties for User .","title":"UserProps "},{"location":"reference/cdk8s-plus-20/python/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-20/python/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-20/python/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-20/python/#apiresource","text":"Implements: cdk8s_plus_20.IApiResource , cdk8s_plus_20.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-20/python/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-20/python/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-20/python/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-20/python/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-20/python/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-20/python/#group","text":"Implements: cdk8s_plus_20.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-20/python/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-20/python/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-20/python/#labelselector","text":"A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors","title":"LabelSelector "},{"location":"reference/cdk8s-plus-20/python/#nonapiresource","text":"Implements: cdk8s_plus_20.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-20/python/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-20/python/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-20/python/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-20/python/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-20/python/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-20/python/#user","text":"Implements: cdk8s_plus_20.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-20/python/#volume","text":"Implements: cdk8s_plus_20.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-20/python/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-20/python/#iapiendpoint","text":"Implemented By: cdk8s_plus_20.AbstractPod , cdk8s_plus_20.ApiResource , cdk8s_plus_20.AwsElasticBlockStorePersistentVolume , cdk8s_plus_20.AzureDiskPersistentVolume , cdk8s_plus_20.BasicAuthSecret , cdk8s_plus_20.ClusterRole , cdk8s_plus_20.ClusterRoleBinding , cdk8s_plus_20.ConfigMap , cdk8s_plus_20.DaemonSet , cdk8s_plus_20.Deployment , cdk8s_plus_20.DockerConfigSecret , cdk8s_plus_20.GCEPersistentDiskPersistentVolume , cdk8s_plus_20.IngressV1Beta1 , cdk8s_plus_20.Job , cdk8s_plus_20.NonApiResource , cdk8s_plus_20.PersistentVolume , cdk8s_plus_20.PersistentVolumeClaim , cdk8s_plus_20.Pod , cdk8s_plus_20.Resource , cdk8s_plus_20.Role , cdk8s_plus_20.RoleBinding , cdk8s_plus_20.Secret , cdk8s_plus_20.Service , cdk8s_plus_20.ServiceAccount , cdk8s_plus_20.ServiceAccountTokenSecret , cdk8s_plus_20.SshAuthSecret , cdk8s_plus_20.StatefulSet , cdk8s_plus_20.TlsSecret , cdk8s_plus_20.Workload , cdk8s_plus_20.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-20/python/#iapiresource","text":"Implemented By: cdk8s_plus_20.AbstractPod , cdk8s_plus_20.ApiResource , cdk8s_plus_20.AwsElasticBlockStorePersistentVolume , cdk8s_plus_20.AzureDiskPersistentVolume , cdk8s_plus_20.BasicAuthSecret , cdk8s_plus_20.ClusterRole , cdk8s_plus_20.ClusterRoleBinding , cdk8s_plus_20.ConfigMap , cdk8s_plus_20.DaemonSet , cdk8s_plus_20.Deployment , cdk8s_plus_20.DockerConfigSecret , cdk8s_plus_20.GCEPersistentDiskPersistentVolume , cdk8s_plus_20.IngressV1Beta1 , cdk8s_plus_20.Job , cdk8s_plus_20.PersistentVolume , cdk8s_plus_20.PersistentVolumeClaim , cdk8s_plus_20.Pod , cdk8s_plus_20.Resource , cdk8s_plus_20.Role , cdk8s_plus_20.RoleBinding , cdk8s_plus_20.Secret , cdk8s_plus_20.Service , cdk8s_plus_20.ServiceAccount , cdk8s_plus_20.ServiceAccountTokenSecret , cdk8s_plus_20.SshAuthSecret , cdk8s_plus_20.StatefulSet , cdk8s_plus_20.TlsSecret , cdk8s_plus_20.Workload , cdk8s_plus_20.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-20/python/#iclusterrole","text":"Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.ClusterRole , cdk8s_plus_20.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-20/python/#iconfigmap","text":"Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.ConfigMap , cdk8s_plus_20.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-20/python/#ipersistentvolume","text":"Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.AwsElasticBlockStorePersistentVolume , cdk8s_plus_20.AzureDiskPersistentVolume , cdk8s_plus_20.GCEPersistentDiskPersistentVolume , cdk8s_plus_20.PersistentVolume , cdk8s_plus_20.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-20/python/#ipersistentvolumeclaim","text":"Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.PersistentVolumeClaim , cdk8s_plus_20.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-20/python/#iresource","text":"Implemented By: cdk8s_plus_20.AbstractPod , cdk8s_plus_20.AwsElasticBlockStorePersistentVolume , cdk8s_plus_20.AzureDiskPersistentVolume , cdk8s_plus_20.BasicAuthSecret , cdk8s_plus_20.ClusterRole , cdk8s_plus_20.ClusterRoleBinding , cdk8s_plus_20.ConfigMap , cdk8s_plus_20.DaemonSet , cdk8s_plus_20.Deployment , cdk8s_plus_20.DockerConfigSecret , cdk8s_plus_20.GCEPersistentDiskPersistentVolume , cdk8s_plus_20.IngressV1Beta1 , cdk8s_plus_20.Job , cdk8s_plus_20.PersistentVolume , cdk8s_plus_20.PersistentVolumeClaim , cdk8s_plus_20.Pod , cdk8s_plus_20.Resource , cdk8s_plus_20.Role , cdk8s_plus_20.RoleBinding , cdk8s_plus_20.Secret , cdk8s_plus_20.Service , cdk8s_plus_20.ServiceAccount , cdk8s_plus_20.ServiceAccountTokenSecret , cdk8s_plus_20.SshAuthSecret , cdk8s_plus_20.StatefulSet , cdk8s_plus_20.TlsSecret , cdk8s_plus_20.Workload , cdk8s_plus_20.IClusterRole , cdk8s_plus_20.IConfigMap , cdk8s_plus_20.IPersistentVolume , cdk8s_plus_20.IPersistentVolumeClaim , cdk8s_plus_20.IResource , cdk8s_plus_20.IRole , cdk8s_plus_20.ISecret , cdk8s_plus_20.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-20/python/#irole","text":"Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.ClusterRole , cdk8s_plus_20.Role , cdk8s_plus_20.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-20/python/#isecret","text":"Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.BasicAuthSecret , cdk8s_plus_20.DockerConfigSecret , cdk8s_plus_20.Secret , cdk8s_plus_20.ServiceAccountTokenSecret , cdk8s_plus_20.SshAuthSecret , cdk8s_plus_20.TlsSecret , cdk8s_plus_20.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-20/python/#iserviceaccount","text":"Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.ServiceAccount , cdk8s_plus_20.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-20/python/#istorage","text":"Implemented By: cdk8s_plus_20.AwsElasticBlockStorePersistentVolume , cdk8s_plus_20.AzureDiskPersistentVolume , cdk8s_plus_20.GCEPersistentDiskPersistentVolume , cdk8s_plus_20.PersistentVolume , cdk8s_plus_20.Volume , cdk8s_plus_20.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-20/python/#isubject","text":"Implemented By: cdk8s_plus_20.Group , cdk8s_plus_20.ServiceAccount , cdk8s_plus_20.User , cdk8s_plus_20.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"ISubject "},{"location":"reference/cdk8s-plus-20/python/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-20/python/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-20/python/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-20/python/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-20/python/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-20/python/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-20/python/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-20/python/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-20/python/#labelselectorrequirementoperator","text":"Possible operators.","title":"LabelSelectorRequirementOperator "},{"location":"reference/cdk8s-plus-20/python/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-20/python/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-20/python/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-20/python/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-20/python/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-20/python/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-20/python/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-20/python/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-20/python/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-20/typescript/","text":"cdk8s-plus-20 (TypeScript) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Initializers \u00b6 import { AbstractPod } from 'cdk8s-plus-20' new AbstractPod ( scope : Construct , id : string , props? : AbstractPodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.AbstractPodProps Methods \u00b6 addContainer \u00b6 public addContainer ( cont : ContainerProps ) cont Required \u00b6 Type: cdk8s-plus-20.ContainerProps addHostAlias \u00b6 public addHostAlias ( hostAlias : HostAlias ) hostAlias Required \u00b6 Type: cdk8s-plus-20.HostAlias addInitContainer \u00b6 public addInitContainer ( cont : ContainerProps ) cont Required \u00b6 Type: cdk8s-plus-20.ContainerProps addVolume \u00b6 public addVolume ( vol : Volume ) vol Required \u00b6 Type: cdk8s-plus-20.Volume Properties \u00b6 automountServiceAccountToken Required \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-20.Container [] dns Required \u00b6 public readonly dns : PodDns ; Type: cdk8s-plus-20.PodDns hostAliases Required \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-20.HostAlias [] initContainers Required \u00b6 public readonly initContainers : Container []; Type: cdk8s-plus-20.Container [] securityContext Required \u00b6 public readonly securityContext : PodSecurityContext ; Type: cdk8s-plus-20.PodSecurityContext volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-20.DockerConfigSecret restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import { AwsElasticBlockStorePersistentVolume } from 'cdk8s-plus-20' new AwsElasticBlockStorePersistentVolume ( scope : Construct , id : string , props : AwsElasticBlockStorePersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-20.AwsElasticBlockStorePersistentVolumeProps Properties \u00b6 fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. volumeId Required \u00b6 public readonly volumeId : string ; Type: string Volume id of this volume. partition Optional \u00b6 public readonly partition : number ; Type: number Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import { AzureDiskPersistentVolume } from 'cdk8s-plus-20' new AzureDiskPersistentVolume ( scope : Construct , id : string , props : AzureDiskPersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-20.AzureDiskPersistentVolumeProps Properties \u00b6 azureKind Required \u00b6 public readonly azureKind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-20.AzureDiskPersistentVolumeKind Azure kind of this volume. cachingMode Required \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-20.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. diskName Required \u00b6 public readonly diskName : string ; Type: string Disk name of this volume. diskUri Required \u00b6 public readonly diskUri : string ; Type: string Disk URI of this volume. fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import { BasicAuthSecret } from 'cdk8s-plus-20' new BasicAuthSecret ( scope : Construct , id : string , props : BasicAuthSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-20.BasicAuthSecretProps ClusterRole \u00b6 Implements: cdk8s-plus-20.IClusterRole , cdk8s-plus-20.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import { ClusterRole } from 'cdk8s-plus-20' new ClusterRole ( scope : Construct , id : string , props? : ClusterRoleProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.ClusterRoleProps Methods \u00b6 aggregate \u00b6 public aggregate ( key : string , value : string ) key Required \u00b6 Type: string value Required \u00b6 Type: string allow \u00b6 public allow ( verbs : string [], endpoints : IApiEndpoint ) verbs Required \u00b6 Type: string [] endpoints Required \u00b6 Type: cdk8s-plus-20.IApiEndpoint The endpoints(s) to apply to. allowCreate \u00b6 public allowCreate ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-20.IApiEndpoint The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-20.IApiEndpoint The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-20.IApiEndpoint The resource(s) to apply to. allowGet \u00b6 public allowGet ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-20.IApiEndpoint The resource(s) to apply to. allowList \u00b6 public allowList ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-20.IApiEndpoint The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-20.IApiEndpoint The resource(s) to apply to. allowRead \u00b6 public allowRead ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-20.IApiEndpoint The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-20.IApiEndpoint The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-20.IApiEndpoint The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-20.IApiEndpoint The resource(s) to apply to. bind \u00b6 public bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-20.ISubject a list of subjects to bind to. bindInNamespace \u00b6 public bindInNamespace ( namespace : string , subjects : ISubject ) namespace Required \u00b6 Type: string the namespace to limit permissions to. subjects Required \u00b6 Type: cdk8s-plus-20.ISubject a list of subjects to bind to. combine \u00b6 public combine ( rol : ClusterRole ) rol Required \u00b6 Type: cdk8s-plus-20.ClusterRole Static Functions \u00b6 fromClusterRoleName \u00b6 import { ClusterRole } from 'cdk8s-plus-20' ClusterRole . fromClusterRoleName ( name : string ) name Required \u00b6 Type: string The name of the role resource. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public readonly rules : ClusterRolePolicyRule []; Type: cdk8s-plus-20.ClusterRolePolicyRule [] Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import { ClusterRoleBinding } from 'cdk8s-plus-20' new ClusterRoleBinding ( scope : Construct , id : string , props : ClusterRoleBindingProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-20.ClusterRoleBindingProps Methods \u00b6 addSubjects \u00b6 public addSubjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-20.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public readonly role : IClusterRole ; Type: cdk8s-plus-20.IClusterRole subjects Required \u00b6 public readonly subjects : ISubject []; Type: cdk8s-plus-20.ISubject [] ConfigMap \u00b6 Implements: cdk8s-plus-20.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import { ConfigMap } from 'cdk8s-plus-20' new ConfigMap ( scope : Construct , id : string , props? : ConfigMapProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.ConfigMapProps Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addData \u00b6 public addData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addDirectory \u00b6 public addDirectory ( localDir : string , options? : AddDirectoryOptions ) localDir Required \u00b6 Type: string A path to a local directory. options Optional \u00b6 Type: cdk8s-plus-20.AddDirectoryOptions Options. addFile \u00b6 public addFile ( localFile : string , key? : string ) localFile Required \u00b6 Type: string The path to the local file. key Optional \u00b6 Type: string The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import { ConfigMap } from 'cdk8s-plus-20' ConfigMap . fromConfigMapName ( name : string ) name Required \u00b6 Type: string The name of the config map to import. Properties \u00b6 binaryData Required \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 public readonly immutable : boolean ; Type: boolean Whether or not this config map is immutable. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import { DaemonSet } from 'cdk8s-plus-20' new DaemonSet ( scope : Construct , id : string , props? : DaemonSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.DaemonSetProps Properties \u00b6 minReadySeconds Required \u00b6 public readonly minReadySeconds : number ; Type: number resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import { Deployment } from 'cdk8s-plus-20' new Deployment ( scope : Construct , id : string , props? : DeploymentProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.DeploymentProps Methods \u00b6 exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeDeploymentViaIngressOptions ) path Required \u00b6 Type: string The ingress path to register under. options Optional \u00b6 Type: cdk8s-plus-20.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService ( options? : ExposeDeploymentViaServiceOptions ) options Optional \u00b6 Type: cdk8s-plus-20.ExposeDeploymentViaServiceOptions Options to determine details of the service and port exposed. Properties \u00b6 minReady Required \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progressDeadline Required \u00b6 public readonly progressDeadline : Duration ; Type: cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public readonly strategy : DeploymentStrategy ; Type: cdk8s-plus-20.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import { DockerConfigSecret } from 'cdk8s-plus-20' new DockerConfigSecret ( scope : Construct , id : string , props : DockerConfigSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-20.DockerConfigSecretProps GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import { GCEPersistentDiskPersistentVolume } from 'cdk8s-plus-20' new GCEPersistentDiskPersistentVolume ( scope : Construct , id : string , props : GCEPersistentDiskPersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-20.GCEPersistentDiskPersistentVolumeProps Properties \u00b6 fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. pdName Required \u00b6 public readonly pdName : string ; Type: string PD resource in GCE of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. partition Optional \u00b6 public readonly partition : number ; Type: number Partition of this volume. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import { IngressV1Beta1 } from 'cdk8s-plus-20' new IngressV1Beta1 ( scope : Construct , id : string , props? : IngressV1Beta1Props ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.IngressV1Beta1Props Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( backend : IngressV1Beta1Backend ) backend Required \u00b6 Type: cdk8s-plus-20.IngressV1Beta1Backend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( host : string , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: string The host name to match. backend Required \u00b6 Type: cdk8s-plus-20.IngressV1Beta1Backend The backend to route to. addHostRule \u00b6 public addHostRule ( host : string , path : string , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: string The host name. path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-20.IngressV1Beta1Backend The backend to route requests to. addRule \u00b6 public addRule ( path : string , backend : IngressV1Beta1Backend ) path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-20.IngressV1Beta1Backend The backend to route requests to. addRules \u00b6 public addRules ( rules : IngressV1Beta1Rule ) rules Required \u00b6 Type: cdk8s-plus-20.IngressV1Beta1Rule The rules to add. addTls \u00b6 public addTls ( tls : IngressV1Beta1Tls []) tls Required \u00b6 Type: cdk8s-plus-20.IngressV1Beta1Tls [] Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import { Job } from 'cdk8s-plus-20' new Job ( scope : Construct , id : string , props? : JobProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.JobProps Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Number of retries before marking failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration TTL before the job is deleted after it is finished. PersistentVolume \u00b6 Implements: cdk8s-plus-20.IPersistentVolume , cdk8s-plus-20.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import { PersistentVolume } from 'cdk8s-plus-20' new PersistentVolume ( scope : Construct , id : string , props? : PersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.PersistentVolumeProps Methods \u00b6 asVolume \u00b6 public asVolume () bind \u00b6 public bind ( claim : IPersistentVolumeClaim ) claim Required \u00b6 Type: cdk8s-plus-20.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 public reserve () Static Functions \u00b6 fromPersistentVolumeName \u00b6 import { PersistentVolume } from 'cdk8s-plus-20' PersistentVolume . fromPersistentVolumeName ( volumeName : string ) volumeName Required \u00b6 Type: string The name of the pv to reference. Properties \u00b6 mode Required \u00b6 public readonly mode : PersistentVolumeMode ; Type: cdk8s-plus-20.PersistentVolumeMode Volume mode of this volume. reclaimPolicy Required \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-20.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-20.PersistentVolumeAccessMode [] Access modes requirement of this claim. claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-20.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Mount options of this volume. storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Storage size of this volume. storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: cdk8s-plus-20.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import { PersistentVolumeClaim } from 'cdk8s-plus-20' new PersistentVolumeClaim ( scope : Construct , id : string , props? : PersistentVolumeClaimProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.PersistentVolumeClaimProps Methods \u00b6 bind \u00b6 public bind ( vol : IPersistentVolume ) vol Required \u00b6 Type: cdk8s-plus-20.IPersistentVolume The PV to bind to. Static Functions \u00b6 fromClaimName \u00b6 import { PersistentVolumeClaim } from 'cdk8s-plus-20' PersistentVolumeClaim . fromClaimName ( claimName : string ) claimName Required \u00b6 Type: string The name of the pvc to reference. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. volumeMode Required \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-20.PersistentVolumeMode Volume mode requirement of this claim. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-20.PersistentVolumeAccessMode [] Access modes requirement of this claim. storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Storage requirement of this claim. storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Storage class requirment of this claim. volume Optional \u00b6 public readonly volume : IPersistentVolume ; Type: cdk8s-plus-20.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import { Pod } from 'cdk8s-plus-20' new Pod ( scope : Construct , id : string , props? : PodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.PodProps Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Resource \u00b6 Implements: cdk8s-plus-20.IResource , cdk8s-plus-20.IApiResource , cdk8s-plus-20.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import { Resource } from 'cdk8s-plus-20' new Resource ( scope : Construct , id : string , options? : ConstructOptions ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: string The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . options Optional \u00b6 Type: constructs.ConstructOptions Options. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 public readonly metadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public readonly name : string ; Type: string The name of this API object. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. resourceName Optional \u00b6 public readonly resourceName : string ; Type: string The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: cdk8s-plus-20.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import { Role } from 'cdk8s-plus-20' new Role ( scope : Construct , id : string , props? : RoleProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.RoleProps Methods \u00b6 allow \u00b6 public allow ( verbs : string [], resources : IApiResource ) verbs Required \u00b6 Type: string [] resources Required \u00b6 Type: cdk8s-plus-20.IApiResource The resource(s) to apply to. allowCreate \u00b6 public allowCreate ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-20.IApiResource The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-20.IApiResource The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-20.IApiResource The resource(s) to apply to. allowGet \u00b6 public allowGet ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-20.IApiResource The resource(s) to apply to. allowList \u00b6 public allowList ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-20.IApiResource The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-20.IApiResource The resource(s) to apply to. allowRead \u00b6 public allowRead ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-20.IApiResource The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-20.IApiResource The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-20.IApiResource The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-20.IApiResource The resource(s) to apply to. bind \u00b6 public bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-20.ISubject a list of subjects to bind to. Static Functions \u00b6 fromRoleName \u00b6 import { Role } from 'cdk8s-plus-20' Role . fromRoleName ( name : string ) name Required \u00b6 Type: string The name of the role resource. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public readonly rules : RolePolicyRule []; Type: cdk8s-plus-20.RolePolicyRule [] Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import { RoleBinding } from 'cdk8s-plus-20' new RoleBinding ( scope : Construct , id : string , props : RoleBindingProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-20.RoleBindingProps Methods \u00b6 addSubjects \u00b6 public addSubjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-20.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public readonly role : IRole ; Type: cdk8s-plus-20.IRole subjects Required \u00b6 public readonly subjects : ISubject []; Type: cdk8s-plus-20.ISubject [] Secret \u00b6 Implements: cdk8s-plus-20.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import { Secret } from 'cdk8s-plus-20' new Secret ( scope : Construct , id : string , props? : SecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.SecretProps Methods \u00b6 addStringData \u00b6 public addStringData ( key : string , value : string ) key Required \u00b6 Type: string Key. value Required \u00b6 Type: string Value. getStringData \u00b6 public getStringData ( key : string ) key Required \u00b6 Type: string Key. Static Functions \u00b6 fromSecretName \u00b6 import { Secret } from 'cdk8s-plus-20' Secret . fromSecretName ( name : string ) name Required \u00b6 Type: string The name of the secret to reference. Properties \u00b6 immutable Required \u00b6 public readonly immutable : boolean ; Type: boolean Whether or not the secret is immutable. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import { Service } from 'cdk8s-plus-20' new Service ( scope : Construct , id : string , props? : ServiceProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.ServiceProps Methods \u00b6 addDeployment \u00b6 public addDeployment ( depl : Deployment , options? : AddDeploymentOptions ) depl Required \u00b6 Type: cdk8s-plus-20.Deployment The deployment to expose. options Optional \u00b6 Type: cdk8s-plus-20.AddDeploymentOptions Optional settings for the port. addSelector \u00b6 public addSelector ( label : string , value : string ) label Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeServiceViaIngressOptions ) path Required \u00b6 Type: string The path to expose the service under. options Optional \u00b6 Type: cdk8s-plus-20.ExposeServiceViaIngressOptions Additional options. serve \u00b6 public serve ( port : number , options? : ServicePortOptions ) port Required \u00b6 Type: number The port definition. options Optional \u00b6 Type: cdk8s-plus-20.ServicePortOptions Properties \u00b6 ports Required \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-20.ServicePort [] Ports for this service. Use serve() to expose additional service ports. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. selector Required \u00b6 public readonly selector : {[ key : string ] : string }; Type: {[ key: string ]: string } Returns the labels which are used to select pods for this service. type Required \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-20.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public readonly externalName : string ; Type: string The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s-plus-20.IServiceAccount , cdk8s-plus-20.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import { ServiceAccount } from 'cdk8s-plus-20' new ServiceAccount ( scope : Construct , id : string , props? : ServiceAccountProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.ServiceAccountProps Methods \u00b6 addSecret \u00b6 public addSecret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s-plus-20.ISecret The secret. Static Functions \u00b6 fromServiceAccountName \u00b6 import { ServiceAccount } from 'cdk8s-plus-20' ServiceAccount . fromServiceAccountName ( name : string ) name Required \u00b6 Type: string The name of the service account resource. Properties \u00b6 automountToken Required \u00b6 public readonly automountToken : boolean ; Type: boolean Whether or not a token is automatically mounted for this service account. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-20.ISecret [] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import { ServiceAccountTokenSecret } from 'cdk8s-plus-20' new ServiceAccountTokenSecret ( scope : Construct , id : string , props : ServiceAccountTokenSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-20.ServiceAccountTokenSecretProps SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import { SshAuthSecret } from 'cdk8s-plus-20' new SshAuthSecret ( scope : Construct , id : string , props : SshAuthSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-20.SshAuthSecretProps StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import { StatefulSet } from 'cdk8s-plus-20' new StatefulSet ( scope : Construct , id : string , props : StatefulSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-20.StatefulSetProps Properties \u00b6 podManagementPolicy Required \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-20.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public readonly strategy : StatefulSetUpdateStrategy ; Type: cdk8s-plus-20.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import { TlsSecret } from 'cdk8s-plus-20' new TlsSecret ( scope : Construct , id : string , props : TlsSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-20.TlsSecretProps Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import { Workload } from 'cdk8s-plus-20' new Workload ( scope : Construct , id : string , props? : WorkloadProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.WorkloadProps Methods \u00b6 select \u00b6 public select ( selectors : LabelSelector ) selectors Required \u00b6 Type: cdk8s-plus-20.LabelSelector Properties \u00b6 matchExpressions Required \u00b6 public readonly matchExpressions : LabelSelectorRequirement []; Type: cdk8s-plus-20.LabelSelectorRequirement [] The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. matchLabels Required \u00b6 public readonly matchLabels : {[ key : string ] : string }; Type: {[ key: string ]: string } The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import { AbstractPodProps } from 'cdk8s-plus-20' const abstractPodProps : AbstractPodProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-20.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import { AddDeploymentOptions } from 'cdk8s-plus-20' const addDeploymentOptions : AddDeploymentOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import { AddDirectoryOptions } from 'cdk8s-plus-20' const addDirectoryOptions : AddDirectoryOptions = { ... } exclude Optional \u00b6 public readonly exclude : string []; Type: string [] Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public readonly keyPrefix : string ; Type: string Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import { ApiResourceOptions } from 'cdk8s-plus-20' const apiResourceOptions : ApiResourceOptions = { ... } apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import { AwsElasticBlockStorePersistentVolumeProps } from 'cdk8s-plus-20' const awsElasticBlockStorePersistentVolumeProps : AwsElasticBlockStorePersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-20.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 public readonly volumeId : string ; Type: string Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import { AwsElasticBlockStoreVolumeOptions } from 'cdk8s-plus-20' const awsElasticBlockStoreVolumeOptions : AwsElasticBlockStoreVolumeOptions = { ... } fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import { AzureDiskPersistentVolumeProps } from 'cdk8s-plus-20' const azureDiskPersistentVolumeProps : AzureDiskPersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-20.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 public readonly diskName : string ; Type: string The Name of the data disk in the blob storage. diskUri Required \u00b6 public readonly diskUri : string ; Type: string The URI the data disk in the blob storage. cachingMode Optional \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-20.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public readonly kind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-20.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import { AzureDiskVolumeOptions } from 'cdk8s-plus-20' const azureDiskVolumeOptions : AzureDiskVolumeOptions = { ... } cachingMode Optional \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-20.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public readonly kind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-20.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import { BasicAuthSecretProps } from 'cdk8s-plus-20' const basicAuthSecretProps : BasicAuthSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 public readonly password : string ; Type: string The password or token for authentication. username Required \u00b6 public readonly username : string ; Type: string The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import { ClusterRoleBindingProps } from 'cdk8s-plus-20' const clusterRoleBindingProps : ClusterRoleBindingProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public readonly role : IClusterRole ; Type: cdk8s-plus-20.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import { ClusterRolePolicyRule } from 'cdk8s-plus-20' const clusterRolePolicyRule : ClusterRolePolicyRule = { ... } endpoints Required \u00b6 public readonly endpoints : IApiEndpoint []; Type: cdk8s-plus-20.IApiEndpoint [] Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 public readonly verbs : string []; Type: string [] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import { ClusterRoleProps } from 'cdk8s-plus-20' const clusterRoleProps : ClusterRoleProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 public readonly aggregationLabels : {[ key : string ] : string }; Type: {[ key: string ]: string } Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 public readonly rules : ClusterRolePolicyRule []; Type: cdk8s-plus-20.ClusterRolePolicyRule [] Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import { CommandProbeOptions } from 'cdk8s-plus-20' const commandProbeOptions : CommandProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import { CommonSecretProps } from 'cdk8s-plus-20' const commonSecretProps : CommonSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import { ConfigMapProps } from 'cdk8s-plus-20' const configMapProps : ConfigMapProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import { ConfigMapVolumeOptions } from 'cdk8s-plus-20' const configMapVolumeOptions : ConfigMapVolumeOptions = { ... } defaultMode Optional \u00b6 public readonly defaultMode : number ; Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public readonly items : {[ key : string ] : PathMapping }; Type: {[ key: string ]: cdk8s-plus-20.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import { ContainerLifecycle } from 'cdk8s-plus-20' const containerLifecycle : ContainerLifecycle = { ... } postStart Optional \u00b6 public readonly postStart : Handler ; Type: cdk8s-plus-20.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. preStop Optional \u00b6 public readonly preStop : Handler ; Type: cdk8s-plus-20.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import { ContainerProps } from 'cdk8s-plus-20' const containerProps : ContainerProps = { ... } image Required \u00b6 public readonly image : string ; Type: string Docker image name. args Optional \u00b6 public readonly args : string []; Type: string [] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public readonly command : string []; Type: string [] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 public readonly env : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-20.EnvValue } Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 public readonly lifecycle : ContainerLifecycle ; Type: cdk8s-plus-20.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 public readonly liveness : Probe ; Type: cdk8s-plus-20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public readonly name : string ; Type: string Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 public readonly port : number ; Type: number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 public readonly readiness : Probe ; Type: cdk8s-plus-20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 public readonly resources : ContainerResources ; Type: cdk8s-plus-20.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 public readonly securityContext : ContainerSecurityContextProps ; Type: cdk8s-plus-20.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 public readonly startup : Probe ; Type: cdk8s-plus-20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public readonly volumeMounts : VolumeMount []; Type: cdk8s-plus-20.VolumeMount [] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public readonly workingDir : string ; Type: string Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import { ContainerResources } from 'cdk8s-plus-20' const containerResources : ContainerResources = { ... } cpu Required \u00b6 public readonly cpu : CpuResources ; Type: cdk8s-plus-20.CpuResources memory Required \u00b6 public readonly memory : MemoryResources ; Type: cdk8s-plus-20.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import { ContainerSecurityContextProps } from 'cdk8s-plus-20' const containerSecurityContextProps : ContainerSecurityContextProps = { ... } ensureNonRoot Optional \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 public readonly group : number ; Type: number Default: Group configured by container runtime The GID to run the entrypoint of the container process. privileged Optional \u00b6 public readonly privileged : boolean ; Type: boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 public readonly readOnlyRootFilesystem : boolean ; Type: boolean Default: false Whether this container has a read-only root filesystem. user Optional \u00b6 public readonly user : number ; Type: number Default: User specified in image metadata The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import { CpuResources } from 'cdk8s-plus-20' const cpuResources : CpuResources = { ... } limit Required \u00b6 public readonly limit : Cpu ; Type: cdk8s-plus-20.Cpu request Required \u00b6 public readonly request : Cpu ; Type: cdk8s-plus-20.Cpu DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import { DaemonSetProps } from 'cdk8s-plus-20' const daemonSetProps : DaemonSetProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-20.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReadySeconds Optional \u00b6 public readonly minReadySeconds : number ; Type: number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import { DeploymentProps } from 'cdk8s-plus-20' const deploymentProps : DeploymentProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-20.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReady Optional \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 public readonly progressDeadline : Duration ; Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. strategy Optional \u00b6 public readonly strategy : DeploymentStrategy ; Type: cdk8s-plus-20.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import { DeploymentStrategyRollingUpdateOptions } from 'cdk8s-plus-20' const deploymentStrategyRollingUpdateOptions : DeploymentStrategyRollingUpdateOptions = { ... } maxSurge Optional \u00b6 public readonly maxSurge : PercentOrAbsolute ; Type: cdk8s-plus-20.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. maxUnavailable Optional \u00b6 public readonly maxUnavailable : PercentOrAbsolute ; Type: cdk8s-plus-20.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import { DnsOption } from 'cdk8s-plus-20' const dnsOption : DnsOption = { ... } name Required \u00b6 public readonly name : string ; Type: string Option name. value Optional \u00b6 public readonly value : string ; Type: string Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import { DockerConfigSecretProps } from 'cdk8s-plus-20' const dockerConfigSecretProps : DockerConfigSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 public readonly data : {[ key : string ] : any }; Type: {[ key: string ]: any } JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import { EmptyDirVolumeOptions } from 'cdk8s-plus-20' const emptyDirVolumeOptions : EmptyDirVolumeOptions = { ... } medium Optional \u00b6 public readonly medium : EmptyDirMedium ; Type: cdk8s-plus-20.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public readonly sizeLimit : Size ; Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import { EnvValueFromConfigMapOptions } from 'cdk8s-plus-20' const envValueFromConfigMapOptions : EnvValueFromConfigMapOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import { EnvValueFromFieldRefOptions } from 'cdk8s-plus-20' const envValueFromFieldRefOptions : EnvValueFromFieldRefOptions = { ... } apiVersion Optional \u00b6 public readonly apiVersion : string ; Type: string Version of the schema the FieldPath is written in terms of. key Optional \u00b6 public readonly key : string ; Type: string The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import { EnvValueFromProcessOptions } from 'cdk8s-plus-20' const envValueFromProcessOptions : EnvValueFromProcessOptions = { ... } required Optional \u00b6 public readonly required : boolean ; Type: boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import { EnvValueFromResourceOptions } from 'cdk8s-plus-20' const envValueFromResourceOptions : EnvValueFromResourceOptions = { ... } container Optional \u00b6 public readonly container : Container ; Type: cdk8s-plus-20.Container The container to select the value from. divisor Optional \u00b6 public readonly divisor : string ; Type: string The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import { EnvValueFromSecretOptions } from 'cdk8s-plus-20' const envValueFromSecretOptions : EnvValueFromSecretOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import { ExposeDeploymentViaIngressOptions } from 'cdk8s-plus-20' const exposeDeploymentViaIngressOptions : ExposeDeploymentViaIngressOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-20.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 public readonly ingress : IngressV1Beta1 ; Type: cdk8s-plus-20.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import { ExposeDeploymentViaServiceOptions } from 'cdk8s-plus-20' const exposeDeploymentViaServiceOptions : ExposeDeploymentViaServiceOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-20.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import { ExposeServiceViaIngressOptions } from 'cdk8s-plus-20' const exposeServiceViaIngressOptions : ExposeServiceViaIngressOptions = { ... } ingress Optional \u00b6 public readonly ingress : IngressV1Beta1 ; Type: cdk8s-plus-20.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import { GCEPersistentDiskPersistentVolumeProps } from 'cdk8s-plus-20' const gCEPersistentDiskPersistentVolumeProps : GCEPersistentDiskPersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-20.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 public readonly pdName : string ; Type: string Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import { GCEPersistentDiskVolumeOptions } from 'cdk8s-plus-20' const gCEPersistentDiskVolumeOptions : GCEPersistentDiskVolumeOptions = { ... } fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GroupProps \u00b6 Properties for Group . Initializer \u00b6 import { GroupProps } from 'cdk8s-plus-20' const groupProps : GroupProps = { ... } name Required \u00b6 public readonly name : string ; Type: string The name of the group. HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import { HandlerFromHttpGetOptions } from 'cdk8s-plus-20' const handlerFromHttpGetOptions : HandlerFromHttpGetOptions = { ... } port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import { HandlerFromTcpSocketOptions } from 'cdk8s-plus-20' const handlerFromTcpSocketOptions : HandlerFromTcpSocketOptions = { ... } host Optional \u00b6 public readonly host : string ; Type: string Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import { HostAlias } from 'cdk8s-plus-20' const hostAlias : HostAlias = { ... } hostnames Required \u00b6 public readonly hostnames : string []; Type: string [] Hostnames for the chosen IP address. ip Required \u00b6 public readonly ip : string ; Type: string IP address of the host file entry. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import { HttpGetProbeOptions } from 'cdk8s-plus-20' const httpGetProbeOptions : HttpGetProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import { IngressV1Beta1Props } from 'cdk8s-plus-20' const ingressV1Beta1Props : IngressV1Beta1Props = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public readonly defaultBackend : IngressV1Beta1Backend ; Type: cdk8s-plus-20.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public readonly rules : IngressV1Beta1Rule []; Type: cdk8s-plus-20.IngressV1Beta1Rule [] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public readonly tls : IngressV1Beta1Tls []; Type: cdk8s-plus-20.IngressV1Beta1Tls [] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import { IngressV1Beta1Rule } from 'cdk8s-plus-20' const ingressV1Beta1Rule : IngressV1Beta1Rule = { ... } backend Required \u00b6 public readonly backend : IngressV1Beta1Backend ; Type: cdk8s-plus-20.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public readonly host : string ; Type: string Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public readonly path : string ; Type: string Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import { IngressV1Beta1Tls } from 'cdk8s-plus-20' const ingressV1Beta1Tls : IngressV1Beta1Tls = { ... } hosts Optional \u00b6 public readonly hosts : string []; Type: string [] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-20.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import { JobProps } from 'cdk8s-plus-20' const jobProps : JobProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-20.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import { LabelSelectorRequirement } from 'cdk8s-plus-20' const labelSelectorRequirement : LabelSelectorRequirement = { ... } key Required \u00b6 public readonly key : string ; Type: string The label key that the selector applies to. operator Required \u00b6 public readonly operator : LabelSelectorRequirementOperator ; Type: cdk8s-plus-20.LabelSelectorRequirementOperator Represents a key\u2019s relationship to a set of values. values Optional \u00b6 public readonly values : string []; Type: string [] An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import { MemoryResources } from 'cdk8s-plus-20' const memoryResources : MemoryResources = { ... } limit Required \u00b6 public readonly limit : Size ; Type: cdk8s.Size request Required \u00b6 public readonly request : Size ; Type: cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import { MountOptions } from 'cdk8s-plus-20' const mountOptions : MountOptions = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-20.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import { PathMapping } from 'cdk8s-plus-20' const pathMapping : PathMapping = { ... } path Required \u00b6 public readonly path : string ; Type: string The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public readonly mode : number ; Type: number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import { PersistentVolumeClaimProps } from 'cdk8s-plus-20' const persistentVolumeClaimProps : PersistentVolumeClaimProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-20.PersistentVolumeAccessMode [] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. - If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 public readonly volume : IPersistentVolume ; Type: cdk8s-plus-20.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import { PersistentVolumeClaimVolumeOptions } from 'cdk8s-plus-20' const persistentVolumeClaimVolumeOptions : PersistentVolumeClaimVolumeOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: Derived from the PVC name. The volume name. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import { PersistentVolumeProps } from 'cdk8s-plus-20' const persistentVolumeProps : PersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-20.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-20.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-20.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-20.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import { PodDnsProps } from 'cdk8s-plus-20' const podDnsProps : PodDnsProps = { ... } hostname Optional \u00b6 public readonly hostname : string ; Type: string Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 public readonly hostnameAsFQDN : boolean ; Type: boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 public readonly nameservers : string []; Type: string [] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 public readonly options : DnsOption []; Type: cdk8s-plus-20.DnsOption [] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 public readonly policy : DnsPolicy ; Type: cdk8s-plus-20.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 public readonly searches : string []; Type: string [] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 public readonly subdomain : string ; Type: string Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import { PodProps } from 'cdk8s-plus-20' const podProps : PodProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-20.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import { PodSecurityContextProps } from 'cdk8s-plus-20' const podSecurityContextProps : PodSecurityContextProps = { ... } ensureNonRoot Optional \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 public readonly fsGroup : number ; Type: number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 public readonly fsGroupChangePolicy : FsGroupChangePolicy ; Type: cdk8s-plus-20.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 public readonly group : number ; Type: number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 public readonly sysctls : Sysctl []; Type: cdk8s-plus-20.Sysctl [] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 public readonly user : number ; Type: number Default: User specified in image metadata The UID to run the entrypoint of the container process. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import { ProbeOptions } from 'cdk8s-plus-20' const probeOptions : ProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import { ResourceProps } from 'cdk8s-plus-20' const resourceProps : ResourceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import { RoleBindingProps } from 'cdk8s-plus-20' const roleBindingProps : RoleBindingProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public readonly role : IRole ; Type: cdk8s-plus-20.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import { RolePolicyRule } from 'cdk8s-plus-20' const rolePolicyRule : RolePolicyRule = { ... } resources Required \u00b6 public readonly resources : IApiResource []; Type: cdk8s-plus-20.IApiResource [] Resources this rule applies to. verbs Required \u00b6 public readonly verbs : string []; Type: string [] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import { RoleProps } from 'cdk8s-plus-20' const roleProps : RoleProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 public readonly rules : RolePolicyRule []; Type: cdk8s-plus-20.RolePolicyRule [] Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import { SecretProps } from 'cdk8s-plus-20' const secretProps : SecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 public readonly stringData : {[ key : string ] : string }; Type: {[ key: string ]: string } stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public readonly type : string ; Type: string Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import { SecretValue } from 'cdk8s-plus-20' const secretValue : SecretValue = { ... } key Required \u00b6 public readonly key : string ; Type: string The JSON key. secret Required \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-20.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import { SecretVolumeOptions } from 'cdk8s-plus-20' const secretVolumeOptions : SecretVolumeOptions = { ... } defaultMode Optional \u00b6 public readonly defaultMode : number ; Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public readonly items : {[ key : string ] : PathMapping }; Type: {[ key: string ]: cdk8s-plus-20.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import { ServiceAccountProps } from 'cdk8s-plus-20' const serviceAccountProps : ServiceAccountProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 public readonly automountToken : boolean ; Type: boolean Default: true Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-20.ISecret [] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import { ServiceAccountTokenSecretProps } from 'cdk8s-plus-20' const serviceAccountTokenSecretProps : ServiceAccountTokenSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount The service account to store a secret for. ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import { ServiceIngressV1BetaBackendOptions } from 'cdk8s-plus-20' const serviceIngressV1BetaBackendOptions : ServiceIngressV1BetaBackendOptions = { ... } port Optional \u00b6 public readonly port : number ; Type: number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import { ServicePort } from 'cdk8s-plus-20' const servicePort : ServicePort = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public readonly port : number ; Type: number The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import { ServicePortOptions } from 'cdk8s-plus-20' const servicePortOptions : ServicePortOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import { ServiceProps } from 'cdk8s-plus-20' const serviceProps : ServiceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public readonly externalIPs : string []; Type: string [] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public readonly externalName : string ; Type: string Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public readonly loadBalancerSourceRanges : string []; Type: string [] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-20.ServicePort [] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-20.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import { SshAuthSecretProps } from 'cdk8s-plus-20' const sshAuthSecretProps : SshAuthSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 public readonly sshPrivateKey : string ; Type: string The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import { StatefulSetProps } from 'cdk8s-plus-20' const statefulSetProps : StatefulSetProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-20.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. service Required \u00b6 public readonly service : Service ; Type: cdk8s-plus-20.Service Service to associate with the statefulset. podManagementPolicy Optional \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-20.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. strategy Optional \u00b6 public readonly strategy : StatefulSetUpdateStrategy ; Type: cdk8s-plus-20.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import { StatefulSetUpdateStrategyRollingUpdateOptions } from 'cdk8s-plus-20' const statefulSetUpdateStrategyRollingUpdateOptions : StatefulSetUpdateStrategyRollingUpdateOptions = { ... } partition Optional \u00b6 public readonly partition : number ; Type: number Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import { Sysctl } from 'cdk8s-plus-20' const sysctl : Sysctl = { ... } name Required \u00b6 public readonly name : string ; Type: string Name of a property to set. value Required \u00b6 public readonly value : string ; Type: string Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import { TcpSocketProbeOptions } from 'cdk8s-plus-20' const tcpSocketProbeOptions : TcpSocketProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 public readonly host : string ; Type: string Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import { TlsSecretProps } from 'cdk8s-plus-20' const tlsSecretProps : TlsSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 public readonly tlsCert : string ; Type: string The TLS cert. tlsKey Required \u00b6 public readonly tlsKey : string ; Type: string The TLS key. UserProps \u00b6 Properties for User . Initializer \u00b6 import { UserProps } from 'cdk8s-plus-20' const userProps : UserProps = { ... } name Required \u00b6 public readonly name : string ; Type: string The name of the user. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import { VolumeMount } from 'cdk8s-plus-20' const volumeMount : VolumeMount = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-20.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 public readonly path : string ; Type: string Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public readonly volume : Volume ; Type: cdk8s-plus-20.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import { WorkloadProps } from 'cdk8s-plus-20' const workloadProps : WorkloadProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-20.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-20.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-20.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-20.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. Classes \u00b6 ApiResource \u00b6 Implements: cdk8s-plus-20.IApiResource , cdk8s-plus-20.IApiEndpoint Represents information about an API resource type. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 custom \u00b6 import { ApiResource } from 'cdk8s-plus-20' ApiResource . custom ( options : ApiResourceOptions ) options Required \u00b6 Type: cdk8s-plus-20.ApiResourceOptions Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for Ingress. JOBS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for Job. LEASES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: cdk8s-plus-20.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import { Container } from 'cdk8s-plus-20' new Container ( props : ContainerProps ) props Required \u00b6 Type: cdk8s-plus-20.ContainerProps Methods \u00b6 addEnv \u00b6 public addEnv ( name : string , value : EnvValue ) name Required \u00b6 Type: string The variable name. value Required \u00b6 Type: cdk8s-plus-20.EnvValue The variable value. mount \u00b6 public mount ( path : string , storage : IStorage , options? : MountOptions ) path Required \u00b6 Type: string The desired path in the container. storage Required \u00b6 Type: cdk8s-plus-20.IStorage The storage to mount. options Optional \u00b6 Type: cdk8s-plus-20.MountOptions Properties \u00b6 env Required \u00b6 public readonly env : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-20.EnvValue } The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 public readonly image : string ; Type: string The container image. imagePullPolicy Required \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-20.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public readonly mounts : VolumeMount []; Type: cdk8s-plus-20.VolumeMount [] Volume mounts configured for this container. name Required \u00b6 public readonly name : string ; Type: string The name of the container. securityContext Required \u00b6 public readonly securityContext : ContainerSecurityContext ; Type: cdk8s-plus-20.ContainerSecurityContext The security context of the container. args Optional \u00b6 public readonly args : string []; Type: string [] Arguments to the entrypoint. command Optional \u00b6 public readonly command : string []; Type: string [] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 public readonly port : number ; Type: number The port this container exposes. resources Optional \u00b6 public readonly resources : ContainerResources ; Type: cdk8s-plus-20.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ workingDir Optional \u00b6 public readonly workingDir : string ; Type: string The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import { ContainerSecurityContext } from 'cdk8s-plus-20' new ContainerSecurityContext ( props? : ContainerSecurityContextProps ) props Optional \u00b6 Type: cdk8s-plus-20.ContainerSecurityContextProps Properties \u00b6 ensureNonRoot Required \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean privileged Required \u00b6 public readonly privileged : boolean ; Type: boolean readOnlyRootFilesystem Required \u00b6 public readonly readOnlyRootFilesystem : boolean ; Type: boolean group Optional \u00b6 public readonly group : number ; Type: number user Optional \u00b6 public readonly user : number ; Type: number Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import { Cpu } from 'cdk8s-plus-20' Cpu . millis ( amount : number ) amount Required \u00b6 Type: number units \u00b6 import { Cpu } from 'cdk8s-plus-20' Cpu . units ( amount : number ) amount Required \u00b6 Type: number Properties \u00b6 amount Required \u00b6 public readonly amount : string ; Type: string DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import { DeploymentStrategy } from 'cdk8s-plus-20' DeploymentStrategy . recreate () rollingUpdate \u00b6 import { DeploymentStrategy } from 'cdk8s-plus-20' DeploymentStrategy . rollingUpdate ( options? : DeploymentStrategyRollingUpdateOptions ) options Optional \u00b6 Type: cdk8s-plus-20.DeploymentStrategyRollingUpdateOptions EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import { EnvValue } from 'cdk8s-plus-20' EnvValue . fromConfigMap ( configMap : IConfigMap , key : string , options? : EnvValueFromConfigMapOptions ) configMap Required \u00b6 Type: cdk8s-plus-20.IConfigMap The config map. key Required \u00b6 Type: string The key to extract the value from. options Optional \u00b6 Type: cdk8s-plus-20.EnvValueFromConfigMapOptions Additional options. fromFieldRef \u00b6 import { EnvValue } from 'cdk8s-plus-20' EnvValue . fromFieldRef ( fieldPath : EnvFieldPaths , options? : EnvValueFromFieldRefOptions ) fieldPath Required \u00b6 Type: cdk8s-plus-20.EnvFieldPaths : The field reference. options Optional \u00b6 Type: cdk8s-plus-20.EnvValueFromFieldRefOptions : Additional options. fromProcess \u00b6 import { EnvValue } from 'cdk8s-plus-20' EnvValue . fromProcess ( key : string , options? : EnvValueFromProcessOptions ) key Required \u00b6 Type: string The key to read. options Optional \u00b6 Type: cdk8s-plus-20.EnvValueFromProcessOptions Additional options. fromResource \u00b6 import { EnvValue } from 'cdk8s-plus-20' EnvValue . fromResource ( resource : ResourceFieldPaths , options? : EnvValueFromResourceOptions ) resource Required \u00b6 Type: cdk8s-plus-20.ResourceFieldPaths : Resource to select the value from. options Optional \u00b6 Type: cdk8s-plus-20.EnvValueFromResourceOptions : Additional options. fromSecretValue \u00b6 import { EnvValue } from 'cdk8s-plus-20' EnvValue . fromSecretValue ( secretValue : SecretValue , options? : EnvValueFromSecretOptions ) secretValue Required \u00b6 Type: cdk8s-plus-20.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: cdk8s-plus-20.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import { EnvValue } from 'cdk8s-plus-20' EnvValue . fromValue ( value : string ) value Required \u00b6 Type: string The value. Properties \u00b6 value Optional \u00b6 public readonly value : any ; Type: any valueFrom Optional \u00b6 public readonly valueFrom : any ; Type: any Group \u00b6 Implements: cdk8s-plus-20.ISubject Represents a group. Initializers \u00b6 import { Group } from 'cdk8s-plus-20' new Group ( props : GroupProps ) props Required \u00b6 Type: cdk8s-plus-20.GroupProps Properties \u00b6 kind Required \u00b6 public readonly kind : string ; Type: string Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public readonly name : string ; Type: string Name of the object being referenced. apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 fromCommand \u00b6 import { Handler } from 'cdk8s-plus-20' Handler . fromCommand ( command : string []) command Required \u00b6 Type: string [] The command to execute. fromHttpGet \u00b6 import { Handler } from 'cdk8s-plus-20' Handler . fromHttpGet ( path : string , options? : HandlerFromHttpGetOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-20.HandlerFromHttpGetOptions Options. fromTcpSocket \u00b6 import { Handler } from 'cdk8s-plus-20' Handler . fromTcpSocket ( options? : HandlerFromTcpSocketOptions ) options Optional \u00b6 Type: cdk8s-plus-20.HandlerFromTcpSocketOptions Options. IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromService \u00b6 import { IngressV1Beta1Backend } from 'cdk8s-plus-20' IngressV1Beta1Backend . fromService ( serv : Service , options? : ServiceIngressV1BetaBackendOptions ) serv Required \u00b6 Type: cdk8s-plus-20.Service The service object. options Optional \u00b6 Type: cdk8s-plus-20.ServiceIngressV1BetaBackendOptions LabelSelector \u00b6 A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors Static Functions \u00b6 doesNotExist \u00b6 import { LabelSelector } from 'cdk8s-plus-20' LabelSelector . doesNotExist ( key : string ) key Required \u00b6 Type: string exists \u00b6 import { LabelSelector } from 'cdk8s-plus-20' LabelSelector . exists ( key : string ) key Required \u00b6 Type: string in \u00b6 import { LabelSelector } from 'cdk8s-plus-20' LabelSelector . in ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] is \u00b6 import { LabelSelector } from 'cdk8s-plus-20' LabelSelector . is ( key : string , value : string , applyToTemplate? : boolean ) key Required \u00b6 Type: string value Required \u00b6 Type: string applyToTemplate Optional \u00b6 Type: boolean notIn \u00b6 import { LabelSelector } from 'cdk8s-plus-20' LabelSelector . notIn ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] Properties \u00b6 applyToTemplate Required \u00b6 public readonly applyToTemplate : boolean ; Type: boolean key Required \u00b6 public readonly key : string ; Type: string operator Optional \u00b6 public readonly operator : LabelSelectorRequirementOperator ; Type: cdk8s-plus-20.LabelSelectorRequirementOperator values Optional \u00b6 public readonly values : string []; Type: string [] NonApiResource \u00b6 Implements: cdk8s-plus-20.IApiEndpoint Factory for creating non api resources. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 of \u00b6 import { NonApiResource } from 'cdk8s-plus-20' NonApiResource . of ( url : string ) url Required \u00b6 Type: string PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 isZero \u00b6 public isZero () Static Functions \u00b6 absolute \u00b6 import { PercentOrAbsolute } from 'cdk8s-plus-20' PercentOrAbsolute . absolute ( num : number ) num Required \u00b6 Type: number percent \u00b6 import { PercentOrAbsolute } from 'cdk8s-plus-20' PercentOrAbsolute . percent ( percent : number ) percent Required \u00b6 Type: number Properties \u00b6 value Required \u00b6 public readonly value : any ; Type: any PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import { PodDns } from 'cdk8s-plus-20' new PodDns ( props? : PodDnsProps ) props Optional \u00b6 Type: cdk8s-plus-20.PodDnsProps Methods \u00b6 addNameserver \u00b6 public addNameserver ( nameservers : string ) nameservers Required \u00b6 Type: string addOption \u00b6 public addOption ( options : DnsOption ) options Required \u00b6 Type: cdk8s-plus-20.DnsOption addSearch \u00b6 public addSearch ( searches : string ) searches Required \u00b6 Type: string Properties \u00b6 hostnameAsFQDN Required \u00b6 public readonly hostnameAsFQDN : boolean ; Type: boolean Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 public readonly nameservers : string []; Type: string [] Nameservers defined for this pod. options Required \u00b6 public readonly options : DnsOption []; Type: cdk8s-plus-20.DnsOption [] Custom dns options defined for this pod. policy Required \u00b6 public readonly policy : DnsPolicy ; Type: cdk8s-plus-20.DnsPolicy The DNS policy of this pod. searches Required \u00b6 public readonly searches : string []; Type: string [] Search domains defined for this pod. hostname Optional \u00b6 public readonly hostname : string ; Type: string The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 public readonly subdomain : string ; Type: string The configured subdomain of the pod. PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import { PodSecurityContext } from 'cdk8s-plus-20' new PodSecurityContext ( props? : PodSecurityContextProps ) props Optional \u00b6 Type: cdk8s-plus-20.PodSecurityContextProps Properties \u00b6 ensureNonRoot Required \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean fsGroupChangePolicy Required \u00b6 public readonly fsGroupChangePolicy : FsGroupChangePolicy ; Type: cdk8s-plus-20.FsGroupChangePolicy sysctls Required \u00b6 public readonly sysctls : Sysctl []; Type: cdk8s-plus-20.Sysctl [] fsGroup Optional \u00b6 public readonly fsGroup : number ; Type: number group Optional \u00b6 public readonly group : number ; Type: number user Optional \u00b6 public readonly user : number ; Type: number Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 fromCommand \u00b6 import { Probe } from 'cdk8s-plus-20' Probe . fromCommand ( command : string [], options? : CommandProbeOptions ) command Required \u00b6 Type: string [] The command to execute. options Optional \u00b6 Type: cdk8s-plus-20.CommandProbeOptions Options. fromHttpGet \u00b6 import { Probe } from 'cdk8s-plus-20' Probe . fromHttpGet ( path : string , options? : HttpGetProbeOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-20.HttpGetProbeOptions Options. fromTcpSocket \u00b6 import { Probe } from 'cdk8s-plus-20' Probe . fromTcpSocket ( options? : TcpSocketProbeOptions ) options Optional \u00b6 Type: cdk8s-plus-20.TcpSocketProbeOptions Options. StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 onDelete \u00b6 import { StatefulSetUpdateStrategy } from 'cdk8s-plus-20' StatefulSetUpdateStrategy . onDelete () rollingUpdate \u00b6 import { StatefulSetUpdateStrategy } from 'cdk8s-plus-20' StatefulSetUpdateStrategy . rollingUpdate ( options? : StatefulSetUpdateStrategyRollingUpdateOptions ) options Optional \u00b6 Type: cdk8s-plus-20.StatefulSetUpdateStrategyRollingUpdateOptions User \u00b6 Implements: cdk8s-plus-20.ISubject Represents a user. Initializers \u00b6 import { User } from 'cdk8s-plus-20' new User ( props : UserProps ) props Required \u00b6 Type: cdk8s-plus-20.UserProps Properties \u00b6 kind Required \u00b6 public readonly kind : string ; Type: string Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public readonly name : string ; Type: string Name of the object being referenced. apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Volume \u00b6 Implements: cdk8s-plus-20.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 asVolume \u00b6 public asVolume () Static Functions \u00b6 fromAwsElasticBlockStore \u00b6 import { Volume } from 'cdk8s-plus-20' Volume . fromAwsElasticBlockStore ( volumeId : string , options? : AwsElasticBlockStoreVolumeOptions ) volumeId Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-20.AwsElasticBlockStoreVolumeOptions fromAzureDisk \u00b6 import { Volume } from 'cdk8s-plus-20' Volume . fromAzureDisk ( diskName : string , diskUri : string , options? : AzureDiskVolumeOptions ) diskName Required \u00b6 Type: string diskUri Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-20.AzureDiskVolumeOptions fromConfigMap \u00b6 import { Volume } from 'cdk8s-plus-20' Volume . fromConfigMap ( configMap : IConfigMap , options? : ConfigMapVolumeOptions ) configMap Required \u00b6 Type: cdk8s-plus-20.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-20.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import { Volume } from 'cdk8s-plus-20' Volume . fromEmptyDir ( name : string , options? : EmptyDirVolumeOptions ) name Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-20.EmptyDirVolumeOptions Additional options. fromGcePersistentDisk \u00b6 import { Volume } from 'cdk8s-plus-20' Volume . fromGcePersistentDisk ( pdName : string , options? : GCEPersistentDiskVolumeOptions ) pdName Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-20.GCEPersistentDiskVolumeOptions fromPersistentVolumeClaim \u00b6 import { Volume } from 'cdk8s-plus-20' Volume . fromPersistentVolumeClaim ( claim : IPersistentVolumeClaim , options? : PersistentVolumeClaimVolumeOptions ) claim Required \u00b6 Type: cdk8s-plus-20.IPersistentVolumeClaim options Optional \u00b6 Type: cdk8s-plus-20.PersistentVolumeClaimVolumeOptions fromSecret \u00b6 import { Volume } from 'cdk8s-plus-20' Volume . fromSecret ( secr : ISecret , options? : SecretVolumeOptions ) secr Required \u00b6 Type: cdk8s-plus-20.ISecret The secret to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-20.SecretVolumeOptions Options. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: cdk8s-plus-20.AbstractPod , cdk8s-plus-20.ApiResource , cdk8s-plus-20.AwsElasticBlockStorePersistentVolume , cdk8s-plus-20.AzureDiskPersistentVolume , cdk8s-plus-20.BasicAuthSecret , cdk8s-plus-20.ClusterRole , cdk8s-plus-20.ClusterRoleBinding , cdk8s-plus-20.ConfigMap , cdk8s-plus-20.DaemonSet , cdk8s-plus-20.Deployment , cdk8s-plus-20.DockerConfigSecret , cdk8s-plus-20.GCEPersistentDiskPersistentVolume , cdk8s-plus-20.IngressV1Beta1 , cdk8s-plus-20.Job , cdk8s-plus-20.NonApiResource , cdk8s-plus-20.PersistentVolume , cdk8s-plus-20.PersistentVolumeClaim , cdk8s-plus-20.Pod , cdk8s-plus-20.Resource , cdk8s-plus-20.Role , cdk8s-plus-20.RoleBinding , cdk8s-plus-20.Secret , cdk8s-plus-20.Service , cdk8s-plus-20.ServiceAccount , cdk8s-plus-20.ServiceAccountTokenSecret , cdk8s-plus-20.SshAuthSecret , cdk8s-plus-20.StatefulSet , cdk8s-plus-20.TlsSecret , cdk8s-plus-20.Workload , cdk8s-plus-20.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () IApiResource \u00b6 Implemented By: cdk8s-plus-20.AbstractPod , cdk8s-plus-20.ApiResource , cdk8s-plus-20.AwsElasticBlockStorePersistentVolume , cdk8s-plus-20.AzureDiskPersistentVolume , cdk8s-plus-20.BasicAuthSecret , cdk8s-plus-20.ClusterRole , cdk8s-plus-20.ClusterRoleBinding , cdk8s-plus-20.ConfigMap , cdk8s-plus-20.DaemonSet , cdk8s-plus-20.Deployment , cdk8s-plus-20.DockerConfigSecret , cdk8s-plus-20.GCEPersistentDiskPersistentVolume , cdk8s-plus-20.IngressV1Beta1 , cdk8s-plus-20.Job , cdk8s-plus-20.PersistentVolume , cdk8s-plus-20.PersistentVolumeClaim , cdk8s-plus-20.Pod , cdk8s-plus-20.Resource , cdk8s-plus-20.Role , cdk8s-plus-20.RoleBinding , cdk8s-plus-20.Secret , cdk8s-plus-20.Service , cdk8s-plus-20.ServiceAccount , cdk8s-plus-20.ServiceAccountTokenSecret , cdk8s-plus-20.SshAuthSecret , cdk8s-plus-20.StatefulSet , cdk8s-plus-20.TlsSecret , cdk8s-plus-20.Workload , cdk8s-plus-20.IApiResource Represents a resource or collection of resources. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resourceName Optional \u00b6 public readonly resourceName : string ; Type: string The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.ClusterRole , cdk8s-plus-20.IClusterRole Represents a cluster-level role. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IConfigMap \u00b6 Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.ConfigMap , cdk8s-plus-20.IConfigMap Represents a config map. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IPersistentVolume \u00b6 Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.AwsElasticBlockStorePersistentVolume , cdk8s-plus-20.AzureDiskPersistentVolume , cdk8s-plus-20.GCEPersistentDiskPersistentVolume , cdk8s-plus-20.PersistentVolume , cdk8s-plus-20.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.PersistentVolumeClaim , cdk8s-plus-20.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IResource \u00b6 Implemented By: cdk8s-plus-20.AbstractPod , cdk8s-plus-20.AwsElasticBlockStorePersistentVolume , cdk8s-plus-20.AzureDiskPersistentVolume , cdk8s-plus-20.BasicAuthSecret , cdk8s-plus-20.ClusterRole , cdk8s-plus-20.ClusterRoleBinding , cdk8s-plus-20.ConfigMap , cdk8s-plus-20.DaemonSet , cdk8s-plus-20.Deployment , cdk8s-plus-20.DockerConfigSecret , cdk8s-plus-20.GCEPersistentDiskPersistentVolume , cdk8s-plus-20.IngressV1Beta1 , cdk8s-plus-20.Job , cdk8s-plus-20.PersistentVolume , cdk8s-plus-20.PersistentVolumeClaim , cdk8s-plus-20.Pod , cdk8s-plus-20.Resource , cdk8s-plus-20.Role , cdk8s-plus-20.RoleBinding , cdk8s-plus-20.Secret , cdk8s-plus-20.Service , cdk8s-plus-20.ServiceAccount , cdk8s-plus-20.ServiceAccountTokenSecret , cdk8s-plus-20.SshAuthSecret , cdk8s-plus-20.StatefulSet , cdk8s-plus-20.TlsSecret , cdk8s-plus-20.Workload , cdk8s-plus-20.IClusterRole , cdk8s-plus-20.IConfigMap , cdk8s-plus-20.IPersistentVolume , cdk8s-plus-20.IPersistentVolumeClaim , cdk8s-plus-20.IResource , cdk8s-plus-20.IRole , cdk8s-plus-20.ISecret , cdk8s-plus-20.IServiceAccount Represents a resource. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IRole \u00b6 Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.ClusterRole , cdk8s-plus-20.Role , cdk8s-plus-20.IRole A reference to any Role or ClusterRole. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.BasicAuthSecret , cdk8s-plus-20.DockerConfigSecret , cdk8s-plus-20.Secret , cdk8s-plus-20.ServiceAccountTokenSecret , cdk8s-plus-20.SshAuthSecret , cdk8s-plus-20.TlsSecret , cdk8s-plus-20.ISecret Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.ServiceAccount , cdk8s-plus-20.IServiceAccount Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IStorage \u00b6 Implemented By: cdk8s-plus-20.AwsElasticBlockStorePersistentVolume , cdk8s-plus-20.AzureDiskPersistentVolume , cdk8s-plus-20.GCEPersistentDiskPersistentVolume , cdk8s-plus-20.PersistentVolume , cdk8s-plus-20.Volume , cdk8s-plus-20.IStorage Represents a piece of storage in the cluster. Methods \u00b6 asVolume \u00b6 public asVolume () ISubject \u00b6 Implemented By: cdk8s-plus-20.Group , cdk8s-plus-20.ServiceAccount , cdk8s-plus-20.User , cdk8s-plus-20.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Properties \u00b6 kind Required \u00b6 public readonly kind : string ; Type: string Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public readonly name : string ; Type: string Name of the object being referenced. apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 public readonly namespace : string ; Type: string Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. LabelSelectorRequirementOperator \u00b6 Possible operators. IN \u00b6 In. NOT_IN \u00b6 NotIn. EXISTS \u00b6 Exists. DOES_NOT_EXIST \u00b6 DoesNotExist. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"TypeScript"},{"location":"reference/cdk8s-plus-20/typescript/#cdk8s-plus-20-typescript","text":"","title":"cdk8s-plus-20 (TypeScript) "},{"location":"reference/cdk8s-plus-20/typescript/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-20/typescript/#abstractpod","text":"","title":"AbstractPod "},{"location":"reference/cdk8s-plus-20/typescript/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-20/typescript/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-20/typescript/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-20/typescript/#clusterrole","text":"Implements: cdk8s-plus-20.IClusterRole , cdk8s-plus-20.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-20/typescript/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-20/typescript/#configmap","text":"Implements: cdk8s-plus-20.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-20/typescript/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-20/typescript/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-20/typescript/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-20/typescript/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-20/typescript/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-20/typescript/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-20/typescript/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-20/typescript/#persistentvolume","text":"Implements: cdk8s-plus-20.IPersistentVolume , cdk8s-plus-20.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-20/typescript/#persistentvolumeclaim","text":"Implements: cdk8s-plus-20.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-20/typescript/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-20/typescript/#resource","text":"Implements: cdk8s-plus-20.IResource , cdk8s-plus-20.IApiResource , cdk8s-plus-20.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-20/typescript/#role","text":"Implements: cdk8s-plus-20.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-20/typescript/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-20/typescript/#secret","text":"Implements: cdk8s-plus-20.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-20/typescript/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-20/typescript/#serviceaccount","text":"Implements: cdk8s-plus-20.IServiceAccount , cdk8s-plus-20.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-20/typescript/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-20/typescript/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-20/typescript/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-20/typescript/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-20/typescript/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-20/typescript/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-20/typescript/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-20/typescript/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-20/typescript/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-20/typescript/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-20/typescript/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-20/typescript/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-20/typescript/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-20/typescript/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-20/typescript/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-20/typescript/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-20/typescript/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-20/typescript/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-20/typescript/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-20/typescript/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-20/typescript/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-20/typescript/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-20/typescript/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-20/typescript/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-20/typescript/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-20/typescript/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-20/typescript/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-20/typescript/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-20/typescript/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-20/typescript/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-20/typescript/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-20/typescript/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-20/typescript/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-20/typescript/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-20/typescript/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-20/typescript/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-20/typescript/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-20/typescript/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-20/typescript/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-20/typescript/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-20/typescript/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-20/typescript/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-20/typescript/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-20/typescript/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-20/typescript/#groupprops","text":"Properties for Group .","title":"GroupProps "},{"location":"reference/cdk8s-plus-20/typescript/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-20/typescript/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-20/typescript/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-20/typescript/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-20/typescript/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-20/typescript/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-20/typescript/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-20/typescript/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-20/typescript/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-20/typescript/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-20/typescript/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-20/typescript/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-20/typescript/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-20/typescript/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-20/typescript/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-20/typescript/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-20/typescript/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-20/typescript/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-20/typescript/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-20/typescript/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-20/typescript/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-20/typescript/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-20/typescript/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-20/typescript/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-20/typescript/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-20/typescript/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-20/typescript/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-20/typescript/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-20/typescript/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-20/typescript/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-20/typescript/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-20/typescript/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-20/typescript/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-20/typescript/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-20/typescript/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-20/typescript/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-20/typescript/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-20/typescript/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-20/typescript/#userprops","text":"Properties for User .","title":"UserProps "},{"location":"reference/cdk8s-plus-20/typescript/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-20/typescript/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-20/typescript/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-20/typescript/#apiresource","text":"Implements: cdk8s-plus-20.IApiResource , cdk8s-plus-20.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-20/typescript/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-20/typescript/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-20/typescript/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-20/typescript/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-20/typescript/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-20/typescript/#group","text":"Implements: cdk8s-plus-20.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-20/typescript/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-20/typescript/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-20/typescript/#labelselector","text":"A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors","title":"LabelSelector "},{"location":"reference/cdk8s-plus-20/typescript/#nonapiresource","text":"Implements: cdk8s-plus-20.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-20/typescript/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-20/typescript/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-20/typescript/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-20/typescript/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-20/typescript/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-20/typescript/#user","text":"Implements: cdk8s-plus-20.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-20/typescript/#volume","text":"Implements: cdk8s-plus-20.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-20/typescript/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-20/typescript/#iapiendpoint","text":"Implemented By: cdk8s-plus-20.AbstractPod , cdk8s-plus-20.ApiResource , cdk8s-plus-20.AwsElasticBlockStorePersistentVolume , cdk8s-plus-20.AzureDiskPersistentVolume , cdk8s-plus-20.BasicAuthSecret , cdk8s-plus-20.ClusterRole , cdk8s-plus-20.ClusterRoleBinding , cdk8s-plus-20.ConfigMap , cdk8s-plus-20.DaemonSet , cdk8s-plus-20.Deployment , cdk8s-plus-20.DockerConfigSecret , cdk8s-plus-20.GCEPersistentDiskPersistentVolume , cdk8s-plus-20.IngressV1Beta1 , cdk8s-plus-20.Job , cdk8s-plus-20.NonApiResource , cdk8s-plus-20.PersistentVolume , cdk8s-plus-20.PersistentVolumeClaim , cdk8s-plus-20.Pod , cdk8s-plus-20.Resource , cdk8s-plus-20.Role , cdk8s-plus-20.RoleBinding , cdk8s-plus-20.Secret , cdk8s-plus-20.Service , cdk8s-plus-20.ServiceAccount , cdk8s-plus-20.ServiceAccountTokenSecret , cdk8s-plus-20.SshAuthSecret , cdk8s-plus-20.StatefulSet , cdk8s-plus-20.TlsSecret , cdk8s-plus-20.Workload , cdk8s-plus-20.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-20/typescript/#iapiresource","text":"Implemented By: cdk8s-plus-20.AbstractPod , cdk8s-plus-20.ApiResource , cdk8s-plus-20.AwsElasticBlockStorePersistentVolume , cdk8s-plus-20.AzureDiskPersistentVolume , cdk8s-plus-20.BasicAuthSecret , cdk8s-plus-20.ClusterRole , cdk8s-plus-20.ClusterRoleBinding , cdk8s-plus-20.ConfigMap , cdk8s-plus-20.DaemonSet , cdk8s-plus-20.Deployment , cdk8s-plus-20.DockerConfigSecret , cdk8s-plus-20.GCEPersistentDiskPersistentVolume , cdk8s-plus-20.IngressV1Beta1 , cdk8s-plus-20.Job , cdk8s-plus-20.PersistentVolume , cdk8s-plus-20.PersistentVolumeClaim , cdk8s-plus-20.Pod , cdk8s-plus-20.Resource , cdk8s-plus-20.Role , cdk8s-plus-20.RoleBinding , cdk8s-plus-20.Secret , cdk8s-plus-20.Service , cdk8s-plus-20.ServiceAccount , cdk8s-plus-20.ServiceAccountTokenSecret , cdk8s-plus-20.SshAuthSecret , cdk8s-plus-20.StatefulSet , cdk8s-plus-20.TlsSecret , cdk8s-plus-20.Workload , cdk8s-plus-20.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-20/typescript/#iclusterrole","text":"Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.ClusterRole , cdk8s-plus-20.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-20/typescript/#iconfigmap","text":"Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.ConfigMap , cdk8s-plus-20.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-20/typescript/#ipersistentvolume","text":"Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.AwsElasticBlockStorePersistentVolume , cdk8s-plus-20.AzureDiskPersistentVolume , cdk8s-plus-20.GCEPersistentDiskPersistentVolume , cdk8s-plus-20.PersistentVolume , cdk8s-plus-20.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-20/typescript/#ipersistentvolumeclaim","text":"Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.PersistentVolumeClaim , cdk8s-plus-20.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-20/typescript/#iresource","text":"Implemented By: cdk8s-plus-20.AbstractPod , cdk8s-plus-20.AwsElasticBlockStorePersistentVolume , cdk8s-plus-20.AzureDiskPersistentVolume , cdk8s-plus-20.BasicAuthSecret , cdk8s-plus-20.ClusterRole , cdk8s-plus-20.ClusterRoleBinding , cdk8s-plus-20.ConfigMap , cdk8s-plus-20.DaemonSet , cdk8s-plus-20.Deployment , cdk8s-plus-20.DockerConfigSecret , cdk8s-plus-20.GCEPersistentDiskPersistentVolume , cdk8s-plus-20.IngressV1Beta1 , cdk8s-plus-20.Job , cdk8s-plus-20.PersistentVolume , cdk8s-plus-20.PersistentVolumeClaim , cdk8s-plus-20.Pod , cdk8s-plus-20.Resource , cdk8s-plus-20.Role , cdk8s-plus-20.RoleBinding , cdk8s-plus-20.Secret , cdk8s-plus-20.Service , cdk8s-plus-20.ServiceAccount , cdk8s-plus-20.ServiceAccountTokenSecret , cdk8s-plus-20.SshAuthSecret , cdk8s-plus-20.StatefulSet , cdk8s-plus-20.TlsSecret , cdk8s-plus-20.Workload , cdk8s-plus-20.IClusterRole , cdk8s-plus-20.IConfigMap , cdk8s-plus-20.IPersistentVolume , cdk8s-plus-20.IPersistentVolumeClaim , cdk8s-plus-20.IResource , cdk8s-plus-20.IRole , cdk8s-plus-20.ISecret , cdk8s-plus-20.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-20/typescript/#irole","text":"Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.ClusterRole , cdk8s-plus-20.Role , cdk8s-plus-20.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-20/typescript/#isecret","text":"Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.BasicAuthSecret , cdk8s-plus-20.DockerConfigSecret , cdk8s-plus-20.Secret , cdk8s-plus-20.ServiceAccountTokenSecret , cdk8s-plus-20.SshAuthSecret , cdk8s-plus-20.TlsSecret , cdk8s-plus-20.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-20/typescript/#iserviceaccount","text":"Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.ServiceAccount , cdk8s-plus-20.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-20/typescript/#istorage","text":"Implemented By: cdk8s-plus-20.AwsElasticBlockStorePersistentVolume , cdk8s-plus-20.AzureDiskPersistentVolume , cdk8s-plus-20.GCEPersistentDiskPersistentVolume , cdk8s-plus-20.PersistentVolume , cdk8s-plus-20.Volume , cdk8s-plus-20.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-20/typescript/#isubject","text":"Implemented By: cdk8s-plus-20.Group , cdk8s-plus-20.ServiceAccount , cdk8s-plus-20.User , cdk8s-plus-20.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"ISubject "},{"location":"reference/cdk8s-plus-20/typescript/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-20/typescript/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-20/typescript/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-20/typescript/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-20/typescript/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-20/typescript/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-20/typescript/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-20/typescript/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-20/typescript/#labelselectorrequirementoperator","text":"Possible operators.","title":"LabelSelectorRequirementOperator "},{"location":"reference/cdk8s-plus-20/typescript/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-20/typescript/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-20/typescript/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-20/typescript/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-20/typescript/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-20/typescript/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-20/typescript/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-20/typescript/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-20/typescript/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-21/go/","text":"cdk8s-plus-21 (Go) \u00b6 For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus21 .","title":"Go"},{"location":"reference/cdk8s-plus-21/go/#cdk8s-plus-21-go","text":"For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus21 .","title":"cdk8s-plus-21 (Go) "},{"location":"reference/cdk8s-plus-21/java/","text":"cdk8s-plus-21 (Java) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Initializers \u00b6 import org.cdk8s.plus21.AbstractPod ; AbstractPod . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps cont ) cont Required \u00b6 Type: org.cdk8s.plus21.ContainerProps addHostAlias \u00b6 public addHostAlias ( HostAlias hostAlias ) hostAlias Required \u00b6 Type: org.cdk8s.plus21.HostAlias addInitContainer \u00b6 public addInitContainer ( ContainerProps cont ) cont Required \u00b6 Type: org.cdk8s.plus21.ContainerProps addVolume \u00b6 public addVolume ( Volume vol ) vol Required \u00b6 Type: org.cdk8s.plus21.Volume Properties \u00b6 automountServiceAccountToken Required \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus21.Container > dns Required \u00b6 public PodDns getDns (); Type: org.cdk8s.plus21.PodDns hostAliases Required \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus21.HostAlias > initContainers Required \u00b6 public java . util . List < Container > getInitContainers (); Type: java.util.List< org.cdk8s.plus21.Container > securityContext Required \u00b6 public PodSecurityContext getSecurityContext (); Type: org.cdk8s.plus21.PodSecurityContext volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus21.DockerConfigSecret restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import org.cdk8s.plus21.AwsElasticBlockStorePersistentVolume ; AwsElasticBlockStorePersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . volumeId ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 Type: java.lang.String Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. volumeId Required \u00b6 public java . lang . String getVolumeId (); Type: java.lang.String Volume id of this volume. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import org.cdk8s.plus21.AzureDiskPersistentVolume ; AzureDiskPersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . diskName ( java . lang . String ) . diskUri ( java . lang . String ) // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 Type: java.lang.String The Name of the data disk in the blob storage. diskUri Required \u00b6 Type: java.lang.String The URI the data disk in the blob storage. cachingMode Optional \u00b6 Type: org.cdk8s.plus21.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: org.cdk8s.plus21.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. Properties \u00b6 azureKind Required \u00b6 public AzureDiskPersistentVolumeKind getAzureKind (); Type: org.cdk8s.plus21.AzureDiskPersistentVolumeKind Azure kind of this volume. cachingMode Required \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus21.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. diskName Required \u00b6 public java . lang . String getDiskName (); Type: java.lang.String Disk name of this volume. diskUri Required \u00b6 public java . lang . String getDiskUri (); Type: java.lang.String Disk URI of this volume. fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import org.cdk8s.plus21.BasicAuthSecret ; BasicAuthSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . password ( java . lang . String ) . username ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 Type: java.lang.String The password or token for authentication. username Required \u00b6 Type: java.lang.String The user name for authentication. ClusterRole \u00b6 Implements: org.cdk8s.plus21.IClusterRole , org.cdk8s.plus21.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import org.cdk8s.plus21.ClusterRole ; ClusterRole . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .aggregationLabels(java.util.Map<java.lang.String, java.lang.String>) // .rules(java.util.List<ClusterRolePolicyRule>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 Type: java.util.Map java.lang.String > Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ClusterRolePolicyRule > Default: [] A list of rules the role should allow. Methods \u00b6 aggregate \u00b6 public aggregate ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String allow \u00b6 public allow ( java . util . List < java . lang . String > verbs , IApiEndpoint endpoints ) verbs Required \u00b6 Type: java.util.List< java.lang.String > endpoints Required \u00b6 Type: org.cdk8s.plus21.IApiEndpoint The endpoints(s) to apply to. allowCreate \u00b6 public allowCreate ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus21.IApiEndpoint The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus21.IApiEndpoint The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus21.IApiEndpoint The resource(s) to apply to. allowGet \u00b6 public allowGet ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus21.IApiEndpoint The resource(s) to apply to. allowList \u00b6 public allowList ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus21.IApiEndpoint The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus21.IApiEndpoint The resource(s) to apply to. allowRead \u00b6 public allowRead ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus21.IApiEndpoint The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus21.IApiEndpoint The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus21.IApiEndpoint The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus21.IApiEndpoint The resource(s) to apply to. bind \u00b6 public bind ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus21.ISubject a list of subjects to bind to. bindInNamespace \u00b6 public bindInNamespace ( java . lang . String namespace , ISubject subjects ) namespace Required \u00b6 Type: java.lang.String the namespace to limit permissions to. subjects Required \u00b6 Type: org.cdk8s.plus21.ISubject a list of subjects to bind to. combine \u00b6 public combine ( ClusterRole rol ) rol Required \u00b6 Type: org.cdk8s.plus21.ClusterRole Static Functions \u00b6 fromClusterRoleName \u00b6 import org.cdk8s.plus21.ClusterRole ; ClusterRole . fromClusterRoleName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the role resource. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public java . util . List < ClusterRolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus21.ClusterRolePolicyRule > Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import org.cdk8s.plus21.ClusterRoleBinding ; ClusterRoleBinding . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) . role ( IClusterRole ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: org.cdk8s.plus21.IClusterRole The role to bind to. Methods \u00b6 addSubjects \u00b6 public addSubjects ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus21.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public IClusterRole getRole (); Type: org.cdk8s.plus21.IClusterRole subjects Required \u00b6 public java . util . List < ISubject > getSubjects (); Type: java.util.List< org.cdk8s.plus21.ISubject > ConfigMap \u00b6 Implements: org.cdk8s.plus21.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import org.cdk8s.plus21.ConfigMap ; ConfigMap . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) // .immutable(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addData \u00b6 public addData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addDirectory \u00b6 public addDirectory ( java . lang . String localDir ) public addDirectory ( java . lang . String localDir , AddDirectoryOptions options ) localDir Required \u00b6 Type: java.lang.String A path to a local directory. options Optional \u00b6 Type: org.cdk8s.plus21.AddDirectoryOptions Options. addFile \u00b6 public addFile ( java . lang . String localFile ) public addFile ( java . lang . String localFile , java . lang . String key ) localFile Required \u00b6 Type: java.lang.String The path to the local file. key Optional \u00b6 Type: java.lang.String The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import org.cdk8s.plus21.ConfigMap ; ConfigMap . fromConfigMapName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the config map to import. Properties \u00b6 binaryData Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Whether or not this config map is immutable. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import org.cdk8s.plus21.DaemonSet ; DaemonSet . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .minReadySeconds(java.lang.Number) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReadySeconds Optional \u00b6 Type: java.lang.Number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Properties \u00b6 minReadySeconds Required \u00b6 public java . lang . Number getMinReadySeconds (); Type: java.lang.Number resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import org.cdk8s.plus21.Deployment ; Deployment . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .minReady(Duration) // .progressDeadline(Duration) // .replicas(java.lang.Number) // .strategy(DeploymentStrategy) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReady Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 Type: org.cdk8s.plus21.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. Methods \u00b6 exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeDeploymentViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The ingress path to register under. options Optional \u00b6 Type: org.cdk8s.plus21.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService () public exposeViaService ( ExposeDeploymentViaServiceOptions options ) options Optional \u00b6 Type: org.cdk8s.plus21.ExposeDeploymentViaServiceOptions Options to determine details of the service and port exposed. Properties \u00b6 minReady Required \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progressDeadline Required \u00b6 public Duration getProgressDeadline (); Type: org.cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public DeploymentStrategy getStrategy (); Type: org.cdk8s.plus21.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import org.cdk8s.plus21.DockerConfigSecret ; DockerConfigSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . data ( java . util . Map < java . lang . String , java . lang . Object > ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 Type: java.util.Map java.lang.Object > JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import org.cdk8s.plus21.GCEPersistentDiskPersistentVolume ; GCEPersistentDiskPersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . pdName ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 Type: java.lang.String Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. pdName Required \u00b6 public java . lang . String getPdName (); Type: java.lang.String PD resource in GCE of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Partition of this volume. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import org.cdk8s.plus21.IngressV1Beta1 ; IngressV1Beta1 . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .defaultBackend(IngressV1Beta1Backend) // .rules(java.util.List<IngressV1Beta1Rule>) // .tls(java.util.List<IngressV1Beta1Tls>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 Type: org.cdk8s.plus21.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.IngressV1Beta1Rule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.IngressV1Beta1Tls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( IngressV1Beta1Backend backend ) backend Required \u00b6 Type: org.cdk8s.plus21.IngressV1Beta1Backend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( java . lang . String host , IngressV1Beta1Backend backend ) host Required \u00b6 Type: java.lang.String The host name to match. backend Required \u00b6 Type: org.cdk8s.plus21.IngressV1Beta1Backend The backend to route to. addHostRule \u00b6 public addHostRule ( java . lang . String host , java . lang . String path , IngressV1Beta1Backend backend ) host Required \u00b6 Type: java.lang.String The host name. path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus21.IngressV1Beta1Backend The backend to route requests to. addRule \u00b6 public addRule ( java . lang . String path , IngressV1Beta1Backend backend ) path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus21.IngressV1Beta1Backend The backend to route requests to. addRules \u00b6 public addRules ( IngressV1Beta1Rule rules ) rules Required \u00b6 Type: org.cdk8s.plus21.IngressV1Beta1Rule The rules to add. addTls \u00b6 public addTls ( java . util . List < IngressV1Beta1Tls > tls ) tls Required \u00b6 Type: java.util.List< org.cdk8s.plus21.IngressV1Beta1Tls > Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import org.cdk8s.plus21.Job ; Job . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. activeDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Number of retries before marking failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration TTL before the job is deleted after it is finished. PersistentVolume \u00b6 Implements: org.cdk8s.plus21.IPersistentVolume , org.cdk8s.plus21.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import org.cdk8s.plus21.PersistentVolume ; PersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 asVolume \u00b6 public asVolume () bind \u00b6 public bind ( IPersistentVolumeClaim claim ) claim Required \u00b6 Type: org.cdk8s.plus21.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 public reserve () Static Functions \u00b6 fromPersistentVolumeName \u00b6 import org.cdk8s.plus21.PersistentVolume ; PersistentVolume . fromPersistentVolumeName ( java . lang . String volumeName ) volumeName Required \u00b6 Type: java.lang.String The name of the pv to reference. Properties \u00b6 mode Required \u00b6 public PersistentVolumeMode getMode (); Type: org.cdk8s.plus21.PersistentVolumeMode Volume mode of this volume. reclaimPolicy Required \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus21.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus21.PersistentVolumeAccessMode > Access modes requirement of this claim. claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus21.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Mount options of this volume. storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Storage size of this volume. storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: org.cdk8s.plus21.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import org.cdk8s.plus21.PersistentVolumeClaim ; PersistentVolumeClaim . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .storage(Size) // .storageClassName(java.lang.String) // .volume(IPersistentVolume) // .volumeMode(PersistentVolumeMode) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.PersistentVolumeAccessMode > Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 Type: org.cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 Type: org.cdk8s.plus21.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 Type: org.cdk8s.plus21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 bind \u00b6 public bind ( IPersistentVolume vol ) vol Required \u00b6 Type: org.cdk8s.plus21.IPersistentVolume The PV to bind to. Static Functions \u00b6 fromClaimName \u00b6 import org.cdk8s.plus21.PersistentVolumeClaim ; PersistentVolumeClaim . fromClaimName ( java . lang . String claimName ) claimName Required \u00b6 Type: java.lang.String The name of the pvc to reference. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. volumeMode Required \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus21.PersistentVolumeMode Volume mode requirement of this claim. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus21.PersistentVolumeAccessMode > Access modes requirement of this claim. storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Storage requirement of this claim. storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Storage class requirment of this claim. volume Optional \u00b6 public IPersistentVolume getVolume (); Type: org.cdk8s.plus21.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import org.cdk8s.plus21.Pod ; Pod . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Resource \u00b6 Implements: org.cdk8s.plus21.IResource , org.cdk8s.plus21.IApiResource , org.cdk8s.plus21.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import org.cdk8s.plus21.Resource ; Resource . Builder . create ( Construct scope , java . lang . String id ) // .nodeFactory(INodeFactory) . build (); scope Required \u00b6 Type: software.constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: java.lang.String The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . nodeFactory Optional \u00b6 Type: software.constructs.INodeFactory Default: the default Node is associated A factory for attaching Node s to the construct. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 public ApiObjectMetadataDefinition getMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this API object. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. resourceName Optional \u00b6 public java . lang . String getResourceName (); Type: java.lang.String The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: org.cdk8s.plus21.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import org.cdk8s.plus21.Role ; Role . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .rules(java.util.List<RolePolicyRule>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.RolePolicyRule > Default: [] A list of rules the role should allow. Methods \u00b6 allow \u00b6 public allow ( java . util . List < java . lang . String > verbs , IApiResource resources ) verbs Required \u00b6 Type: java.util.List< java.lang.String > resources Required \u00b6 Type: org.cdk8s.plus21.IApiResource The resource(s) to apply to. allowCreate \u00b6 public allowCreate ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus21.IApiResource The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus21.IApiResource The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus21.IApiResource The resource(s) to apply to. allowGet \u00b6 public allowGet ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus21.IApiResource The resource(s) to apply to. allowList \u00b6 public allowList ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus21.IApiResource The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus21.IApiResource The resource(s) to apply to. allowRead \u00b6 public allowRead ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus21.IApiResource The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus21.IApiResource The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus21.IApiResource The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus21.IApiResource The resource(s) to apply to. bind \u00b6 public bind ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus21.ISubject a list of subjects to bind to. Static Functions \u00b6 fromRoleName \u00b6 import org.cdk8s.plus21.Role ; Role . fromRoleName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the role resource. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public java . util . List < RolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus21.RolePolicyRule > Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import org.cdk8s.plus21.RoleBinding ; RoleBinding . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) . role ( IRole ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: org.cdk8s.plus21.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. Methods \u00b6 addSubjects \u00b6 public addSubjects ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus21.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public IRole getRole (); Type: org.cdk8s.plus21.IRole subjects Required \u00b6 public java . util . List < ISubject > getSubjects (); Type: java.util.List< org.cdk8s.plus21.ISubject > Secret \u00b6 Implements: org.cdk8s.plus21.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import org.cdk8s.plus21.Secret ; Secret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 addStringData \u00b6 public addStringData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String Key. value Required \u00b6 Type: java.lang.String Value. getStringData \u00b6 public getStringData ( java . lang . String key ) key Required \u00b6 Type: java.lang.String Key. Static Functions \u00b6 fromSecretName \u00b6 import org.cdk8s.plus21.Secret ; Secret . fromSecretName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the secret to reference. Properties \u00b6 immutable Required \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Whether or not the secret is immutable. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import org.cdk8s.plus21.Service ; Service . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .type(ServiceType) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ServicePort > The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: org.cdk8s.plus21.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 addDeployment \u00b6 public addDeployment ( Deployment depl ) public addDeployment ( Deployment depl , AddDeploymentOptions options ) depl Required \u00b6 Type: org.cdk8s.plus21.Deployment The deployment to expose. options Optional \u00b6 Type: org.cdk8s.plus21.AddDeploymentOptions Optional settings for the port. addSelector \u00b6 public addSelector ( java . lang . String label , java . lang . String value ) label Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeServiceViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The path to expose the service under. options Optional \u00b6 Type: org.cdk8s.plus21.ExposeServiceViaIngressOptions Additional options. serve \u00b6 public serve ( java . lang . Number port ) public serve ( java . lang . Number port , ServicePortOptions options ) port Required \u00b6 Type: java.lang.Number The port definition. options Optional \u00b6 Type: org.cdk8s.plus21.ServicePortOptions Properties \u00b6 ports Required \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus21.ServicePort > Ports for this service. Use serve() to expose additional service ports. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. selector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getSelector (); Type: java.util.Map java.lang.String > Returns the labels which are used to select pods for this service. type Required \u00b6 public ServiceType getType (); Type: org.cdk8s.plus21.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: org.cdk8s.plus21.IServiceAccount , org.cdk8s.plus21.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import org.cdk8s.plus21.ServiceAccount ; ServiceAccount . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountToken(java.lang.Boolean) // .secrets(java.util.List<ISecret>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 addSecret \u00b6 public addSecret ( ISecret secr ) secr Required \u00b6 Type: org.cdk8s.plus21.ISecret The secret. Static Functions \u00b6 fromServiceAccountName \u00b6 import org.cdk8s.plus21.ServiceAccount ; ServiceAccount . fromServiceAccountName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the service account resource. Properties \u00b6 automountToken Required \u00b6 public java . lang . Boolean getAutomountToken (); Type: java.lang.Boolean Whether or not a token is automatically mounted for this service account. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus21.ISecret > List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import org.cdk8s.plus21.ServiceAccountTokenSecret ; ServiceAccountTokenSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . serviceAccount ( IServiceAccount ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 Type: org.cdk8s.plus21.IServiceAccount The service account to store a secret for. SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import org.cdk8s.plus21.SshAuthSecret ; SshAuthSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . sshPrivateKey ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 Type: java.lang.String The SSH private key to use. StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import org.cdk8s.plus21.StatefulSet ; StatefulSet . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) . service ( Service ) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) // .strategy(StatefulSetUpdateStrategy) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. service Required \u00b6 Type: org.cdk8s.plus21.Service Service to associate with the statefulset. podManagementPolicy Optional \u00b6 Type: org.cdk8s.plus21.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 Type: org.cdk8s.plus21.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. Properties \u00b6 podManagementPolicy Required \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus21.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public StatefulSetUpdateStrategy getStrategy (); Type: org.cdk8s.plus21.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import org.cdk8s.plus21.TlsSecret ; TlsSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . tlsCert ( java . lang . String ) . tlsKey ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 Type: java.lang.String The TLS cert. tlsKey Required \u00b6 Type: java.lang.String The TLS key. Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import org.cdk8s.plus21.Workload ; Workload . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. Methods \u00b6 select \u00b6 public select ( LabelSelector selectors ) selectors Required \u00b6 Type: org.cdk8s.plus21.LabelSelector Properties \u00b6 matchExpressions Required \u00b6 public java . util . List < LabelSelectorRequirement > getMatchExpressions (); Type: java.util.List< org.cdk8s.plus21.LabelSelectorRequirement > The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. matchLabels Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getMatchLabels (); Type: java.util.Map java.lang.String > The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import org.cdk8s.plus21.AbstractPodProps ; AbstractPodProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus21.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import org.cdk8s.plus21.AddDeploymentOptions ; AddDeploymentOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) // .port(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import org.cdk8s.plus21.AddDirectoryOptions ; AddDirectoryOptions . builder () // .exclude(java.util.List<java.lang.String>) // .keyPrefix(java.lang.String) . build (); exclude Optional \u00b6 public java . util . List < java . lang . String > getExclude (); Type: java.util.List< java.lang.String > Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public java . lang . String getKeyPrefix (); Type: java.lang.String Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import org.cdk8s.plus21.ApiResourceOptions ; ApiResourceOptions . builder () . apiGroup ( java . lang . String ) . resourceType ( java . lang . String ) . build (); apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import org.cdk8s.plus21.AwsElasticBlockStorePersistentVolumeProps ; AwsElasticBlockStorePersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . volumeId ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus21.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 public java . lang . String getVolumeId (); Type: java.lang.String Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import org.cdk8s.plus21.AwsElasticBlockStoreVolumeOptions ; AwsElasticBlockStoreVolumeOptions . builder () // .fsType(java.lang.String) // .name(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import org.cdk8s.plus21.AzureDiskPersistentVolumeProps ; AzureDiskPersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . diskName ( java . lang . String ) . diskUri ( java . lang . String ) // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus21.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 public java . lang . String getDiskName (); Type: java.lang.String The Name of the data disk in the blob storage. diskUri Required \u00b6 public java . lang . String getDiskUri (); Type: java.lang.String The URI the data disk in the blob storage. cachingMode Optional \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus21.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public AzureDiskPersistentVolumeKind getKind (); Type: org.cdk8s.plus21.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import org.cdk8s.plus21.AzureDiskVolumeOptions ; AzureDiskVolumeOptions . builder () // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .name(java.lang.String) // .readOnly(java.lang.Boolean) . build (); cachingMode Optional \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus21.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public AzureDiskPersistentVolumeKind getKind (); Type: org.cdk8s.plus21.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import org.cdk8s.plus21.BasicAuthSecretProps ; BasicAuthSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . password ( java . lang . String ) . username ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 public java . lang . String getPassword (); Type: java.lang.String The password or token for authentication. username Required \u00b6 public java . lang . String getUsername (); Type: java.lang.String The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import org.cdk8s.plus21.ClusterRoleBindingProps ; ClusterRoleBindingProps . builder () // .metadata(ApiObjectMetadata) . role ( IClusterRole ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public IClusterRole getRole (); Type: org.cdk8s.plus21.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import org.cdk8s.plus21.ClusterRolePolicyRule ; ClusterRolePolicyRule . builder () . endpoints ( java . util . List < IApiEndpoint > ) . verbs ( java . util . List < java . lang . String > ) . build (); endpoints Required \u00b6 public java . util . List < IApiEndpoint > getEndpoints (); Type: java.util.List< org.cdk8s.plus21.IApiEndpoint > Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 public java . util . List < java . lang . String > getVerbs (); Type: java.util.List< java.lang.String > Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import org.cdk8s.plus21.ClusterRoleProps ; ClusterRoleProps . builder () // .metadata(ApiObjectMetadata) // .aggregationLabels(java.util.Map<java.lang.String, java.lang.String>) // .rules(java.util.List<ClusterRolePolicyRule>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getAggregationLabels (); Type: java.util.Map java.lang.String > Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 public java . util . List < ClusterRolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus21.ClusterRolePolicyRule > Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import org.cdk8s.plus21.CommandProbeOptions ; CommandProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import org.cdk8s.plus21.CommonSecretProps ; CommonSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import org.cdk8s.plus21.ConfigMapProps ; ConfigMapProps . builder () // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) // .immutable(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import org.cdk8s.plus21.ConfigMapVolumeOptions ; ConfigMapVolumeOptions . builder () // .defaultMode(java.lang.Number) // .items(java.util.Map<java.lang.String, PathMapping>) // .name(java.lang.String) // .optional(java.lang.Boolean) . build (); defaultMode Optional \u00b6 public java . lang . Number getDefaultMode (); Type: java.lang.Number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public java . util . Map < java . lang . String , PathMapping > getItems (); Type: java.util.Map \u0002klzzwxh:8312\u0003 > Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import org.cdk8s.plus21.ContainerLifecycle ; ContainerLifecycle . builder () // .postStart(Handler) // .preStop(Handler) . build (); postStart Optional \u00b6 public Handler getPostStart (); Type: org.cdk8s.plus21.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. preStop Optional \u00b6 public Handler getPreStop (); Type: org.cdk8s.plus21.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import org.cdk8s.plus21.ContainerProps ; ContainerProps . builder () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .env(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .lifecycle(ContainerLifecycle) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .readiness(Probe) // .resources(ContainerResources) // .securityContext(ContainerSecurityContextProps) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String Docker image name. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnv (); Type: java.util.Map \u0002klzzwxh:8285\u0003 > Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 public ContainerLifecycle getLifecycle (); Type: org.cdk8s.plus21.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 public Probe getLiveness (); Type: org.cdk8s.plus21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 public Probe getReadiness (); Type: org.cdk8s.plus21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 public ContainerResources getResources (); Type: org.cdk8s.plus21.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 public ContainerSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus21.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 public Probe getStartup (); Type: org.cdk8s.plus21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public java . util . List < VolumeMount > getVolumeMounts (); Type: java.util.List< org.cdk8s.plus21.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import org.cdk8s.plus21.ContainerResources ; ContainerResources . builder () . cpu ( CpuResources ) . memory ( MemoryResources ) . build (); cpu Required \u00b6 public CpuResources getCpu (); Type: org.cdk8s.plus21.CpuResources memory Required \u00b6 public MemoryResources getMemory (); Type: org.cdk8s.plus21.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import org.cdk8s.plus21.ContainerSecurityContextProps ; ContainerSecurityContextProps . builder () // .ensureNonRoot(java.lang.Boolean) // .group(java.lang.Number) // .privileged(java.lang.Boolean) // .readOnlyRootFilesystem(java.lang.Boolean) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. privileged Optional \u00b6 public java . lang . Boolean getPrivileged (); Type: java.lang.Boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 public java . lang . Boolean getReadOnlyRootFilesystem (); Type: java.lang.Boolean Default: false Whether this container has a read-only root filesystem. user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import org.cdk8s.plus21.CpuResources ; CpuResources . builder () . limit ( Cpu ) . request ( Cpu ) . build (); limit Required \u00b6 public Cpu getLimit (); Type: org.cdk8s.plus21.Cpu request Required \u00b6 public Cpu getRequest (); Type: org.cdk8s.plus21.Cpu DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import org.cdk8s.plus21.DaemonSetProps ; DaemonSetProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .minReadySeconds(java.lang.Number) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus21.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReadySeconds Optional \u00b6 public java . lang . Number getMinReadySeconds (); Type: java.lang.Number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import org.cdk8s.plus21.DeploymentProps ; DeploymentProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .minReady(Duration) // .progressDeadline(Duration) // .replicas(java.lang.Number) // .strategy(DeploymentStrategy) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus21.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReady Optional \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 public Duration getProgressDeadline (); Type: org.cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 public DeploymentStrategy getStrategy (); Type: org.cdk8s.plus21.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import org.cdk8s.plus21.DeploymentStrategyRollingUpdateOptions ; DeploymentStrategyRollingUpdateOptions . builder () // .maxSurge(PercentOrAbsolute) // .maxUnavailable(PercentOrAbsolute) . build (); maxSurge Optional \u00b6 public PercentOrAbsolute getMaxSurge (); Type: org.cdk8s.plus21.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. maxUnavailable Optional \u00b6 public PercentOrAbsolute getMaxUnavailable (); Type: org.cdk8s.plus21.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import org.cdk8s.plus21.DnsOption ; DnsOption . builder () . name ( java . lang . String ) // .value(java.lang.String) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Option name. value Optional \u00b6 public java . lang . String getValue (); Type: java.lang.String Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import org.cdk8s.plus21.DockerConfigSecretProps ; DockerConfigSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . data ( java . util . Map < java . lang . String , java . lang . Object > ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 public java . util . Map < java . lang . String , java . lang . Object > getData (); Type: java.util.Map java.lang.Object > JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import org.cdk8s.plus21.EmptyDirVolumeOptions ; EmptyDirVolumeOptions . builder () // .medium(EmptyDirMedium) // .sizeLimit(Size) . build (); medium Optional \u00b6 public EmptyDirMedium getMedium (); Type: org.cdk8s.plus21.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public Size getSizeLimit (); Type: org.cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import org.cdk8s.plus21.EnvValueFromConfigMapOptions ; EnvValueFromConfigMapOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import org.cdk8s.plus21.EnvValueFromFieldRefOptions ; EnvValueFromFieldRefOptions . builder () // .apiVersion(java.lang.String) // .key(java.lang.String) . build (); apiVersion Optional \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String Version of the schema the FieldPath is written in terms of. key Optional \u00b6 public java . lang . String getKey (); Type: java.lang.String The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import org.cdk8s.plus21.EnvValueFromProcessOptions ; EnvValueFromProcessOptions . builder () // .required(java.lang.Boolean) . build (); required Optional \u00b6 public java . lang . Boolean getRequired (); Type: java.lang.Boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import org.cdk8s.plus21.EnvValueFromResourceOptions ; EnvValueFromResourceOptions . builder () // .container(Container) // .divisor(java.lang.String) . build (); container Optional \u00b6 public Container getContainer (); Type: org.cdk8s.plus21.Container The container to select the value from. divisor Optional \u00b6 public java . lang . String getDivisor (); Type: java.lang.String The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import org.cdk8s.plus21.EnvValueFromSecretOptions ; EnvValueFromSecretOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import org.cdk8s.plus21.ExposeDeploymentViaIngressOptions ; ExposeDeploymentViaIngressOptions . builder () // .name(java.lang.String) // .port(java.lang.Number) // .protocol(Protocol) // .serviceType(ServiceType) // .targetPort(java.lang.Number) // .ingress(IngressV1Beta1) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus21.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 public IngressV1Beta1 getIngress (); Type: org.cdk8s.plus21.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import org.cdk8s.plus21.ExposeDeploymentViaServiceOptions ; ExposeDeploymentViaServiceOptions . builder () // .name(java.lang.String) // .port(java.lang.Number) // .protocol(Protocol) // .serviceType(ServiceType) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus21.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import org.cdk8s.plus21.ExposeServiceViaIngressOptions ; ExposeServiceViaIngressOptions . builder () // .ingress(IngressV1Beta1) . build (); ingress Optional \u00b6 public IngressV1Beta1 getIngress (); Type: org.cdk8s.plus21.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import org.cdk8s.plus21.GCEPersistentDiskPersistentVolumeProps ; GCEPersistentDiskPersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . pdName ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus21.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 public java . lang . String getPdName (); Type: java.lang.String Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import org.cdk8s.plus21.GCEPersistentDiskVolumeOptions ; GCEPersistentDiskVolumeOptions . builder () // .fsType(java.lang.String) // .name(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GroupProps \u00b6 Properties for Group . Initializer \u00b6 import org.cdk8s.plus21.GroupProps ; GroupProps . builder () . name ( java . lang . String ) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the group. HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import org.cdk8s.plus21.HandlerFromHttpGetOptions ; HandlerFromHttpGetOptions . builder () // .port(java.lang.Number) . build (); port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import org.cdk8s.plus21.HandlerFromTcpSocketOptions ; HandlerFromTcpSocketOptions . builder () // .host(java.lang.String) // .port(java.lang.Number) . build (); host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import org.cdk8s.plus21.HostAlias ; HostAlias . builder () . hostnames ( java . util . List < java . lang . String > ) . ip ( java . lang . String ) . build (); hostnames Required \u00b6 public java . util . List < java . lang . String > getHostnames (); Type: java.util.List< java.lang.String > Hostnames for the chosen IP address. ip Required \u00b6 public java . lang . String getIp (); Type: java.lang.String IP address of the host file entry. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import org.cdk8s.plus21.HttpGetProbeOptions ; HttpGetProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) // .port(java.lang.Number) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import org.cdk8s.plus21.IngressV1Beta1Props ; IngressV1Beta1Props . builder () // .metadata(ApiObjectMetadata) // .defaultBackend(IngressV1Beta1Backend) // .rules(java.util.List<IngressV1Beta1Rule>) // .tls(java.util.List<IngressV1Beta1Tls>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public IngressV1Beta1Backend getDefaultBackend (); Type: org.cdk8s.plus21.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public java . util . List < IngressV1Beta1Rule > getRules (); Type: java.util.List< org.cdk8s.plus21.IngressV1Beta1Rule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public java . util . List < IngressV1Beta1Tls > getTls (); Type: java.util.List< org.cdk8s.plus21.IngressV1Beta1Tls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import org.cdk8s.plus21.IngressV1Beta1Rule ; IngressV1Beta1Rule . builder () . backend ( IngressV1Beta1Backend ) // .host(java.lang.String) // .path(java.lang.String) . build (); backend Required \u00b6 public IngressV1Beta1Backend getBackend (); Type: org.cdk8s.plus21.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public java . lang . String getPath (); Type: java.lang.String Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import org.cdk8s.plus21.IngressV1Beta1Tls ; IngressV1Beta1Tls . builder () // .hosts(java.util.List<java.lang.String>) // .secret(ISecret) . build (); hosts Optional \u00b6 public java . util . List < java . lang . String > getHosts (); Type: java.util.List< java.lang.String > Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus21.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import org.cdk8s.plus21.JobProps ; JobProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus21.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import org.cdk8s.plus21.LabelSelectorRequirement ; LabelSelectorRequirement . builder () . key ( java . lang . String ) . operator ( LabelSelectorRequirementOperator ) // .values(java.util.List<java.lang.String>) . build (); key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String The label key that the selector applies to. operator Required \u00b6 public LabelSelectorRequirementOperator getOperator (); Type: org.cdk8s.plus21.LabelSelectorRequirementOperator Represents a key\u2019s relationship to a set of values. values Optional \u00b6 public java . util . List < java . lang . String > getValues (); Type: java.util.List< java.lang.String > An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import org.cdk8s.plus21.MemoryResources ; MemoryResources . builder () . limit ( Size ) . request ( Size ) . build (); limit Required \u00b6 public Size getLimit (); Type: org.cdk8s.Size request Required \u00b6 public Size getRequest (); Type: org.cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import org.cdk8s.plus21.MountOptions ; MountOptions . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus21.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import org.cdk8s.plus21.PathMapping ; PathMapping . builder () . path ( java . lang . String ) // .mode(java.lang.Number) . build (); path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public java . lang . Number getMode (); Type: java.lang.Number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import org.cdk8s.plus21.PersistentVolumeClaimProps ; PersistentVolumeClaimProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .storage(Size) // .storageClassName(java.lang.String) // .volume(IPersistentVolume) // .volumeMode(PersistentVolumeMode) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus21.PersistentVolumeAccessMode > Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 public IPersistentVolume getVolume (); Type: org.cdk8s.plus21.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import org.cdk8s.plus21.PersistentVolumeClaimVolumeOptions ; PersistentVolumeClaimVolumeOptions . builder () // .name(java.lang.String) // .readOnly(java.lang.Boolean) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: Derived from the PVC name. The volume name. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import org.cdk8s.plus21.PersistentVolumeProps ; PersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus21.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import org.cdk8s.plus21.PodDnsProps ; PodDnsProps . builder () // .hostname(java.lang.String) // .hostnameAsFQDN(java.lang.Boolean) // .nameservers(java.util.List<java.lang.String>) // .options(java.util.List<DnsOption>) // .policy(DnsPolicy) // .searches(java.util.List<java.lang.String>) // .subdomain(java.lang.String) . build (); hostname Optional \u00b6 public java . lang . String getHostname (); Type: java.lang.String Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 public java . lang . Boolean getHostnameAsFQDN (); Type: java.lang.Boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 public java . util . List < java . lang . String > getNameservers (); Type: java.util.List< java.lang.String > A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 public java . util . List < DnsOption > getOptions (); Type: java.util.List< org.cdk8s.plus21.DnsOption > List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 public DnsPolicy getPolicy (); Type: org.cdk8s.plus21.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 public java . util . List < java . lang . String > getSearches (); Type: java.util.List< java.lang.String > A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 public java . lang . String getSubdomain (); Type: java.lang.String Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import org.cdk8s.plus21.PodProps ; PodProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus21.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import org.cdk8s.plus21.PodSecurityContextProps ; PodSecurityContextProps . builder () // .ensureNonRoot(java.lang.Boolean) // .fsGroup(java.lang.Number) // .fsGroupChangePolicy(FsGroupChangePolicy) // .group(java.lang.Number) // .sysctls(java.util.List<Sysctl>) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 public java . lang . Number getFsGroup (); Type: java.lang.Number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 public FsGroupChangePolicy getFsGroupChangePolicy (); Type: org.cdk8s.plus21.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 public java . util . List < Sysctl > getSysctls (); Type: java.util.List< org.cdk8s.plus21.Sysctl > Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import org.cdk8s.plus21.ProbeOptions ; ProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import org.cdk8s.plus21.ResourceProps ; ResourceProps . builder () // .metadata(ApiObjectMetadata) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import org.cdk8s.plus21.RoleBindingProps ; RoleBindingProps . builder () // .metadata(ApiObjectMetadata) . role ( IRole ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public IRole getRole (); Type: org.cdk8s.plus21.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import org.cdk8s.plus21.RolePolicyRule ; RolePolicyRule . builder () . resources ( java . util . List < IApiResource > ) . verbs ( java . util . List < java . lang . String > ) . build (); resources Required \u00b6 public java . util . List < IApiResource > getResources (); Type: java.util.List< org.cdk8s.plus21.IApiResource > Resources this rule applies to. verbs Required \u00b6 public java . util . List < java . lang . String > getVerbs (); Type: java.util.List< java.lang.String > Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import org.cdk8s.plus21.RoleProps ; RoleProps . builder () // .metadata(ApiObjectMetadata) // .rules(java.util.List<RolePolicyRule>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 public java . util . List < RolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus21.RolePolicyRule > Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import org.cdk8s.plus21.SecretProps ; SecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getStringData (); Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public java . lang . String getType (); Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import org.cdk8s.plus21.SecretValue ; SecretValue . builder () . key ( java . lang . String ) . secret ( ISecret ) . build (); key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String The JSON key. secret Required \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus21.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import org.cdk8s.plus21.SecretVolumeOptions ; SecretVolumeOptions . builder () // .defaultMode(java.lang.Number) // .items(java.util.Map<java.lang.String, PathMapping>) // .name(java.lang.String) // .optional(java.lang.Boolean) . build (); defaultMode Optional \u00b6 public java . lang . Number getDefaultMode (); Type: java.lang.Number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public java . util . Map < java . lang . String , PathMapping > getItems (); Type: java.util.Map \u0002klzzwxh:7609\u0003 > Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import org.cdk8s.plus21.ServiceAccountProps ; ServiceAccountProps . builder () // .metadata(ApiObjectMetadata) // .automountToken(java.lang.Boolean) // .secrets(java.util.List<ISecret>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 public java . lang . Boolean getAutomountToken (); Type: java.lang.Boolean Default: true Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus21.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import org.cdk8s.plus21.ServiceAccountTokenSecretProps ; ServiceAccountTokenSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . serviceAccount ( IServiceAccount ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount The service account to store a secret for. ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import org.cdk8s.plus21.ServiceIngressV1BetaBackendOptions ; ServiceIngressV1BetaBackendOptions . builder () // .port(java.lang.Number) . build (); port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import org.cdk8s.plus21.ServicePort ; ServicePort . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . port ( java . lang . Number ) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import org.cdk8s.plus21.ServicePortOptions ; ServicePortOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import org.cdk8s.plus21.ServiceProps ; ServiceProps . builder () // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .type(ServiceType) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public java . util . List < java . lang . String > getExternalIPs (); Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public java . util . List < java . lang . String > getLoadBalancerSourceRanges (); Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus21.ServicePort > The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 public ServiceType getType (); Type: org.cdk8s.plus21.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import org.cdk8s.plus21.SshAuthSecretProps ; SshAuthSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . sshPrivateKey ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 public java . lang . String getSshPrivateKey (); Type: java.lang.String The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import org.cdk8s.plus21.StatefulSetProps ; StatefulSetProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) . service ( Service ) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) // .strategy(StatefulSetUpdateStrategy) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus21.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. service Required \u00b6 public Service getService (); Type: org.cdk8s.plus21.Service Service to associate with the statefulset. podManagementPolicy Optional \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus21.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 public StatefulSetUpdateStrategy getStrategy (); Type: org.cdk8s.plus21.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import org.cdk8s.plus21.StatefulSetUpdateStrategyRollingUpdateOptions ; StatefulSetUpdateStrategyRollingUpdateOptions . builder () // .partition(java.lang.Number) . build (); partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import org.cdk8s.plus21.Sysctl ; Sysctl . builder () . name ( java . lang . String ) . value ( java . lang . String ) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of a property to set. value Required \u00b6 public java . lang . String getValue (); Type: java.lang.String Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import org.cdk8s.plus21.TcpSocketProbeOptions ; TcpSocketProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) // .host(java.lang.String) // .port(java.lang.Number) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import org.cdk8s.plus21.TlsSecretProps ; TlsSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . tlsCert ( java . lang . String ) . tlsKey ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 public java . lang . String getTlsCert (); Type: java.lang.String The TLS cert. tlsKey Required \u00b6 public java . lang . String getTlsKey (); Type: java.lang.String The TLS key. UserProps \u00b6 Properties for User . Initializer \u00b6 import org.cdk8s.plus21.UserProps ; UserProps . builder () . name ( java . lang . String ) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the user. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import org.cdk8s.plus21.VolumeMount ; VolumeMount . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . path ( java . lang . String ) . volume ( Volume ) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus21.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public Volume getVolume (); Type: org.cdk8s.plus21.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import org.cdk8s.plus21.WorkloadProps ; WorkloadProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus21.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. Classes \u00b6 ApiResource \u00b6 Implements: org.cdk8s.plus21.IApiResource , org.cdk8s.plus21.IApiEndpoint Represents information about an API resource type. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 custom \u00b6 import org.cdk8s.plus21.ApiResource ; ApiResource . custom ( ApiResourceOptions options ) options Required \u00b6 Type: org.cdk8s.plus21.ApiResourceOptions Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for Ingress. JOBS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for Job. LEASES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: org.cdk8s.plus21.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import org.cdk8s.plus21.Container ; Container . Builder . create () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .env(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .lifecycle(ContainerLifecycle) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .readiness(Probe) // .resources(ContainerResources) // .securityContext(ContainerSecurityContextProps) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 Type: java.lang.String Docker image name. args Optional \u00b6 Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: java.util.Map \u0002klzzwxh:7165\u0003 > Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 Type: org.cdk8s.plus21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: org.cdk8s.plus21.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: org.cdk8s.plus21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: java.lang.Number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: org.cdk8s.plus21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: org.cdk8s.plus21.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 Type: org.cdk8s.plus21.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: org.cdk8s.plus21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 addEnv \u00b6 public addEnv ( java . lang . String name , EnvValue value ) name Required \u00b6 Type: java.lang.String The variable name. value Required \u00b6 Type: org.cdk8s.plus21.EnvValue The variable value. mount \u00b6 public mount ( java . lang . String path , IStorage storage ) public mount ( java . lang . String path , IStorage storage , MountOptions options ) path Required \u00b6 Type: java.lang.String The desired path in the container. storage Required \u00b6 Type: org.cdk8s.plus21.IStorage The storage to mount. options Optional \u00b6 Type: org.cdk8s.plus21.MountOptions Properties \u00b6 env Required \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnv (); Type: java.util.Map \u0002klzzwxh:7110\u0003 > The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String The container image. imagePullPolicy Required \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus21.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public java . util . List < VolumeMount > getMounts (); Type: java.util.List< org.cdk8s.plus21.VolumeMount > Volume mounts configured for this container. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the container. securityContext Required \u00b6 public ContainerSecurityContext getSecurityContext (); Type: org.cdk8s.plus21.ContainerSecurityContext The security context of the container. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Arguments to the entrypoint. command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Entrypoint array (the command to execute when the container starts). port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port this container exposes. resources Optional \u00b6 public ContainerResources getResources (); Type: org.cdk8s.plus21.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import org.cdk8s.plus21.ContainerSecurityContext ; ContainerSecurityContext . Builder . create () // .ensureNonRoot(java.lang.Boolean) // .group(java.lang.Number) // .privileged(java.lang.Boolean) // .readOnlyRootFilesystem(java.lang.Boolean) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 Type: java.lang.Boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. privileged Optional \u00b6 Type: java.lang.Boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 Type: java.lang.Boolean Default: false Whether this container has a read-only root filesystem. user Optional \u00b6 Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensureNonRoot Required \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean privileged Required \u00b6 public java . lang . Boolean getPrivileged (); Type: java.lang.Boolean readOnlyRootFilesystem Required \u00b6 public java . lang . Boolean getReadOnlyRootFilesystem (); Type: java.lang.Boolean group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import org.cdk8s.plus21.Cpu ; Cpu . millis ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number units \u00b6 import org.cdk8s.plus21.Cpu ; Cpu . units ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number Properties \u00b6 amount Required \u00b6 public java . lang . String getAmount (); Type: java.lang.String DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import org.cdk8s.plus21.DeploymentStrategy ; DeploymentStrategy . recreate () rollingUpdate \u00b6 import org.cdk8s.plus21.DeploymentStrategy ; DeploymentStrategy . rollingUpdate () DeploymentStrategy . rollingUpdate ( DeploymentStrategyRollingUpdateOptions options ) options Optional \u00b6 Type: org.cdk8s.plus21.DeploymentStrategyRollingUpdateOptions EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus21.EnvValue ; EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key ) EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key , EnvValueFromConfigMapOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus21.IConfigMap The config map. key Required \u00b6 Type: java.lang.String The key to extract the value from. options Optional \u00b6 Type: org.cdk8s.plus21.EnvValueFromConfigMapOptions Additional options. fromFieldRef \u00b6 import org.cdk8s.plus21.EnvValue ; EnvValue . fromFieldRef ( EnvFieldPaths fieldPath ) EnvValue . fromFieldRef ( EnvFieldPaths fieldPath , EnvValueFromFieldRefOptions options ) fieldPath Required \u00b6 Type: org.cdk8s.plus21.EnvFieldPaths : The field reference. options Optional \u00b6 Type: org.cdk8s.plus21.EnvValueFromFieldRefOptions : Additional options. fromProcess \u00b6 import org.cdk8s.plus21.EnvValue ; EnvValue . fromProcess ( java . lang . String key ) EnvValue . fromProcess ( java . lang . String key , EnvValueFromProcessOptions options ) key Required \u00b6 Type: java.lang.String The key to read. options Optional \u00b6 Type: org.cdk8s.plus21.EnvValueFromProcessOptions Additional options. fromResource \u00b6 import org.cdk8s.plus21.EnvValue ; EnvValue . fromResource ( ResourceFieldPaths resource ) EnvValue . fromResource ( ResourceFieldPaths resource , EnvValueFromResourceOptions options ) resource Required \u00b6 Type: org.cdk8s.plus21.ResourceFieldPaths : Resource to select the value from. options Optional \u00b6 Type: org.cdk8s.plus21.EnvValueFromResourceOptions : Additional options. fromSecretValue \u00b6 import org.cdk8s.plus21.EnvValue ; EnvValue . fromSecretValue ( SecretValue secretValue ) EnvValue . fromSecretValue ( SecretValue secretValue , EnvValueFromSecretOptions options ) secretValue Required \u00b6 Type: org.cdk8s.plus21.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: org.cdk8s.plus21.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import org.cdk8s.plus21.EnvValue ; EnvValue . fromValue ( java . lang . String value ) value Required \u00b6 Type: java.lang.String The value. Properties \u00b6 value Optional \u00b6 public java . lang . Object getValue (); Type: java.lang.Object valueFrom Optional \u00b6 public java . lang . Object getValueFrom (); Type: java.lang.Object Group \u00b6 Implements: org.cdk8s.plus21.ISubject Represents a group. Initializers \u00b6 import org.cdk8s.plus21.Group ; Group . Builder . create () . name ( java . lang . String ) . build (); name Required \u00b6 Type: java.lang.String The name of the group. Properties \u00b6 kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of the object being referenced. apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 fromCommand \u00b6 import org.cdk8s.plus21.Handler ; Handler . fromCommand ( java . util . List < java . lang . String > command ) command Required \u00b6 Type: java.util.List< java.lang.String > The command to execute. fromHttpGet \u00b6 import org.cdk8s.plus21.Handler ; Handler . fromHttpGet ( java . lang . String path ) Handler . fromHttpGet ( java . lang . String path , HandlerFromHttpGetOptions options ) path Required \u00b6 Type: java.lang.String The URL path to hit. options Optional \u00b6 Type: org.cdk8s.plus21.HandlerFromHttpGetOptions Options. fromTcpSocket \u00b6 import org.cdk8s.plus21.Handler ; Handler . fromTcpSocket () Handler . fromTcpSocket ( HandlerFromTcpSocketOptions options ) options Optional \u00b6 Type: org.cdk8s.plus21.HandlerFromTcpSocketOptions Options. IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromService \u00b6 import org.cdk8s.plus21.IngressV1Beta1Backend ; IngressV1Beta1Backend . fromService ( Service serv ) IngressV1Beta1Backend . fromService ( Service serv , ServiceIngressV1BetaBackendOptions options ) serv Required \u00b6 Type: org.cdk8s.plus21.Service The service object. options Optional \u00b6 Type: org.cdk8s.plus21.ServiceIngressV1BetaBackendOptions LabelSelector \u00b6 A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors Static Functions \u00b6 doesNotExist \u00b6 import org.cdk8s.plus21.LabelSelector ; LabelSelector . doesNotExist ( java . lang . String key ) key Required \u00b6 Type: java.lang.String exists \u00b6 import org.cdk8s.plus21.LabelSelector ; LabelSelector . exists ( java . lang . String key ) key Required \u00b6 Type: java.lang.String in \u00b6 import org.cdk8s.plus21.LabelSelector ; LabelSelector . in ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > is \u00b6 import org.cdk8s.plus21.LabelSelector ; LabelSelector . is ( java . lang . String key , java . lang . String value ) LabelSelector . is ( java . lang . String key , java . lang . String value , java . lang . Boolean applyToTemplate ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String applyToTemplate Optional \u00b6 Type: java.lang.Boolean notIn \u00b6 import org.cdk8s.plus21.LabelSelector ; LabelSelector . notIn ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > Properties \u00b6 applyToTemplate Required \u00b6 public java . lang . Boolean getApplyToTemplate (); Type: java.lang.Boolean key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String operator Optional \u00b6 public LabelSelectorRequirementOperator getOperator (); Type: org.cdk8s.plus21.LabelSelectorRequirementOperator values Optional \u00b6 public java . util . List < java . lang . String > getValues (); Type: java.util.List< java.lang.String > NonApiResource \u00b6 Implements: org.cdk8s.plus21.IApiEndpoint Factory for creating non api resources. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 of \u00b6 import org.cdk8s.plus21.NonApiResource ; NonApiResource . of ( java . lang . String url ) url Required \u00b6 Type: java.lang.String PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 isZero \u00b6 public isZero () Static Functions \u00b6 absolute \u00b6 import org.cdk8s.plus21.PercentOrAbsolute ; PercentOrAbsolute . absolute ( java . lang . Number num ) num Required \u00b6 Type: java.lang.Number percent \u00b6 import org.cdk8s.plus21.PercentOrAbsolute ; PercentOrAbsolute . percent ( java . lang . Number percent ) percent Required \u00b6 Type: java.lang.Number Properties \u00b6 value Required \u00b6 public java . lang . Object getValue (); Type: java.lang.Object PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import org.cdk8s.plus21.PodDns ; PodDns . Builder . create () // .hostname(java.lang.String) // .hostnameAsFQDN(java.lang.Boolean) // .nameservers(java.util.List<java.lang.String>) // .options(java.util.List<DnsOption>) // .policy(DnsPolicy) // .searches(java.util.List<java.lang.String>) // .subdomain(java.lang.String) . build (); hostname Optional \u00b6 Type: java.lang.String Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 Type: java.lang.Boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 Type: java.util.List< java.lang.String > A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.DnsOption > List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 Type: org.cdk8s.plus21.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 Type: java.util.List< java.lang.String > A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 Type: java.lang.String Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. Methods \u00b6 addNameserver \u00b6 public addNameserver ( java . lang . String nameservers ) nameservers Required \u00b6 Type: java.lang.String addOption \u00b6 public addOption ( DnsOption options ) options Required \u00b6 Type: org.cdk8s.plus21.DnsOption addSearch \u00b6 public addSearch ( java . lang . String searches ) searches Required \u00b6 Type: java.lang.String Properties \u00b6 hostnameAsFQDN Required \u00b6 public java . lang . Boolean getHostnameAsFQDN (); Type: java.lang.Boolean Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 public java . util . List < java . lang . String > getNameservers (); Type: java.util.List< java.lang.String > Nameservers defined for this pod. options Required \u00b6 public java . util . List < DnsOption > getOptions (); Type: java.util.List< org.cdk8s.plus21.DnsOption > Custom dns options defined for this pod. policy Required \u00b6 public DnsPolicy getPolicy (); Type: org.cdk8s.plus21.DnsPolicy The DNS policy of this pod. searches Required \u00b6 public java . util . List < java . lang . String > getSearches (); Type: java.util.List< java.lang.String > Search domains defined for this pod. hostname Optional \u00b6 public java . lang . String getHostname (); Type: java.lang.String The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 public java . lang . String getSubdomain (); Type: java.lang.String The configured subdomain of the pod. PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import org.cdk8s.plus21.PodSecurityContext ; PodSecurityContext . Builder . create () // .ensureNonRoot(java.lang.Boolean) // .fsGroup(java.lang.Number) // .fsGroupChangePolicy(FsGroupChangePolicy) // .group(java.lang.Number) // .sysctls(java.util.List<Sysctl>) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 Type: java.lang.Boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 Type: java.lang.Number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 Type: org.cdk8s.plus21.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.Sysctl > Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensureNonRoot Required \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean fsGroupChangePolicy Required \u00b6 public FsGroupChangePolicy getFsGroupChangePolicy (); Type: org.cdk8s.plus21.FsGroupChangePolicy sysctls Required \u00b6 public java . util . List < Sysctl > getSysctls (); Type: java.util.List< org.cdk8s.plus21.Sysctl > fsGroup Optional \u00b6 public java . lang . Number getFsGroup (); Type: java.lang.Number group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 fromCommand \u00b6 import org.cdk8s.plus21.Probe ; Probe . fromCommand ( java . util . List < java . lang . String > command ) Probe . fromCommand ( java . util . List < java . lang . String > command , CommandProbeOptions options ) command Required \u00b6 Type: java.util.List< java.lang.String > The command to execute. options Optional \u00b6 Type: org.cdk8s.plus21.CommandProbeOptions Options. fromHttpGet \u00b6 import org.cdk8s.plus21.Probe ; Probe . fromHttpGet ( java . lang . String path ) Probe . fromHttpGet ( java . lang . String path , HttpGetProbeOptions options ) path Required \u00b6 Type: java.lang.String The URL path to hit. options Optional \u00b6 Type: org.cdk8s.plus21.HttpGetProbeOptions Options. fromTcpSocket \u00b6 import org.cdk8s.plus21.Probe ; Probe . fromTcpSocket () Probe . fromTcpSocket ( TcpSocketProbeOptions options ) options Optional \u00b6 Type: org.cdk8s.plus21.TcpSocketProbeOptions Options. StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 onDelete \u00b6 import org.cdk8s.plus21.StatefulSetUpdateStrategy ; StatefulSetUpdateStrategy . onDelete () rollingUpdate \u00b6 import org.cdk8s.plus21.StatefulSetUpdateStrategy ; StatefulSetUpdateStrategy . rollingUpdate () StatefulSetUpdateStrategy . rollingUpdate ( StatefulSetUpdateStrategyRollingUpdateOptions options ) options Optional \u00b6 Type: org.cdk8s.plus21.StatefulSetUpdateStrategyRollingUpdateOptions User \u00b6 Implements: org.cdk8s.plus21.ISubject Represents a user. Initializers \u00b6 import org.cdk8s.plus21.User ; User . Builder . create () . name ( java . lang . String ) . build (); name Required \u00b6 Type: java.lang.String The name of the user. Properties \u00b6 kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of the object being referenced. apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Volume \u00b6 Implements: org.cdk8s.plus21.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 asVolume \u00b6 public asVolume () Static Functions \u00b6 fromAwsElasticBlockStore \u00b6 import org.cdk8s.plus21.Volume ; Volume . fromAwsElasticBlockStore ( java . lang . String volumeId ) Volume . fromAwsElasticBlockStore ( java . lang . String volumeId , AwsElasticBlockStoreVolumeOptions options ) volumeId Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus21.AwsElasticBlockStoreVolumeOptions fromAzureDisk \u00b6 import org.cdk8s.plus21.Volume ; Volume . fromAzureDisk ( java . lang . String diskName , java . lang . String diskUri ) Volume . fromAzureDisk ( java . lang . String diskName , java . lang . String diskUri , AzureDiskVolumeOptions options ) diskName Required \u00b6 Type: java.lang.String diskUri Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus21.AzureDiskVolumeOptions fromConfigMap \u00b6 import org.cdk8s.plus21.Volume ; Volume . fromConfigMap ( IConfigMap configMap ) Volume . fromConfigMap ( IConfigMap configMap , ConfigMapVolumeOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus21.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: org.cdk8s.plus21.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import org.cdk8s.plus21.Volume ; Volume . fromEmptyDir ( java . lang . String name ) Volume . fromEmptyDir ( java . lang . String name , EmptyDirVolumeOptions options ) name Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus21.EmptyDirVolumeOptions Additional options. fromGcePersistentDisk \u00b6 import org.cdk8s.plus21.Volume ; Volume . fromGcePersistentDisk ( java . lang . String pdName ) Volume . fromGcePersistentDisk ( java . lang . String pdName , GCEPersistentDiskVolumeOptions options ) pdName Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus21.GCEPersistentDiskVolumeOptions fromPersistentVolumeClaim \u00b6 import org.cdk8s.plus21.Volume ; Volume . fromPersistentVolumeClaim ( IPersistentVolumeClaim claim ) Volume . fromPersistentVolumeClaim ( IPersistentVolumeClaim claim , PersistentVolumeClaimVolumeOptions options ) claim Required \u00b6 Type: org.cdk8s.plus21.IPersistentVolumeClaim options Optional \u00b6 Type: org.cdk8s.plus21.PersistentVolumeClaimVolumeOptions fromSecret \u00b6 import org.cdk8s.plus21.Volume ; Volume . fromSecret ( ISecret secr ) Volume . fromSecret ( ISecret secr , SecretVolumeOptions options ) secr Required \u00b6 Type: org.cdk8s.plus21.ISecret The secret to use to populate the volume. options Optional \u00b6 Type: org.cdk8s.plus21.SecretVolumeOptions Options. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: org.cdk8s.plus21.AbstractPod , org.cdk8s.plus21.ApiResource , org.cdk8s.plus21.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus21.AzureDiskPersistentVolume , org.cdk8s.plus21.BasicAuthSecret , org.cdk8s.plus21.ClusterRole , org.cdk8s.plus21.ClusterRoleBinding , org.cdk8s.plus21.ConfigMap , org.cdk8s.plus21.DaemonSet , org.cdk8s.plus21.Deployment , org.cdk8s.plus21.DockerConfigSecret , org.cdk8s.plus21.GCEPersistentDiskPersistentVolume , org.cdk8s.plus21.IngressV1Beta1 , org.cdk8s.plus21.Job , org.cdk8s.plus21.NonApiResource , org.cdk8s.plus21.PersistentVolume , org.cdk8s.plus21.PersistentVolumeClaim , org.cdk8s.plus21.Pod , org.cdk8s.plus21.Resource , org.cdk8s.plus21.Role , org.cdk8s.plus21.RoleBinding , org.cdk8s.plus21.Secret , org.cdk8s.plus21.Service , org.cdk8s.plus21.ServiceAccount , org.cdk8s.plus21.ServiceAccountTokenSecret , org.cdk8s.plus21.SshAuthSecret , org.cdk8s.plus21.StatefulSet , org.cdk8s.plus21.TlsSecret , org.cdk8s.plus21.Workload , org.cdk8s.plus21.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () IApiResource \u00b6 Implemented By: org.cdk8s.plus21.AbstractPod , org.cdk8s.plus21.ApiResource , org.cdk8s.plus21.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus21.AzureDiskPersistentVolume , org.cdk8s.plus21.BasicAuthSecret , org.cdk8s.plus21.ClusterRole , org.cdk8s.plus21.ClusterRoleBinding , org.cdk8s.plus21.ConfigMap , org.cdk8s.plus21.DaemonSet , org.cdk8s.plus21.Deployment , org.cdk8s.plus21.DockerConfigSecret , org.cdk8s.plus21.GCEPersistentDiskPersistentVolume , org.cdk8s.plus21.IngressV1Beta1 , org.cdk8s.plus21.Job , org.cdk8s.plus21.PersistentVolume , org.cdk8s.plus21.PersistentVolumeClaim , org.cdk8s.plus21.Pod , org.cdk8s.plus21.Resource , org.cdk8s.plus21.Role , org.cdk8s.plus21.RoleBinding , org.cdk8s.plus21.Secret , org.cdk8s.plus21.Service , org.cdk8s.plus21.ServiceAccount , org.cdk8s.plus21.ServiceAccountTokenSecret , org.cdk8s.plus21.SshAuthSecret , org.cdk8s.plus21.StatefulSet , org.cdk8s.plus21.TlsSecret , org.cdk8s.plus21.Workload , org.cdk8s.plus21.IApiResource Represents a resource or collection of resources. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resourceName Optional \u00b6 public java . lang . String getResourceName (); Type: java.lang.String The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.ClusterRole , org.cdk8s.plus21.IClusterRole Represents a cluster-level role. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IConfigMap \u00b6 Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.ConfigMap , org.cdk8s.plus21.IConfigMap Represents a config map. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IPersistentVolume \u00b6 Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus21.AzureDiskPersistentVolume , org.cdk8s.plus21.GCEPersistentDiskPersistentVolume , org.cdk8s.plus21.PersistentVolume , org.cdk8s.plus21.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.PersistentVolumeClaim , org.cdk8s.plus21.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IResource \u00b6 Implemented By: org.cdk8s.plus21.AbstractPod , org.cdk8s.plus21.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus21.AzureDiskPersistentVolume , org.cdk8s.plus21.BasicAuthSecret , org.cdk8s.plus21.ClusterRole , org.cdk8s.plus21.ClusterRoleBinding , org.cdk8s.plus21.ConfigMap , org.cdk8s.plus21.DaemonSet , org.cdk8s.plus21.Deployment , org.cdk8s.plus21.DockerConfigSecret , org.cdk8s.plus21.GCEPersistentDiskPersistentVolume , org.cdk8s.plus21.IngressV1Beta1 , org.cdk8s.plus21.Job , org.cdk8s.plus21.PersistentVolume , org.cdk8s.plus21.PersistentVolumeClaim , org.cdk8s.plus21.Pod , org.cdk8s.plus21.Resource , org.cdk8s.plus21.Role , org.cdk8s.plus21.RoleBinding , org.cdk8s.plus21.Secret , org.cdk8s.plus21.Service , org.cdk8s.plus21.ServiceAccount , org.cdk8s.plus21.ServiceAccountTokenSecret , org.cdk8s.plus21.SshAuthSecret , org.cdk8s.plus21.StatefulSet , org.cdk8s.plus21.TlsSecret , org.cdk8s.plus21.Workload , org.cdk8s.plus21.IClusterRole , org.cdk8s.plus21.IConfigMap , org.cdk8s.plus21.IPersistentVolume , org.cdk8s.plus21.IPersistentVolumeClaim , org.cdk8s.plus21.IResource , org.cdk8s.plus21.IRole , org.cdk8s.plus21.ISecret , org.cdk8s.plus21.IServiceAccount Represents a resource. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IRole \u00b6 Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.ClusterRole , org.cdk8s.plus21.Role , org.cdk8s.plus21.IRole A reference to any Role or ClusterRole. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. ISecret \u00b6 Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.BasicAuthSecret , org.cdk8s.plus21.DockerConfigSecret , org.cdk8s.plus21.Secret , org.cdk8s.plus21.ServiceAccountTokenSecret , org.cdk8s.plus21.SshAuthSecret , org.cdk8s.plus21.TlsSecret , org.cdk8s.plus21.ISecret Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.ServiceAccount , org.cdk8s.plus21.IServiceAccount Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IStorage \u00b6 Implemented By: org.cdk8s.plus21.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus21.AzureDiskPersistentVolume , org.cdk8s.plus21.GCEPersistentDiskPersistentVolume , org.cdk8s.plus21.PersistentVolume , org.cdk8s.plus21.Volume , org.cdk8s.plus21.IStorage Represents a piece of storage in the cluster. Methods \u00b6 asVolume \u00b6 public asVolume () ISubject \u00b6 Implemented By: org.cdk8s.plus21.Group , org.cdk8s.plus21.ServiceAccount , org.cdk8s.plus21.User , org.cdk8s.plus21.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Properties \u00b6 kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of the object being referenced. apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. LabelSelectorRequirementOperator \u00b6 Possible operators. IN \u00b6 In. NOT_IN \u00b6 NotIn. EXISTS \u00b6 Exists. DOES_NOT_EXIST \u00b6 DoesNotExist. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"Java"},{"location":"reference/cdk8s-plus-21/java/#cdk8s-plus-21-java","text":"","title":"cdk8s-plus-21 (Java) "},{"location":"reference/cdk8s-plus-21/java/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-21/java/#abstractpod","text":"","title":"AbstractPod "},{"location":"reference/cdk8s-plus-21/java/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-21/java/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-21/java/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-21/java/#clusterrole","text":"Implements: org.cdk8s.plus21.IClusterRole , org.cdk8s.plus21.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-21/java/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-21/java/#configmap","text":"Implements: org.cdk8s.plus21.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-21/java/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-21/java/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-21/java/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-21/java/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-21/java/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-21/java/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-21/java/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-21/java/#persistentvolume","text":"Implements: org.cdk8s.plus21.IPersistentVolume , org.cdk8s.plus21.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-21/java/#persistentvolumeclaim","text":"Implements: org.cdk8s.plus21.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-21/java/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-21/java/#resource","text":"Implements: org.cdk8s.plus21.IResource , org.cdk8s.plus21.IApiResource , org.cdk8s.plus21.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-21/java/#role","text":"Implements: org.cdk8s.plus21.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-21/java/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-21/java/#secret","text":"Implements: org.cdk8s.plus21.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-21/java/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-21/java/#serviceaccount","text":"Implements: org.cdk8s.plus21.IServiceAccount , org.cdk8s.plus21.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-21/java/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-21/java/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-21/java/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-21/java/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-21/java/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-21/java/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-21/java/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-21/java/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-21/java/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-21/java/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-21/java/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-21/java/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-21/java/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-21/java/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-21/java/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-21/java/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-21/java/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-21/java/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-21/java/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-21/java/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-21/java/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-21/java/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-21/java/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-21/java/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-21/java/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-21/java/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-21/java/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-21/java/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-21/java/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-21/java/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-21/java/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-21/java/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-21/java/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-21/java/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-21/java/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-21/java/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-21/java/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-21/java/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-21/java/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-21/java/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-21/java/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-21/java/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-21/java/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-21/java/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-21/java/#groupprops","text":"Properties for Group .","title":"GroupProps "},{"location":"reference/cdk8s-plus-21/java/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-21/java/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-21/java/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-21/java/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-21/java/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-21/java/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-21/java/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-21/java/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-21/java/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-21/java/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-21/java/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-21/java/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-21/java/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-21/java/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-21/java/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-21/java/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-21/java/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-21/java/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-21/java/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-21/java/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-21/java/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-21/java/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-21/java/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-21/java/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-21/java/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-21/java/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-21/java/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-21/java/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-21/java/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-21/java/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-21/java/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-21/java/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-21/java/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-21/java/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-21/java/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-21/java/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-21/java/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-21/java/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-21/java/#userprops","text":"Properties for User .","title":"UserProps "},{"location":"reference/cdk8s-plus-21/java/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-21/java/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-21/java/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-21/java/#apiresource","text":"Implements: org.cdk8s.plus21.IApiResource , org.cdk8s.plus21.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-21/java/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-21/java/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-21/java/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-21/java/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-21/java/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-21/java/#group","text":"Implements: org.cdk8s.plus21.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-21/java/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-21/java/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-21/java/#labelselector","text":"A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors","title":"LabelSelector "},{"location":"reference/cdk8s-plus-21/java/#nonapiresource","text":"Implements: org.cdk8s.plus21.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-21/java/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-21/java/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-21/java/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-21/java/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-21/java/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-21/java/#user","text":"Implements: org.cdk8s.plus21.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-21/java/#volume","text":"Implements: org.cdk8s.plus21.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-21/java/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-21/java/#iapiendpoint","text":"Implemented By: org.cdk8s.plus21.AbstractPod , org.cdk8s.plus21.ApiResource , org.cdk8s.plus21.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus21.AzureDiskPersistentVolume , org.cdk8s.plus21.BasicAuthSecret , org.cdk8s.plus21.ClusterRole , org.cdk8s.plus21.ClusterRoleBinding , org.cdk8s.plus21.ConfigMap , org.cdk8s.plus21.DaemonSet , org.cdk8s.plus21.Deployment , org.cdk8s.plus21.DockerConfigSecret , org.cdk8s.plus21.GCEPersistentDiskPersistentVolume , org.cdk8s.plus21.IngressV1Beta1 , org.cdk8s.plus21.Job , org.cdk8s.plus21.NonApiResource , org.cdk8s.plus21.PersistentVolume , org.cdk8s.plus21.PersistentVolumeClaim , org.cdk8s.plus21.Pod , org.cdk8s.plus21.Resource , org.cdk8s.plus21.Role , org.cdk8s.plus21.RoleBinding , org.cdk8s.plus21.Secret , org.cdk8s.plus21.Service , org.cdk8s.plus21.ServiceAccount , org.cdk8s.plus21.ServiceAccountTokenSecret , org.cdk8s.plus21.SshAuthSecret , org.cdk8s.plus21.StatefulSet , org.cdk8s.plus21.TlsSecret , org.cdk8s.plus21.Workload , org.cdk8s.plus21.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-21/java/#iapiresource","text":"Implemented By: org.cdk8s.plus21.AbstractPod , org.cdk8s.plus21.ApiResource , org.cdk8s.plus21.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus21.AzureDiskPersistentVolume , org.cdk8s.plus21.BasicAuthSecret , org.cdk8s.plus21.ClusterRole , org.cdk8s.plus21.ClusterRoleBinding , org.cdk8s.plus21.ConfigMap , org.cdk8s.plus21.DaemonSet , org.cdk8s.plus21.Deployment , org.cdk8s.plus21.DockerConfigSecret , org.cdk8s.plus21.GCEPersistentDiskPersistentVolume , org.cdk8s.plus21.IngressV1Beta1 , org.cdk8s.plus21.Job , org.cdk8s.plus21.PersistentVolume , org.cdk8s.plus21.PersistentVolumeClaim , org.cdk8s.plus21.Pod , org.cdk8s.plus21.Resource , org.cdk8s.plus21.Role , org.cdk8s.plus21.RoleBinding , org.cdk8s.plus21.Secret , org.cdk8s.plus21.Service , org.cdk8s.plus21.ServiceAccount , org.cdk8s.plus21.ServiceAccountTokenSecret , org.cdk8s.plus21.SshAuthSecret , org.cdk8s.plus21.StatefulSet , org.cdk8s.plus21.TlsSecret , org.cdk8s.plus21.Workload , org.cdk8s.plus21.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-21/java/#iclusterrole","text":"Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.ClusterRole , org.cdk8s.plus21.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-21/java/#iconfigmap","text":"Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.ConfigMap , org.cdk8s.plus21.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-21/java/#ipersistentvolume","text":"Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus21.AzureDiskPersistentVolume , org.cdk8s.plus21.GCEPersistentDiskPersistentVolume , org.cdk8s.plus21.PersistentVolume , org.cdk8s.plus21.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-21/java/#ipersistentvolumeclaim","text":"Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.PersistentVolumeClaim , org.cdk8s.plus21.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-21/java/#iresource","text":"Implemented By: org.cdk8s.plus21.AbstractPod , org.cdk8s.plus21.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus21.AzureDiskPersistentVolume , org.cdk8s.plus21.BasicAuthSecret , org.cdk8s.plus21.ClusterRole , org.cdk8s.plus21.ClusterRoleBinding , org.cdk8s.plus21.ConfigMap , org.cdk8s.plus21.DaemonSet , org.cdk8s.plus21.Deployment , org.cdk8s.plus21.DockerConfigSecret , org.cdk8s.plus21.GCEPersistentDiskPersistentVolume , org.cdk8s.plus21.IngressV1Beta1 , org.cdk8s.plus21.Job , org.cdk8s.plus21.PersistentVolume , org.cdk8s.plus21.PersistentVolumeClaim , org.cdk8s.plus21.Pod , org.cdk8s.plus21.Resource , org.cdk8s.plus21.Role , org.cdk8s.plus21.RoleBinding , org.cdk8s.plus21.Secret , org.cdk8s.plus21.Service , org.cdk8s.plus21.ServiceAccount , org.cdk8s.plus21.ServiceAccountTokenSecret , org.cdk8s.plus21.SshAuthSecret , org.cdk8s.plus21.StatefulSet , org.cdk8s.plus21.TlsSecret , org.cdk8s.plus21.Workload , org.cdk8s.plus21.IClusterRole , org.cdk8s.plus21.IConfigMap , org.cdk8s.plus21.IPersistentVolume , org.cdk8s.plus21.IPersistentVolumeClaim , org.cdk8s.plus21.IResource , org.cdk8s.plus21.IRole , org.cdk8s.plus21.ISecret , org.cdk8s.plus21.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-21/java/#irole","text":"Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.ClusterRole , org.cdk8s.plus21.Role , org.cdk8s.plus21.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-21/java/#isecret","text":"Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.BasicAuthSecret , org.cdk8s.plus21.DockerConfigSecret , org.cdk8s.plus21.Secret , org.cdk8s.plus21.ServiceAccountTokenSecret , org.cdk8s.plus21.SshAuthSecret , org.cdk8s.plus21.TlsSecret , org.cdk8s.plus21.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-21/java/#iserviceaccount","text":"Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.ServiceAccount , org.cdk8s.plus21.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-21/java/#istorage","text":"Implemented By: org.cdk8s.plus21.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus21.AzureDiskPersistentVolume , org.cdk8s.plus21.GCEPersistentDiskPersistentVolume , org.cdk8s.plus21.PersistentVolume , org.cdk8s.plus21.Volume , org.cdk8s.plus21.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-21/java/#isubject","text":"Implemented By: org.cdk8s.plus21.Group , org.cdk8s.plus21.ServiceAccount , org.cdk8s.plus21.User , org.cdk8s.plus21.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"ISubject "},{"location":"reference/cdk8s-plus-21/java/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-21/java/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-21/java/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-21/java/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-21/java/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-21/java/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-21/java/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-21/java/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-21/java/#labelselectorrequirementoperator","text":"Possible operators.","title":"LabelSelectorRequirementOperator "},{"location":"reference/cdk8s-plus-21/java/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-21/java/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-21/java/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-21/java/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-21/java/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-21/java/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-21/java/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-21/java/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-21/java/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-21/python/","text":"cdk8s-plus-21 (Python) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . AbstractPod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_21.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_21.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_21.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_21.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_21.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_21.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_host_alias \u00b6 def add_host_alias ( hostnames : typing . List [ str ], ip : str ) hostnames Required \u00b6 Type: typing.List[ str ] Hostnames for the chosen IP address. ip Required \u00b6 Type: str IP address of the host file entry. add_init_container \u00b6 def add_init_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_21.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_21.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_21.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_21.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_21.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( vol : Volume ) vol Required \u00b6 Type: cdk8s_plus_21.Volume Properties \u00b6 automount_service_account_token Required \u00b6 automount_service_account_token : bool Type: bool containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_21.Container ] dns Required \u00b6 dns : PodDns Type: cdk8s_plus_21.PodDns host_aliases Required \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_21.HostAlias ] init_containers Required \u00b6 init_containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_21.Container ] security_context Required \u00b6 security_context : PodSecurityContext Type: cdk8s_plus_21.PodSecurityContext volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_21.DockerConfigSecret restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . AwsElasticBlockStorePersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , volume_id : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volume_id Required \u00b6 Type: str Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. volume_id Required \u00b6 volume_id : str Type: str Volume id of this volume. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . AzureDiskPersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. disk_name Required \u00b6 Type: str The Name of the data disk in the blob storage. disk_uri Required \u00b6 Type: str The URI the data disk in the blob storage. caching_mode Optional \u00b6 Type: cdk8s_plus_21.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: cdk8s_plus_21.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. read_only Optional \u00b6 Type: bool Default: false Force the ReadOnly setting in VolumeMounts. Properties \u00b6 azure_kind Required \u00b6 azure_kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_21.AzureDiskPersistentVolumeKind Azure kind of this volume. caching_mode Required \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_21.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. disk_name Required \u00b6 disk_name : str Type: str Disk name of this volume. disk_uri Required \u00b6 disk_uri : str Type: str Disk URI of this volume. fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . BasicAuthSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , password : str , username : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 Type: str The password or token for authentication. username Required \u00b6 Type: str The user name for authentication. ClusterRole \u00b6 Implements: cdk8s_plus_21.IClusterRole , cdk8s_plus_21.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ClusterRole ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , aggregation_labels : typing . Mapping [ str ] = None , rules : typing . List [ ClusterRolePolicyRule ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregation_labels Optional \u00b6 Type: typing.Mapping[ str ] Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ClusterRolePolicyRule ] Default: [] A list of rules the role should allow. Methods \u00b6 aggregate \u00b6 def aggregate ( key : str , value : str ) key Required \u00b6 Type: str value Required \u00b6 Type: str allow \u00b6 def allow ( verbs : typing . List [ str ], endpoints : IApiEndpoint ) verbs Required \u00b6 Type: typing.List[ str ] endpoints Required \u00b6 Type: cdk8s_plus_21.IApiEndpoint The endpoints(s) to apply to. allow_create \u00b6 def allow_create ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_21.IApiEndpoint The resource(s) to apply to. allow_delete \u00b6 def allow_delete ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_21.IApiEndpoint The resource(s) to apply to. allow_delete_collection \u00b6 def allow_delete_collection ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_21.IApiEndpoint The resource(s) to apply to. allow_get \u00b6 def allow_get ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_21.IApiEndpoint The resource(s) to apply to. allow_list \u00b6 def allow_list ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_21.IApiEndpoint The resource(s) to apply to. allow_patch \u00b6 def allow_patch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_21.IApiEndpoint The resource(s) to apply to. allow_read \u00b6 def allow_read ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_21.IApiEndpoint The resource(s) to apply to. allow_read_write \u00b6 def allow_read_write ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_21.IApiEndpoint The resource(s) to apply to. allow_update \u00b6 def allow_update ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_21.IApiEndpoint The resource(s) to apply to. allow_watch \u00b6 def allow_watch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_21.IApiEndpoint The resource(s) to apply to. bind \u00b6 def bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_21.ISubject a list of subjects to bind to. bind_in_namespace \u00b6 def bind_in_namespace ( namespace : str , subjects : ISubject ) namespace Required \u00b6 Type: str the namespace to limit permissions to. subjects Required \u00b6 Type: cdk8s_plus_21.ISubject a list of subjects to bind to. combine \u00b6 def combine ( rol : ClusterRole ) rol Required \u00b6 Type: cdk8s_plus_21.ClusterRole Static Functions \u00b6 from_cluster_role_name \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ClusterRole . from_cluster_role_name ( name : str ) name Required \u00b6 Type: str The name of the role resource. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 rules : typing . List [ ClusterRolePolicyRule ] Type: typing.List[ cdk8s_plus_21.ClusterRolePolicyRule ] Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ClusterRoleBinding ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , role : IClusterRole ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: cdk8s_plus_21.IClusterRole The role to bind to. Methods \u00b6 add_subjects \u00b6 def add_subjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_21.ISubject The subjects to add. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 role : IClusterRole Type: cdk8s_plus_21.IClusterRole subjects Required \u00b6 subjects : typing . List [ ISubject ] Type: typing.List[ cdk8s_plus_21.ISubject ] ConfigMap \u00b6 Implements: cdk8s_plus_21.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ConfigMap ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None , immutable : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Methods \u00b6 add_binary_data \u00b6 def add_binary_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_data \u00b6 def add_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_directory \u00b6 def add_directory ( local_dir : str , exclude : typing . List [ str ] = None , key_prefix : str = None ) local_dir Required \u00b6 Type: str A path to a local directory. exclude Optional \u00b6 Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. add_file \u00b6 def add_file ( local_file : str , key : str = None ) local_file Required \u00b6 Type: str The path to the local file. key Optional \u00b6 Type: str The ConfigMap key (default to the file name). Static Functions \u00b6 from_config_map_name \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ConfigMap . from_config_map_name ( name : str ) name Required \u00b6 Type: str The name of the config map to import. Properties \u00b6 binary_data Required \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 immutable : bool Type: bool Whether or not this config map is immutable. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . DaemonSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , min_ready_seconds : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_21.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. min_ready_seconds Optional \u00b6 Type: typing.Union[int, float] Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Properties \u00b6 min_ready_seconds Required \u00b6 min_ready_seconds : typing . Union [ int , float ] Type: typing.Union[int, float] resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Deployment ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , min_ready : Duration = None , progress_deadline : Duration = None , replicas : typing . Union [ int , float ] = None , strategy : DeploymentStrategy = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_21.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. min_ready Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progress_deadline Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 Type: cdk8s_plus_21.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. Methods \u00b6 expose_via_ingress \u00b6 def expose_via_ingress ( path : str , name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None , ingress : IngressV1Beta1 = None ) path Required \u00b6 Type: str The ingress path to register under. name Optional \u00b6 Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 Type: cdk8s_plus_21.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 Type: cdk8s_plus_21.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. expose_via_service \u00b6 def expose_via_service ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 Type: cdk8s_plus_21.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. Properties \u00b6 min_ready Required \u00b6 min_ready : Duration Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progress_deadline Required \u00b6 progress_deadline : Duration Type: cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 strategy : DeploymentStrategy Type: cdk8s_plus_21.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . DockerConfigSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , data : typing . Mapping [ typing . Any ] ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 Type: typing.Mapping[ typing.Any ] JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . GCEPersistentDiskPersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , pd_name : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pd_name Required \u00b6 Type: str Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. pd_name Required \u00b6 pd_name : str Type: str PD resource in GCE of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Partition of this volume. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . IngressV1Beta1 ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , default_backend : IngressV1Beta1Backend = None , rules : typing . List [ IngressV1Beta1Rule ] = None , tls : typing . List [ IngressV1Beta1Tls ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 Type: cdk8s_plus_21.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_21.IngressV1Beta1Rule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: typing.List[ cdk8s_plus_21.IngressV1Beta1Tls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 add_default_backend \u00b6 def add_default_backend ( backend : IngressV1Beta1Backend ) backend Required \u00b6 Type: cdk8s_plus_21.IngressV1Beta1Backend The backend to use for requests that do not match any rule. add_host_default_backend \u00b6 def add_host_default_backend ( host : str , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: str The host name to match. backend Required \u00b6 Type: cdk8s_plus_21.IngressV1Beta1Backend The backend to route to. add_host_rule \u00b6 def add_host_rule ( host : str , path : str , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: str The host name. path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_21.IngressV1Beta1Backend The backend to route requests to. add_rule \u00b6 def add_rule ( path : str , backend : IngressV1Beta1Backend ) path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_21.IngressV1Beta1Backend The backend to route requests to. add_rules \u00b6 def add_rules ( backend : IngressV1Beta1Backend , host : str = None , path : str = None ) backend Required \u00b6 Type: cdk8s_plus_21.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. add_tls \u00b6 def add_tls ( tls : typing . List [ IngressV1Beta1Tls ] ) tls Required \u00b6 Type: typing.List[ cdk8s_plus_21.IngressV1Beta1Tls ] Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Job ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_21.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. active_deadline Optional \u00b6 Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Number of retries before marking failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration TTL before the job is deleted after it is finished. PersistentVolume \u00b6 Implements: cdk8s_plus_21.IPersistentVolume , cdk8s_plus_21.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 as_volume \u00b6 def as_volume () bind \u00b6 def bind ( claim : IPersistentVolumeClaim ) claim Required \u00b6 Type: cdk8s_plus_21.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 def reserve () Static Functions \u00b6 from_persistent_volume_name \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PersistentVolume . from_persistent_volume_name ( volume_name : str ) volume_name Required \u00b6 Type: str The name of the pv to reference. Properties \u00b6 mode Required \u00b6 mode : PersistentVolumeMode Type: cdk8s_plus_21.PersistentVolumeMode Volume mode of this volume. reclaim_policy Required \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_21.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_21.PersistentVolumeAccessMode ] Access modes requirement of this claim. claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_21.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Mount options of this volume. storage Optional \u00b6 storage : Size Type: cdk8s.Size Storage size of this volume. storage_class_name Optional \u00b6 storage_class_name : str Type: str Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: cdk8s_plus_21.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PersistentVolumeClaim ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , storage : Size = None , storage_class_name : str = None , volume : IPersistentVolume = None , volume_mode : PersistentVolumeMode = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.PersistentVolumeAccessMode ] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 Type: cdk8s_plus_21.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volume_mode Optional \u00b6 Type: cdk8s_plus_21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 bind \u00b6 def bind ( vol : IPersistentVolume ) vol Required \u00b6 Type: cdk8s_plus_21.IPersistentVolume The PV to bind to. Static Functions \u00b6 from_claim_name \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PersistentVolumeClaim . from_claim_name ( claim_name : str ) claim_name Required \u00b6 Type: str The name of the pvc to reference. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. volume_mode Required \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_21.PersistentVolumeMode Volume mode requirement of this claim. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_21.PersistentVolumeAccessMode ] Access modes requirement of this claim. storage Optional \u00b6 storage : Size Type: cdk8s.Size Storage requirement of this claim. storage_class_name Optional \u00b6 storage_class_name : str Type: str Storage class requirment of this claim. volume Optional \u00b6 volume : IPersistentVolume Type: cdk8s_plus_21.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Pod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_21.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Resource \u00b6 Implements: cdk8s_plus_21.IResource , cdk8s_plus_21.IApiResource , cdk8s_plus_21.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Resource ( scope : Construct , id : str , node_factory : INodeFactory = None ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: str The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . node_factory Optional \u00b6 Type: constructs.INodeFactory Default: the default Node is associated A factory for attaching Node s to the construct. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 name : str Type: str The name of this API object. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. resource_name Optional \u00b6 resource_name : str Type: str The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: cdk8s_plus_21.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Role ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , rules : typing . List [ RolePolicyRule ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_21.RolePolicyRule ] Default: [] A list of rules the role should allow. Methods \u00b6 allow \u00b6 def allow ( verbs : typing . List [ str ], resources : IApiResource ) verbs Required \u00b6 Type: typing.List[ str ] resources Required \u00b6 Type: cdk8s_plus_21.IApiResource The resource(s) to apply to. allow_create \u00b6 def allow_create ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_21.IApiResource The resource(s) to apply to. allow_delete \u00b6 def allow_delete ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_21.IApiResource The resource(s) to apply to. allow_delete_collection \u00b6 def allow_delete_collection ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_21.IApiResource The resource(s) to apply to. allow_get \u00b6 def allow_get ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_21.IApiResource The resource(s) to apply to. allow_list \u00b6 def allow_list ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_21.IApiResource The resource(s) to apply to. allow_patch \u00b6 def allow_patch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_21.IApiResource The resource(s) to apply to. allow_read \u00b6 def allow_read ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_21.IApiResource The resource(s) to apply to. allow_read_write \u00b6 def allow_read_write ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_21.IApiResource The resource(s) to apply to. allow_update \u00b6 def allow_update ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_21.IApiResource The resource(s) to apply to. allow_watch \u00b6 def allow_watch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_21.IApiResource The resource(s) to apply to. bind \u00b6 def bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_21.ISubject a list of subjects to bind to. Static Functions \u00b6 from_role_name \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Role . from_role_name ( name : str ) name Required \u00b6 Type: str The name of the role resource. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 rules : typing . List [ RolePolicyRule ] Type: typing.List[ cdk8s_plus_21.RolePolicyRule ] Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . RoleBinding ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , role : IRole ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: cdk8s_plus_21.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. Methods \u00b6 add_subjects \u00b6 def add_subjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_21.ISubject The subjects to add. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 role : IRole Type: cdk8s_plus_21.IRole subjects Required \u00b6 subjects : typing . List [ ISubject ] Type: typing.List[ cdk8s_plus_21.ISubject ] Secret \u00b6 Implements: cdk8s_plus_21.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Secret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , string_data : typing . Mapping [ str ] = None , type : str = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. string_data Optional \u00b6 Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 add_string_data \u00b6 def add_string_data ( key : str , value : str ) key Required \u00b6 Type: str Key. value Required \u00b6 Type: str Value. get_string_data \u00b6 def get_string_data ( key : str ) key Required \u00b6 Type: str Key. Static Functions \u00b6 from_secret_name \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Secret . from_secret_name ( name : str ) name Required \u00b6 Type: str The name of the secret to reference. Properties \u00b6 immutable Required \u00b6 immutable : bool Type: bool Whether or not the secret is immutable. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Service ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: cdk8s_plus_21.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 add_deployment \u00b6 def add_deployment ( depl : Deployment , name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None ) depl Required \u00b6 Type: cdk8s_plus_21.Deployment The deployment to expose. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the first container of the deployment. The port number the service will bind to. add_selector \u00b6 def add_selector ( label : str , value : str ) label Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. expose_via_ingress \u00b6 def expose_via_ingress ( path : str , ingress : IngressV1Beta1 = None ) path Required \u00b6 Type: str The path to expose the service under. ingress Optional \u00b6 Type: cdk8s_plus_21.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. serve \u00b6 def serve ( port : typing . Union [ int , float ], name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) port Required \u00b6 Type: typing.Union[int, float] The port definition. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. Properties \u00b6 ports Required \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_21.ServicePort ] Ports for this service. Use serve() to expose additional service ports. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. selector Required \u00b6 selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] Returns the labels which are used to select pods for this service. type Required \u00b6 type : ServiceType Type: cdk8s_plus_21.ServiceType Determines how the Service is exposed. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str The IP address of the service and is usually assigned randomly by the master. external_name Optional \u00b6 external_name : str Type: str The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s_plus_21.IServiceAccount , cdk8s_plus_21.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ServiceAccount ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_token : bool = None , secrets : typing . List [ ISecret ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_token Optional \u00b6 Type: bool Default: true Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 add_secret \u00b6 def add_secret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s_plus_21.ISecret The secret. Static Functions \u00b6 from_service_account_name \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ServiceAccount . from_service_account_name ( name : str ) name Required \u00b6 Type: str The name of the service account resource. Properties \u00b6 automount_token Required \u00b6 automount_token : bool Type: bool Whether or not a token is automatically mounted for this service account. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_21.ISecret ] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ServiceAccountTokenSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , service_account : IServiceAccount ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. service_account Required \u00b6 Type: cdk8s_plus_21.IServiceAccount The service account to store a secret for. SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . SshAuthSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , ssh_private_key : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ssh_private_key Required \u00b6 Type: str The SSH private key to use. StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . StatefulSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , service : Service , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None , strategy : StatefulSetUpdateStrategy = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_21.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. service Required \u00b6 Type: cdk8s_plus_21.Service Service to associate with the statefulset. pod_management_policy Optional \u00b6 Type: cdk8s_plus_21.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 Type: cdk8s_plus_21.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. Properties \u00b6 pod_management_policy Required \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_21.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 strategy : StatefulSetUpdateStrategy Type: cdk8s_plus_21.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . TlsSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , tls_cert : str , tls_key : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tls_cert Required \u00b6 Type: str The TLS cert. tls_key Required \u00b6 Type: str The TLS key. Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Workload ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_21.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. Methods \u00b6 select \u00b6 def select ( selectors : LabelSelector ) selectors Required \u00b6 Type: cdk8s_plus_21.LabelSelector Properties \u00b6 match_expressions Required \u00b6 match_expressions : typing . List [ LabelSelectorRequirement ] Type: typing.List[ cdk8s_plus_21.LabelSelectorRequirement ] The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. match_labels Required \u00b6 match_labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . AbstractPodProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_21.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . AddDeploymentOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . AddDirectoryOptions ( exclude : typing . List [ str ] = None , key_prefix : str = None ) exclude Optional \u00b6 exclude : typing . List [ str ] Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 key_prefix : str Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ApiResourceOptions ( api_group : str , resource_type : str ) api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . AwsElasticBlockStorePersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , volume_id : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_21.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volume_id Required \u00b6 volume_id : str Type: str Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . AwsElasticBlockStoreVolumeOptions ( fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . AzureDiskPersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_21.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. disk_name Required \u00b6 disk_name : str Type: str The Name of the data disk in the blob storage. disk_uri Required \u00b6 disk_uri : str Type: str The URI the data disk in the blob storage. caching_mode Optional \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_21.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_21.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. read_only Optional \u00b6 read_only : bool Type: bool Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . AzureDiskVolumeOptions ( caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , name : str = None , read_only : bool = None ) caching_mode Optional \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_21.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_21.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. read_only Optional \u00b6 read_only : bool Type: bool Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . BasicAuthSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , password : str , username : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 password : str Type: str The password or token for authentication. username Required \u00b6 username : str Type: str The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ClusterRoleBindingProps ( metadata : ApiObjectMetadata = None , role : IClusterRole ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 role : IClusterRole Type: cdk8s_plus_21.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ClusterRolePolicyRule ( endpoints : typing . List [ IApiEndpoint ], verbs : typing . List [ str ] ) endpoints Required \u00b6 endpoints : typing . List [ IApiEndpoint ] Type: typing.List[ cdk8s_plus_21.IApiEndpoint ] Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 verbs : typing . List [ str ] Type: typing.List[ str ] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ClusterRoleProps ( metadata : ApiObjectMetadata = None , aggregation_labels : typing . Mapping [ str ] = None , rules : typing . List [ ClusterRolePolicyRule ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregation_labels Optional \u00b6 aggregation_labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 rules : typing . List [ ClusterRolePolicyRule ] Type: typing.List[ cdk8s_plus_21.ClusterRolePolicyRule ] Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . CommandProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . CommonSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ConfigMapProps ( metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None , immutable : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ConfigMapVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 default_mode : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 items : typing . Mapping [ PathMapping ] Type: typing.Mapping[ cdk8s_plus_21.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. optional Optional \u00b6 optional : bool Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ContainerLifecycle ( post_start : Handler = None , pre_stop : Handler = None ) post_start Optional \u00b6 post_start : Handler Type: cdk8s_plus_21.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. pre_stop Optional \u00b6 pre_stop : Handler Type: cdk8s_plus_21.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ContainerProps ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 image : str Type: str Docker image name. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 env : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_21.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 lifecycle : ContainerLifecycle Type: cdk8s_plus_21.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 liveness : Probe Type: cdk8s_plus_21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 name : str Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 readiness : Probe Type: cdk8s_plus_21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 resources : ContainerResources Type: cdk8s_plus_21.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 security_context : ContainerSecurityContextProps Type: cdk8s_plus_21.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 startup : Probe Type: cdk8s_plus_21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 volume_mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_21.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 working_dir : str Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ContainerResources ( cpu : CpuResources , memory : MemoryResources ) cpu Required \u00b6 cpu : CpuResources Type: cdk8s_plus_21.CpuResources memory Required \u00b6 memory : MemoryResources Type: cdk8s_plus_21.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ContainerSecurityContextProps ( ensure_non_root : bool = None , group : typing . Union [ int , float ] = None , privileged : bool = None , read_only_root_filesystem : bool = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 ensure_non_root : bool Type: bool Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. privileged Optional \u00b6 privileged : bool Type: bool Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. read_only_root_filesystem Optional \u00b6 read_only_root_filesystem : bool Type: bool Default: false Whether this container has a read-only root filesystem. user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . CpuResources ( limit : Cpu , request : Cpu ) limit Required \u00b6 limit : Cpu Type: cdk8s_plus_21.Cpu request Required \u00b6 request : Cpu Type: cdk8s_plus_21.Cpu DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . DaemonSetProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , min_ready_seconds : typing . Union [ int , float ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_21.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. min_ready_seconds Optional \u00b6 min_ready_seconds : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . DeploymentProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , min_ready : Duration = None , progress_deadline : Duration = None , replicas : typing . Union [ int , float ] = None , strategy : DeploymentStrategy = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_21.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. min_ready Optional \u00b6 min_ready : Duration Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progress_deadline Optional \u00b6 progress_deadline : Duration Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 strategy : DeploymentStrategy Type: cdk8s_plus_21.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . DeploymentStrategyRollingUpdateOptions ( max_surge : PercentOrAbsolute = None , max_unavailable : PercentOrAbsolute = None ) max_surge Optional \u00b6 max_surge : PercentOrAbsolute Type: cdk8s_plus_21.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. max_unavailable Optional \u00b6 max_unavailable : PercentOrAbsolute Type: cdk8s_plus_21.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . DnsOption ( name : str , value : str = None ) name Required \u00b6 name : str Type: str Option name. value Optional \u00b6 value : str Type: str Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . DockerConfigSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , data : typing . Mapping [ typing . Any ] ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 data : typing . Mapping [ typing . Any ] Type: typing.Mapping[ typing.Any ] JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EmptyDirVolumeOptions ( medium : EmptyDirMedium = None , size_limit : Size = None ) medium Optional \u00b6 medium : EmptyDirMedium Type: cdk8s_plus_21.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 size_limit : Size Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValueFromConfigMapOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValueFromFieldRefOptions ( api_version : str = None , key : str = None ) api_version Optional \u00b6 api_version : str Type: str Version of the schema the FieldPath is written in terms of. key Optional \u00b6 key : str Type: str The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValueFromProcessOptions ( required : bool = None ) required Optional \u00b6 required : bool Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValueFromResourceOptions ( container : Container = None , divisor : str = None ) container Optional \u00b6 container : Container Type: cdk8s_plus_21.Container The container to select the value from. divisor Optional \u00b6 divisor : str Type: str The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValueFromSecretOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ExposeDeploymentViaIngressOptions ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None , ingress : IngressV1Beta1 = None ) name Optional \u00b6 name : str Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_21.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 ingress : IngressV1Beta1 Type: cdk8s_plus_21.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ExposeDeploymentViaServiceOptions ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_21.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ExposeServiceViaIngressOptions ( ingress : IngressV1Beta1 = None ) ingress Optional \u00b6 ingress : IngressV1Beta1 Type: cdk8s_plus_21.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . GCEPersistentDiskPersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , pd_name : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_21.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pd_name Required \u00b6 pd_name : str Type: str Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . GCEPersistentDiskVolumeOptions ( fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GroupProps \u00b6 Properties for Group . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . GroupProps ( name : str ) name Required \u00b6 name : str Type: str The name of the group. HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . HandlerFromHttpGetOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . HandlerFromTcpSocketOptions ( host : str = None , port : typing . Union [ int , float ] = None ) host Optional \u00b6 host : str Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . HostAlias ( hostnames : typing . List [ str ], ip : str ) hostnames Required \u00b6 hostnames : typing . List [ str ] Type: typing.List[ str ] Hostnames for the chosen IP address. ip Required \u00b6 ip : str Type: str IP address of the host file entry. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . HttpGetProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . IngressV1Beta1Props ( metadata : ApiObjectMetadata = None , default_backend : IngressV1Beta1Backend = None , rules : typing . List [ IngressV1Beta1Rule ] = None , tls : typing . List [ IngressV1Beta1Tls ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 default_backend : IngressV1Beta1Backend Type: cdk8s_plus_21.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 rules : typing . List [ IngressV1Beta1Rule ] Type: typing.List[ cdk8s_plus_21.IngressV1Beta1Rule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 tls : typing . List [ IngressV1Beta1Tls ] Type: typing.List[ cdk8s_plus_21.IngressV1Beta1Tls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . IngressV1Beta1Rule ( backend : IngressV1Beta1Backend , host : str = None , path : str = None ) backend Required \u00b6 backend : IngressV1Beta1Backend Type: cdk8s_plus_21.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 host : str Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 path : str Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . IngressV1Beta1Tls ( hosts : typing . List [ str ] = None , secret : ISecret = None ) hosts Optional \u00b6 hosts : typing . List [ str ] Type: typing.List[ str ] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 secret : ISecret Type: cdk8s_plus_21.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . JobProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_21.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . LabelSelectorRequirement ( key : str , operator : LabelSelectorRequirementOperator , values : typing . List [ str ] = None ) key Required \u00b6 key : str Type: str The label key that the selector applies to. operator Required \u00b6 operator : LabelSelectorRequirementOperator Type: cdk8s_plus_21.LabelSelectorRequirementOperator Represents a key\u2019s relationship to a set of values. values Optional \u00b6 values : typing . List [ str ] Type: typing.List[ str ] An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . MemoryResources ( limit : Size , request : Size ) limit Required \u00b6 limit : Size Type: cdk8s.Size request Required \u00b6 request : Size Type: cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . MountOptions ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_21.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PathMapping ( path : str , mode : typing . Union [ int , float ] = None ) path Required \u00b6 path : str Type: str The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 mode : typing . Union [ int , float ] Type: typing.Union[int, float] Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PersistentVolumeClaimProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , storage : Size = None , storage_class_name : str = None , volume : IPersistentVolume = None , volume_mode : PersistentVolumeMode = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_21.PersistentVolumeAccessMode ] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 volume : IPersistentVolume Type: cdk8s_plus_21.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PersistentVolumeClaimVolumeOptions ( name : str = None , read_only : bool = None ) name Optional \u00b6 name : str Type: str Default: Derived from the PVC name. The volume name. read_only Optional \u00b6 read_only : bool Type: bool Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_21.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PodDnsProps ( hostname : str = None , hostname_as_fqd_n : bool = None , nameservers : typing . List [ str ] = None , options : typing . List [ DnsOption ] = None , policy : DnsPolicy = None , searches : typing . List [ str ] = None , subdomain : str = None ) hostname Optional \u00b6 hostname : str Type: str Default: Set to a system-defined value. Specifies the hostname of the Pod. hostname_as_fqd_n Optional \u00b6 hostname_as_fqd_n : bool Type: bool Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 nameservers : typing . List [ str ] Type: typing.List[ str ] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 options : typing . List [ DnsOption ] Type: typing.List[ cdk8s_plus_21.DnsOption ] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 policy : DnsPolicy Type: cdk8s_plus_21.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 searches : typing . List [ str ] Type: typing.List[ str ] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 subdomain : str Type: str Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PodProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_21.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PodSecurityContextProps ( ensure_non_root : bool = None , fs_group : typing . Union [ int , float ] = None , fs_group_change_policy : FsGroupChangePolicy = None , group : typing . Union [ int , float ] = None , sysctls : typing . List [ Sysctl ] = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 ensure_non_root : bool Type: bool Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fs_group Optional \u00b6 fs_group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fs_group_change_policy Optional \u00b6 fs_group_change_policy : FsGroupChangePolicy Type: cdk8s_plus_21.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 sysctls : typing . List [ Sysctl ] Type: typing.List[ cdk8s_plus_21.Sysctl ] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ResourceProps ( metadata : ApiObjectMetadata = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . RoleBindingProps ( metadata : ApiObjectMetadata = None , role : IRole ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 role : IRole Type: cdk8s_plus_21.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . RolePolicyRule ( resources : typing . List [ IApiResource ], verbs : typing . List [ str ] ) resources Required \u00b6 resources : typing . List [ IApiResource ] Type: typing.List[ cdk8s_plus_21.IApiResource ] Resources this rule applies to. verbs Required \u00b6 verbs : typing . List [ str ] Type: typing.List[ str ] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . RoleProps ( metadata : ApiObjectMetadata = None , rules : typing . List [ RolePolicyRule ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 rules : typing . List [ RolePolicyRule ] Type: typing.List[ cdk8s_plus_21.RolePolicyRule ] Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . SecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , string_data : typing . Mapping [ str ] = None , type : str = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. string_data Optional \u00b6 string_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 type : str Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . SecretValue ( key : str , secret : ISecret ) key Required \u00b6 key : str Type: str The JSON key. secret Required \u00b6 secret : ISecret Type: cdk8s_plus_21.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . SecretVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 default_mode : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 items : typing . Mapping [ PathMapping ] Type: typing.Mapping[ cdk8s_plus_21.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. optional Optional \u00b6 optional : bool Type: bool Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ServiceAccountProps ( metadata : ApiObjectMetadata = None , automount_token : bool = None , secrets : typing . List [ ISecret ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_token Optional \u00b6 automount_token : bool Type: bool Default: true Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_21.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ServiceAccountTokenSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , service_account : IServiceAccount ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. service_account Required \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount The service account to store a secret for. ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ServiceIngressV1BetaBackendOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ServicePort ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ServicePortOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ServiceProps ( metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 external_i_ps : typing . List [ str ] Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 external_name : str Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 load_balancer_source_ranges : typing . List [ str ] Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_21.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 type : ServiceType Type: cdk8s_plus_21.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . SshAuthSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , ssh_private_key : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ssh_private_key Required \u00b6 ssh_private_key : str Type: str The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . StatefulSetProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , service : Service , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None , strategy : StatefulSetUpdateStrategy = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_21.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. service Required \u00b6 service : Service Type: cdk8s_plus_21.Service Service to associate with the statefulset. pod_management_policy Optional \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_21.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 strategy : StatefulSetUpdateStrategy Type: cdk8s_plus_21.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . StatefulSetUpdateStrategyRollingUpdateOptions ( partition : typing . Union [ int , float ] = None ) partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Sysctl ( name : str , value : str ) name Required \u00b6 name : str Type: str Name of a property to set. value Required \u00b6 value : str Type: str Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . TcpSocketProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , host : str = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 host : str Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . TlsSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , tls_cert : str , tls_key : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tls_cert Required \u00b6 tls_cert : str Type: str The TLS cert. tls_key Required \u00b6 tls_key : str Type: str The TLS key. UserProps \u00b6 Properties for User . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . UserProps ( name : str ) name Required \u00b6 name : str Type: str The name of the user. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . VolumeMount ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None , path : str , volume : Volume ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_21.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 path : str Type: str Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 volume : Volume Type: cdk8s_plus_21.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . WorkloadProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_21.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. Classes \u00b6 ApiResource \u00b6 Implements: cdk8s_plus_21.IApiResource , cdk8s_plus_21.IApiEndpoint Represents information about an API resource type. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Static Functions \u00b6 custom \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ApiResource . custom ( api_group : str , resource_type : str ) api_group Required \u00b6 Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for Ingress. JOBS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for Job. LEASES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: cdk8s_plus_21.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_21.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_21.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_21.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_21.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_21.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 add_env \u00b6 def add_env ( name : str , value : EnvValue ) name Required \u00b6 Type: str The variable name. value Required \u00b6 Type: cdk8s_plus_21.EnvValue The variable value. mount \u00b6 def mount ( path : str , storage : IStorage , propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) path Required \u00b6 Type: str The desired path in the container. storage Required \u00b6 Type: cdk8s_plus_21.IStorage The storage to mount. propagation Optional \u00b6 Type: cdk8s_plus_21.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. Properties \u00b6 env Required \u00b6 env : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_21.EnvValue ] The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 image : str Type: str The container image. image_pull_policy Required \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_21.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_21.VolumeMount ] Volume mounts configured for this container. name Required \u00b6 name : str Type: str The name of the container. security_context Required \u00b6 security_context : ContainerSecurityContext Type: cdk8s_plus_21.ContainerSecurityContext The security context of the container. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Arguments to the entrypoint. command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port this container exposes. resources Optional \u00b6 resources : ContainerResources Type: cdk8s_plus_21.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ working_dir Optional \u00b6 working_dir : str Type: str The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ContainerSecurityContext ( ensure_non_root : bool = None , group : typing . Union [ int , float ] = None , privileged : bool = None , read_only_root_filesystem : bool = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 Type: bool Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. privileged Optional \u00b6 Type: bool Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. read_only_root_filesystem Optional \u00b6 Type: bool Default: false Whether this container has a read-only root filesystem. user Optional \u00b6 Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensure_non_root Required \u00b6 ensure_non_root : bool Type: bool privileged Required \u00b6 privileged : bool Type: bool read_only_root_filesystem Required \u00b6 read_only_root_filesystem : bool Type: bool group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Cpu . millis ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] units \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Cpu . units ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] Properties \u00b6 amount Required \u00b6 amount : str Type: str DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . DeploymentStrategy . recreate () rolling_update \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . DeploymentStrategy . rolling_update ( max_surge : PercentOrAbsolute = None , max_unavailable : PercentOrAbsolute = None ) max_surge Optional \u00b6 Type: cdk8s_plus_21.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. max_unavailable Optional \u00b6 Type: cdk8s_plus_21.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValue . from_config_map ( config_map : IConfigMap , key : str , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_21.IConfigMap The config map. key Required \u00b6 Type: str The key to extract the value from. optional Optional \u00b6 Type: bool Default: false Specify whether the ConfigMap or its key must be defined. from_field_ref \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValue . from_field_ref ( field_path : EnvFieldPaths , api_version : str = None , key : str = None ) field_path Required \u00b6 Type: cdk8s_plus_21.EnvFieldPaths : The field reference. api_version Optional \u00b6 Type: str Version of the schema the FieldPath is written in terms of. key Optional \u00b6 Type: str The key to select the pod label or annotation. from_process \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValue . from_process ( key : str , required : bool = None ) key Required \u00b6 Type: str The key to read. required Optional \u00b6 Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. from_resource \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValue . from_resource ( resource : ResourceFieldPaths , container : Container = None , divisor : str = None ) resource Required \u00b6 Type: cdk8s_plus_21.ResourceFieldPaths : Resource to select the value from. container Optional \u00b6 Type: cdk8s_plus_21.Container The container to select the value from. divisor Optional \u00b6 Type: str The output format of the exposed resource. from_secret_value \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValue . from_secret_value ( key : str , secret : ISecret , optional : bool = None ) key Required \u00b6 Type: str The JSON key. secret Required \u00b6 Type: cdk8s_plus_21.ISecret The secret. optional Optional \u00b6 Type: bool Default: false Specify whether the Secret or its key must be defined. from_value \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValue . from_value ( value : str ) value Required \u00b6 Type: str The value. Properties \u00b6 value Optional \u00b6 value : typing . Any Type: typing.Any value_from Optional \u00b6 value_from : typing . Any Type: typing.Any Group \u00b6 Implements: cdk8s_plus_21.ISubject Represents a group. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Group ( name : str ) name Required \u00b6 Type: str The name of the group. Properties \u00b6 kind Required \u00b6 kind : str Type: str Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 name : str Type: str Name of the object being referenced. api_group Optional \u00b6 api_group : str Type: str APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Handler . from_command ( command : typing . List [ str ] ) command Required \u00b6 Type: typing.List[ str ] The command to execute. from_http_get \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Handler . from_http_get ( path : str , port : typing . Union [ int , float ] = None ) path Required \u00b6 Type: str The URL path to hit. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. from_tcp_socket \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Handler . from_tcp_socket ( host : str = None , port : typing . Union [ int , float ] = None ) host Optional \u00b6 Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 from_service \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . IngressV1Beta1Backend . from_service ( serv : Service , port : typing . Union [ int , float ] = None ) serv Required \u00b6 Type: cdk8s_plus_21.Service The service object. port Optional \u00b6 Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. LabelSelector \u00b6 A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors Static Functions \u00b6 does_not_exist \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . LabelSelector . does_not_exist ( key : str ) key Required \u00b6 Type: str exists \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . LabelSelector . exists ( key : str ) key Required \u00b6 Type: str in \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . LabelSelector . in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] is \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . LabelSelector . is ( key : str , value : str , apply_to_template : bool = None ) key Required \u00b6 Type: str value Required \u00b6 Type: str apply_to_template Optional \u00b6 Type: bool not_in \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . LabelSelector . not_in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] Properties \u00b6 apply_to_template Required \u00b6 apply_to_template : bool Type: bool key Required \u00b6 key : str Type: str operator Optional \u00b6 operator : LabelSelectorRequirementOperator Type: cdk8s_plus_21.LabelSelectorRequirementOperator values Optional \u00b6 values : typing . List [ str ] Type: typing.List[ str ] NonApiResource \u00b6 Implements: cdk8s_plus_21.IApiEndpoint Factory for creating non api resources. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Static Functions \u00b6 of \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . NonApiResource . of ( url : str ) url Required \u00b6 Type: str PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 is_zero \u00b6 def is_zero () Static Functions \u00b6 absolute \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PercentOrAbsolute . absolute ( num : typing . Union [ int , float ] ) num Required \u00b6 Type: typing.Union[int, float] percent \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PercentOrAbsolute . percent ( percent : typing . Union [ int , float ] ) percent Required \u00b6 Type: typing.Union[int, float] Properties \u00b6 value Required \u00b6 value : typing . Any Type: typing.Any PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PodDns ( hostname : str = None , hostname_as_fqd_n : bool = None , nameservers : typing . List [ str ] = None , options : typing . List [ DnsOption ] = None , policy : DnsPolicy = None , searches : typing . List [ str ] = None , subdomain : str = None ) hostname Optional \u00b6 Type: str Default: Set to a system-defined value. Specifies the hostname of the Pod. hostname_as_fqd_n Optional \u00b6 Type: bool Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 Type: typing.List[ str ] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 Type: typing.List[ cdk8s_plus_21.DnsOption ] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 Type: cdk8s_plus_21.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 Type: typing.List[ str ] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 Type: str Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. Methods \u00b6 add_nameserver \u00b6 def add_nameserver ( nameservers : str ) nameservers Required \u00b6 Type: str add_option \u00b6 def add_option ( name : str , value : str = None ) name Required \u00b6 Type: str Option name. value Optional \u00b6 Type: str Default: No value. Option value. add_search \u00b6 def add_search ( searches : str ) searches Required \u00b6 Type: str Properties \u00b6 hostname_as_fqd_n Required \u00b6 hostname_as_fqd_n : bool Type: bool Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 nameservers : typing . List [ str ] Type: typing.List[ str ] Nameservers defined for this pod. options Required \u00b6 options : typing . List [ DnsOption ] Type: typing.List[ cdk8s_plus_21.DnsOption ] Custom dns options defined for this pod. policy Required \u00b6 policy : DnsPolicy Type: cdk8s_plus_21.DnsPolicy The DNS policy of this pod. searches Required \u00b6 searches : typing . List [ str ] Type: typing.List[ str ] Search domains defined for this pod. hostname Optional \u00b6 hostname : str Type: str The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 subdomain : str Type: str The configured subdomain of the pod. PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PodSecurityContext ( ensure_non_root : bool = None , fs_group : typing . Union [ int , float ] = None , fs_group_change_policy : FsGroupChangePolicy = None , group : typing . Union [ int , float ] = None , sysctls : typing . List [ Sysctl ] = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 Type: bool Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fs_group Optional \u00b6 Type: typing.Union[int, float] Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fs_group_change_policy Optional \u00b6 Type: cdk8s_plus_21.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 Type: typing.List[ cdk8s_plus_21.Sysctl ] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensure_non_root Required \u00b6 ensure_non_root : bool Type: bool fs_group_change_policy Required \u00b6 fs_group_change_policy : FsGroupChangePolicy Type: cdk8s_plus_21.FsGroupChangePolicy sysctls Required \u00b6 sysctls : typing . List [ Sysctl ] Type: typing.List[ cdk8s_plus_21.Sysctl ] fs_group Optional \u00b6 fs_group : typing . Union [ int , float ] Type: typing.Union[int, float] group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Probe . from_command ( command : typing . List [ str ], failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) command Required \u00b6 Type: typing.List[ str ] The command to execute. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes from_http_get \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Probe . from_http_get ( path : str , failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) path Required \u00b6 Type: str The URL path to hit. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. from_tcp_socket \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Probe . from_tcp_socket ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , host : str = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 on_delete \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . StatefulSetUpdateStrategy . on_delete () rolling_update \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . StatefulSetUpdateStrategy . rolling_update ( partition : typing . Union [ int , float ] = None ) partition Optional \u00b6 Type: typing.Union[int, float] Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions User \u00b6 Implements: cdk8s_plus_21.ISubject Represents a user. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . User ( name : str ) name Required \u00b6 Type: str The name of the user. Properties \u00b6 kind Required \u00b6 kind : str Type: str Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 name : str Type: str Name of the object being referenced. api_group Optional \u00b6 api_group : str Type: str APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Volume \u00b6 Implements: cdk8s_plus_21.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 as_volume \u00b6 def as_volume () Static Functions \u00b6 from_aws_elastic_block_store \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Volume . from_aws_elastic_block_store ( volume_id : str , fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) volume_id Required \u00b6 Type: str fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 Type: str Default: auto-generated The volume name. partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore from_azure_disk \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Volume . from_azure_disk ( disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , name : str = None , read_only : bool = None ) disk_name Required \u00b6 Type: str disk_uri Required \u00b6 Type: str caching_mode Optional \u00b6 Type: cdk8s_plus_21.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: cdk8s_plus_21.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 Type: str Default: auto-generated The volume name. read_only Optional \u00b6 Type: bool Default: false Force the ReadOnly setting in VolumeMounts. from_config_map \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Volume . from_config_map ( config_map : IConfigMap , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_21.IConfigMap The config map to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_21.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. from_empty_dir \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Volume . from_empty_dir ( name : str , medium : EmptyDirMedium = None , size_limit : Size = None ) name Required \u00b6 Type: str medium Optional \u00b6 Type: cdk8s_plus_21.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. from_gce_persistent_disk \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Volume . from_gce_persistent_disk ( pd_name : str , fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) pd_name Required \u00b6 Type: str fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 Type: str Default: auto-generated The volume name. partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore from_persistent_volume_claim \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Volume . from_persistent_volume_claim ( claim : IPersistentVolumeClaim , name : str = None , read_only : bool = None ) claim Required \u00b6 Type: cdk8s_plus_21.IPersistentVolumeClaim name Optional \u00b6 Type: str Default: Derived from the PVC name. The volume name. read_only Optional \u00b6 Type: bool Default: false Will force the ReadOnly setting in VolumeMounts. from_secret \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Volume . from_secret ( secr : ISecret , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) secr Required \u00b6 Type: cdk8s_plus_21.ISecret The secret to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_21.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the secret or its keys must be defined. Properties \u00b6 name Required \u00b6 name : str Type: str Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: cdk8s_plus_21.AbstractPod , cdk8s_plus_21.ApiResource , cdk8s_plus_21.AwsElasticBlockStorePersistentVolume , cdk8s_plus_21.AzureDiskPersistentVolume , cdk8s_plus_21.BasicAuthSecret , cdk8s_plus_21.ClusterRole , cdk8s_plus_21.ClusterRoleBinding , cdk8s_plus_21.ConfigMap , cdk8s_plus_21.DaemonSet , cdk8s_plus_21.Deployment , cdk8s_plus_21.DockerConfigSecret , cdk8s_plus_21.GCEPersistentDiskPersistentVolume , cdk8s_plus_21.IngressV1Beta1 , cdk8s_plus_21.Job , cdk8s_plus_21.NonApiResource , cdk8s_plus_21.PersistentVolume , cdk8s_plus_21.PersistentVolumeClaim , cdk8s_plus_21.Pod , cdk8s_plus_21.Resource , cdk8s_plus_21.Role , cdk8s_plus_21.RoleBinding , cdk8s_plus_21.Secret , cdk8s_plus_21.Service , cdk8s_plus_21.ServiceAccount , cdk8s_plus_21.ServiceAccountTokenSecret , cdk8s_plus_21.SshAuthSecret , cdk8s_plus_21.StatefulSet , cdk8s_plus_21.TlsSecret , cdk8s_plus_21.Workload , cdk8s_plus_21.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () IApiResource \u00b6 Implemented By: cdk8s_plus_21.AbstractPod , cdk8s_plus_21.ApiResource , cdk8s_plus_21.AwsElasticBlockStorePersistentVolume , cdk8s_plus_21.AzureDiskPersistentVolume , cdk8s_plus_21.BasicAuthSecret , cdk8s_plus_21.ClusterRole , cdk8s_plus_21.ClusterRoleBinding , cdk8s_plus_21.ConfigMap , cdk8s_plus_21.DaemonSet , cdk8s_plus_21.Deployment , cdk8s_plus_21.DockerConfigSecret , cdk8s_plus_21.GCEPersistentDiskPersistentVolume , cdk8s_plus_21.IngressV1Beta1 , cdk8s_plus_21.Job , cdk8s_plus_21.PersistentVolume , cdk8s_plus_21.PersistentVolumeClaim , cdk8s_plus_21.Pod , cdk8s_plus_21.Resource , cdk8s_plus_21.Role , cdk8s_plus_21.RoleBinding , cdk8s_plus_21.Secret , cdk8s_plus_21.Service , cdk8s_plus_21.ServiceAccount , cdk8s_plus_21.ServiceAccountTokenSecret , cdk8s_plus_21.SshAuthSecret , cdk8s_plus_21.StatefulSet , cdk8s_plus_21.TlsSecret , cdk8s_plus_21.Workload , cdk8s_plus_21.IApiResource Represents a resource or collection of resources. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resource_name Optional \u00b6 resource_name : str Type: str The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.ClusterRole , cdk8s_plus_21.IClusterRole Represents a cluster-level role. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IConfigMap \u00b6 Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.ConfigMap , cdk8s_plus_21.IConfigMap Represents a config map. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IPersistentVolume \u00b6 Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.AwsElasticBlockStorePersistentVolume , cdk8s_plus_21.AzureDiskPersistentVolume , cdk8s_plus_21.GCEPersistentDiskPersistentVolume , cdk8s_plus_21.PersistentVolume , cdk8s_plus_21.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.PersistentVolumeClaim , cdk8s_plus_21.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IResource \u00b6 Implemented By: cdk8s_plus_21.AbstractPod , cdk8s_plus_21.AwsElasticBlockStorePersistentVolume , cdk8s_plus_21.AzureDiskPersistentVolume , cdk8s_plus_21.BasicAuthSecret , cdk8s_plus_21.ClusterRole , cdk8s_plus_21.ClusterRoleBinding , cdk8s_plus_21.ConfigMap , cdk8s_plus_21.DaemonSet , cdk8s_plus_21.Deployment , cdk8s_plus_21.DockerConfigSecret , cdk8s_plus_21.GCEPersistentDiskPersistentVolume , cdk8s_plus_21.IngressV1Beta1 , cdk8s_plus_21.Job , cdk8s_plus_21.PersistentVolume , cdk8s_plus_21.PersistentVolumeClaim , cdk8s_plus_21.Pod , cdk8s_plus_21.Resource , cdk8s_plus_21.Role , cdk8s_plus_21.RoleBinding , cdk8s_plus_21.Secret , cdk8s_plus_21.Service , cdk8s_plus_21.ServiceAccount , cdk8s_plus_21.ServiceAccountTokenSecret , cdk8s_plus_21.SshAuthSecret , cdk8s_plus_21.StatefulSet , cdk8s_plus_21.TlsSecret , cdk8s_plus_21.Workload , cdk8s_plus_21.IClusterRole , cdk8s_plus_21.IConfigMap , cdk8s_plus_21.IPersistentVolume , cdk8s_plus_21.IPersistentVolumeClaim , cdk8s_plus_21.IResource , cdk8s_plus_21.IRole , cdk8s_plus_21.ISecret , cdk8s_plus_21.IServiceAccount Represents a resource. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IRole \u00b6 Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.ClusterRole , cdk8s_plus_21.Role , cdk8s_plus_21.IRole A reference to any Role or ClusterRole. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.BasicAuthSecret , cdk8s_plus_21.DockerConfigSecret , cdk8s_plus_21.Secret , cdk8s_plus_21.ServiceAccountTokenSecret , cdk8s_plus_21.SshAuthSecret , cdk8s_plus_21.TlsSecret , cdk8s_plus_21.ISecret Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.ServiceAccount , cdk8s_plus_21.IServiceAccount Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IStorage \u00b6 Implemented By: cdk8s_plus_21.AwsElasticBlockStorePersistentVolume , cdk8s_plus_21.AzureDiskPersistentVolume , cdk8s_plus_21.GCEPersistentDiskPersistentVolume , cdk8s_plus_21.PersistentVolume , cdk8s_plus_21.Volume , cdk8s_plus_21.IStorage Represents a piece of storage in the cluster. Methods \u00b6 as_volume \u00b6 def as_volume () ISubject \u00b6 Implemented By: cdk8s_plus_21.Group , cdk8s_plus_21.ServiceAccount , cdk8s_plus_21.User , cdk8s_plus_21.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Properties \u00b6 kind Required \u00b6 kind : str Type: str Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 name : str Type: str Name of the object being referenced. api_group Optional \u00b6 api_group : str Type: str APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 namespace : str Type: str Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. LabelSelectorRequirementOperator \u00b6 Possible operators. IN \u00b6 In. NOT_IN \u00b6 NotIn. EXISTS \u00b6 Exists. DOES_NOT_EXIST \u00b6 DoesNotExist. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"Python"},{"location":"reference/cdk8s-plus-21/python/#cdk8s-plus-21-python","text":"","title":"cdk8s-plus-21 (Python) "},{"location":"reference/cdk8s-plus-21/python/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-21/python/#abstractpod","text":"","title":"AbstractPod "},{"location":"reference/cdk8s-plus-21/python/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-21/python/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-21/python/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-21/python/#clusterrole","text":"Implements: cdk8s_plus_21.IClusterRole , cdk8s_plus_21.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-21/python/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-21/python/#configmap","text":"Implements: cdk8s_plus_21.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-21/python/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-21/python/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-21/python/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-21/python/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-21/python/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-21/python/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-21/python/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-21/python/#persistentvolume","text":"Implements: cdk8s_plus_21.IPersistentVolume , cdk8s_plus_21.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-21/python/#persistentvolumeclaim","text":"Implements: cdk8s_plus_21.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-21/python/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-21/python/#resource","text":"Implements: cdk8s_plus_21.IResource , cdk8s_plus_21.IApiResource , cdk8s_plus_21.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-21/python/#role","text":"Implements: cdk8s_plus_21.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-21/python/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-21/python/#secret","text":"Implements: cdk8s_plus_21.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-21/python/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-21/python/#serviceaccount","text":"Implements: cdk8s_plus_21.IServiceAccount , cdk8s_plus_21.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-21/python/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-21/python/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-21/python/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-21/python/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-21/python/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-21/python/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-21/python/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-21/python/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-21/python/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-21/python/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-21/python/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-21/python/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-21/python/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-21/python/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-21/python/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-21/python/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-21/python/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-21/python/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-21/python/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-21/python/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-21/python/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-21/python/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-21/python/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-21/python/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-21/python/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-21/python/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-21/python/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-21/python/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-21/python/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-21/python/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-21/python/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-21/python/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-21/python/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-21/python/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-21/python/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-21/python/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-21/python/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-21/python/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-21/python/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-21/python/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-21/python/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-21/python/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-21/python/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-21/python/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-21/python/#groupprops","text":"Properties for Group .","title":"GroupProps "},{"location":"reference/cdk8s-plus-21/python/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-21/python/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-21/python/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-21/python/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-21/python/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-21/python/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-21/python/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-21/python/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-21/python/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-21/python/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-21/python/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-21/python/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-21/python/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-21/python/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-21/python/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-21/python/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-21/python/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-21/python/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-21/python/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-21/python/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-21/python/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-21/python/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-21/python/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-21/python/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-21/python/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-21/python/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-21/python/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-21/python/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-21/python/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-21/python/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-21/python/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-21/python/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-21/python/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-21/python/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-21/python/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-21/python/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-21/python/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-21/python/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-21/python/#userprops","text":"Properties for User .","title":"UserProps "},{"location":"reference/cdk8s-plus-21/python/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-21/python/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-21/python/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-21/python/#apiresource","text":"Implements: cdk8s_plus_21.IApiResource , cdk8s_plus_21.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-21/python/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-21/python/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-21/python/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-21/python/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-21/python/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-21/python/#group","text":"Implements: cdk8s_plus_21.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-21/python/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-21/python/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-21/python/#labelselector","text":"A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors","title":"LabelSelector "},{"location":"reference/cdk8s-plus-21/python/#nonapiresource","text":"Implements: cdk8s_plus_21.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-21/python/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-21/python/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-21/python/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-21/python/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-21/python/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-21/python/#user","text":"Implements: cdk8s_plus_21.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-21/python/#volume","text":"Implements: cdk8s_plus_21.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-21/python/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-21/python/#iapiendpoint","text":"Implemented By: cdk8s_plus_21.AbstractPod , cdk8s_plus_21.ApiResource , cdk8s_plus_21.AwsElasticBlockStorePersistentVolume , cdk8s_plus_21.AzureDiskPersistentVolume , cdk8s_plus_21.BasicAuthSecret , cdk8s_plus_21.ClusterRole , cdk8s_plus_21.ClusterRoleBinding , cdk8s_plus_21.ConfigMap , cdk8s_plus_21.DaemonSet , cdk8s_plus_21.Deployment , cdk8s_plus_21.DockerConfigSecret , cdk8s_plus_21.GCEPersistentDiskPersistentVolume , cdk8s_plus_21.IngressV1Beta1 , cdk8s_plus_21.Job , cdk8s_plus_21.NonApiResource , cdk8s_plus_21.PersistentVolume , cdk8s_plus_21.PersistentVolumeClaim , cdk8s_plus_21.Pod , cdk8s_plus_21.Resource , cdk8s_plus_21.Role , cdk8s_plus_21.RoleBinding , cdk8s_plus_21.Secret , cdk8s_plus_21.Service , cdk8s_plus_21.ServiceAccount , cdk8s_plus_21.ServiceAccountTokenSecret , cdk8s_plus_21.SshAuthSecret , cdk8s_plus_21.StatefulSet , cdk8s_plus_21.TlsSecret , cdk8s_plus_21.Workload , cdk8s_plus_21.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-21/python/#iapiresource","text":"Implemented By: cdk8s_plus_21.AbstractPod , cdk8s_plus_21.ApiResource , cdk8s_plus_21.AwsElasticBlockStorePersistentVolume , cdk8s_plus_21.AzureDiskPersistentVolume , cdk8s_plus_21.BasicAuthSecret , cdk8s_plus_21.ClusterRole , cdk8s_plus_21.ClusterRoleBinding , cdk8s_plus_21.ConfigMap , cdk8s_plus_21.DaemonSet , cdk8s_plus_21.Deployment , cdk8s_plus_21.DockerConfigSecret , cdk8s_plus_21.GCEPersistentDiskPersistentVolume , cdk8s_plus_21.IngressV1Beta1 , cdk8s_plus_21.Job , cdk8s_plus_21.PersistentVolume , cdk8s_plus_21.PersistentVolumeClaim , cdk8s_plus_21.Pod , cdk8s_plus_21.Resource , cdk8s_plus_21.Role , cdk8s_plus_21.RoleBinding , cdk8s_plus_21.Secret , cdk8s_plus_21.Service , cdk8s_plus_21.ServiceAccount , cdk8s_plus_21.ServiceAccountTokenSecret , cdk8s_plus_21.SshAuthSecret , cdk8s_plus_21.StatefulSet , cdk8s_plus_21.TlsSecret , cdk8s_plus_21.Workload , cdk8s_plus_21.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-21/python/#iclusterrole","text":"Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.ClusterRole , cdk8s_plus_21.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-21/python/#iconfigmap","text":"Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.ConfigMap , cdk8s_plus_21.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-21/python/#ipersistentvolume","text":"Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.AwsElasticBlockStorePersistentVolume , cdk8s_plus_21.AzureDiskPersistentVolume , cdk8s_plus_21.GCEPersistentDiskPersistentVolume , cdk8s_plus_21.PersistentVolume , cdk8s_plus_21.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-21/python/#ipersistentvolumeclaim","text":"Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.PersistentVolumeClaim , cdk8s_plus_21.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-21/python/#iresource","text":"Implemented By: cdk8s_plus_21.AbstractPod , cdk8s_plus_21.AwsElasticBlockStorePersistentVolume , cdk8s_plus_21.AzureDiskPersistentVolume , cdk8s_plus_21.BasicAuthSecret , cdk8s_plus_21.ClusterRole , cdk8s_plus_21.ClusterRoleBinding , cdk8s_plus_21.ConfigMap , cdk8s_plus_21.DaemonSet , cdk8s_plus_21.Deployment , cdk8s_plus_21.DockerConfigSecret , cdk8s_plus_21.GCEPersistentDiskPersistentVolume , cdk8s_plus_21.IngressV1Beta1 , cdk8s_plus_21.Job , cdk8s_plus_21.PersistentVolume , cdk8s_plus_21.PersistentVolumeClaim , cdk8s_plus_21.Pod , cdk8s_plus_21.Resource , cdk8s_plus_21.Role , cdk8s_plus_21.RoleBinding , cdk8s_plus_21.Secret , cdk8s_plus_21.Service , cdk8s_plus_21.ServiceAccount , cdk8s_plus_21.ServiceAccountTokenSecret , cdk8s_plus_21.SshAuthSecret , cdk8s_plus_21.StatefulSet , cdk8s_plus_21.TlsSecret , cdk8s_plus_21.Workload , cdk8s_plus_21.IClusterRole , cdk8s_plus_21.IConfigMap , cdk8s_plus_21.IPersistentVolume , cdk8s_plus_21.IPersistentVolumeClaim , cdk8s_plus_21.IResource , cdk8s_plus_21.IRole , cdk8s_plus_21.ISecret , cdk8s_plus_21.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-21/python/#irole","text":"Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.ClusterRole , cdk8s_plus_21.Role , cdk8s_plus_21.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-21/python/#isecret","text":"Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.BasicAuthSecret , cdk8s_plus_21.DockerConfigSecret , cdk8s_plus_21.Secret , cdk8s_plus_21.ServiceAccountTokenSecret , cdk8s_plus_21.SshAuthSecret , cdk8s_plus_21.TlsSecret , cdk8s_plus_21.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-21/python/#iserviceaccount","text":"Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.ServiceAccount , cdk8s_plus_21.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-21/python/#istorage","text":"Implemented By: cdk8s_plus_21.AwsElasticBlockStorePersistentVolume , cdk8s_plus_21.AzureDiskPersistentVolume , cdk8s_plus_21.GCEPersistentDiskPersistentVolume , cdk8s_plus_21.PersistentVolume , cdk8s_plus_21.Volume , cdk8s_plus_21.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-21/python/#isubject","text":"Implemented By: cdk8s_plus_21.Group , cdk8s_plus_21.ServiceAccount , cdk8s_plus_21.User , cdk8s_plus_21.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"ISubject "},{"location":"reference/cdk8s-plus-21/python/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-21/python/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-21/python/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-21/python/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-21/python/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-21/python/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-21/python/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-21/python/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-21/python/#labelselectorrequirementoperator","text":"Possible operators.","title":"LabelSelectorRequirementOperator "},{"location":"reference/cdk8s-plus-21/python/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-21/python/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-21/python/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-21/python/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-21/python/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-21/python/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-21/python/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-21/python/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-21/python/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-21/typescript/","text":"cdk8s-plus-21 (TypeScript) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Initializers \u00b6 import { AbstractPod } from 'cdk8s-plus-21' new AbstractPod ( scope : Construct , id : string , props? : AbstractPodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.AbstractPodProps Methods \u00b6 addContainer \u00b6 public addContainer ( cont : ContainerProps ) cont Required \u00b6 Type: cdk8s-plus-21.ContainerProps addHostAlias \u00b6 public addHostAlias ( hostAlias : HostAlias ) hostAlias Required \u00b6 Type: cdk8s-plus-21.HostAlias addInitContainer \u00b6 public addInitContainer ( cont : ContainerProps ) cont Required \u00b6 Type: cdk8s-plus-21.ContainerProps addVolume \u00b6 public addVolume ( vol : Volume ) vol Required \u00b6 Type: cdk8s-plus-21.Volume Properties \u00b6 automountServiceAccountToken Required \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-21.Container [] dns Required \u00b6 public readonly dns : PodDns ; Type: cdk8s-plus-21.PodDns hostAliases Required \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-21.HostAlias [] initContainers Required \u00b6 public readonly initContainers : Container []; Type: cdk8s-plus-21.Container [] securityContext Required \u00b6 public readonly securityContext : PodSecurityContext ; Type: cdk8s-plus-21.PodSecurityContext volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-21.DockerConfigSecret restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import { AwsElasticBlockStorePersistentVolume } from 'cdk8s-plus-21' new AwsElasticBlockStorePersistentVolume ( scope : Construct , id : string , props : AwsElasticBlockStorePersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-21.AwsElasticBlockStorePersistentVolumeProps Properties \u00b6 fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. volumeId Required \u00b6 public readonly volumeId : string ; Type: string Volume id of this volume. partition Optional \u00b6 public readonly partition : number ; Type: number Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import { AzureDiskPersistentVolume } from 'cdk8s-plus-21' new AzureDiskPersistentVolume ( scope : Construct , id : string , props : AzureDiskPersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-21.AzureDiskPersistentVolumeProps Properties \u00b6 azureKind Required \u00b6 public readonly azureKind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-21.AzureDiskPersistentVolumeKind Azure kind of this volume. cachingMode Required \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-21.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. diskName Required \u00b6 public readonly diskName : string ; Type: string Disk name of this volume. diskUri Required \u00b6 public readonly diskUri : string ; Type: string Disk URI of this volume. fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import { BasicAuthSecret } from 'cdk8s-plus-21' new BasicAuthSecret ( scope : Construct , id : string , props : BasicAuthSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-21.BasicAuthSecretProps ClusterRole \u00b6 Implements: cdk8s-plus-21.IClusterRole , cdk8s-plus-21.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import { ClusterRole } from 'cdk8s-plus-21' new ClusterRole ( scope : Construct , id : string , props? : ClusterRoleProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.ClusterRoleProps Methods \u00b6 aggregate \u00b6 public aggregate ( key : string , value : string ) key Required \u00b6 Type: string value Required \u00b6 Type: string allow \u00b6 public allow ( verbs : string [], endpoints : IApiEndpoint ) verbs Required \u00b6 Type: string [] endpoints Required \u00b6 Type: cdk8s-plus-21.IApiEndpoint The endpoints(s) to apply to. allowCreate \u00b6 public allowCreate ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-21.IApiEndpoint The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-21.IApiEndpoint The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-21.IApiEndpoint The resource(s) to apply to. allowGet \u00b6 public allowGet ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-21.IApiEndpoint The resource(s) to apply to. allowList \u00b6 public allowList ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-21.IApiEndpoint The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-21.IApiEndpoint The resource(s) to apply to. allowRead \u00b6 public allowRead ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-21.IApiEndpoint The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-21.IApiEndpoint The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-21.IApiEndpoint The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-21.IApiEndpoint The resource(s) to apply to. bind \u00b6 public bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-21.ISubject a list of subjects to bind to. bindInNamespace \u00b6 public bindInNamespace ( namespace : string , subjects : ISubject ) namespace Required \u00b6 Type: string the namespace to limit permissions to. subjects Required \u00b6 Type: cdk8s-plus-21.ISubject a list of subjects to bind to. combine \u00b6 public combine ( rol : ClusterRole ) rol Required \u00b6 Type: cdk8s-plus-21.ClusterRole Static Functions \u00b6 fromClusterRoleName \u00b6 import { ClusterRole } from 'cdk8s-plus-21' ClusterRole . fromClusterRoleName ( name : string ) name Required \u00b6 Type: string The name of the role resource. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public readonly rules : ClusterRolePolicyRule []; Type: cdk8s-plus-21.ClusterRolePolicyRule [] Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import { ClusterRoleBinding } from 'cdk8s-plus-21' new ClusterRoleBinding ( scope : Construct , id : string , props : ClusterRoleBindingProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-21.ClusterRoleBindingProps Methods \u00b6 addSubjects \u00b6 public addSubjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-21.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public readonly role : IClusterRole ; Type: cdk8s-plus-21.IClusterRole subjects Required \u00b6 public readonly subjects : ISubject []; Type: cdk8s-plus-21.ISubject [] ConfigMap \u00b6 Implements: cdk8s-plus-21.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import { ConfigMap } from 'cdk8s-plus-21' new ConfigMap ( scope : Construct , id : string , props? : ConfigMapProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.ConfigMapProps Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addData \u00b6 public addData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addDirectory \u00b6 public addDirectory ( localDir : string , options? : AddDirectoryOptions ) localDir Required \u00b6 Type: string A path to a local directory. options Optional \u00b6 Type: cdk8s-plus-21.AddDirectoryOptions Options. addFile \u00b6 public addFile ( localFile : string , key? : string ) localFile Required \u00b6 Type: string The path to the local file. key Optional \u00b6 Type: string The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import { ConfigMap } from 'cdk8s-plus-21' ConfigMap . fromConfigMapName ( name : string ) name Required \u00b6 Type: string The name of the config map to import. Properties \u00b6 binaryData Required \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 public readonly immutable : boolean ; Type: boolean Whether or not this config map is immutable. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import { DaemonSet } from 'cdk8s-plus-21' new DaemonSet ( scope : Construct , id : string , props? : DaemonSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.DaemonSetProps Properties \u00b6 minReadySeconds Required \u00b6 public readonly minReadySeconds : number ; Type: number resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import { Deployment } from 'cdk8s-plus-21' new Deployment ( scope : Construct , id : string , props? : DeploymentProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.DeploymentProps Methods \u00b6 exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeDeploymentViaIngressOptions ) path Required \u00b6 Type: string The ingress path to register under. options Optional \u00b6 Type: cdk8s-plus-21.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService ( options? : ExposeDeploymentViaServiceOptions ) options Optional \u00b6 Type: cdk8s-plus-21.ExposeDeploymentViaServiceOptions Options to determine details of the service and port exposed. Properties \u00b6 minReady Required \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progressDeadline Required \u00b6 public readonly progressDeadline : Duration ; Type: cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public readonly strategy : DeploymentStrategy ; Type: cdk8s-plus-21.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import { DockerConfigSecret } from 'cdk8s-plus-21' new DockerConfigSecret ( scope : Construct , id : string , props : DockerConfigSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-21.DockerConfigSecretProps GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import { GCEPersistentDiskPersistentVolume } from 'cdk8s-plus-21' new GCEPersistentDiskPersistentVolume ( scope : Construct , id : string , props : GCEPersistentDiskPersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-21.GCEPersistentDiskPersistentVolumeProps Properties \u00b6 fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. pdName Required \u00b6 public readonly pdName : string ; Type: string PD resource in GCE of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. partition Optional \u00b6 public readonly partition : number ; Type: number Partition of this volume. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import { IngressV1Beta1 } from 'cdk8s-plus-21' new IngressV1Beta1 ( scope : Construct , id : string , props? : IngressV1Beta1Props ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.IngressV1Beta1Props Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( backend : IngressV1Beta1Backend ) backend Required \u00b6 Type: cdk8s-plus-21.IngressV1Beta1Backend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( host : string , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: string The host name to match. backend Required \u00b6 Type: cdk8s-plus-21.IngressV1Beta1Backend The backend to route to. addHostRule \u00b6 public addHostRule ( host : string , path : string , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: string The host name. path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-21.IngressV1Beta1Backend The backend to route requests to. addRule \u00b6 public addRule ( path : string , backend : IngressV1Beta1Backend ) path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-21.IngressV1Beta1Backend The backend to route requests to. addRules \u00b6 public addRules ( rules : IngressV1Beta1Rule ) rules Required \u00b6 Type: cdk8s-plus-21.IngressV1Beta1Rule The rules to add. addTls \u00b6 public addTls ( tls : IngressV1Beta1Tls []) tls Required \u00b6 Type: cdk8s-plus-21.IngressV1Beta1Tls [] Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import { Job } from 'cdk8s-plus-21' new Job ( scope : Construct , id : string , props? : JobProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.JobProps Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Number of retries before marking failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration TTL before the job is deleted after it is finished. PersistentVolume \u00b6 Implements: cdk8s-plus-21.IPersistentVolume , cdk8s-plus-21.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import { PersistentVolume } from 'cdk8s-plus-21' new PersistentVolume ( scope : Construct , id : string , props? : PersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.PersistentVolumeProps Methods \u00b6 asVolume \u00b6 public asVolume () bind \u00b6 public bind ( claim : IPersistentVolumeClaim ) claim Required \u00b6 Type: cdk8s-plus-21.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 public reserve () Static Functions \u00b6 fromPersistentVolumeName \u00b6 import { PersistentVolume } from 'cdk8s-plus-21' PersistentVolume . fromPersistentVolumeName ( volumeName : string ) volumeName Required \u00b6 Type: string The name of the pv to reference. Properties \u00b6 mode Required \u00b6 public readonly mode : PersistentVolumeMode ; Type: cdk8s-plus-21.PersistentVolumeMode Volume mode of this volume. reclaimPolicy Required \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-21.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-21.PersistentVolumeAccessMode [] Access modes requirement of this claim. claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-21.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Mount options of this volume. storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Storage size of this volume. storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: cdk8s-plus-21.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import { PersistentVolumeClaim } from 'cdk8s-plus-21' new PersistentVolumeClaim ( scope : Construct , id : string , props? : PersistentVolumeClaimProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.PersistentVolumeClaimProps Methods \u00b6 bind \u00b6 public bind ( vol : IPersistentVolume ) vol Required \u00b6 Type: cdk8s-plus-21.IPersistentVolume The PV to bind to. Static Functions \u00b6 fromClaimName \u00b6 import { PersistentVolumeClaim } from 'cdk8s-plus-21' PersistentVolumeClaim . fromClaimName ( claimName : string ) claimName Required \u00b6 Type: string The name of the pvc to reference. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. volumeMode Required \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-21.PersistentVolumeMode Volume mode requirement of this claim. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-21.PersistentVolumeAccessMode [] Access modes requirement of this claim. storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Storage requirement of this claim. storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Storage class requirment of this claim. volume Optional \u00b6 public readonly volume : IPersistentVolume ; Type: cdk8s-plus-21.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import { Pod } from 'cdk8s-plus-21' new Pod ( scope : Construct , id : string , props? : PodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.PodProps Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Resource \u00b6 Implements: cdk8s-plus-21.IResource , cdk8s-plus-21.IApiResource , cdk8s-plus-21.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import { Resource } from 'cdk8s-plus-21' new Resource ( scope : Construct , id : string , options? : ConstructOptions ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: string The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . options Optional \u00b6 Type: constructs.ConstructOptions Options. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 public readonly metadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public readonly name : string ; Type: string The name of this API object. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. resourceName Optional \u00b6 public readonly resourceName : string ; Type: string The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: cdk8s-plus-21.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import { Role } from 'cdk8s-plus-21' new Role ( scope : Construct , id : string , props? : RoleProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.RoleProps Methods \u00b6 allow \u00b6 public allow ( verbs : string [], resources : IApiResource ) verbs Required \u00b6 Type: string [] resources Required \u00b6 Type: cdk8s-plus-21.IApiResource The resource(s) to apply to. allowCreate \u00b6 public allowCreate ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-21.IApiResource The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-21.IApiResource The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-21.IApiResource The resource(s) to apply to. allowGet \u00b6 public allowGet ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-21.IApiResource The resource(s) to apply to. allowList \u00b6 public allowList ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-21.IApiResource The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-21.IApiResource The resource(s) to apply to. allowRead \u00b6 public allowRead ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-21.IApiResource The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-21.IApiResource The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-21.IApiResource The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-21.IApiResource The resource(s) to apply to. bind \u00b6 public bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-21.ISubject a list of subjects to bind to. Static Functions \u00b6 fromRoleName \u00b6 import { Role } from 'cdk8s-plus-21' Role . fromRoleName ( name : string ) name Required \u00b6 Type: string The name of the role resource. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public readonly rules : RolePolicyRule []; Type: cdk8s-plus-21.RolePolicyRule [] Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import { RoleBinding } from 'cdk8s-plus-21' new RoleBinding ( scope : Construct , id : string , props : RoleBindingProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-21.RoleBindingProps Methods \u00b6 addSubjects \u00b6 public addSubjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-21.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public readonly role : IRole ; Type: cdk8s-plus-21.IRole subjects Required \u00b6 public readonly subjects : ISubject []; Type: cdk8s-plus-21.ISubject [] Secret \u00b6 Implements: cdk8s-plus-21.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import { Secret } from 'cdk8s-plus-21' new Secret ( scope : Construct , id : string , props? : SecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.SecretProps Methods \u00b6 addStringData \u00b6 public addStringData ( key : string , value : string ) key Required \u00b6 Type: string Key. value Required \u00b6 Type: string Value. getStringData \u00b6 public getStringData ( key : string ) key Required \u00b6 Type: string Key. Static Functions \u00b6 fromSecretName \u00b6 import { Secret } from 'cdk8s-plus-21' Secret . fromSecretName ( name : string ) name Required \u00b6 Type: string The name of the secret to reference. Properties \u00b6 immutable Required \u00b6 public readonly immutable : boolean ; Type: boolean Whether or not the secret is immutable. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import { Service } from 'cdk8s-plus-21' new Service ( scope : Construct , id : string , props? : ServiceProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.ServiceProps Methods \u00b6 addDeployment \u00b6 public addDeployment ( depl : Deployment , options? : AddDeploymentOptions ) depl Required \u00b6 Type: cdk8s-plus-21.Deployment The deployment to expose. options Optional \u00b6 Type: cdk8s-plus-21.AddDeploymentOptions Optional settings for the port. addSelector \u00b6 public addSelector ( label : string , value : string ) label Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeServiceViaIngressOptions ) path Required \u00b6 Type: string The path to expose the service under. options Optional \u00b6 Type: cdk8s-plus-21.ExposeServiceViaIngressOptions Additional options. serve \u00b6 public serve ( port : number , options? : ServicePortOptions ) port Required \u00b6 Type: number The port definition. options Optional \u00b6 Type: cdk8s-plus-21.ServicePortOptions Properties \u00b6 ports Required \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-21.ServicePort [] Ports for this service. Use serve() to expose additional service ports. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. selector Required \u00b6 public readonly selector : {[ key : string ] : string }; Type: {[ key: string ]: string } Returns the labels which are used to select pods for this service. type Required \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-21.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public readonly externalName : string ; Type: string The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s-plus-21.IServiceAccount , cdk8s-plus-21.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import { ServiceAccount } from 'cdk8s-plus-21' new ServiceAccount ( scope : Construct , id : string , props? : ServiceAccountProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.ServiceAccountProps Methods \u00b6 addSecret \u00b6 public addSecret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s-plus-21.ISecret The secret. Static Functions \u00b6 fromServiceAccountName \u00b6 import { ServiceAccount } from 'cdk8s-plus-21' ServiceAccount . fromServiceAccountName ( name : string ) name Required \u00b6 Type: string The name of the service account resource. Properties \u00b6 automountToken Required \u00b6 public readonly automountToken : boolean ; Type: boolean Whether or not a token is automatically mounted for this service account. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-21.ISecret [] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import { ServiceAccountTokenSecret } from 'cdk8s-plus-21' new ServiceAccountTokenSecret ( scope : Construct , id : string , props : ServiceAccountTokenSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-21.ServiceAccountTokenSecretProps SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import { SshAuthSecret } from 'cdk8s-plus-21' new SshAuthSecret ( scope : Construct , id : string , props : SshAuthSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-21.SshAuthSecretProps StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import { StatefulSet } from 'cdk8s-plus-21' new StatefulSet ( scope : Construct , id : string , props : StatefulSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-21.StatefulSetProps Properties \u00b6 podManagementPolicy Required \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-21.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public readonly strategy : StatefulSetUpdateStrategy ; Type: cdk8s-plus-21.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import { TlsSecret } from 'cdk8s-plus-21' new TlsSecret ( scope : Construct , id : string , props : TlsSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-21.TlsSecretProps Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import { Workload } from 'cdk8s-plus-21' new Workload ( scope : Construct , id : string , props? : WorkloadProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.WorkloadProps Methods \u00b6 select \u00b6 public select ( selectors : LabelSelector ) selectors Required \u00b6 Type: cdk8s-plus-21.LabelSelector Properties \u00b6 matchExpressions Required \u00b6 public readonly matchExpressions : LabelSelectorRequirement []; Type: cdk8s-plus-21.LabelSelectorRequirement [] The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. matchLabels Required \u00b6 public readonly matchLabels : {[ key : string ] : string }; Type: {[ key: string ]: string } The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import { AbstractPodProps } from 'cdk8s-plus-21' const abstractPodProps : AbstractPodProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-21.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import { AddDeploymentOptions } from 'cdk8s-plus-21' const addDeploymentOptions : AddDeploymentOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import { AddDirectoryOptions } from 'cdk8s-plus-21' const addDirectoryOptions : AddDirectoryOptions = { ... } exclude Optional \u00b6 public readonly exclude : string []; Type: string [] Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public readonly keyPrefix : string ; Type: string Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import { ApiResourceOptions } from 'cdk8s-plus-21' const apiResourceOptions : ApiResourceOptions = { ... } apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import { AwsElasticBlockStorePersistentVolumeProps } from 'cdk8s-plus-21' const awsElasticBlockStorePersistentVolumeProps : AwsElasticBlockStorePersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-21.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 public readonly volumeId : string ; Type: string Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import { AwsElasticBlockStoreVolumeOptions } from 'cdk8s-plus-21' const awsElasticBlockStoreVolumeOptions : AwsElasticBlockStoreVolumeOptions = { ... } fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import { AzureDiskPersistentVolumeProps } from 'cdk8s-plus-21' const azureDiskPersistentVolumeProps : AzureDiskPersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-21.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 public readonly diskName : string ; Type: string The Name of the data disk in the blob storage. diskUri Required \u00b6 public readonly diskUri : string ; Type: string The URI the data disk in the blob storage. cachingMode Optional \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-21.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public readonly kind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-21.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import { AzureDiskVolumeOptions } from 'cdk8s-plus-21' const azureDiskVolumeOptions : AzureDiskVolumeOptions = { ... } cachingMode Optional \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-21.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public readonly kind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-21.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import { BasicAuthSecretProps } from 'cdk8s-plus-21' const basicAuthSecretProps : BasicAuthSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 public readonly password : string ; Type: string The password or token for authentication. username Required \u00b6 public readonly username : string ; Type: string The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import { ClusterRoleBindingProps } from 'cdk8s-plus-21' const clusterRoleBindingProps : ClusterRoleBindingProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public readonly role : IClusterRole ; Type: cdk8s-plus-21.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import { ClusterRolePolicyRule } from 'cdk8s-plus-21' const clusterRolePolicyRule : ClusterRolePolicyRule = { ... } endpoints Required \u00b6 public readonly endpoints : IApiEndpoint []; Type: cdk8s-plus-21.IApiEndpoint [] Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 public readonly verbs : string []; Type: string [] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import { ClusterRoleProps } from 'cdk8s-plus-21' const clusterRoleProps : ClusterRoleProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 public readonly aggregationLabels : {[ key : string ] : string }; Type: {[ key: string ]: string } Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 public readonly rules : ClusterRolePolicyRule []; Type: cdk8s-plus-21.ClusterRolePolicyRule [] Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import { CommandProbeOptions } from 'cdk8s-plus-21' const commandProbeOptions : CommandProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import { CommonSecretProps } from 'cdk8s-plus-21' const commonSecretProps : CommonSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import { ConfigMapProps } from 'cdk8s-plus-21' const configMapProps : ConfigMapProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import { ConfigMapVolumeOptions } from 'cdk8s-plus-21' const configMapVolumeOptions : ConfigMapVolumeOptions = { ... } defaultMode Optional \u00b6 public readonly defaultMode : number ; Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public readonly items : {[ key : string ] : PathMapping }; Type: {[ key: string ]: cdk8s-plus-21.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import { ContainerLifecycle } from 'cdk8s-plus-21' const containerLifecycle : ContainerLifecycle = { ... } postStart Optional \u00b6 public readonly postStart : Handler ; Type: cdk8s-plus-21.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. preStop Optional \u00b6 public readonly preStop : Handler ; Type: cdk8s-plus-21.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import { ContainerProps } from 'cdk8s-plus-21' const containerProps : ContainerProps = { ... } image Required \u00b6 public readonly image : string ; Type: string Docker image name. args Optional \u00b6 public readonly args : string []; Type: string [] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public readonly command : string []; Type: string [] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 public readonly env : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-21.EnvValue } Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 public readonly lifecycle : ContainerLifecycle ; Type: cdk8s-plus-21.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 public readonly liveness : Probe ; Type: cdk8s-plus-21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public readonly name : string ; Type: string Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 public readonly port : number ; Type: number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 public readonly readiness : Probe ; Type: cdk8s-plus-21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 public readonly resources : ContainerResources ; Type: cdk8s-plus-21.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 public readonly securityContext : ContainerSecurityContextProps ; Type: cdk8s-plus-21.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 public readonly startup : Probe ; Type: cdk8s-plus-21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public readonly volumeMounts : VolumeMount []; Type: cdk8s-plus-21.VolumeMount [] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public readonly workingDir : string ; Type: string Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import { ContainerResources } from 'cdk8s-plus-21' const containerResources : ContainerResources = { ... } cpu Required \u00b6 public readonly cpu : CpuResources ; Type: cdk8s-plus-21.CpuResources memory Required \u00b6 public readonly memory : MemoryResources ; Type: cdk8s-plus-21.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import { ContainerSecurityContextProps } from 'cdk8s-plus-21' const containerSecurityContextProps : ContainerSecurityContextProps = { ... } ensureNonRoot Optional \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 public readonly group : number ; Type: number Default: Group configured by container runtime The GID to run the entrypoint of the container process. privileged Optional \u00b6 public readonly privileged : boolean ; Type: boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 public readonly readOnlyRootFilesystem : boolean ; Type: boolean Default: false Whether this container has a read-only root filesystem. user Optional \u00b6 public readonly user : number ; Type: number Default: User specified in image metadata The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import { CpuResources } from 'cdk8s-plus-21' const cpuResources : CpuResources = { ... } limit Required \u00b6 public readonly limit : Cpu ; Type: cdk8s-plus-21.Cpu request Required \u00b6 public readonly request : Cpu ; Type: cdk8s-plus-21.Cpu DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import { DaemonSetProps } from 'cdk8s-plus-21' const daemonSetProps : DaemonSetProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-21.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReadySeconds Optional \u00b6 public readonly minReadySeconds : number ; Type: number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import { DeploymentProps } from 'cdk8s-plus-21' const deploymentProps : DeploymentProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-21.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReady Optional \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 public readonly progressDeadline : Duration ; Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. strategy Optional \u00b6 public readonly strategy : DeploymentStrategy ; Type: cdk8s-plus-21.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import { DeploymentStrategyRollingUpdateOptions } from 'cdk8s-plus-21' const deploymentStrategyRollingUpdateOptions : DeploymentStrategyRollingUpdateOptions = { ... } maxSurge Optional \u00b6 public readonly maxSurge : PercentOrAbsolute ; Type: cdk8s-plus-21.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. maxUnavailable Optional \u00b6 public readonly maxUnavailable : PercentOrAbsolute ; Type: cdk8s-plus-21.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import { DnsOption } from 'cdk8s-plus-21' const dnsOption : DnsOption = { ... } name Required \u00b6 public readonly name : string ; Type: string Option name. value Optional \u00b6 public readonly value : string ; Type: string Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import { DockerConfigSecretProps } from 'cdk8s-plus-21' const dockerConfigSecretProps : DockerConfigSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 public readonly data : {[ key : string ] : any }; Type: {[ key: string ]: any } JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import { EmptyDirVolumeOptions } from 'cdk8s-plus-21' const emptyDirVolumeOptions : EmptyDirVolumeOptions = { ... } medium Optional \u00b6 public readonly medium : EmptyDirMedium ; Type: cdk8s-plus-21.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public readonly sizeLimit : Size ; Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import { EnvValueFromConfigMapOptions } from 'cdk8s-plus-21' const envValueFromConfigMapOptions : EnvValueFromConfigMapOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import { EnvValueFromFieldRefOptions } from 'cdk8s-plus-21' const envValueFromFieldRefOptions : EnvValueFromFieldRefOptions = { ... } apiVersion Optional \u00b6 public readonly apiVersion : string ; Type: string Version of the schema the FieldPath is written in terms of. key Optional \u00b6 public readonly key : string ; Type: string The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import { EnvValueFromProcessOptions } from 'cdk8s-plus-21' const envValueFromProcessOptions : EnvValueFromProcessOptions = { ... } required Optional \u00b6 public readonly required : boolean ; Type: boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import { EnvValueFromResourceOptions } from 'cdk8s-plus-21' const envValueFromResourceOptions : EnvValueFromResourceOptions = { ... } container Optional \u00b6 public readonly container : Container ; Type: cdk8s-plus-21.Container The container to select the value from. divisor Optional \u00b6 public readonly divisor : string ; Type: string The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import { EnvValueFromSecretOptions } from 'cdk8s-plus-21' const envValueFromSecretOptions : EnvValueFromSecretOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import { ExposeDeploymentViaIngressOptions } from 'cdk8s-plus-21' const exposeDeploymentViaIngressOptions : ExposeDeploymentViaIngressOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-21.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 public readonly ingress : IngressV1Beta1 ; Type: cdk8s-plus-21.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import { ExposeDeploymentViaServiceOptions } from 'cdk8s-plus-21' const exposeDeploymentViaServiceOptions : ExposeDeploymentViaServiceOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-21.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import { ExposeServiceViaIngressOptions } from 'cdk8s-plus-21' const exposeServiceViaIngressOptions : ExposeServiceViaIngressOptions = { ... } ingress Optional \u00b6 public readonly ingress : IngressV1Beta1 ; Type: cdk8s-plus-21.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import { GCEPersistentDiskPersistentVolumeProps } from 'cdk8s-plus-21' const gCEPersistentDiskPersistentVolumeProps : GCEPersistentDiskPersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-21.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 public readonly pdName : string ; Type: string Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import { GCEPersistentDiskVolumeOptions } from 'cdk8s-plus-21' const gCEPersistentDiskVolumeOptions : GCEPersistentDiskVolumeOptions = { ... } fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GroupProps \u00b6 Properties for Group . Initializer \u00b6 import { GroupProps } from 'cdk8s-plus-21' const groupProps : GroupProps = { ... } name Required \u00b6 public readonly name : string ; Type: string The name of the group. HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import { HandlerFromHttpGetOptions } from 'cdk8s-plus-21' const handlerFromHttpGetOptions : HandlerFromHttpGetOptions = { ... } port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import { HandlerFromTcpSocketOptions } from 'cdk8s-plus-21' const handlerFromTcpSocketOptions : HandlerFromTcpSocketOptions = { ... } host Optional \u00b6 public readonly host : string ; Type: string Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import { HostAlias } from 'cdk8s-plus-21' const hostAlias : HostAlias = { ... } hostnames Required \u00b6 public readonly hostnames : string []; Type: string [] Hostnames for the chosen IP address. ip Required \u00b6 public readonly ip : string ; Type: string IP address of the host file entry. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import { HttpGetProbeOptions } from 'cdk8s-plus-21' const httpGetProbeOptions : HttpGetProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import { IngressV1Beta1Props } from 'cdk8s-plus-21' const ingressV1Beta1Props : IngressV1Beta1Props = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public readonly defaultBackend : IngressV1Beta1Backend ; Type: cdk8s-plus-21.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public readonly rules : IngressV1Beta1Rule []; Type: cdk8s-plus-21.IngressV1Beta1Rule [] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public readonly tls : IngressV1Beta1Tls []; Type: cdk8s-plus-21.IngressV1Beta1Tls [] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import { IngressV1Beta1Rule } from 'cdk8s-plus-21' const ingressV1Beta1Rule : IngressV1Beta1Rule = { ... } backend Required \u00b6 public readonly backend : IngressV1Beta1Backend ; Type: cdk8s-plus-21.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public readonly host : string ; Type: string Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public readonly path : string ; Type: string Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import { IngressV1Beta1Tls } from 'cdk8s-plus-21' const ingressV1Beta1Tls : IngressV1Beta1Tls = { ... } hosts Optional \u00b6 public readonly hosts : string []; Type: string [] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-21.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import { JobProps } from 'cdk8s-plus-21' const jobProps : JobProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-21.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import { LabelSelectorRequirement } from 'cdk8s-plus-21' const labelSelectorRequirement : LabelSelectorRequirement = { ... } key Required \u00b6 public readonly key : string ; Type: string The label key that the selector applies to. operator Required \u00b6 public readonly operator : LabelSelectorRequirementOperator ; Type: cdk8s-plus-21.LabelSelectorRequirementOperator Represents a key\u2019s relationship to a set of values. values Optional \u00b6 public readonly values : string []; Type: string [] An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import { MemoryResources } from 'cdk8s-plus-21' const memoryResources : MemoryResources = { ... } limit Required \u00b6 public readonly limit : Size ; Type: cdk8s.Size request Required \u00b6 public readonly request : Size ; Type: cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import { MountOptions } from 'cdk8s-plus-21' const mountOptions : MountOptions = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-21.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import { PathMapping } from 'cdk8s-plus-21' const pathMapping : PathMapping = { ... } path Required \u00b6 public readonly path : string ; Type: string The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public readonly mode : number ; Type: number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import { PersistentVolumeClaimProps } from 'cdk8s-plus-21' const persistentVolumeClaimProps : PersistentVolumeClaimProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-21.PersistentVolumeAccessMode [] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. - If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 public readonly volume : IPersistentVolume ; Type: cdk8s-plus-21.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import { PersistentVolumeClaimVolumeOptions } from 'cdk8s-plus-21' const persistentVolumeClaimVolumeOptions : PersistentVolumeClaimVolumeOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: Derived from the PVC name. The volume name. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import { PersistentVolumeProps } from 'cdk8s-plus-21' const persistentVolumeProps : PersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-21.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-21.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-21.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-21.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import { PodDnsProps } from 'cdk8s-plus-21' const podDnsProps : PodDnsProps = { ... } hostname Optional \u00b6 public readonly hostname : string ; Type: string Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 public readonly hostnameAsFQDN : boolean ; Type: boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 public readonly nameservers : string []; Type: string [] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 public readonly options : DnsOption []; Type: cdk8s-plus-21.DnsOption [] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 public readonly policy : DnsPolicy ; Type: cdk8s-plus-21.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 public readonly searches : string []; Type: string [] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 public readonly subdomain : string ; Type: string Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import { PodProps } from 'cdk8s-plus-21' const podProps : PodProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-21.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import { PodSecurityContextProps } from 'cdk8s-plus-21' const podSecurityContextProps : PodSecurityContextProps = { ... } ensureNonRoot Optional \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 public readonly fsGroup : number ; Type: number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 public readonly fsGroupChangePolicy : FsGroupChangePolicy ; Type: cdk8s-plus-21.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 public readonly group : number ; Type: number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 public readonly sysctls : Sysctl []; Type: cdk8s-plus-21.Sysctl [] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 public readonly user : number ; Type: number Default: User specified in image metadata The UID to run the entrypoint of the container process. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import { ProbeOptions } from 'cdk8s-plus-21' const probeOptions : ProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import { ResourceProps } from 'cdk8s-plus-21' const resourceProps : ResourceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import { RoleBindingProps } from 'cdk8s-plus-21' const roleBindingProps : RoleBindingProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public readonly role : IRole ; Type: cdk8s-plus-21.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import { RolePolicyRule } from 'cdk8s-plus-21' const rolePolicyRule : RolePolicyRule = { ... } resources Required \u00b6 public readonly resources : IApiResource []; Type: cdk8s-plus-21.IApiResource [] Resources this rule applies to. verbs Required \u00b6 public readonly verbs : string []; Type: string [] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import { RoleProps } from 'cdk8s-plus-21' const roleProps : RoleProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 public readonly rules : RolePolicyRule []; Type: cdk8s-plus-21.RolePolicyRule [] Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import { SecretProps } from 'cdk8s-plus-21' const secretProps : SecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 public readonly stringData : {[ key : string ] : string }; Type: {[ key: string ]: string } stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public readonly type : string ; Type: string Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import { SecretValue } from 'cdk8s-plus-21' const secretValue : SecretValue = { ... } key Required \u00b6 public readonly key : string ; Type: string The JSON key. secret Required \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-21.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import { SecretVolumeOptions } from 'cdk8s-plus-21' const secretVolumeOptions : SecretVolumeOptions = { ... } defaultMode Optional \u00b6 public readonly defaultMode : number ; Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public readonly items : {[ key : string ] : PathMapping }; Type: {[ key: string ]: cdk8s-plus-21.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import { ServiceAccountProps } from 'cdk8s-plus-21' const serviceAccountProps : ServiceAccountProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 public readonly automountToken : boolean ; Type: boolean Default: true Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-21.ISecret [] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import { ServiceAccountTokenSecretProps } from 'cdk8s-plus-21' const serviceAccountTokenSecretProps : ServiceAccountTokenSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount The service account to store a secret for. ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import { ServiceIngressV1BetaBackendOptions } from 'cdk8s-plus-21' const serviceIngressV1BetaBackendOptions : ServiceIngressV1BetaBackendOptions = { ... } port Optional \u00b6 public readonly port : number ; Type: number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import { ServicePort } from 'cdk8s-plus-21' const servicePort : ServicePort = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public readonly port : number ; Type: number The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import { ServicePortOptions } from 'cdk8s-plus-21' const servicePortOptions : ServicePortOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import { ServiceProps } from 'cdk8s-plus-21' const serviceProps : ServiceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public readonly externalIPs : string []; Type: string [] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public readonly externalName : string ; Type: string Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public readonly loadBalancerSourceRanges : string []; Type: string [] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-21.ServicePort [] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-21.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import { SshAuthSecretProps } from 'cdk8s-plus-21' const sshAuthSecretProps : SshAuthSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 public readonly sshPrivateKey : string ; Type: string The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import { StatefulSetProps } from 'cdk8s-plus-21' const statefulSetProps : StatefulSetProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-21.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. service Required \u00b6 public readonly service : Service ; Type: cdk8s-plus-21.Service Service to associate with the statefulset. podManagementPolicy Optional \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-21.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. strategy Optional \u00b6 public readonly strategy : StatefulSetUpdateStrategy ; Type: cdk8s-plus-21.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import { StatefulSetUpdateStrategyRollingUpdateOptions } from 'cdk8s-plus-21' const statefulSetUpdateStrategyRollingUpdateOptions : StatefulSetUpdateStrategyRollingUpdateOptions = { ... } partition Optional \u00b6 public readonly partition : number ; Type: number Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import { Sysctl } from 'cdk8s-plus-21' const sysctl : Sysctl = { ... } name Required \u00b6 public readonly name : string ; Type: string Name of a property to set. value Required \u00b6 public readonly value : string ; Type: string Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import { TcpSocketProbeOptions } from 'cdk8s-plus-21' const tcpSocketProbeOptions : TcpSocketProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 public readonly host : string ; Type: string Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import { TlsSecretProps } from 'cdk8s-plus-21' const tlsSecretProps : TlsSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 public readonly tlsCert : string ; Type: string The TLS cert. tlsKey Required \u00b6 public readonly tlsKey : string ; Type: string The TLS key. UserProps \u00b6 Properties for User . Initializer \u00b6 import { UserProps } from 'cdk8s-plus-21' const userProps : UserProps = { ... } name Required \u00b6 public readonly name : string ; Type: string The name of the user. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import { VolumeMount } from 'cdk8s-plus-21' const volumeMount : VolumeMount = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-21.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 public readonly path : string ; Type: string Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public readonly volume : Volume ; Type: cdk8s-plus-21.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import { WorkloadProps } from 'cdk8s-plus-21' const workloadProps : WorkloadProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-21.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-21.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-21.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-21.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. Classes \u00b6 ApiResource \u00b6 Implements: cdk8s-plus-21.IApiResource , cdk8s-plus-21.IApiEndpoint Represents information about an API resource type. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 custom \u00b6 import { ApiResource } from 'cdk8s-plus-21' ApiResource . custom ( options : ApiResourceOptions ) options Required \u00b6 Type: cdk8s-plus-21.ApiResourceOptions Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for Ingress. JOBS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for Job. LEASES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: cdk8s-plus-21.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import { Container } from 'cdk8s-plus-21' new Container ( props : ContainerProps ) props Required \u00b6 Type: cdk8s-plus-21.ContainerProps Methods \u00b6 addEnv \u00b6 public addEnv ( name : string , value : EnvValue ) name Required \u00b6 Type: string The variable name. value Required \u00b6 Type: cdk8s-plus-21.EnvValue The variable value. mount \u00b6 public mount ( path : string , storage : IStorage , options? : MountOptions ) path Required \u00b6 Type: string The desired path in the container. storage Required \u00b6 Type: cdk8s-plus-21.IStorage The storage to mount. options Optional \u00b6 Type: cdk8s-plus-21.MountOptions Properties \u00b6 env Required \u00b6 public readonly env : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-21.EnvValue } The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 public readonly image : string ; Type: string The container image. imagePullPolicy Required \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-21.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public readonly mounts : VolumeMount []; Type: cdk8s-plus-21.VolumeMount [] Volume mounts configured for this container. name Required \u00b6 public readonly name : string ; Type: string The name of the container. securityContext Required \u00b6 public readonly securityContext : ContainerSecurityContext ; Type: cdk8s-plus-21.ContainerSecurityContext The security context of the container. args Optional \u00b6 public readonly args : string []; Type: string [] Arguments to the entrypoint. command Optional \u00b6 public readonly command : string []; Type: string [] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 public readonly port : number ; Type: number The port this container exposes. resources Optional \u00b6 public readonly resources : ContainerResources ; Type: cdk8s-plus-21.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ workingDir Optional \u00b6 public readonly workingDir : string ; Type: string The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import { ContainerSecurityContext } from 'cdk8s-plus-21' new ContainerSecurityContext ( props? : ContainerSecurityContextProps ) props Optional \u00b6 Type: cdk8s-plus-21.ContainerSecurityContextProps Properties \u00b6 ensureNonRoot Required \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean privileged Required \u00b6 public readonly privileged : boolean ; Type: boolean readOnlyRootFilesystem Required \u00b6 public readonly readOnlyRootFilesystem : boolean ; Type: boolean group Optional \u00b6 public readonly group : number ; Type: number user Optional \u00b6 public readonly user : number ; Type: number Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import { Cpu } from 'cdk8s-plus-21' Cpu . millis ( amount : number ) amount Required \u00b6 Type: number units \u00b6 import { Cpu } from 'cdk8s-plus-21' Cpu . units ( amount : number ) amount Required \u00b6 Type: number Properties \u00b6 amount Required \u00b6 public readonly amount : string ; Type: string DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import { DeploymentStrategy } from 'cdk8s-plus-21' DeploymentStrategy . recreate () rollingUpdate \u00b6 import { DeploymentStrategy } from 'cdk8s-plus-21' DeploymentStrategy . rollingUpdate ( options? : DeploymentStrategyRollingUpdateOptions ) options Optional \u00b6 Type: cdk8s-plus-21.DeploymentStrategyRollingUpdateOptions EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import { EnvValue } from 'cdk8s-plus-21' EnvValue . fromConfigMap ( configMap : IConfigMap , key : string , options? : EnvValueFromConfigMapOptions ) configMap Required \u00b6 Type: cdk8s-plus-21.IConfigMap The config map. key Required \u00b6 Type: string The key to extract the value from. options Optional \u00b6 Type: cdk8s-plus-21.EnvValueFromConfigMapOptions Additional options. fromFieldRef \u00b6 import { EnvValue } from 'cdk8s-plus-21' EnvValue . fromFieldRef ( fieldPath : EnvFieldPaths , options? : EnvValueFromFieldRefOptions ) fieldPath Required \u00b6 Type: cdk8s-plus-21.EnvFieldPaths : The field reference. options Optional \u00b6 Type: cdk8s-plus-21.EnvValueFromFieldRefOptions : Additional options. fromProcess \u00b6 import { EnvValue } from 'cdk8s-plus-21' EnvValue . fromProcess ( key : string , options? : EnvValueFromProcessOptions ) key Required \u00b6 Type: string The key to read. options Optional \u00b6 Type: cdk8s-plus-21.EnvValueFromProcessOptions Additional options. fromResource \u00b6 import { EnvValue } from 'cdk8s-plus-21' EnvValue . fromResource ( resource : ResourceFieldPaths , options? : EnvValueFromResourceOptions ) resource Required \u00b6 Type: cdk8s-plus-21.ResourceFieldPaths : Resource to select the value from. options Optional \u00b6 Type: cdk8s-plus-21.EnvValueFromResourceOptions : Additional options. fromSecretValue \u00b6 import { EnvValue } from 'cdk8s-plus-21' EnvValue . fromSecretValue ( secretValue : SecretValue , options? : EnvValueFromSecretOptions ) secretValue Required \u00b6 Type: cdk8s-plus-21.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: cdk8s-plus-21.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import { EnvValue } from 'cdk8s-plus-21' EnvValue . fromValue ( value : string ) value Required \u00b6 Type: string The value. Properties \u00b6 value Optional \u00b6 public readonly value : any ; Type: any valueFrom Optional \u00b6 public readonly valueFrom : any ; Type: any Group \u00b6 Implements: cdk8s-plus-21.ISubject Represents a group. Initializers \u00b6 import { Group } from 'cdk8s-plus-21' new Group ( props : GroupProps ) props Required \u00b6 Type: cdk8s-plus-21.GroupProps Properties \u00b6 kind Required \u00b6 public readonly kind : string ; Type: string Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public readonly name : string ; Type: string Name of the object being referenced. apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 fromCommand \u00b6 import { Handler } from 'cdk8s-plus-21' Handler . fromCommand ( command : string []) command Required \u00b6 Type: string [] The command to execute. fromHttpGet \u00b6 import { Handler } from 'cdk8s-plus-21' Handler . fromHttpGet ( path : string , options? : HandlerFromHttpGetOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-21.HandlerFromHttpGetOptions Options. fromTcpSocket \u00b6 import { Handler } from 'cdk8s-plus-21' Handler . fromTcpSocket ( options? : HandlerFromTcpSocketOptions ) options Optional \u00b6 Type: cdk8s-plus-21.HandlerFromTcpSocketOptions Options. IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromService \u00b6 import { IngressV1Beta1Backend } from 'cdk8s-plus-21' IngressV1Beta1Backend . fromService ( serv : Service , options? : ServiceIngressV1BetaBackendOptions ) serv Required \u00b6 Type: cdk8s-plus-21.Service The service object. options Optional \u00b6 Type: cdk8s-plus-21.ServiceIngressV1BetaBackendOptions LabelSelector \u00b6 A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors Static Functions \u00b6 doesNotExist \u00b6 import { LabelSelector } from 'cdk8s-plus-21' LabelSelector . doesNotExist ( key : string ) key Required \u00b6 Type: string exists \u00b6 import { LabelSelector } from 'cdk8s-plus-21' LabelSelector . exists ( key : string ) key Required \u00b6 Type: string in \u00b6 import { LabelSelector } from 'cdk8s-plus-21' LabelSelector . in ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] is \u00b6 import { LabelSelector } from 'cdk8s-plus-21' LabelSelector . is ( key : string , value : string , applyToTemplate? : boolean ) key Required \u00b6 Type: string value Required \u00b6 Type: string applyToTemplate Optional \u00b6 Type: boolean notIn \u00b6 import { LabelSelector } from 'cdk8s-plus-21' LabelSelector . notIn ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] Properties \u00b6 applyToTemplate Required \u00b6 public readonly applyToTemplate : boolean ; Type: boolean key Required \u00b6 public readonly key : string ; Type: string operator Optional \u00b6 public readonly operator : LabelSelectorRequirementOperator ; Type: cdk8s-plus-21.LabelSelectorRequirementOperator values Optional \u00b6 public readonly values : string []; Type: string [] NonApiResource \u00b6 Implements: cdk8s-plus-21.IApiEndpoint Factory for creating non api resources. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 of \u00b6 import { NonApiResource } from 'cdk8s-plus-21' NonApiResource . of ( url : string ) url Required \u00b6 Type: string PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 isZero \u00b6 public isZero () Static Functions \u00b6 absolute \u00b6 import { PercentOrAbsolute } from 'cdk8s-plus-21' PercentOrAbsolute . absolute ( num : number ) num Required \u00b6 Type: number percent \u00b6 import { PercentOrAbsolute } from 'cdk8s-plus-21' PercentOrAbsolute . percent ( percent : number ) percent Required \u00b6 Type: number Properties \u00b6 value Required \u00b6 public readonly value : any ; Type: any PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import { PodDns } from 'cdk8s-plus-21' new PodDns ( props? : PodDnsProps ) props Optional \u00b6 Type: cdk8s-plus-21.PodDnsProps Methods \u00b6 addNameserver \u00b6 public addNameserver ( nameservers : string ) nameservers Required \u00b6 Type: string addOption \u00b6 public addOption ( options : DnsOption ) options Required \u00b6 Type: cdk8s-plus-21.DnsOption addSearch \u00b6 public addSearch ( searches : string ) searches Required \u00b6 Type: string Properties \u00b6 hostnameAsFQDN Required \u00b6 public readonly hostnameAsFQDN : boolean ; Type: boolean Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 public readonly nameservers : string []; Type: string [] Nameservers defined for this pod. options Required \u00b6 public readonly options : DnsOption []; Type: cdk8s-plus-21.DnsOption [] Custom dns options defined for this pod. policy Required \u00b6 public readonly policy : DnsPolicy ; Type: cdk8s-plus-21.DnsPolicy The DNS policy of this pod. searches Required \u00b6 public readonly searches : string []; Type: string [] Search domains defined for this pod. hostname Optional \u00b6 public readonly hostname : string ; Type: string The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 public readonly subdomain : string ; Type: string The configured subdomain of the pod. PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import { PodSecurityContext } from 'cdk8s-plus-21' new PodSecurityContext ( props? : PodSecurityContextProps ) props Optional \u00b6 Type: cdk8s-plus-21.PodSecurityContextProps Properties \u00b6 ensureNonRoot Required \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean fsGroupChangePolicy Required \u00b6 public readonly fsGroupChangePolicy : FsGroupChangePolicy ; Type: cdk8s-plus-21.FsGroupChangePolicy sysctls Required \u00b6 public readonly sysctls : Sysctl []; Type: cdk8s-plus-21.Sysctl [] fsGroup Optional \u00b6 public readonly fsGroup : number ; Type: number group Optional \u00b6 public readonly group : number ; Type: number user Optional \u00b6 public readonly user : number ; Type: number Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 fromCommand \u00b6 import { Probe } from 'cdk8s-plus-21' Probe . fromCommand ( command : string [], options? : CommandProbeOptions ) command Required \u00b6 Type: string [] The command to execute. options Optional \u00b6 Type: cdk8s-plus-21.CommandProbeOptions Options. fromHttpGet \u00b6 import { Probe } from 'cdk8s-plus-21' Probe . fromHttpGet ( path : string , options? : HttpGetProbeOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-21.HttpGetProbeOptions Options. fromTcpSocket \u00b6 import { Probe } from 'cdk8s-plus-21' Probe . fromTcpSocket ( options? : TcpSocketProbeOptions ) options Optional \u00b6 Type: cdk8s-plus-21.TcpSocketProbeOptions Options. StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 onDelete \u00b6 import { StatefulSetUpdateStrategy } from 'cdk8s-plus-21' StatefulSetUpdateStrategy . onDelete () rollingUpdate \u00b6 import { StatefulSetUpdateStrategy } from 'cdk8s-plus-21' StatefulSetUpdateStrategy . rollingUpdate ( options? : StatefulSetUpdateStrategyRollingUpdateOptions ) options Optional \u00b6 Type: cdk8s-plus-21.StatefulSetUpdateStrategyRollingUpdateOptions User \u00b6 Implements: cdk8s-plus-21.ISubject Represents a user. Initializers \u00b6 import { User } from 'cdk8s-plus-21' new User ( props : UserProps ) props Required \u00b6 Type: cdk8s-plus-21.UserProps Properties \u00b6 kind Required \u00b6 public readonly kind : string ; Type: string Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public readonly name : string ; Type: string Name of the object being referenced. apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Volume \u00b6 Implements: cdk8s-plus-21.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 asVolume \u00b6 public asVolume () Static Functions \u00b6 fromAwsElasticBlockStore \u00b6 import { Volume } from 'cdk8s-plus-21' Volume . fromAwsElasticBlockStore ( volumeId : string , options? : AwsElasticBlockStoreVolumeOptions ) volumeId Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-21.AwsElasticBlockStoreVolumeOptions fromAzureDisk \u00b6 import { Volume } from 'cdk8s-plus-21' Volume . fromAzureDisk ( diskName : string , diskUri : string , options? : AzureDiskVolumeOptions ) diskName Required \u00b6 Type: string diskUri Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-21.AzureDiskVolumeOptions fromConfigMap \u00b6 import { Volume } from 'cdk8s-plus-21' Volume . fromConfigMap ( configMap : IConfigMap , options? : ConfigMapVolumeOptions ) configMap Required \u00b6 Type: cdk8s-plus-21.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-21.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import { Volume } from 'cdk8s-plus-21' Volume . fromEmptyDir ( name : string , options? : EmptyDirVolumeOptions ) name Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-21.EmptyDirVolumeOptions Additional options. fromGcePersistentDisk \u00b6 import { Volume } from 'cdk8s-plus-21' Volume . fromGcePersistentDisk ( pdName : string , options? : GCEPersistentDiskVolumeOptions ) pdName Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-21.GCEPersistentDiskVolumeOptions fromPersistentVolumeClaim \u00b6 import { Volume } from 'cdk8s-plus-21' Volume . fromPersistentVolumeClaim ( claim : IPersistentVolumeClaim , options? : PersistentVolumeClaimVolumeOptions ) claim Required \u00b6 Type: cdk8s-plus-21.IPersistentVolumeClaim options Optional \u00b6 Type: cdk8s-plus-21.PersistentVolumeClaimVolumeOptions fromSecret \u00b6 import { Volume } from 'cdk8s-plus-21' Volume . fromSecret ( secr : ISecret , options? : SecretVolumeOptions ) secr Required \u00b6 Type: cdk8s-plus-21.ISecret The secret to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-21.SecretVolumeOptions Options. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: cdk8s-plus-21.AbstractPod , cdk8s-plus-21.ApiResource , cdk8s-plus-21.AwsElasticBlockStorePersistentVolume , cdk8s-plus-21.AzureDiskPersistentVolume , cdk8s-plus-21.BasicAuthSecret , cdk8s-plus-21.ClusterRole , cdk8s-plus-21.ClusterRoleBinding , cdk8s-plus-21.ConfigMap , cdk8s-plus-21.DaemonSet , cdk8s-plus-21.Deployment , cdk8s-plus-21.DockerConfigSecret , cdk8s-plus-21.GCEPersistentDiskPersistentVolume , cdk8s-plus-21.IngressV1Beta1 , cdk8s-plus-21.Job , cdk8s-plus-21.NonApiResource , cdk8s-plus-21.PersistentVolume , cdk8s-plus-21.PersistentVolumeClaim , cdk8s-plus-21.Pod , cdk8s-plus-21.Resource , cdk8s-plus-21.Role , cdk8s-plus-21.RoleBinding , cdk8s-plus-21.Secret , cdk8s-plus-21.Service , cdk8s-plus-21.ServiceAccount , cdk8s-plus-21.ServiceAccountTokenSecret , cdk8s-plus-21.SshAuthSecret , cdk8s-plus-21.StatefulSet , cdk8s-plus-21.TlsSecret , cdk8s-plus-21.Workload , cdk8s-plus-21.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () IApiResource \u00b6 Implemented By: cdk8s-plus-21.AbstractPod , cdk8s-plus-21.ApiResource , cdk8s-plus-21.AwsElasticBlockStorePersistentVolume , cdk8s-plus-21.AzureDiskPersistentVolume , cdk8s-plus-21.BasicAuthSecret , cdk8s-plus-21.ClusterRole , cdk8s-plus-21.ClusterRoleBinding , cdk8s-plus-21.ConfigMap , cdk8s-plus-21.DaemonSet , cdk8s-plus-21.Deployment , cdk8s-plus-21.DockerConfigSecret , cdk8s-plus-21.GCEPersistentDiskPersistentVolume , cdk8s-plus-21.IngressV1Beta1 , cdk8s-plus-21.Job , cdk8s-plus-21.PersistentVolume , cdk8s-plus-21.PersistentVolumeClaim , cdk8s-plus-21.Pod , cdk8s-plus-21.Resource , cdk8s-plus-21.Role , cdk8s-plus-21.RoleBinding , cdk8s-plus-21.Secret , cdk8s-plus-21.Service , cdk8s-plus-21.ServiceAccount , cdk8s-plus-21.ServiceAccountTokenSecret , cdk8s-plus-21.SshAuthSecret , cdk8s-plus-21.StatefulSet , cdk8s-plus-21.TlsSecret , cdk8s-plus-21.Workload , cdk8s-plus-21.IApiResource Represents a resource or collection of resources. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resourceName Optional \u00b6 public readonly resourceName : string ; Type: string The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.ClusterRole , cdk8s-plus-21.IClusterRole Represents a cluster-level role. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IConfigMap \u00b6 Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.ConfigMap , cdk8s-plus-21.IConfigMap Represents a config map. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IPersistentVolume \u00b6 Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.AwsElasticBlockStorePersistentVolume , cdk8s-plus-21.AzureDiskPersistentVolume , cdk8s-plus-21.GCEPersistentDiskPersistentVolume , cdk8s-plus-21.PersistentVolume , cdk8s-plus-21.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.PersistentVolumeClaim , cdk8s-plus-21.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IResource \u00b6 Implemented By: cdk8s-plus-21.AbstractPod , cdk8s-plus-21.AwsElasticBlockStorePersistentVolume , cdk8s-plus-21.AzureDiskPersistentVolume , cdk8s-plus-21.BasicAuthSecret , cdk8s-plus-21.ClusterRole , cdk8s-plus-21.ClusterRoleBinding , cdk8s-plus-21.ConfigMap , cdk8s-plus-21.DaemonSet , cdk8s-plus-21.Deployment , cdk8s-plus-21.DockerConfigSecret , cdk8s-plus-21.GCEPersistentDiskPersistentVolume , cdk8s-plus-21.IngressV1Beta1 , cdk8s-plus-21.Job , cdk8s-plus-21.PersistentVolume , cdk8s-plus-21.PersistentVolumeClaim , cdk8s-plus-21.Pod , cdk8s-plus-21.Resource , cdk8s-plus-21.Role , cdk8s-plus-21.RoleBinding , cdk8s-plus-21.Secret , cdk8s-plus-21.Service , cdk8s-plus-21.ServiceAccount , cdk8s-plus-21.ServiceAccountTokenSecret , cdk8s-plus-21.SshAuthSecret , cdk8s-plus-21.StatefulSet , cdk8s-plus-21.TlsSecret , cdk8s-plus-21.Workload , cdk8s-plus-21.IClusterRole , cdk8s-plus-21.IConfigMap , cdk8s-plus-21.IPersistentVolume , cdk8s-plus-21.IPersistentVolumeClaim , cdk8s-plus-21.IResource , cdk8s-plus-21.IRole , cdk8s-plus-21.ISecret , cdk8s-plus-21.IServiceAccount Represents a resource. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IRole \u00b6 Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.ClusterRole , cdk8s-plus-21.Role , cdk8s-plus-21.IRole A reference to any Role or ClusterRole. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.BasicAuthSecret , cdk8s-plus-21.DockerConfigSecret , cdk8s-plus-21.Secret , cdk8s-plus-21.ServiceAccountTokenSecret , cdk8s-plus-21.SshAuthSecret , cdk8s-plus-21.TlsSecret , cdk8s-plus-21.ISecret Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.ServiceAccount , cdk8s-plus-21.IServiceAccount Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IStorage \u00b6 Implemented By: cdk8s-plus-21.AwsElasticBlockStorePersistentVolume , cdk8s-plus-21.AzureDiskPersistentVolume , cdk8s-plus-21.GCEPersistentDiskPersistentVolume , cdk8s-plus-21.PersistentVolume , cdk8s-plus-21.Volume , cdk8s-plus-21.IStorage Represents a piece of storage in the cluster. Methods \u00b6 asVolume \u00b6 public asVolume () ISubject \u00b6 Implemented By: cdk8s-plus-21.Group , cdk8s-plus-21.ServiceAccount , cdk8s-plus-21.User , cdk8s-plus-21.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Properties \u00b6 kind Required \u00b6 public readonly kind : string ; Type: string Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public readonly name : string ; Type: string Name of the object being referenced. apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 public readonly namespace : string ; Type: string Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. LabelSelectorRequirementOperator \u00b6 Possible operators. IN \u00b6 In. NOT_IN \u00b6 NotIn. EXISTS \u00b6 Exists. DOES_NOT_EXIST \u00b6 DoesNotExist. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"TypeScript"},{"location":"reference/cdk8s-plus-21/typescript/#cdk8s-plus-21-typescript","text":"","title":"cdk8s-plus-21 (TypeScript) "},{"location":"reference/cdk8s-plus-21/typescript/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-21/typescript/#abstractpod","text":"","title":"AbstractPod "},{"location":"reference/cdk8s-plus-21/typescript/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-21/typescript/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-21/typescript/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-21/typescript/#clusterrole","text":"Implements: cdk8s-plus-21.IClusterRole , cdk8s-plus-21.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-21/typescript/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-21/typescript/#configmap","text":"Implements: cdk8s-plus-21.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-21/typescript/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-21/typescript/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-21/typescript/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-21/typescript/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-21/typescript/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-21/typescript/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-21/typescript/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-21/typescript/#persistentvolume","text":"Implements: cdk8s-plus-21.IPersistentVolume , cdk8s-plus-21.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-21/typescript/#persistentvolumeclaim","text":"Implements: cdk8s-plus-21.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-21/typescript/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-21/typescript/#resource","text":"Implements: cdk8s-plus-21.IResource , cdk8s-plus-21.IApiResource , cdk8s-plus-21.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-21/typescript/#role","text":"Implements: cdk8s-plus-21.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-21/typescript/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-21/typescript/#secret","text":"Implements: cdk8s-plus-21.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-21/typescript/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-21/typescript/#serviceaccount","text":"Implements: cdk8s-plus-21.IServiceAccount , cdk8s-plus-21.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-21/typescript/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-21/typescript/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-21/typescript/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-21/typescript/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-21/typescript/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-21/typescript/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-21/typescript/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-21/typescript/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-21/typescript/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-21/typescript/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-21/typescript/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-21/typescript/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-21/typescript/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-21/typescript/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-21/typescript/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-21/typescript/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-21/typescript/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-21/typescript/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-21/typescript/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-21/typescript/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-21/typescript/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-21/typescript/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-21/typescript/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-21/typescript/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-21/typescript/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-21/typescript/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-21/typescript/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-21/typescript/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-21/typescript/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-21/typescript/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-21/typescript/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-21/typescript/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-21/typescript/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-21/typescript/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-21/typescript/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-21/typescript/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-21/typescript/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-21/typescript/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-21/typescript/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-21/typescript/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-21/typescript/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-21/typescript/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-21/typescript/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-21/typescript/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-21/typescript/#groupprops","text":"Properties for Group .","title":"GroupProps "},{"location":"reference/cdk8s-plus-21/typescript/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-21/typescript/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-21/typescript/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-21/typescript/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-21/typescript/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-21/typescript/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-21/typescript/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-21/typescript/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-21/typescript/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-21/typescript/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-21/typescript/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-21/typescript/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-21/typescript/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-21/typescript/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-21/typescript/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-21/typescript/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-21/typescript/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-21/typescript/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-21/typescript/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-21/typescript/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-21/typescript/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-21/typescript/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-21/typescript/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-21/typescript/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-21/typescript/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-21/typescript/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-21/typescript/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-21/typescript/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-21/typescript/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-21/typescript/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-21/typescript/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-21/typescript/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-21/typescript/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-21/typescript/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-21/typescript/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-21/typescript/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-21/typescript/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-21/typescript/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-21/typescript/#userprops","text":"Properties for User .","title":"UserProps "},{"location":"reference/cdk8s-plus-21/typescript/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-21/typescript/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-21/typescript/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-21/typescript/#apiresource","text":"Implements: cdk8s-plus-21.IApiResource , cdk8s-plus-21.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-21/typescript/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-21/typescript/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-21/typescript/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-21/typescript/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-21/typescript/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-21/typescript/#group","text":"Implements: cdk8s-plus-21.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-21/typescript/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-21/typescript/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-21/typescript/#labelselector","text":"A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors","title":"LabelSelector "},{"location":"reference/cdk8s-plus-21/typescript/#nonapiresource","text":"Implements: cdk8s-plus-21.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-21/typescript/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-21/typescript/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-21/typescript/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-21/typescript/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-21/typescript/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-21/typescript/#user","text":"Implements: cdk8s-plus-21.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-21/typescript/#volume","text":"Implements: cdk8s-plus-21.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-21/typescript/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-21/typescript/#iapiendpoint","text":"Implemented By: cdk8s-plus-21.AbstractPod , cdk8s-plus-21.ApiResource , cdk8s-plus-21.AwsElasticBlockStorePersistentVolume , cdk8s-plus-21.AzureDiskPersistentVolume , cdk8s-plus-21.BasicAuthSecret , cdk8s-plus-21.ClusterRole , cdk8s-plus-21.ClusterRoleBinding , cdk8s-plus-21.ConfigMap , cdk8s-plus-21.DaemonSet , cdk8s-plus-21.Deployment , cdk8s-plus-21.DockerConfigSecret , cdk8s-plus-21.GCEPersistentDiskPersistentVolume , cdk8s-plus-21.IngressV1Beta1 , cdk8s-plus-21.Job , cdk8s-plus-21.NonApiResource , cdk8s-plus-21.PersistentVolume , cdk8s-plus-21.PersistentVolumeClaim , cdk8s-plus-21.Pod , cdk8s-plus-21.Resource , cdk8s-plus-21.Role , cdk8s-plus-21.RoleBinding , cdk8s-plus-21.Secret , cdk8s-plus-21.Service , cdk8s-plus-21.ServiceAccount , cdk8s-plus-21.ServiceAccountTokenSecret , cdk8s-plus-21.SshAuthSecret , cdk8s-plus-21.StatefulSet , cdk8s-plus-21.TlsSecret , cdk8s-plus-21.Workload , cdk8s-plus-21.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-21/typescript/#iapiresource","text":"Implemented By: cdk8s-plus-21.AbstractPod , cdk8s-plus-21.ApiResource , cdk8s-plus-21.AwsElasticBlockStorePersistentVolume , cdk8s-plus-21.AzureDiskPersistentVolume , cdk8s-plus-21.BasicAuthSecret , cdk8s-plus-21.ClusterRole , cdk8s-plus-21.ClusterRoleBinding , cdk8s-plus-21.ConfigMap , cdk8s-plus-21.DaemonSet , cdk8s-plus-21.Deployment , cdk8s-plus-21.DockerConfigSecret , cdk8s-plus-21.GCEPersistentDiskPersistentVolume , cdk8s-plus-21.IngressV1Beta1 , cdk8s-plus-21.Job , cdk8s-plus-21.PersistentVolume , cdk8s-plus-21.PersistentVolumeClaim , cdk8s-plus-21.Pod , cdk8s-plus-21.Resource , cdk8s-plus-21.Role , cdk8s-plus-21.RoleBinding , cdk8s-plus-21.Secret , cdk8s-plus-21.Service , cdk8s-plus-21.ServiceAccount , cdk8s-plus-21.ServiceAccountTokenSecret , cdk8s-plus-21.SshAuthSecret , cdk8s-plus-21.StatefulSet , cdk8s-plus-21.TlsSecret , cdk8s-plus-21.Workload , cdk8s-plus-21.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-21/typescript/#iclusterrole","text":"Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.ClusterRole , cdk8s-plus-21.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-21/typescript/#iconfigmap","text":"Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.ConfigMap , cdk8s-plus-21.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-21/typescript/#ipersistentvolume","text":"Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.AwsElasticBlockStorePersistentVolume , cdk8s-plus-21.AzureDiskPersistentVolume , cdk8s-plus-21.GCEPersistentDiskPersistentVolume , cdk8s-plus-21.PersistentVolume , cdk8s-plus-21.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-21/typescript/#ipersistentvolumeclaim","text":"Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.PersistentVolumeClaim , cdk8s-plus-21.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-21/typescript/#iresource","text":"Implemented By: cdk8s-plus-21.AbstractPod , cdk8s-plus-21.AwsElasticBlockStorePersistentVolume , cdk8s-plus-21.AzureDiskPersistentVolume , cdk8s-plus-21.BasicAuthSecret , cdk8s-plus-21.ClusterRole , cdk8s-plus-21.ClusterRoleBinding , cdk8s-plus-21.ConfigMap , cdk8s-plus-21.DaemonSet , cdk8s-plus-21.Deployment , cdk8s-plus-21.DockerConfigSecret , cdk8s-plus-21.GCEPersistentDiskPersistentVolume , cdk8s-plus-21.IngressV1Beta1 , cdk8s-plus-21.Job , cdk8s-plus-21.PersistentVolume , cdk8s-plus-21.PersistentVolumeClaim , cdk8s-plus-21.Pod , cdk8s-plus-21.Resource , cdk8s-plus-21.Role , cdk8s-plus-21.RoleBinding , cdk8s-plus-21.Secret , cdk8s-plus-21.Service , cdk8s-plus-21.ServiceAccount , cdk8s-plus-21.ServiceAccountTokenSecret , cdk8s-plus-21.SshAuthSecret , cdk8s-plus-21.StatefulSet , cdk8s-plus-21.TlsSecret , cdk8s-plus-21.Workload , cdk8s-plus-21.IClusterRole , cdk8s-plus-21.IConfigMap , cdk8s-plus-21.IPersistentVolume , cdk8s-plus-21.IPersistentVolumeClaim , cdk8s-plus-21.IResource , cdk8s-plus-21.IRole , cdk8s-plus-21.ISecret , cdk8s-plus-21.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-21/typescript/#irole","text":"Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.ClusterRole , cdk8s-plus-21.Role , cdk8s-plus-21.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-21/typescript/#isecret","text":"Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.BasicAuthSecret , cdk8s-plus-21.DockerConfigSecret , cdk8s-plus-21.Secret , cdk8s-plus-21.ServiceAccountTokenSecret , cdk8s-plus-21.SshAuthSecret , cdk8s-plus-21.TlsSecret , cdk8s-plus-21.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-21/typescript/#iserviceaccount","text":"Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.ServiceAccount , cdk8s-plus-21.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-21/typescript/#istorage","text":"Implemented By: cdk8s-plus-21.AwsElasticBlockStorePersistentVolume , cdk8s-plus-21.AzureDiskPersistentVolume , cdk8s-plus-21.GCEPersistentDiskPersistentVolume , cdk8s-plus-21.PersistentVolume , cdk8s-plus-21.Volume , cdk8s-plus-21.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-21/typescript/#isubject","text":"Implemented By: cdk8s-plus-21.Group , cdk8s-plus-21.ServiceAccount , cdk8s-plus-21.User , cdk8s-plus-21.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"ISubject "},{"location":"reference/cdk8s-plus-21/typescript/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-21/typescript/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-21/typescript/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-21/typescript/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-21/typescript/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-21/typescript/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-21/typescript/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-21/typescript/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-21/typescript/#labelselectorrequirementoperator","text":"Possible operators.","title":"LabelSelectorRequirementOperator "},{"location":"reference/cdk8s-plus-21/typescript/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-21/typescript/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-21/typescript/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-21/typescript/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-21/typescript/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-21/typescript/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-21/typescript/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-21/typescript/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-21/typescript/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-22/go/","text":"cdk8s-plus-22 (Go) \u00b6 For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus22 .","title":"Go"},{"location":"reference/cdk8s-plus-22/go/#cdk8s-plus-22-go","text":"For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus22 .","title":"cdk8s-plus-22 (Go) "},{"location":"reference/cdk8s-plus-22/java/","text":"cdk8s-plus-22 (Java) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Initializers \u00b6 import org.cdk8s.plus22.AbstractPod ; AbstractPod . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps cont ) cont Required \u00b6 Type: org.cdk8s.plus22.ContainerProps addHostAlias \u00b6 public addHostAlias ( HostAlias hostAlias ) hostAlias Required \u00b6 Type: org.cdk8s.plus22.HostAlias addInitContainer \u00b6 public addInitContainer ( ContainerProps cont ) cont Required \u00b6 Type: org.cdk8s.plus22.ContainerProps addVolume \u00b6 public addVolume ( Volume vol ) vol Required \u00b6 Type: org.cdk8s.plus22.Volume Properties \u00b6 automountServiceAccountToken Required \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus22.Container > dns Required \u00b6 public PodDns getDns (); Type: org.cdk8s.plus22.PodDns hostAliases Required \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus22.HostAlias > initContainers Required \u00b6 public java . util . List < Container > getInitContainers (); Type: java.util.List< org.cdk8s.plus22.Container > securityContext Required \u00b6 public PodSecurityContext getSecurityContext (); Type: org.cdk8s.plus22.PodSecurityContext volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus22.DockerConfigSecret restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume ; AwsElasticBlockStorePersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . volumeId ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 Type: java.lang.String Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. volumeId Required \u00b6 public java . lang . String getVolumeId (); Type: java.lang.String Volume id of this volume. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import org.cdk8s.plus22.AzureDiskPersistentVolume ; AzureDiskPersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . diskName ( java . lang . String ) . diskUri ( java . lang . String ) // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 Type: java.lang.String The Name of the data disk in the blob storage. diskUri Required \u00b6 Type: java.lang.String The URI the data disk in the blob storage. cachingMode Optional \u00b6 Type: org.cdk8s.plus22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: org.cdk8s.plus22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. Properties \u00b6 azureKind Required \u00b6 public AzureDiskPersistentVolumeKind getAzureKind (); Type: org.cdk8s.plus22.AzureDiskPersistentVolumeKind Azure kind of this volume. cachingMode Required \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus22.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. diskName Required \u00b6 public java . lang . String getDiskName (); Type: java.lang.String Disk name of this volume. diskUri Required \u00b6 public java . lang . String getDiskUri (); Type: java.lang.String Disk URI of this volume. fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import org.cdk8s.plus22.BasicAuthSecret ; BasicAuthSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . password ( java . lang . String ) . username ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 Type: java.lang.String The password or token for authentication. username Required \u00b6 Type: java.lang.String The user name for authentication. ClusterRole \u00b6 Implements: org.cdk8s.plus22.IClusterRole , org.cdk8s.plus22.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import org.cdk8s.plus22.ClusterRole ; ClusterRole . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .aggregationLabels(java.util.Map<java.lang.String, java.lang.String>) // .rules(java.util.List<ClusterRolePolicyRule>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 Type: java.util.Map java.lang.String > Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ClusterRolePolicyRule > Default: [] A list of rules the role should allow. Methods \u00b6 aggregate \u00b6 public aggregate ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String allow \u00b6 public allow ( java . util . List < java . lang . String > verbs , IApiEndpoint endpoints ) verbs Required \u00b6 Type: java.util.List< java.lang.String > endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The endpoints(s) to apply to. allowCreate \u00b6 public allowCreate ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowGet \u00b6 public allowGet ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowList \u00b6 public allowList ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowRead \u00b6 public allowRead ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( IApiEndpoint endpoints ) endpoints Required \u00b6 Type: org.cdk8s.plus22.IApiEndpoint The resource(s) to apply to. bind \u00b6 public bind ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus22.ISubject a list of subjects to bind to. bindInNamespace \u00b6 public bindInNamespace ( java . lang . String namespace , ISubject subjects ) namespace Required \u00b6 Type: java.lang.String the namespace to limit permissions to. subjects Required \u00b6 Type: org.cdk8s.plus22.ISubject a list of subjects to bind to. combine \u00b6 public combine ( ClusterRole rol ) rol Required \u00b6 Type: org.cdk8s.plus22.ClusterRole Static Functions \u00b6 fromClusterRoleName \u00b6 import org.cdk8s.plus22.ClusterRole ; ClusterRole . fromClusterRoleName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the role resource. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public java . util . List < ClusterRolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus22.ClusterRolePolicyRule > Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import org.cdk8s.plus22.ClusterRoleBinding ; ClusterRoleBinding . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) . role ( IClusterRole ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: org.cdk8s.plus22.IClusterRole The role to bind to. Methods \u00b6 addSubjects \u00b6 public addSubjects ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus22.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public IClusterRole getRole (); Type: org.cdk8s.plus22.IClusterRole subjects Required \u00b6 public java . util . List < ISubject > getSubjects (); Type: java.util.List< org.cdk8s.plus22.ISubject > ConfigMap \u00b6 Implements: org.cdk8s.plus22.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import org.cdk8s.plus22.ConfigMap ; ConfigMap . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) // .immutable(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addData \u00b6 public addData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addDirectory \u00b6 public addDirectory ( java . lang . String localDir ) public addDirectory ( java . lang . String localDir , AddDirectoryOptions options ) localDir Required \u00b6 Type: java.lang.String A path to a local directory. options Optional \u00b6 Type: org.cdk8s.plus22.AddDirectoryOptions Options. addFile \u00b6 public addFile ( java . lang . String localFile ) public addFile ( java . lang . String localFile , java . lang . String key ) localFile Required \u00b6 Type: java.lang.String The path to the local file. key Optional \u00b6 Type: java.lang.String The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import org.cdk8s.plus22.ConfigMap ; ConfigMap . fromConfigMapName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the config map to import. Properties \u00b6 binaryData Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Whether or not this config map is immutable. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import org.cdk8s.plus22.DaemonSet ; DaemonSet . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .minReadySeconds(java.lang.Number) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReadySeconds Optional \u00b6 Type: java.lang.Number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Properties \u00b6 minReadySeconds Required \u00b6 public java . lang . Number getMinReadySeconds (); Type: java.lang.Number resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import org.cdk8s.plus22.Deployment ; Deployment . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .minReady(Duration) // .progressDeadline(Duration) // .replicas(java.lang.Number) // .strategy(DeploymentStrategy) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReady Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 Type: org.cdk8s.plus22.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. Methods \u00b6 exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeDeploymentViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The ingress path to register under. options Optional \u00b6 Type: org.cdk8s.plus22.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService () public exposeViaService ( ExposeDeploymentViaServiceOptions options ) options Optional \u00b6 Type: org.cdk8s.plus22.ExposeDeploymentViaServiceOptions Options to determine details of the service and port exposed. Properties \u00b6 minReady Required \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progressDeadline Required \u00b6 public Duration getProgressDeadline (); Type: org.cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public DeploymentStrategy getStrategy (); Type: org.cdk8s.plus22.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import org.cdk8s.plus22.DockerConfigSecret ; DockerConfigSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . data ( java . util . Map < java . lang . String , java . lang . Object > ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 Type: java.util.Map java.lang.Object > JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import org.cdk8s.plus22.GCEPersistentDiskPersistentVolume ; GCEPersistentDiskPersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . pdName ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 Type: java.lang.String Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fsType Required \u00b6 public java . lang . String getFsType (); Type: java.lang.String File system type of this volume. pdName Required \u00b6 public java . lang . String getPdName (); Type: java.lang.String PD resource in GCE of this volume. readOnly Required \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Whether or not it is mounted as a read-only volume. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Partition of this volume. Ingress \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import org.cdk8s.plus22.Ingress ; Ingress . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .defaultBackend(IngressBackend) // .rules(java.util.List<IngressRule>) // .tls(java.util.List<IngressTls>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 Type: org.cdk8s.plus22.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.IngressRule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.IngressTls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( IngressBackend backend ) backend Required \u00b6 Type: org.cdk8s.plus22.IngressBackend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( java . lang . String host , IngressBackend backend ) host Required \u00b6 Type: java.lang.String The host name to match. backend Required \u00b6 Type: org.cdk8s.plus22.IngressBackend The backend to route to. addHostRule \u00b6 public addHostRule ( java . lang . String host , java . lang . String path , IngressBackend backend ) public addHostRule ( java . lang . String host , java . lang . String path , IngressBackend backend , HttpIngressPathType pathType ) host Required \u00b6 Type: java.lang.String The host name. path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus22.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: org.cdk8s.plus22.HttpIngressPathType How the path is matched against request paths. addRule \u00b6 public addRule ( java . lang . String path , IngressBackend backend ) public addRule ( java . lang . String path , IngressBackend backend , HttpIngressPathType pathType ) path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus22.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: org.cdk8s.plus22.HttpIngressPathType How the path is matched against request paths. addRules \u00b6 public addRules ( IngressRule rules ) rules Required \u00b6 Type: org.cdk8s.plus22.IngressRule The rules to add. addTls \u00b6 public addTls ( java . util . List < IngressTls > tls ) tls Required \u00b6 Type: java.util.List< org.cdk8s.plus22.IngressTls > Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import org.cdk8s.plus22.Job ; Job . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. activeDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Number of retries before marking failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration TTL before the job is deleted after it is finished. PersistentVolume \u00b6 Implements: org.cdk8s.plus22.IPersistentVolume , org.cdk8s.plus22.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import org.cdk8s.plus22.PersistentVolume ; PersistentVolume . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: org.cdk8s.plus22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 asVolume \u00b6 public asVolume () bind \u00b6 public bind ( IPersistentVolumeClaim claim ) claim Required \u00b6 Type: org.cdk8s.plus22.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 public reserve () Static Functions \u00b6 fromPersistentVolumeName \u00b6 import org.cdk8s.plus22.PersistentVolume ; PersistentVolume . fromPersistentVolumeName ( java . lang . String volumeName ) volumeName Required \u00b6 Type: java.lang.String The name of the pv to reference. Properties \u00b6 mode Required \u00b6 public PersistentVolumeMode getMode (); Type: org.cdk8s.plus22.PersistentVolumeMode Volume mode of this volume. reclaimPolicy Required \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Access modes requirement of this claim. claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus22.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Mount options of this volume. storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Storage size of this volume. storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: org.cdk8s.plus22.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import org.cdk8s.plus22.PersistentVolumeClaim ; PersistentVolumeClaim . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .storage(Size) // .storageClassName(java.lang.String) // .volume(IPersistentVolume) // .volumeMode(PersistentVolumeMode) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 Type: org.cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 Type: java.lang.String Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 Type: org.cdk8s.plus22.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 bind \u00b6 public bind ( IPersistentVolume vol ) vol Required \u00b6 Type: org.cdk8s.plus22.IPersistentVolume The PV to bind to. Static Functions \u00b6 fromClaimName \u00b6 import org.cdk8s.plus22.PersistentVolumeClaim ; PersistentVolumeClaim . fromClaimName ( java . lang . String claimName ) claimName Required \u00b6 Type: java.lang.String The name of the pvc to reference. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. volumeMode Required \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus22.PersistentVolumeMode Volume mode requirement of this claim. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Access modes requirement of this claim. storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Storage requirement of this claim. storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Storage class requirment of this claim. volume Optional \u00b6 public IPersistentVolume getVolume (); Type: org.cdk8s.plus22.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import org.cdk8s.plus22.Pod ; Pod . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Resource \u00b6 Implements: org.cdk8s.plus22.IResource , org.cdk8s.plus22.IApiResource , org.cdk8s.plus22.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import org.cdk8s.plus22.Resource ; Resource . Builder . create ( Construct scope , java . lang . String id ) // .nodeFactory(INodeFactory) . build (); scope Required \u00b6 Type: software.constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: java.lang.String The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . nodeFactory Optional \u00b6 Type: software.constructs.INodeFactory Default: the default Node is associated A factory for attaching Node s to the construct. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 public ApiObjectMetadataDefinition getMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this API object. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. resourceName Optional \u00b6 public java . lang . String getResourceName (); Type: java.lang.String The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: org.cdk8s.plus22.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import org.cdk8s.plus22.Role ; Role . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .rules(java.util.List<RolePolicyRule>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.RolePolicyRule > Default: [] A list of rules the role should allow. Methods \u00b6 allow \u00b6 public allow ( java . util . List < java . lang . String > verbs , IApiResource resources ) verbs Required \u00b6 Type: java.util.List< java.lang.String > resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowCreate \u00b6 public allowCreate ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowGet \u00b6 public allowGet ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowList \u00b6 public allowList ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowRead \u00b6 public allowRead ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( IApiResource resources ) resources Required \u00b6 Type: org.cdk8s.plus22.IApiResource The resource(s) to apply to. bind \u00b6 public bind ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus22.ISubject a list of subjects to bind to. Static Functions \u00b6 fromRoleName \u00b6 import org.cdk8s.plus22.Role ; Role . fromRoleName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the role resource. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public java . util . List < RolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus22.RolePolicyRule > Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import org.cdk8s.plus22.RoleBinding ; RoleBinding . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) . role ( IRole ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: org.cdk8s.plus22.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. Methods \u00b6 addSubjects \u00b6 public addSubjects ( ISubject subjects ) subjects Required \u00b6 Type: org.cdk8s.plus22.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public IRole getRole (); Type: org.cdk8s.plus22.IRole subjects Required \u00b6 public java . util . List < ISubject > getSubjects (); Type: java.util.List< org.cdk8s.plus22.ISubject > Secret \u00b6 Implements: org.cdk8s.plus22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import org.cdk8s.plus22.Secret ; Secret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 addStringData \u00b6 public addStringData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String Key. value Required \u00b6 Type: java.lang.String Value. getStringData \u00b6 public getStringData ( java . lang . String key ) key Required \u00b6 Type: java.lang.String Key. Static Functions \u00b6 fromSecretName \u00b6 import org.cdk8s.plus22.Secret ; Secret . fromSecretName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the secret to reference. Properties \u00b6 immutable Required \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Whether or not the secret is immutable. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import org.cdk8s.plus22.Service ; Service . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .type(ServiceType) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ServicePort > The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: org.cdk8s.plus22.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 addDeployment \u00b6 public addDeployment ( Deployment depl ) public addDeployment ( Deployment depl , AddDeploymentOptions options ) depl Required \u00b6 Type: org.cdk8s.plus22.Deployment The deployment to expose. options Optional \u00b6 Type: org.cdk8s.plus22.AddDeploymentOptions Optional settings for the port. addSelector \u00b6 public addSelector ( java . lang . String label , java . lang . String value ) label Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeServiceViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The path to expose the service under. options Optional \u00b6 Type: org.cdk8s.plus22.ExposeServiceViaIngressOptions Additional options. serve \u00b6 public serve ( java . lang . Number port ) public serve ( java . lang . Number port , ServicePortOptions options ) port Required \u00b6 Type: java.lang.Number The port definition. options Optional \u00b6 Type: org.cdk8s.plus22.ServicePortOptions Properties \u00b6 ports Required \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus22.ServicePort > Ports for this service. Use serve() to expose additional service ports. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. selector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getSelector (); Type: java.util.Map java.lang.String > Returns the labels which are used to select pods for this service. type Required \u00b6 public ServiceType getType (); Type: org.cdk8s.plus22.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: org.cdk8s.plus22.IServiceAccount , org.cdk8s.plus22.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import org.cdk8s.plus22.ServiceAccount ; ServiceAccount . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountToken(java.lang.Boolean) // .secrets(java.util.List<ISecret>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 addSecret \u00b6 public addSecret ( ISecret secr ) secr Required \u00b6 Type: org.cdk8s.plus22.ISecret The secret. Static Functions \u00b6 fromServiceAccountName \u00b6 import org.cdk8s.plus22.ServiceAccount ; ServiceAccount . fromServiceAccountName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the service account resource. Properties \u00b6 automountToken Required \u00b6 public java . lang . Boolean getAutomountToken (); Type: java.lang.Boolean Whether or not a token is automatically mounted for this service account. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus22.ISecret > List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import org.cdk8s.plus22.ServiceAccountTokenSecret ; ServiceAccountTokenSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . serviceAccount ( IServiceAccount ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 Type: org.cdk8s.plus22.IServiceAccount The service account to store a secret for. SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import org.cdk8s.plus22.SshAuthSecret ; SshAuthSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . sshPrivateKey ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 Type: java.lang.String The SSH private key to use. StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import org.cdk8s.plus22.StatefulSet ; StatefulSet . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) . service ( Service ) // .minReady(Duration) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) // .strategy(StatefulSetUpdateStrategy) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. service Required \u00b6 Type: org.cdk8s.plus22.Service Service to associate with the statefulset. minReady Optional \u00b6 Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds podManagementPolicy Optional \u00b6 Type: org.cdk8s.plus22.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 Type: org.cdk8s.plus22.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. Properties \u00b6 minReady Required \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. podManagementPolicy Required \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus22.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public StatefulSetUpdateStrategy getStrategy (); Type: org.cdk8s.plus22.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import org.cdk8s.plus22.TlsSecret ; TlsSecret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . tlsCert ( java . lang . String ) . tlsKey ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 Type: java.lang.String The TLS cert. tlsKey Required \u00b6 Type: java.lang.String The TLS key. Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import org.cdk8s.plus22.Workload ; Workload . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. Methods \u00b6 select \u00b6 public select ( LabelSelector selectors ) selectors Required \u00b6 Type: org.cdk8s.plus22.LabelSelector Properties \u00b6 matchExpressions Required \u00b6 public java . util . List < LabelSelectorRequirement > getMatchExpressions (); Type: java.util.List< org.cdk8s.plus22.LabelSelectorRequirement > The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. matchLabels Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getMatchLabels (); Type: java.util.Map java.lang.String > The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import org.cdk8s.plus22.AbstractPodProps ; AbstractPodProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import org.cdk8s.plus22.AddDeploymentOptions ; AddDeploymentOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) // .port(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import org.cdk8s.plus22.AddDirectoryOptions ; AddDirectoryOptions . builder () // .exclude(java.util.List<java.lang.String>) // .keyPrefix(java.lang.String) . build (); exclude Optional \u00b6 public java . util . List < java . lang . String > getExclude (); Type: java.util.List< java.lang.String > Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public java . lang . String getKeyPrefix (); Type: java.lang.String Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import org.cdk8s.plus22.ApiResourceOptions ; ApiResourceOptions . builder () . apiGroup ( java . lang . String ) . resourceType ( java . lang . String ) . build (); apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import org.cdk8s.plus22.AwsElasticBlockStorePersistentVolumeProps ; AwsElasticBlockStorePersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . volumeId ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 public java . lang . String getVolumeId (); Type: java.lang.String Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import org.cdk8s.plus22.AwsElasticBlockStoreVolumeOptions ; AwsElasticBlockStoreVolumeOptions . builder () // .fsType(java.lang.String) // .name(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import org.cdk8s.plus22.AzureDiskPersistentVolumeProps ; AzureDiskPersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . diskName ( java . lang . String ) . diskUri ( java . lang . String ) // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 public java . lang . String getDiskName (); Type: java.lang.String The Name of the data disk in the blob storage. diskUri Required \u00b6 public java . lang . String getDiskUri (); Type: java.lang.String The URI the data disk in the blob storage. cachingMode Optional \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public AzureDiskPersistentVolumeKind getKind (); Type: org.cdk8s.plus22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import org.cdk8s.plus22.AzureDiskVolumeOptions ; AzureDiskVolumeOptions . builder () // .cachingMode(AzureDiskPersistentVolumeCachingMode) // .fsType(java.lang.String) // .kind(AzureDiskPersistentVolumeKind) // .name(java.lang.String) // .readOnly(java.lang.Boolean) . build (); cachingMode Optional \u00b6 public AzureDiskPersistentVolumeCachingMode getCachingMode (); Type: org.cdk8s.plus22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public AzureDiskPersistentVolumeKind getKind (); Type: org.cdk8s.plus22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import org.cdk8s.plus22.BasicAuthSecretProps ; BasicAuthSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . password ( java . lang . String ) . username ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 public java . lang . String getPassword (); Type: java.lang.String The password or token for authentication. username Required \u00b6 public java . lang . String getUsername (); Type: java.lang.String The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import org.cdk8s.plus22.ClusterRoleBindingProps ; ClusterRoleBindingProps . builder () // .metadata(ApiObjectMetadata) . role ( IClusterRole ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public IClusterRole getRole (); Type: org.cdk8s.plus22.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import org.cdk8s.plus22.ClusterRolePolicyRule ; ClusterRolePolicyRule . builder () . endpoints ( java . util . List < IApiEndpoint > ) . verbs ( java . util . List < java . lang . String > ) . build (); endpoints Required \u00b6 public java . util . List < IApiEndpoint > getEndpoints (); Type: java.util.List< org.cdk8s.plus22.IApiEndpoint > Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 public java . util . List < java . lang . String > getVerbs (); Type: java.util.List< java.lang.String > Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import org.cdk8s.plus22.ClusterRoleProps ; ClusterRoleProps . builder () // .metadata(ApiObjectMetadata) // .aggregationLabels(java.util.Map<java.lang.String, java.lang.String>) // .rules(java.util.List<ClusterRolePolicyRule>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getAggregationLabels (); Type: java.util.Map java.lang.String > Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 public java . util . List < ClusterRolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus22.ClusterRolePolicyRule > Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import org.cdk8s.plus22.CommandProbeOptions ; CommandProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import org.cdk8s.plus22.CommonSecretProps ; CommonSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import org.cdk8s.plus22.ConfigMapProps ; ConfigMapProps . builder () // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) // .immutable(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import org.cdk8s.plus22.ConfigMapVolumeOptions ; ConfigMapVolumeOptions . builder () // .defaultMode(java.lang.Number) // .items(java.util.Map<java.lang.String, PathMapping>) // .name(java.lang.String) // .optional(java.lang.Boolean) . build (); defaultMode Optional \u00b6 public java . lang . Number getDefaultMode (); Type: java.lang.Number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public java . util . Map < java . lang . String , PathMapping > getItems (); Type: java.util.Map \u0002klzzwxh:8378\u0003 > Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import org.cdk8s.plus22.ContainerLifecycle ; ContainerLifecycle . builder () // .postStart(Handler) // .preStop(Handler) . build (); postStart Optional \u00b6 public Handler getPostStart (); Type: org.cdk8s.plus22.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. preStop Optional \u00b6 public Handler getPreStop (); Type: org.cdk8s.plus22.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import org.cdk8s.plus22.ContainerProps ; ContainerProps . builder () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .env(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .lifecycle(ContainerLifecycle) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .readiness(Probe) // .resources(ContainerResources) // .securityContext(ContainerSecurityContextProps) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String Docker image name. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnv (); Type: java.util.Map \u0002klzzwxh:8351\u0003 > Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 public ContainerLifecycle getLifecycle (); Type: org.cdk8s.plus22.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 public Probe getLiveness (); Type: org.cdk8s.plus22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 public Probe getReadiness (); Type: org.cdk8s.plus22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 public ContainerResources getResources (); Type: org.cdk8s.plus22.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 public ContainerSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus22.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 public Probe getStartup (); Type: org.cdk8s.plus22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public java . util . List < VolumeMount > getVolumeMounts (); Type: java.util.List< org.cdk8s.plus22.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import org.cdk8s.plus22.ContainerResources ; ContainerResources . builder () . cpu ( CpuResources ) . memory ( MemoryResources ) . build (); cpu Required \u00b6 public CpuResources getCpu (); Type: org.cdk8s.plus22.CpuResources memory Required \u00b6 public MemoryResources getMemory (); Type: org.cdk8s.plus22.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import org.cdk8s.plus22.ContainerSecurityContextProps ; ContainerSecurityContextProps . builder () // .ensureNonRoot(java.lang.Boolean) // .group(java.lang.Number) // .privileged(java.lang.Boolean) // .readOnlyRootFilesystem(java.lang.Boolean) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. privileged Optional \u00b6 public java . lang . Boolean getPrivileged (); Type: java.lang.Boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 public java . lang . Boolean getReadOnlyRootFilesystem (); Type: java.lang.Boolean Default: false Whether this container has a read-only root filesystem. user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import org.cdk8s.plus22.CpuResources ; CpuResources . builder () . limit ( Cpu ) . request ( Cpu ) . build (); limit Required \u00b6 public Cpu getLimit (); Type: org.cdk8s.plus22.Cpu request Required \u00b6 public Cpu getRequest (); Type: org.cdk8s.plus22.Cpu DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import org.cdk8s.plus22.DaemonSetProps ; DaemonSetProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .minReadySeconds(java.lang.Number) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReadySeconds Optional \u00b6 public java . lang . Number getMinReadySeconds (); Type: java.lang.Number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import org.cdk8s.plus22.DeploymentProps ; DeploymentProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .minReady(Duration) // .progressDeadline(Duration) // .replicas(java.lang.Number) // .strategy(DeploymentStrategy) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReady Optional \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 public Duration getProgressDeadline (); Type: org.cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 public DeploymentStrategy getStrategy (); Type: org.cdk8s.plus22.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import org.cdk8s.plus22.DeploymentStrategyRollingUpdateOptions ; DeploymentStrategyRollingUpdateOptions . builder () // .maxSurge(PercentOrAbsolute) // .maxUnavailable(PercentOrAbsolute) . build (); maxSurge Optional \u00b6 public PercentOrAbsolute getMaxSurge (); Type: org.cdk8s.plus22.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. maxUnavailable Optional \u00b6 public PercentOrAbsolute getMaxUnavailable (); Type: org.cdk8s.plus22.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import org.cdk8s.plus22.DnsOption ; DnsOption . builder () . name ( java . lang . String ) // .value(java.lang.String) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Option name. value Optional \u00b6 public java . lang . String getValue (); Type: java.lang.String Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import org.cdk8s.plus22.DockerConfigSecretProps ; DockerConfigSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . data ( java . util . Map < java . lang . String , java . lang . Object > ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 public java . util . Map < java . lang . String , java . lang . Object > getData (); Type: java.util.Map java.lang.Object > JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import org.cdk8s.plus22.EmptyDirVolumeOptions ; EmptyDirVolumeOptions . builder () // .medium(EmptyDirMedium) // .sizeLimit(Size) . build (); medium Optional \u00b6 public EmptyDirMedium getMedium (); Type: org.cdk8s.plus22.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public Size getSizeLimit (); Type: org.cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import org.cdk8s.plus22.EnvValueFromConfigMapOptions ; EnvValueFromConfigMapOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import org.cdk8s.plus22.EnvValueFromFieldRefOptions ; EnvValueFromFieldRefOptions . builder () // .apiVersion(java.lang.String) // .key(java.lang.String) . build (); apiVersion Optional \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String Version of the schema the FieldPath is written in terms of. key Optional \u00b6 public java . lang . String getKey (); Type: java.lang.String The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import org.cdk8s.plus22.EnvValueFromProcessOptions ; EnvValueFromProcessOptions . builder () // .required(java.lang.Boolean) . build (); required Optional \u00b6 public java . lang . Boolean getRequired (); Type: java.lang.Boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import org.cdk8s.plus22.EnvValueFromResourceOptions ; EnvValueFromResourceOptions . builder () // .container(Container) // .divisor(java.lang.String) . build (); container Optional \u00b6 public Container getContainer (); Type: org.cdk8s.plus22.Container The container to select the value from. divisor Optional \u00b6 public java . lang . String getDivisor (); Type: java.lang.String The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import org.cdk8s.plus22.EnvValueFromSecretOptions ; EnvValueFromSecretOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import org.cdk8s.plus22.ExposeDeploymentViaIngressOptions ; ExposeDeploymentViaIngressOptions . builder () // .name(java.lang.String) // .port(java.lang.Number) // .protocol(Protocol) // .serviceType(ServiceType) // .targetPort(java.lang.Number) // .ingress(Ingress) // .pathType(HttpIngressPathType) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus22.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 public Ingress getIngress (); Type: org.cdk8s.plus22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public HttpIngressPathType getPathType (); Type: org.cdk8s.plus22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import org.cdk8s.plus22.ExposeDeploymentViaServiceOptions ; ExposeDeploymentViaServiceOptions . builder () // .name(java.lang.String) // .port(java.lang.Number) // .protocol(Protocol) // .serviceType(ServiceType) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus22.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import org.cdk8s.plus22.ExposeServiceViaIngressOptions ; ExposeServiceViaIngressOptions . builder () // .ingress(Ingress) // .pathType(HttpIngressPathType) . build (); ingress Optional \u00b6 public Ingress getIngress (); Type: org.cdk8s.plus22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public HttpIngressPathType getPathType (); Type: org.cdk8s.plus22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import org.cdk8s.plus22.GCEPersistentDiskPersistentVolumeProps ; GCEPersistentDiskPersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . pdName ( java . lang . String ) // .fsType(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 public java . lang . String getPdName (); Type: java.lang.String Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import org.cdk8s.plus22.GCEPersistentDiskVolumeOptions ; GCEPersistentDiskVolumeOptions . builder () // .fsType(java.lang.String) // .name(java.lang.String) // .partition(java.lang.Number) // .readOnly(java.lang.Boolean) . build (); fsType Optional \u00b6 public java . lang . String getFsType (); Type: java.lang.String Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GroupProps \u00b6 Properties for Group . Initializer \u00b6 import org.cdk8s.plus22.GroupProps ; GroupProps . builder () . name ( java . lang . String ) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the group. HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import org.cdk8s.plus22.HandlerFromHttpGetOptions ; HandlerFromHttpGetOptions . builder () // .port(java.lang.Number) . build (); port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import org.cdk8s.plus22.HandlerFromTcpSocketOptions ; HandlerFromTcpSocketOptions . builder () // .host(java.lang.String) // .port(java.lang.Number) . build (); host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import org.cdk8s.plus22.HostAlias ; HostAlias . builder () . hostnames ( java . util . List < java . lang . String > ) . ip ( java . lang . String ) . build (); hostnames Required \u00b6 public java . util . List < java . lang . String > getHostnames (); Type: java.util.List< java.lang.String > Hostnames for the chosen IP address. ip Required \u00b6 public java . lang . String getIp (); Type: java.lang.String IP address of the host file entry. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import org.cdk8s.plus22.HttpGetProbeOptions ; HttpGetProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) // .port(java.lang.Number) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to use when sending the GET request. IngressProps \u00b6 Properties for Ingress . Initializer \u00b6 import org.cdk8s.plus22.IngressProps ; IngressProps . builder () // .metadata(ApiObjectMetadata) // .defaultBackend(IngressBackend) // .rules(java.util.List<IngressRule>) // .tls(java.util.List<IngressTls>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public IngressBackend getDefaultBackend (); Type: org.cdk8s.plus22.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public java . util . List < IngressRule > getRules (); Type: java.util.List< org.cdk8s.plus22.IngressRule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public java . util . List < IngressTls > getTls (); Type: java.util.List< org.cdk8s.plus22.IngressTls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressRule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import org.cdk8s.plus22.IngressRule ; IngressRule . builder () . backend ( IngressBackend ) // .host(java.lang.String) // .path(java.lang.String) // .pathType(HttpIngressPathType) . build (); backend Required \u00b6 public IngressBackend getBackend (); Type: org.cdk8s.plus22.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public java . lang . String getPath (); Type: java.lang.String Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. pathType Optional \u00b6 public HttpIngressPathType getPathType (); Type: org.cdk8s.plus22.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types IngressTls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import org.cdk8s.plus22.IngressTls ; IngressTls . builder () // .hosts(java.util.List<java.lang.String>) // .secret(ISecret) . build (); hosts Optional \u00b6 public java . util . List < java . lang . String > getHosts (); Type: java.util.List< java.lang.String > Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus22.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import org.cdk8s.plus22.JobProps ; JobProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import org.cdk8s.plus22.LabelSelectorRequirement ; LabelSelectorRequirement . builder () . key ( java . lang . String ) . operator ( LabelSelectorRequirementOperator ) // .values(java.util.List<java.lang.String>) . build (); key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String The label key that the selector applies to. operator Required \u00b6 public LabelSelectorRequirementOperator getOperator (); Type: org.cdk8s.plus22.LabelSelectorRequirementOperator Represents a key\u2019s relationship to a set of values. values Optional \u00b6 public java . util . List < java . lang . String > getValues (); Type: java.util.List< java.lang.String > An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import org.cdk8s.plus22.MemoryResources ; MemoryResources . builder () . limit ( Size ) . request ( Size ) . build (); limit Required \u00b6 public Size getLimit (); Type: org.cdk8s.Size request Required \u00b6 public Size getRequest (); Type: org.cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import org.cdk8s.plus22.MountOptions ; MountOptions . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import org.cdk8s.plus22.PathMapping ; PathMapping . builder () . path ( java . lang . String ) // .mode(java.lang.Number) . build (); path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public java . lang . Number getMode (); Type: java.lang.Number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import org.cdk8s.plus22.PersistentVolumeClaimProps ; PersistentVolumeClaimProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .storage(Size) // .storageClassName(java.lang.String) // .volume(IPersistentVolume) // .volumeMode(PersistentVolumeMode) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 public IPersistentVolume getVolume (); Type: org.cdk8s.plus22.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import org.cdk8s.plus22.PersistentVolumeClaimVolumeOptions ; PersistentVolumeClaimVolumeOptions . builder () // .name(java.lang.String) // .readOnly(java.lang.Boolean) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: Derived from the PVC name. The volume name. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import org.cdk8s.plus22.PersistentVolumeProps ; PersistentVolumeProps . builder () // .metadata(ApiObjectMetadata) // .accessModes(java.util.List<PersistentVolumeAccessMode>) // .claim(IPersistentVolumeClaim) // .mountOptions(java.util.List<java.lang.String>) // .reclaimPolicy(PersistentVolumeReclaimPolicy) // .storage(Size) // .storageClassName(java.lang.String) // .volumeMode(PersistentVolumeMode) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public java . util . List < PersistentVolumeAccessMode > getAccessModes (); Type: java.util.List< org.cdk8s.plus22.PersistentVolumeAccessMode > Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public IPersistentVolumeClaim getClaim (); Type: org.cdk8s.plus22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public java . util . List < java . lang . String > getMountOptions (); Type: java.util.List< java.lang.String > Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public PersistentVolumeReclaimPolicy getReclaimPolicy (); Type: org.cdk8s.plus22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public Size getStorage (); Type: org.cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public java . lang . String getStorageClassName (); Type: java.lang.String Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public PersistentVolumeMode getVolumeMode (); Type: org.cdk8s.plus22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import org.cdk8s.plus22.PodDnsProps ; PodDnsProps . builder () // .hostname(java.lang.String) // .hostnameAsFQDN(java.lang.Boolean) // .nameservers(java.util.List<java.lang.String>) // .options(java.util.List<DnsOption>) // .policy(DnsPolicy) // .searches(java.util.List<java.lang.String>) // .subdomain(java.lang.String) . build (); hostname Optional \u00b6 public java . lang . String getHostname (); Type: java.lang.String Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 public java . lang . Boolean getHostnameAsFQDN (); Type: java.lang.Boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 public java . util . List < java . lang . String > getNameservers (); Type: java.util.List< java.lang.String > A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 public java . util . List < DnsOption > getOptions (); Type: java.util.List< org.cdk8s.plus22.DnsOption > List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 public DnsPolicy getPolicy (); Type: org.cdk8s.plus22.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 public java . util . List < java . lang . String > getSearches (); Type: java.util.List< java.lang.String > A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 public java . lang . String getSubdomain (); Type: java.lang.String Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import org.cdk8s.plus22.PodProps ; PodProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import org.cdk8s.plus22.PodSecurityContextProps ; PodSecurityContextProps . builder () // .ensureNonRoot(java.lang.Boolean) // .fsGroup(java.lang.Number) // .fsGroupChangePolicy(FsGroupChangePolicy) // .group(java.lang.Number) // .sysctls(java.util.List<Sysctl>) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 public java . lang . Number getFsGroup (); Type: java.lang.Number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 public FsGroupChangePolicy getFsGroupChangePolicy (); Type: org.cdk8s.plus22.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 public java . util . List < Sysctl > getSysctls (); Type: java.util.List< org.cdk8s.plus22.Sysctl > Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import org.cdk8s.plus22.ProbeOptions ; ProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import org.cdk8s.plus22.ResourceProps ; ResourceProps . builder () // .metadata(ApiObjectMetadata) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import org.cdk8s.plus22.RoleBindingProps ; RoleBindingProps . builder () // .metadata(ApiObjectMetadata) . role ( IRole ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public IRole getRole (); Type: org.cdk8s.plus22.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import org.cdk8s.plus22.RolePolicyRule ; RolePolicyRule . builder () . resources ( java . util . List < IApiResource > ) . verbs ( java . util . List < java . lang . String > ) . build (); resources Required \u00b6 public java . util . List < IApiResource > getResources (); Type: java.util.List< org.cdk8s.plus22.IApiResource > Resources this rule applies to. verbs Required \u00b6 public java . util . List < java . lang . String > getVerbs (); Type: java.util.List< java.lang.String > Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import org.cdk8s.plus22.RoleProps ; RoleProps . builder () // .metadata(ApiObjectMetadata) // .rules(java.util.List<RolePolicyRule>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 public java . util . List < RolePolicyRule > getRules (); Type: java.util.List< org.cdk8s.plus22.RolePolicyRule > Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import org.cdk8s.plus22.SecretProps ; SecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getStringData (); Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public java . lang . String getType (); Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import org.cdk8s.plus22.SecretValue ; SecretValue . builder () . key ( java . lang . String ) . secret ( ISecret ) . build (); key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String The JSON key. secret Required \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus22.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import org.cdk8s.plus22.SecretVolumeOptions ; SecretVolumeOptions . builder () // .defaultMode(java.lang.Number) // .items(java.util.Map<java.lang.String, PathMapping>) // .name(java.lang.String) // .optional(java.lang.Boolean) . build (); defaultMode Optional \u00b6 public java . lang . Number getDefaultMode (); Type: java.lang.Number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public java . util . Map < java . lang . String , PathMapping > getItems (); Type: java.util.Map \u0002klzzwxh:7664\u0003 > Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import org.cdk8s.plus22.ServiceAccountProps ; ServiceAccountProps . builder () // .metadata(ApiObjectMetadata) // .automountToken(java.lang.Boolean) // .secrets(java.util.List<ISecret>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 public java . lang . Boolean getAutomountToken (); Type: java.lang.Boolean Default: true Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus22.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import org.cdk8s.plus22.ServiceAccountTokenSecretProps ; ServiceAccountTokenSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . serviceAccount ( IServiceAccount ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount The service account to store a secret for. ServiceIngressBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import org.cdk8s.plus22.ServiceIngressBackendOptions ; ServiceIngressBackendOptions . builder () // .port(java.lang.Number) . build (); port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import org.cdk8s.plus22.ServicePort ; ServicePort . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . port ( java . lang . Number ) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import org.cdk8s.plus22.ServicePortOptions ; ServicePortOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import org.cdk8s.plus22.ServiceProps ; ServiceProps . builder () // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .type(ServiceType) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public java . util . List < java . lang . String > getExternalIPs (); Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public java . util . List < java . lang . String > getLoadBalancerSourceRanges (); Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus22.ServicePort > The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 public ServiceType getType (); Type: org.cdk8s.plus22.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import org.cdk8s.plus22.SshAuthSecretProps ; SshAuthSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . sshPrivateKey ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 public java . lang . String getSshPrivateKey (); Type: java.lang.String The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import org.cdk8s.plus22.StatefulSetProps ; StatefulSetProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) . service ( Service ) // .minReady(Duration) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) // .strategy(StatefulSetUpdateStrategy) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. service Required \u00b6 public Service getService (); Type: org.cdk8s.plus22.Service Service to associate with the statefulset. minReady Optional \u00b6 public Duration getMinReady (); Type: org.cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds podManagementPolicy Optional \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus22.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. strategy Optional \u00b6 public StatefulSetUpdateStrategy getStrategy (); Type: org.cdk8s.plus22.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import org.cdk8s.plus22.StatefulSetUpdateStrategyRollingUpdateOptions ; StatefulSetUpdateStrategyRollingUpdateOptions . builder () // .partition(java.lang.Number) . build (); partition Optional \u00b6 public java . lang . Number getPartition (); Type: java.lang.Number Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import org.cdk8s.plus22.Sysctl ; Sysctl . builder () . name ( java . lang . String ) . value ( java . lang . String ) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of a property to set. value Required \u00b6 public java . lang . String getValue (); Type: java.lang.String Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import org.cdk8s.plus22.TcpSocketProbeOptions ; TcpSocketProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) // .host(java.lang.String) // .port(java.lang.Number) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import org.cdk8s.plus22.TlsSecretProps ; TlsSecretProps . builder () // .metadata(ApiObjectMetadata) // .immutable(java.lang.Boolean) . tlsCert ( java . lang . String ) . tlsKey ( java . lang . String ) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public java . lang . Boolean getImmutable (); Type: java.lang.Boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 public java . lang . String getTlsCert (); Type: java.lang.String The TLS cert. tlsKey Required \u00b6 public java . lang . String getTlsKey (); Type: java.lang.String The TLS key. UserProps \u00b6 Properties for User . Initializer \u00b6 import org.cdk8s.plus22.UserProps ; UserProps . builder () . name ( java . lang . String ) . build (); name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the user. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import org.cdk8s.plus22.VolumeMount ; VolumeMount . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . path ( java . lang . String ) . volume ( Volume ) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public Volume getVolume (); Type: org.cdk8s.plus22.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import org.cdk8s.plus22.WorkloadProps ; WorkloadProps . builder () // .metadata(ApiObjectMetadata) // .automountServiceAccountToken(java.lang.Boolean) // .containers(java.util.List<ContainerProps>) // .dns(PodDnsProps) // .dockerRegistryAuth(DockerConfigSecret) // .hostAliases(java.util.List<HostAlias>) // .initContainers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .securityContext(PodSecurityContextProps) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .select(java.lang.Boolean) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public java . lang . Boolean getAutomountServiceAccountToken (); Type: java.lang.Boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public PodDnsProps getDns (); Type: org.cdk8s.plus22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public DockerConfigSecret getDockerRegistryAuth (); Type: org.cdk8s.plus22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public java . util . List < HostAlias > getHostAliases (); Type: java.util.List< org.cdk8s.plus22.HostAlias > HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public java . util . List < ContainerProps > getInitContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public PodSecurityContextProps getSecurityContext (); Type: org.cdk8s.plus22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public java . lang . Boolean getSelect (); Type: java.lang.Boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. Classes \u00b6 ApiResource \u00b6 Implements: org.cdk8s.plus22.IApiResource , org.cdk8s.plus22.IApiEndpoint Represents information about an API resource type. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 custom \u00b6 import org.cdk8s.plus22.ApiResource ; ApiResource . custom ( ApiResourceOptions options ) options Required \u00b6 Type: org.cdk8s.plus22.ApiResourceOptions Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Ingress. JOBS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Job. LEASES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: org.cdk8s.plus22.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import org.cdk8s.plus22.Container ; Container . Builder . create () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .env(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .lifecycle(ContainerLifecycle) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .readiness(Probe) // .resources(ContainerResources) // .securityContext(ContainerSecurityContextProps) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 Type: java.lang.String Docker image name. args Optional \u00b6 Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: java.util.Map \u0002klzzwxh:7216\u0003 > Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 Type: org.cdk8s.plus22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: org.cdk8s.plus22.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: org.cdk8s.plus22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: java.lang.Number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: org.cdk8s.plus22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: org.cdk8s.plus22.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 Type: org.cdk8s.plus22.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: org.cdk8s.plus22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 addEnv \u00b6 public addEnv ( java . lang . String name , EnvValue value ) name Required \u00b6 Type: java.lang.String The variable name. value Required \u00b6 Type: org.cdk8s.plus22.EnvValue The variable value. mount \u00b6 public mount ( java . lang . String path , IStorage storage ) public mount ( java . lang . String path , IStorage storage , MountOptions options ) path Required \u00b6 Type: java.lang.String The desired path in the container. storage Required \u00b6 Type: org.cdk8s.plus22.IStorage The storage to mount. options Optional \u00b6 Type: org.cdk8s.plus22.MountOptions Properties \u00b6 env Required \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnv (); Type: java.util.Map \u0002klzzwxh:7161\u0003 > The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String The container image. imagePullPolicy Required \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus22.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public java . util . List < VolumeMount > getMounts (); Type: java.util.List< org.cdk8s.plus22.VolumeMount > Volume mounts configured for this container. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the container. securityContext Required \u00b6 public ContainerSecurityContext getSecurityContext (); Type: org.cdk8s.plus22.ContainerSecurityContext The security context of the container. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Arguments to the entrypoint. command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Entrypoint array (the command to execute when the container starts). port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port this container exposes. resources Optional \u00b6 public ContainerResources getResources (); Type: org.cdk8s.plus22.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import org.cdk8s.plus22.ContainerSecurityContext ; ContainerSecurityContext . Builder . create () // .ensureNonRoot(java.lang.Boolean) // .group(java.lang.Number) // .privileged(java.lang.Boolean) // .readOnlyRootFilesystem(java.lang.Boolean) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 Type: java.lang.Boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. privileged Optional \u00b6 Type: java.lang.Boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 Type: java.lang.Boolean Default: false Whether this container has a read-only root filesystem. user Optional \u00b6 Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensureNonRoot Required \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean privileged Required \u00b6 public java . lang . Boolean getPrivileged (); Type: java.lang.Boolean readOnlyRootFilesystem Required \u00b6 public java . lang . Boolean getReadOnlyRootFilesystem (); Type: java.lang.Boolean group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import org.cdk8s.plus22.Cpu ; Cpu . millis ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number units \u00b6 import org.cdk8s.plus22.Cpu ; Cpu . units ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number Properties \u00b6 amount Required \u00b6 public java . lang . String getAmount (); Type: java.lang.String DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import org.cdk8s.plus22.DeploymentStrategy ; DeploymentStrategy . recreate () rollingUpdate \u00b6 import org.cdk8s.plus22.DeploymentStrategy ; DeploymentStrategy . rollingUpdate () DeploymentStrategy . rollingUpdate ( DeploymentStrategyRollingUpdateOptions options ) options Optional \u00b6 Type: org.cdk8s.plus22.DeploymentStrategyRollingUpdateOptions EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus22.EnvValue ; EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key ) EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key , EnvValueFromConfigMapOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus22.IConfigMap The config map. key Required \u00b6 Type: java.lang.String The key to extract the value from. options Optional \u00b6 Type: org.cdk8s.plus22.EnvValueFromConfigMapOptions Additional options. fromFieldRef \u00b6 import org.cdk8s.plus22.EnvValue ; EnvValue . fromFieldRef ( EnvFieldPaths fieldPath ) EnvValue . fromFieldRef ( EnvFieldPaths fieldPath , EnvValueFromFieldRefOptions options ) fieldPath Required \u00b6 Type: org.cdk8s.plus22.EnvFieldPaths : The field reference. options Optional \u00b6 Type: org.cdk8s.plus22.EnvValueFromFieldRefOptions : Additional options. fromProcess \u00b6 import org.cdk8s.plus22.EnvValue ; EnvValue . fromProcess ( java . lang . String key ) EnvValue . fromProcess ( java . lang . String key , EnvValueFromProcessOptions options ) key Required \u00b6 Type: java.lang.String The key to read. options Optional \u00b6 Type: org.cdk8s.plus22.EnvValueFromProcessOptions Additional options. fromResource \u00b6 import org.cdk8s.plus22.EnvValue ; EnvValue . fromResource ( ResourceFieldPaths resource ) EnvValue . fromResource ( ResourceFieldPaths resource , EnvValueFromResourceOptions options ) resource Required \u00b6 Type: org.cdk8s.plus22.ResourceFieldPaths : Resource to select the value from. options Optional \u00b6 Type: org.cdk8s.plus22.EnvValueFromResourceOptions : Additional options. fromSecretValue \u00b6 import org.cdk8s.plus22.EnvValue ; EnvValue . fromSecretValue ( SecretValue secretValue ) EnvValue . fromSecretValue ( SecretValue secretValue , EnvValueFromSecretOptions options ) secretValue Required \u00b6 Type: org.cdk8s.plus22.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: org.cdk8s.plus22.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import org.cdk8s.plus22.EnvValue ; EnvValue . fromValue ( java . lang . String value ) value Required \u00b6 Type: java.lang.String The value. Properties \u00b6 value Optional \u00b6 public java . lang . Object getValue (); Type: java.lang.Object valueFrom Optional \u00b6 public java . lang . Object getValueFrom (); Type: java.lang.Object Group \u00b6 Implements: org.cdk8s.plus22.ISubject Represents a group. Initializers \u00b6 import org.cdk8s.plus22.Group ; Group . Builder . create () . name ( java . lang . String ) . build (); name Required \u00b6 Type: java.lang.String The name of the group. Properties \u00b6 kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of the object being referenced. apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 fromCommand \u00b6 import org.cdk8s.plus22.Handler ; Handler . fromCommand ( java . util . List < java . lang . String > command ) command Required \u00b6 Type: java.util.List< java.lang.String > The command to execute. fromHttpGet \u00b6 import org.cdk8s.plus22.Handler ; Handler . fromHttpGet ( java . lang . String path ) Handler . fromHttpGet ( java . lang . String path , HandlerFromHttpGetOptions options ) path Required \u00b6 Type: java.lang.String The URL path to hit. options Optional \u00b6 Type: org.cdk8s.plus22.HandlerFromHttpGetOptions Options. fromTcpSocket \u00b6 import org.cdk8s.plus22.Handler ; Handler . fromTcpSocket () Handler . fromTcpSocket ( HandlerFromTcpSocketOptions options ) options Optional \u00b6 Type: org.cdk8s.plus22.HandlerFromTcpSocketOptions Options. IngressBackend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromService \u00b6 import org.cdk8s.plus22.IngressBackend ; IngressBackend . fromService ( Service serv ) IngressBackend . fromService ( Service serv , ServiceIngressBackendOptions options ) serv Required \u00b6 Type: org.cdk8s.plus22.Service The service object. options Optional \u00b6 Type: org.cdk8s.plus22.ServiceIngressBackendOptions LabelSelector \u00b6 A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors Static Functions \u00b6 doesNotExist \u00b6 import org.cdk8s.plus22.LabelSelector ; LabelSelector . doesNotExist ( java . lang . String key ) key Required \u00b6 Type: java.lang.String exists \u00b6 import org.cdk8s.plus22.LabelSelector ; LabelSelector . exists ( java . lang . String key ) key Required \u00b6 Type: java.lang.String in \u00b6 import org.cdk8s.plus22.LabelSelector ; LabelSelector . in ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > is \u00b6 import org.cdk8s.plus22.LabelSelector ; LabelSelector . is ( java . lang . String key , java . lang . String value ) LabelSelector . is ( java . lang . String key , java . lang . String value , java . lang . Boolean applyToTemplate ) key Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.String applyToTemplate Optional \u00b6 Type: java.lang.Boolean notIn \u00b6 import org.cdk8s.plus22.LabelSelector ; LabelSelector . notIn ( java . lang . String key , java . util . List < java . lang . String > values ) key Required \u00b6 Type: java.lang.String values Required \u00b6 Type: java.util.List< java.lang.String > Properties \u00b6 applyToTemplate Required \u00b6 public java . lang . Boolean getApplyToTemplate (); Type: java.lang.Boolean key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String operator Optional \u00b6 public LabelSelectorRequirementOperator getOperator (); Type: org.cdk8s.plus22.LabelSelectorRequirementOperator values Optional \u00b6 public java . util . List < java . lang . String > getValues (); Type: java.util.List< java.lang.String > NonApiResource \u00b6 Implements: org.cdk8s.plus22.IApiEndpoint Factory for creating non api resources. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 of \u00b6 import org.cdk8s.plus22.NonApiResource ; NonApiResource . of ( java . lang . String url ) url Required \u00b6 Type: java.lang.String PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 isZero \u00b6 public isZero () Static Functions \u00b6 absolute \u00b6 import org.cdk8s.plus22.PercentOrAbsolute ; PercentOrAbsolute . absolute ( java . lang . Number num ) num Required \u00b6 Type: java.lang.Number percent \u00b6 import org.cdk8s.plus22.PercentOrAbsolute ; PercentOrAbsolute . percent ( java . lang . Number percent ) percent Required \u00b6 Type: java.lang.Number Properties \u00b6 value Required \u00b6 public java . lang . Object getValue (); Type: java.lang.Object PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import org.cdk8s.plus22.PodDns ; PodDns . Builder . create () // .hostname(java.lang.String) // .hostnameAsFQDN(java.lang.Boolean) // .nameservers(java.util.List<java.lang.String>) // .options(java.util.List<DnsOption>) // .policy(DnsPolicy) // .searches(java.util.List<java.lang.String>) // .subdomain(java.lang.String) . build (); hostname Optional \u00b6 Type: java.lang.String Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 Type: java.lang.Boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 Type: java.util.List< java.lang.String > A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.DnsOption > List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 Type: org.cdk8s.plus22.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 Type: java.util.List< java.lang.String > A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 Type: java.lang.String Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. Methods \u00b6 addNameserver \u00b6 public addNameserver ( java . lang . String nameservers ) nameservers Required \u00b6 Type: java.lang.String addOption \u00b6 public addOption ( DnsOption options ) options Required \u00b6 Type: org.cdk8s.plus22.DnsOption addSearch \u00b6 public addSearch ( java . lang . String searches ) searches Required \u00b6 Type: java.lang.String Properties \u00b6 hostnameAsFQDN Required \u00b6 public java . lang . Boolean getHostnameAsFQDN (); Type: java.lang.Boolean Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 public java . util . List < java . lang . String > getNameservers (); Type: java.util.List< java.lang.String > Nameservers defined for this pod. options Required \u00b6 public java . util . List < DnsOption > getOptions (); Type: java.util.List< org.cdk8s.plus22.DnsOption > Custom dns options defined for this pod. policy Required \u00b6 public DnsPolicy getPolicy (); Type: org.cdk8s.plus22.DnsPolicy The DNS policy of this pod. searches Required \u00b6 public java . util . List < java . lang . String > getSearches (); Type: java.util.List< java.lang.String > Search domains defined for this pod. hostname Optional \u00b6 public java . lang . String getHostname (); Type: java.lang.String The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 public java . lang . String getSubdomain (); Type: java.lang.String The configured subdomain of the pod. PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import org.cdk8s.plus22.PodSecurityContext ; PodSecurityContext . Builder . create () // .ensureNonRoot(java.lang.Boolean) // .fsGroup(java.lang.Number) // .fsGroupChangePolicy(FsGroupChangePolicy) // .group(java.lang.Number) // .sysctls(java.util.List<Sysctl>) // .user(java.lang.Number) . build (); ensureNonRoot Optional \u00b6 Type: java.lang.Boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 Type: java.lang.Number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 Type: org.cdk8s.plus22.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 Type: java.lang.Number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Sysctl > Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 Type: java.lang.Number Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensureNonRoot Required \u00b6 public java . lang . Boolean getEnsureNonRoot (); Type: java.lang.Boolean fsGroupChangePolicy Required \u00b6 public FsGroupChangePolicy getFsGroupChangePolicy (); Type: org.cdk8s.plus22.FsGroupChangePolicy sysctls Required \u00b6 public java . util . List < Sysctl > getSysctls (); Type: java.util.List< org.cdk8s.plus22.Sysctl > fsGroup Optional \u00b6 public java . lang . Number getFsGroup (); Type: java.lang.Number group Optional \u00b6 public java . lang . Number getGroup (); Type: java.lang.Number user Optional \u00b6 public java . lang . Number getUser (); Type: java.lang.Number Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 fromCommand \u00b6 import org.cdk8s.plus22.Probe ; Probe . fromCommand ( java . util . List < java . lang . String > command ) Probe . fromCommand ( java . util . List < java . lang . String > command , CommandProbeOptions options ) command Required \u00b6 Type: java.util.List< java.lang.String > The command to execute. options Optional \u00b6 Type: org.cdk8s.plus22.CommandProbeOptions Options. fromHttpGet \u00b6 import org.cdk8s.plus22.Probe ; Probe . fromHttpGet ( java . lang . String path ) Probe . fromHttpGet ( java . lang . String path , HttpGetProbeOptions options ) path Required \u00b6 Type: java.lang.String The URL path to hit. options Optional \u00b6 Type: org.cdk8s.plus22.HttpGetProbeOptions Options. fromTcpSocket \u00b6 import org.cdk8s.plus22.Probe ; Probe . fromTcpSocket () Probe . fromTcpSocket ( TcpSocketProbeOptions options ) options Optional \u00b6 Type: org.cdk8s.plus22.TcpSocketProbeOptions Options. StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 onDelete \u00b6 import org.cdk8s.plus22.StatefulSetUpdateStrategy ; StatefulSetUpdateStrategy . onDelete () rollingUpdate \u00b6 import org.cdk8s.plus22.StatefulSetUpdateStrategy ; StatefulSetUpdateStrategy . rollingUpdate () StatefulSetUpdateStrategy . rollingUpdate ( StatefulSetUpdateStrategyRollingUpdateOptions options ) options Optional \u00b6 Type: org.cdk8s.plus22.StatefulSetUpdateStrategyRollingUpdateOptions User \u00b6 Implements: org.cdk8s.plus22.ISubject Represents a user. Initializers \u00b6 import org.cdk8s.plus22.User ; User . Builder . create () . name ( java . lang . String ) . build (); name Required \u00b6 Type: java.lang.String The name of the user. Properties \u00b6 kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of the object being referenced. apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Volume \u00b6 Implements: org.cdk8s.plus22.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 asVolume \u00b6 public asVolume () Static Functions \u00b6 fromAwsElasticBlockStore \u00b6 import org.cdk8s.plus22.Volume ; Volume . fromAwsElasticBlockStore ( java . lang . String volumeId ) Volume . fromAwsElasticBlockStore ( java . lang . String volumeId , AwsElasticBlockStoreVolumeOptions options ) volumeId Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus22.AwsElasticBlockStoreVolumeOptions fromAzureDisk \u00b6 import org.cdk8s.plus22.Volume ; Volume . fromAzureDisk ( java . lang . String diskName , java . lang . String diskUri ) Volume . fromAzureDisk ( java . lang . String diskName , java . lang . String diskUri , AzureDiskVolumeOptions options ) diskName Required \u00b6 Type: java.lang.String diskUri Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus22.AzureDiskVolumeOptions fromConfigMap \u00b6 import org.cdk8s.plus22.Volume ; Volume . fromConfigMap ( IConfigMap configMap ) Volume . fromConfigMap ( IConfigMap configMap , ConfigMapVolumeOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus22.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: org.cdk8s.plus22.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import org.cdk8s.plus22.Volume ; Volume . fromEmptyDir ( java . lang . String name ) Volume . fromEmptyDir ( java . lang . String name , EmptyDirVolumeOptions options ) name Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus22.EmptyDirVolumeOptions Additional options. fromGcePersistentDisk \u00b6 import org.cdk8s.plus22.Volume ; Volume . fromGcePersistentDisk ( java . lang . String pdName ) Volume . fromGcePersistentDisk ( java . lang . String pdName , GCEPersistentDiskVolumeOptions options ) pdName Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus22.GCEPersistentDiskVolumeOptions fromPersistentVolumeClaim \u00b6 import org.cdk8s.plus22.Volume ; Volume . fromPersistentVolumeClaim ( IPersistentVolumeClaim claim ) Volume . fromPersistentVolumeClaim ( IPersistentVolumeClaim claim , PersistentVolumeClaimVolumeOptions options ) claim Required \u00b6 Type: org.cdk8s.plus22.IPersistentVolumeClaim options Optional \u00b6 Type: org.cdk8s.plus22.PersistentVolumeClaimVolumeOptions fromSecret \u00b6 import org.cdk8s.plus22.Volume ; Volume . fromSecret ( ISecret secr ) Volume . fromSecret ( ISecret secr , SecretVolumeOptions options ) secr Required \u00b6 Type: org.cdk8s.plus22.ISecret The secret to use to populate the volume. options Optional \u00b6 Type: org.cdk8s.plus22.SecretVolumeOptions Options. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.ApiResource , org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.BasicAuthSecret , org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.ClusterRoleBinding , org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.DockerConfigSecret , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.Ingress , org.cdk8s.plus22.Job , org.cdk8s.plus22.NonApiResource , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.PersistentVolumeClaim , org.cdk8s.plus22.Pod , org.cdk8s.plus22.Resource , org.cdk8s.plus22.Role , org.cdk8s.plus22.RoleBinding , org.cdk8s.plus22.Secret , org.cdk8s.plus22.Service , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.ServiceAccountTokenSecret , org.cdk8s.plus22.SshAuthSecret , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.TlsSecret , org.cdk8s.plus22.Workload , org.cdk8s.plus22.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () IApiResource \u00b6 Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.ApiResource , org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.BasicAuthSecret , org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.ClusterRoleBinding , org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.DockerConfigSecret , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.Ingress , org.cdk8s.plus22.Job , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.PersistentVolumeClaim , org.cdk8s.plus22.Pod , org.cdk8s.plus22.Resource , org.cdk8s.plus22.Role , org.cdk8s.plus22.RoleBinding , org.cdk8s.plus22.Secret , org.cdk8s.plus22.Service , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.ServiceAccountTokenSecret , org.cdk8s.plus22.SshAuthSecret , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.TlsSecret , org.cdk8s.plus22.Workload , org.cdk8s.plus22.IApiResource Represents a resource or collection of resources. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public java . lang . String getResourceType (); Type: java.lang.String The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resourceName Optional \u00b6 public java . lang . String getResourceName (); Type: java.lang.String The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.IClusterRole Represents a cluster-level role. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IConfigMap \u00b6 Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.IConfigMap Represents a config map. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IPersistentVolume \u00b6 Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.PersistentVolumeClaim , org.cdk8s.plus22.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IResource \u00b6 Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.BasicAuthSecret , org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.ClusterRoleBinding , org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.DockerConfigSecret , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.Ingress , org.cdk8s.plus22.Job , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.PersistentVolumeClaim , org.cdk8s.plus22.Pod , org.cdk8s.plus22.Resource , org.cdk8s.plus22.Role , org.cdk8s.plus22.RoleBinding , org.cdk8s.plus22.Secret , org.cdk8s.plus22.Service , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.ServiceAccountTokenSecret , org.cdk8s.plus22.SshAuthSecret , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.TlsSecret , org.cdk8s.plus22.Workload , org.cdk8s.plus22.IClusterRole , org.cdk8s.plus22.IConfigMap , org.cdk8s.plus22.IPersistentVolume , org.cdk8s.plus22.IPersistentVolumeClaim , org.cdk8s.plus22.IResource , org.cdk8s.plus22.IRole , org.cdk8s.plus22.ISecret , org.cdk8s.plus22.IServiceAccount Represents a resource. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IRole \u00b6 Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.Role , org.cdk8s.plus22.IRole A reference to any Role or ClusterRole. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. ISecret \u00b6 Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.BasicAuthSecret , org.cdk8s.plus22.DockerConfigSecret , org.cdk8s.plus22.Secret , org.cdk8s.plus22.ServiceAccountTokenSecret , org.cdk8s.plus22.SshAuthSecret , org.cdk8s.plus22.TlsSecret , org.cdk8s.plus22.ISecret Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.IServiceAccount Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IStorage \u00b6 Implemented By: org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.Volume , org.cdk8s.plus22.IStorage Represents a piece of storage in the cluster. Methods \u00b6 asVolume \u00b6 public asVolume () ISubject \u00b6 Implemented By: org.cdk8s.plus22.Group , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.User , org.cdk8s.plus22.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Properties \u00b6 kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of the object being referenced. apiGroup Optional \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. HttpIngressPathType \u00b6 Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types PREFIX \u00b6 Matches the URL path exactly. EXACT \u00b6 Matches based on a URL path prefix split by \u2018/\u2019. IMPLEMENTATION_SPECIFIC \u00b6 Matching is specified by the underlying IngressClass. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. LabelSelectorRequirementOperator \u00b6 Possible operators. IN \u00b6 In. NOT_IN \u00b6 NotIn. EXISTS \u00b6 Exists. DOES_NOT_EXIST \u00b6 DoesNotExist. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"Java"},{"location":"reference/cdk8s-plus-22/java/#cdk8s-plus-22-java","text":"","title":"cdk8s-plus-22 (Java) "},{"location":"reference/cdk8s-plus-22/java/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-22/java/#abstractpod","text":"","title":"AbstractPod "},{"location":"reference/cdk8s-plus-22/java/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-22/java/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-22/java/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-22/java/#clusterrole","text":"Implements: org.cdk8s.plus22.IClusterRole , org.cdk8s.plus22.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-22/java/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-22/java/#configmap","text":"Implements: org.cdk8s.plus22.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-22/java/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-22/java/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-22/java/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-22/java/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-22/java/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-22/java/#ingress","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"Ingress "},{"location":"reference/cdk8s-plus-22/java/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-22/java/#persistentvolume","text":"Implements: org.cdk8s.plus22.IPersistentVolume , org.cdk8s.plus22.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-22/java/#persistentvolumeclaim","text":"Implements: org.cdk8s.plus22.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-22/java/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-22/java/#resource","text":"Implements: org.cdk8s.plus22.IResource , org.cdk8s.plus22.IApiResource , org.cdk8s.plus22.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-22/java/#role","text":"Implements: org.cdk8s.plus22.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-22/java/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-22/java/#secret","text":"Implements: org.cdk8s.plus22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-22/java/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-22/java/#serviceaccount","text":"Implements: org.cdk8s.plus22.IServiceAccount , org.cdk8s.plus22.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-22/java/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-22/java/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-22/java/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-22/java/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-22/java/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-22/java/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-22/java/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-22/java/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-22/java/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-22/java/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-22/java/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-22/java/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/java/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-22/java/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/java/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-22/java/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-22/java/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-22/java/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-22/java/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-22/java/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-22/java/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-22/java/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-22/java/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-22/java/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-22/java/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-22/java/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-22/java/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-22/java/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-22/java/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-22/java/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-22/java/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-22/java/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-22/java/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-22/java/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-22/java/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-22/java/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-22/java/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-22/java/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-22/java/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-22/java/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-22/java/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-22/java/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-22/java/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/java/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-22/java/#groupprops","text":"Properties for Group .","title":"GroupProps "},{"location":"reference/cdk8s-plus-22/java/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-22/java/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-22/java/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-22/java/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-22/java/#ingressprops","text":"Properties for Ingress .","title":"IngressProps "},{"location":"reference/cdk8s-plus-22/java/#ingressrule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressRule "},{"location":"reference/cdk8s-plus-22/java/#ingresstls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressTls "},{"location":"reference/cdk8s-plus-22/java/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-22/java/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-22/java/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-22/java/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-22/java/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-22/java/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-22/java/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-22/java/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/java/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-22/java/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-22/java/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-22/java/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-22/java/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-22/java/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-22/java/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-22/java/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-22/java/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-22/java/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-22/java/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-22/java/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-22/java/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-22/java/#serviceingressbackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressBackendOptions "},{"location":"reference/cdk8s-plus-22/java/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-22/java/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-22/java/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-22/java/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-22/java/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-22/java/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-22/java/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-22/java/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-22/java/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-22/java/#userprops","text":"Properties for User .","title":"UserProps "},{"location":"reference/cdk8s-plus-22/java/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-22/java/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-22/java/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-22/java/#apiresource","text":"Implements: org.cdk8s.plus22.IApiResource , org.cdk8s.plus22.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-22/java/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-22/java/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-22/java/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-22/java/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-22/java/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-22/java/#group","text":"Implements: org.cdk8s.plus22.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-22/java/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-22/java/#ingressbackend","text":"The backend for an ingress path.","title":"IngressBackend "},{"location":"reference/cdk8s-plus-22/java/#labelselector","text":"A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors","title":"LabelSelector "},{"location":"reference/cdk8s-plus-22/java/#nonapiresource","text":"Implements: org.cdk8s.plus22.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-22/java/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-22/java/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-22/java/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-22/java/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-22/java/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-22/java/#user","text":"Implements: org.cdk8s.plus22.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-22/java/#volume","text":"Implements: org.cdk8s.plus22.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-22/java/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-22/java/#iapiendpoint","text":"Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.ApiResource , org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.BasicAuthSecret , org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.ClusterRoleBinding , org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.DockerConfigSecret , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.Ingress , org.cdk8s.plus22.Job , org.cdk8s.plus22.NonApiResource , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.PersistentVolumeClaim , org.cdk8s.plus22.Pod , org.cdk8s.plus22.Resource , org.cdk8s.plus22.Role , org.cdk8s.plus22.RoleBinding , org.cdk8s.plus22.Secret , org.cdk8s.plus22.Service , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.ServiceAccountTokenSecret , org.cdk8s.plus22.SshAuthSecret , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.TlsSecret , org.cdk8s.plus22.Workload , org.cdk8s.plus22.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-22/java/#iapiresource","text":"Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.ApiResource , org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.BasicAuthSecret , org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.ClusterRoleBinding , org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.DockerConfigSecret , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.Ingress , org.cdk8s.plus22.Job , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.PersistentVolumeClaim , org.cdk8s.plus22.Pod , org.cdk8s.plus22.Resource , org.cdk8s.plus22.Role , org.cdk8s.plus22.RoleBinding , org.cdk8s.plus22.Secret , org.cdk8s.plus22.Service , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.ServiceAccountTokenSecret , org.cdk8s.plus22.SshAuthSecret , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.TlsSecret , org.cdk8s.plus22.Workload , org.cdk8s.plus22.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-22/java/#iclusterrole","text":"Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-22/java/#iconfigmap","text":"Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-22/java/#ipersistentvolume","text":"Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-22/java/#ipersistentvolumeclaim","text":"Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.PersistentVolumeClaim , org.cdk8s.plus22.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-22/java/#iresource","text":"Implemented By: org.cdk8s.plus22.AbstractPod , org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.BasicAuthSecret , org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.ClusterRoleBinding , org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.DaemonSet , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.DockerConfigSecret , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.Ingress , org.cdk8s.plus22.Job , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.PersistentVolumeClaim , org.cdk8s.plus22.Pod , org.cdk8s.plus22.Resource , org.cdk8s.plus22.Role , org.cdk8s.plus22.RoleBinding , org.cdk8s.plus22.Secret , org.cdk8s.plus22.Service , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.ServiceAccountTokenSecret , org.cdk8s.plus22.SshAuthSecret , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.TlsSecret , org.cdk8s.plus22.Workload , org.cdk8s.plus22.IClusterRole , org.cdk8s.plus22.IConfigMap , org.cdk8s.plus22.IPersistentVolume , org.cdk8s.plus22.IPersistentVolumeClaim , org.cdk8s.plus22.IResource , org.cdk8s.plus22.IRole , org.cdk8s.plus22.ISecret , org.cdk8s.plus22.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-22/java/#irole","text":"Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ClusterRole , org.cdk8s.plus22.Role , org.cdk8s.plus22.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-22/java/#isecret","text":"Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.BasicAuthSecret , org.cdk8s.plus22.DockerConfigSecret , org.cdk8s.plus22.Secret , org.cdk8s.plus22.ServiceAccountTokenSecret , org.cdk8s.plus22.SshAuthSecret , org.cdk8s.plus22.TlsSecret , org.cdk8s.plus22.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-22/java/#iserviceaccount","text":"Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-22/java/#istorage","text":"Implemented By: org.cdk8s.plus22.AwsElasticBlockStorePersistentVolume , org.cdk8s.plus22.AzureDiskPersistentVolume , org.cdk8s.plus22.GCEPersistentDiskPersistentVolume , org.cdk8s.plus22.PersistentVolume , org.cdk8s.plus22.Volume , org.cdk8s.plus22.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-22/java/#isubject","text":"Implemented By: org.cdk8s.plus22.Group , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.User , org.cdk8s.plus22.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"ISubject "},{"location":"reference/cdk8s-plus-22/java/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-22/java/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-22/java/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-22/java/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-22/java/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-22/java/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-22/java/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-22/java/#httpingresspathtype","text":"Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types","title":"HttpIngressPathType "},{"location":"reference/cdk8s-plus-22/java/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-22/java/#labelselectorrequirementoperator","text":"Possible operators.","title":"LabelSelectorRequirementOperator "},{"location":"reference/cdk8s-plus-22/java/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-22/java/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-22/java/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-22/java/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-22/java/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-22/java/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-22/java/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-22/java/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-22/java/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-22/python/","text":"cdk8s-plus-22 (Python) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AbstractPod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_22.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_22.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_22.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_22.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_host_alias \u00b6 def add_host_alias ( hostnames : typing . List [ str ], ip : str ) hostnames Required \u00b6 Type: typing.List[ str ] Hostnames for the chosen IP address. ip Required \u00b6 Type: str IP address of the host file entry. add_init_container \u00b6 def add_init_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_22.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_22.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_22.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_22.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( vol : Volume ) vol Required \u00b6 Type: cdk8s_plus_22.Volume Properties \u00b6 automount_service_account_token Required \u00b6 automount_service_account_token : bool Type: bool containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_22.Container ] dns Required \u00b6 dns : PodDns Type: cdk8s_plus_22.PodDns host_aliases Required \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_22.HostAlias ] init_containers Required \u00b6 init_containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_22.Container ] security_context Required \u00b6 security_context : PodSecurityContext Type: cdk8s_plus_22.PodSecurityContext volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_22.DockerConfigSecret restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AwsElasticBlockStorePersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , volume_id : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volume_id Required \u00b6 Type: str Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. volume_id Required \u00b6 volume_id : str Type: str Volume id of this volume. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AzureDiskPersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. disk_name Required \u00b6 Type: str The Name of the data disk in the blob storage. disk_uri Required \u00b6 Type: str The URI the data disk in the blob storage. caching_mode Optional \u00b6 Type: cdk8s_plus_22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: cdk8s_plus_22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. read_only Optional \u00b6 Type: bool Default: false Force the ReadOnly setting in VolumeMounts. Properties \u00b6 azure_kind Required \u00b6 azure_kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_22.AzureDiskPersistentVolumeKind Azure kind of this volume. caching_mode Required \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_22.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. disk_name Required \u00b6 disk_name : str Type: str Disk name of this volume. disk_uri Required \u00b6 disk_uri : str Type: str Disk URI of this volume. fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . BasicAuthSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , password : str , username : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 Type: str The password or token for authentication. username Required \u00b6 Type: str The user name for authentication. ClusterRole \u00b6 Implements: cdk8s_plus_22.IClusterRole , cdk8s_plus_22.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ClusterRole ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , aggregation_labels : typing . Mapping [ str ] = None , rules : typing . List [ ClusterRolePolicyRule ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregation_labels Optional \u00b6 Type: typing.Mapping[ str ] Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ClusterRolePolicyRule ] Default: [] A list of rules the role should allow. Methods \u00b6 aggregate \u00b6 def aggregate ( key : str , value : str ) key Required \u00b6 Type: str value Required \u00b6 Type: str allow \u00b6 def allow ( verbs : typing . List [ str ], endpoints : IApiEndpoint ) verbs Required \u00b6 Type: typing.List[ str ] endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The endpoints(s) to apply to. allow_create \u00b6 def allow_create ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_delete \u00b6 def allow_delete ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_delete_collection \u00b6 def allow_delete_collection ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_get \u00b6 def allow_get ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_list \u00b6 def allow_list ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_patch \u00b6 def allow_patch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_read \u00b6 def allow_read ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_read_write \u00b6 def allow_read_write ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_update \u00b6 def allow_update ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. allow_watch \u00b6 def allow_watch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s_plus_22.IApiEndpoint The resource(s) to apply to. bind \u00b6 def bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_22.ISubject a list of subjects to bind to. bind_in_namespace \u00b6 def bind_in_namespace ( namespace : str , subjects : ISubject ) namespace Required \u00b6 Type: str the namespace to limit permissions to. subjects Required \u00b6 Type: cdk8s_plus_22.ISubject a list of subjects to bind to. combine \u00b6 def combine ( rol : ClusterRole ) rol Required \u00b6 Type: cdk8s_plus_22.ClusterRole Static Functions \u00b6 from_cluster_role_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ClusterRole . from_cluster_role_name ( name : str ) name Required \u00b6 Type: str The name of the role resource. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 rules : typing . List [ ClusterRolePolicyRule ] Type: typing.List[ cdk8s_plus_22.ClusterRolePolicyRule ] Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ClusterRoleBinding ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , role : IClusterRole ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: cdk8s_plus_22.IClusterRole The role to bind to. Methods \u00b6 add_subjects \u00b6 def add_subjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_22.ISubject The subjects to add. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 role : IClusterRole Type: cdk8s_plus_22.IClusterRole subjects Required \u00b6 subjects : typing . List [ ISubject ] Type: typing.List[ cdk8s_plus_22.ISubject ] ConfigMap \u00b6 Implements: cdk8s_plus_22.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ConfigMap ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None , immutable : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Methods \u00b6 add_binary_data \u00b6 def add_binary_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_data \u00b6 def add_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_directory \u00b6 def add_directory ( local_dir : str , exclude : typing . List [ str ] = None , key_prefix : str = None ) local_dir Required \u00b6 Type: str A path to a local directory. exclude Optional \u00b6 Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. add_file \u00b6 def add_file ( local_file : str , key : str = None ) local_file Required \u00b6 Type: str The path to the local file. key Optional \u00b6 Type: str The ConfigMap key (default to the file name). Static Functions \u00b6 from_config_map_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ConfigMap . from_config_map_name ( name : str ) name Required \u00b6 Type: str The name of the config map to import. Properties \u00b6 binary_data Required \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 immutable : bool Type: bool Whether or not this config map is immutable. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DaemonSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , min_ready_seconds : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. min_ready_seconds Optional \u00b6 Type: typing.Union[int, float] Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Properties \u00b6 min_ready_seconds Required \u00b6 min_ready_seconds : typing . Union [ int , float ] Type: typing.Union[int, float] resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Deployment ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , min_ready : Duration = None , progress_deadline : Duration = None , replicas : typing . Union [ int , float ] = None , strategy : DeploymentStrategy = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. min_ready Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progress_deadline Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 Type: cdk8s_plus_22.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. Methods \u00b6 expose_via_ingress \u00b6 def expose_via_ingress ( path : str , name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None , ingress : Ingress = None , path_type : HttpIngressPathType = None ) path Required \u00b6 Type: str The ingress path to register under. name Optional \u00b6 Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 Type: cdk8s_plus_22.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 Type: cdk8s_plus_22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 Type: cdk8s_plus_22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. expose_via_service \u00b6 def expose_via_service ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 Type: cdk8s_plus_22.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. Properties \u00b6 min_ready Required \u00b6 min_ready : Duration Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progress_deadline Required \u00b6 progress_deadline : Duration Type: cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 strategy : DeploymentStrategy Type: cdk8s_plus_22.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DockerConfigSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , data : typing . Mapping [ typing . Any ] ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 Type: typing.Mapping[ typing.Any ] JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . GCEPersistentDiskPersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , pd_name : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pd_name Required \u00b6 Type: str Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Properties \u00b6 fs_type Required \u00b6 fs_type : str Type: str File system type of this volume. pd_name Required \u00b6 pd_name : str Type: str PD resource in GCE of this volume. read_only Required \u00b6 read_only : bool Type: bool Whether or not it is mounted as a read-only volume. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Partition of this volume. Ingress \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Ingress ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , default_backend : IngressBackend = None , rules : typing . List [ IngressRule ] = None , tls : typing . List [ IngressTls ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 Type: cdk8s_plus_22.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_22.IngressRule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: typing.List[ cdk8s_plus_22.IngressTls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 add_default_backend \u00b6 def add_default_backend ( backend : IngressBackend ) backend Required \u00b6 Type: cdk8s_plus_22.IngressBackend The backend to use for requests that do not match any rule. add_host_default_backend \u00b6 def add_host_default_backend ( host : str , backend : IngressBackend ) host Required \u00b6 Type: str The host name to match. backend Required \u00b6 Type: cdk8s_plus_22.IngressBackend The backend to route to. add_host_rule \u00b6 def add_host_rule ( host : str , path : str , backend : IngressBackend , path_type : HttpIngressPathType = None ) host Required \u00b6 Type: str The host name. path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_22.IngressBackend The backend to route requests to. path_type Optional \u00b6 Type: cdk8s_plus_22.HttpIngressPathType How the path is matched against request paths. add_rule \u00b6 def add_rule ( path : str , backend : IngressBackend , path_type : HttpIngressPathType = None ) path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_22.IngressBackend The backend to route requests to. path_type Optional \u00b6 Type: cdk8s_plus_22.HttpIngressPathType How the path is matched against request paths. add_rules \u00b6 def add_rules ( backend : IngressBackend , host : str = None , path : str = None , path_type : HttpIngressPathType = None ) backend Required \u00b6 Type: cdk8s_plus_22.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. path_type Optional \u00b6 Type: cdk8s_plus_22.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types add_tls \u00b6 def add_tls ( tls : typing . List [ IngressTls ] ) tls Required \u00b6 Type: typing.List[ cdk8s_plus_22.IngressTls ] Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Job ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. active_deadline Optional \u00b6 Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Number of retries before marking failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration TTL before the job is deleted after it is finished. PersistentVolume \u00b6 Implements: cdk8s_plus_22.IPersistentVolume , cdk8s_plus_22.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PersistentVolume ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 Type: cdk8s_plus_22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 as_volume \u00b6 def as_volume () bind \u00b6 def bind ( claim : IPersistentVolumeClaim ) claim Required \u00b6 Type: cdk8s_plus_22.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 def reserve () Static Functions \u00b6 from_persistent_volume_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PersistentVolume . from_persistent_volume_name ( volume_name : str ) volume_name Required \u00b6 Type: str The name of the pv to reference. Properties \u00b6 mode Required \u00b6 mode : PersistentVolumeMode Type: cdk8s_plus_22.PersistentVolumeMode Volume mode of this volume. reclaim_policy Required \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Access modes requirement of this claim. claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_22.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Mount options of this volume. storage Optional \u00b6 storage : Size Type: cdk8s.Size Storage size of this volume. storage_class_name Optional \u00b6 storage_class_name : str Type: str Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: cdk8s_plus_22.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PersistentVolumeClaim ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , storage : Size = None , storage_class_name : str = None , volume : IPersistentVolume = None , volume_mode : PersistentVolumeMode = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 Type: str Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 Type: cdk8s_plus_22.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volume_mode Optional \u00b6 Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. Methods \u00b6 bind \u00b6 def bind ( vol : IPersistentVolume ) vol Required \u00b6 Type: cdk8s_plus_22.IPersistentVolume The PV to bind to. Static Functions \u00b6 from_claim_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PersistentVolumeClaim . from_claim_name ( claim_name : str ) claim_name Required \u00b6 Type: str The name of the pvc to reference. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. volume_mode Required \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_22.PersistentVolumeMode Volume mode requirement of this claim. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Access modes requirement of this claim. storage Optional \u00b6 storage : Size Type: cdk8s.Size Storage requirement of this claim. storage_class_name Optional \u00b6 storage_class_name : str Type: str Storage class requirment of this claim. volume Optional \u00b6 volume : IPersistentVolume Type: cdk8s_plus_22.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Pod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Resource \u00b6 Implements: cdk8s_plus_22.IResource , cdk8s_plus_22.IApiResource , cdk8s_plus_22.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Resource ( scope : Construct , id : str , node_factory : INodeFactory = None ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: str The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . node_factory Optional \u00b6 Type: constructs.INodeFactory Default: the default Node is associated A factory for attaching Node s to the construct. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 name : str Type: str The name of this API object. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. resource_name Optional \u00b6 resource_name : str Type: str The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: cdk8s_plus_22.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Role ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , rules : typing . List [ RolePolicyRule ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_22.RolePolicyRule ] Default: [] A list of rules the role should allow. Methods \u00b6 allow \u00b6 def allow ( verbs : typing . List [ str ], resources : IApiResource ) verbs Required \u00b6 Type: typing.List[ str ] resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_create \u00b6 def allow_create ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_delete \u00b6 def allow_delete ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_delete_collection \u00b6 def allow_delete_collection ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_get \u00b6 def allow_get ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_list \u00b6 def allow_list ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_patch \u00b6 def allow_patch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_read \u00b6 def allow_read ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_read_write \u00b6 def allow_read_write ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_update \u00b6 def allow_update ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. allow_watch \u00b6 def allow_watch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s_plus_22.IApiResource The resource(s) to apply to. bind \u00b6 def bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_22.ISubject a list of subjects to bind to. Static Functions \u00b6 from_role_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Role . from_role_name ( name : str ) name Required \u00b6 Type: str The name of the role resource. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 rules : typing . List [ RolePolicyRule ] Type: typing.List[ cdk8s_plus_22.RolePolicyRule ] Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . RoleBinding ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , role : IRole ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 Type: cdk8s_plus_22.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. Methods \u00b6 add_subjects \u00b6 def add_subjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s_plus_22.ISubject The subjects to add. Properties \u00b6 resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 role : IRole Type: cdk8s_plus_22.IRole subjects Required \u00b6 subjects : typing . List [ ISubject ] Type: typing.List[ cdk8s_plus_22.ISubject ] Secret \u00b6 Implements: cdk8s_plus_22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Secret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , string_data : typing . Mapping [ str ] = None , type : str = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. string_data Optional \u00b6 Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 add_string_data \u00b6 def add_string_data ( key : str , value : str ) key Required \u00b6 Type: str Key. value Required \u00b6 Type: str Value. get_string_data \u00b6 def get_string_data ( key : str ) key Required \u00b6 Type: str Key. Static Functions \u00b6 from_secret_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Secret . from_secret_name ( name : str ) name Required \u00b6 Type: str The name of the secret to reference. Properties \u00b6 immutable Required \u00b6 immutable : bool Type: bool Whether or not the secret is immutable. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Service ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: cdk8s_plus_22.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 add_deployment \u00b6 def add_deployment ( depl : Deployment , name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None ) depl Required \u00b6 Type: cdk8s_plus_22.Deployment The deployment to expose. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the first container of the deployment. The port number the service will bind to. add_selector \u00b6 def add_selector ( label : str , value : str ) label Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. expose_via_ingress \u00b6 def expose_via_ingress ( path : str , ingress : Ingress = None , path_type : HttpIngressPathType = None ) path Required \u00b6 Type: str The path to expose the service under. ingress Optional \u00b6 Type: cdk8s_plus_22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 Type: cdk8s_plus_22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. serve \u00b6 def serve ( port : typing . Union [ int , float ], name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) port Required \u00b6 Type: typing.Union[int, float] The port definition. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. Properties \u00b6 ports Required \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_22.ServicePort ] Ports for this service. Use serve() to expose additional service ports. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. selector Required \u00b6 selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] Returns the labels which are used to select pods for this service. type Required \u00b6 type : ServiceType Type: cdk8s_plus_22.ServiceType Determines how the Service is exposed. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str The IP address of the service and is usually assigned randomly by the master. external_name Optional \u00b6 external_name : str Type: str The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s_plus_22.IServiceAccount , cdk8s_plus_22.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceAccount ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_token : bool = None , secrets : typing . List [ ISecret ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_token Optional \u00b6 Type: bool Default: true Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 add_secret \u00b6 def add_secret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s_plus_22.ISecret The secret. Static Functions \u00b6 from_service_account_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceAccount . from_service_account_name ( name : str ) name Required \u00b6 Type: str The name of the service account resource. Properties \u00b6 automount_token Required \u00b6 automount_token : bool Type: bool Whether or not a token is automatically mounted for this service account. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_22.ISecret ] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceAccountTokenSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , service_account : IServiceAccount ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. service_account Required \u00b6 Type: cdk8s_plus_22.IServiceAccount The service account to store a secret for. SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . SshAuthSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , ssh_private_key : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ssh_private_key Required \u00b6 Type: str The SSH private key to use. StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . StatefulSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , service : Service , min_ready : Duration = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None , strategy : StatefulSetUpdateStrategy = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. service Required \u00b6 Type: cdk8s_plus_22.Service Service to associate with the statefulset. min_ready Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds pod_management_policy Optional \u00b6 Type: cdk8s_plus_22.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 Type: cdk8s_plus_22.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. Properties \u00b6 min_ready Required \u00b6 min_ready : Duration Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. pod_management_policy Required \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_22.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 strategy : StatefulSetUpdateStrategy Type: cdk8s_plus_22.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . TlsSecret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , immutable : bool = None , tls_cert : str , tls_key : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tls_cert Required \u00b6 Type: str The TLS cert. tls_key Required \u00b6 Type: str The TLS key. Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Workload ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. Methods \u00b6 select \u00b6 def select ( selectors : LabelSelector ) selectors Required \u00b6 Type: cdk8s_plus_22.LabelSelector Properties \u00b6 match_expressions Required \u00b6 match_expressions : typing . List [ LabelSelectorRequirement ] Type: typing.List[ cdk8s_plus_22.LabelSelectorRequirement ] The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. match_labels Required \u00b6 match_labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AbstractPodProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AddDeploymentOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AddDirectoryOptions ( exclude : typing . List [ str ] = None , key_prefix : str = None ) exclude Optional \u00b6 exclude : typing . List [ str ] Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 key_prefix : str Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ApiResourceOptions ( api_group : str , resource_type : str ) api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AwsElasticBlockStorePersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , volume_id : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volume_id Required \u00b6 volume_id : str Type: str Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AwsElasticBlockStoreVolumeOptions ( fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AzureDiskPersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. disk_name Required \u00b6 disk_name : str Type: str The Name of the data disk in the blob storage. disk_uri Required \u00b6 disk_uri : str Type: str The URI the data disk in the blob storage. caching_mode Optional \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. read_only Optional \u00b6 read_only : bool Type: bool Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AzureDiskVolumeOptions ( caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , name : str = None , read_only : bool = None ) caching_mode Optional \u00b6 caching_mode : AzureDiskPersistentVolumeCachingMode Type: cdk8s_plus_22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 kind : AzureDiskPersistentVolumeKind Type: cdk8s_plus_22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. read_only Optional \u00b6 read_only : bool Type: bool Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . BasicAuthSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , password : str , username : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 password : str Type: str The password or token for authentication. username Required \u00b6 username : str Type: str The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ClusterRoleBindingProps ( metadata : ApiObjectMetadata = None , role : IClusterRole ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 role : IClusterRole Type: cdk8s_plus_22.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ClusterRolePolicyRule ( endpoints : typing . List [ IApiEndpoint ], verbs : typing . List [ str ] ) endpoints Required \u00b6 endpoints : typing . List [ IApiEndpoint ] Type: typing.List[ cdk8s_plus_22.IApiEndpoint ] Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 verbs : typing . List [ str ] Type: typing.List[ str ] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ClusterRoleProps ( metadata : ApiObjectMetadata = None , aggregation_labels : typing . Mapping [ str ] = None , rules : typing . List [ ClusterRolePolicyRule ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregation_labels Optional \u00b6 aggregation_labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 rules : typing . List [ ClusterRolePolicyRule ] Type: typing.List[ cdk8s_plus_22.ClusterRolePolicyRule ] Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . CommandProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . CommonSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ConfigMapProps ( metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None , immutable : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ConfigMapVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 default_mode : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 items : typing . Mapping [ PathMapping ] Type: typing.Mapping[ cdk8s_plus_22.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. optional Optional \u00b6 optional : bool Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ContainerLifecycle ( post_start : Handler = None , pre_stop : Handler = None ) post_start Optional \u00b6 post_start : Handler Type: cdk8s_plus_22.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. pre_stop Optional \u00b6 pre_stop : Handler Type: cdk8s_plus_22.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ContainerProps ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 image : str Type: str Docker image name. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 env : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 lifecycle : ContainerLifecycle Type: cdk8s_plus_22.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 liveness : Probe Type: cdk8s_plus_22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 name : str Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 readiness : Probe Type: cdk8s_plus_22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 resources : ContainerResources Type: cdk8s_plus_22.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 security_context : ContainerSecurityContextProps Type: cdk8s_plus_22.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 startup : Probe Type: cdk8s_plus_22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 volume_mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_22.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 working_dir : str Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ContainerResources ( cpu : CpuResources , memory : MemoryResources ) cpu Required \u00b6 cpu : CpuResources Type: cdk8s_plus_22.CpuResources memory Required \u00b6 memory : MemoryResources Type: cdk8s_plus_22.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ContainerSecurityContextProps ( ensure_non_root : bool = None , group : typing . Union [ int , float ] = None , privileged : bool = None , read_only_root_filesystem : bool = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 ensure_non_root : bool Type: bool Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. privileged Optional \u00b6 privileged : bool Type: bool Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. read_only_root_filesystem Optional \u00b6 read_only_root_filesystem : bool Type: bool Default: false Whether this container has a read-only root filesystem. user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . CpuResources ( limit : Cpu , request : Cpu ) limit Required \u00b6 limit : Cpu Type: cdk8s_plus_22.Cpu request Required \u00b6 request : Cpu Type: cdk8s_plus_22.Cpu DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DaemonSetProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , min_ready_seconds : typing . Union [ int , float ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. min_ready_seconds Optional \u00b6 min_ready_seconds : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DeploymentProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , min_ready : Duration = None , progress_deadline : Duration = None , replicas : typing . Union [ int , float ] = None , strategy : DeploymentStrategy = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. min_ready Optional \u00b6 min_ready : Duration Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progress_deadline Optional \u00b6 progress_deadline : Duration Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 strategy : DeploymentStrategy Type: cdk8s_plus_22.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DeploymentStrategyRollingUpdateOptions ( max_surge : PercentOrAbsolute = None , max_unavailable : PercentOrAbsolute = None ) max_surge Optional \u00b6 max_surge : PercentOrAbsolute Type: cdk8s_plus_22.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. max_unavailable Optional \u00b6 max_unavailable : PercentOrAbsolute Type: cdk8s_plus_22.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DnsOption ( name : str , value : str = None ) name Required \u00b6 name : str Type: str Option name. value Optional \u00b6 value : str Type: str Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DockerConfigSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , data : typing . Mapping [ typing . Any ] ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 data : typing . Mapping [ typing . Any ] Type: typing.Mapping[ typing.Any ] JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EmptyDirVolumeOptions ( medium : EmptyDirMedium = None , size_limit : Size = None ) medium Optional \u00b6 medium : EmptyDirMedium Type: cdk8s_plus_22.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 size_limit : Size Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValueFromConfigMapOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValueFromFieldRefOptions ( api_version : str = None , key : str = None ) api_version Optional \u00b6 api_version : str Type: str Version of the schema the FieldPath is written in terms of. key Optional \u00b6 key : str Type: str The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValueFromProcessOptions ( required : bool = None ) required Optional \u00b6 required : bool Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValueFromResourceOptions ( container : Container = None , divisor : str = None ) container Optional \u00b6 container : Container Type: cdk8s_plus_22.Container The container to select the value from. divisor Optional \u00b6 divisor : str Type: str The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValueFromSecretOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ExposeDeploymentViaIngressOptions ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None , ingress : Ingress = None , path_type : HttpIngressPathType = None ) name Optional \u00b6 name : str Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_22.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 ingress : Ingress Type: cdk8s_plus_22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 path_type : HttpIngressPathType Type: cdk8s_plus_22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ExposeDeploymentViaServiceOptions ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_22.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ExposeServiceViaIngressOptions ( ingress : Ingress = None , path_type : HttpIngressPathType = None ) ingress Optional \u00b6 ingress : Ingress Type: cdk8s_plus_22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 path_type : HttpIngressPathType Type: cdk8s_plus_22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . GCEPersistentDiskPersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None , pd_name : str , fs_type : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pd_name Required \u00b6 pd_name : str Type: str Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . GCEPersistentDiskVolumeOptions ( fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) fs_type Optional \u00b6 fs_type : str Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 read_only : bool Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GroupProps \u00b6 Properties for Group . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . GroupProps ( name : str ) name Required \u00b6 name : str Type: str The name of the group. HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . HandlerFromHttpGetOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . HandlerFromTcpSocketOptions ( host : str = None , port : typing . Union [ int , float ] = None ) host Optional \u00b6 host : str Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . HostAlias ( hostnames : typing . List [ str ], ip : str ) hostnames Required \u00b6 hostnames : typing . List [ str ] Type: typing.List[ str ] Hostnames for the chosen IP address. ip Required \u00b6 ip : str Type: str IP address of the host file entry. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . HttpGetProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. IngressProps \u00b6 Properties for Ingress . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . IngressProps ( metadata : ApiObjectMetadata = None , default_backend : IngressBackend = None , rules : typing . List [ IngressRule ] = None , tls : typing . List [ IngressTls ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 default_backend : IngressBackend Type: cdk8s_plus_22.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 rules : typing . List [ IngressRule ] Type: typing.List[ cdk8s_plus_22.IngressRule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 tls : typing . List [ IngressTls ] Type: typing.List[ cdk8s_plus_22.IngressTls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressRule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . IngressRule ( backend : IngressBackend , host : str = None , path : str = None , path_type : HttpIngressPathType = None ) backend Required \u00b6 backend : IngressBackend Type: cdk8s_plus_22.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 host : str Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 path : str Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. path_type Optional \u00b6 path_type : HttpIngressPathType Type: cdk8s_plus_22.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types IngressTls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . IngressTls ( hosts : typing . List [ str ] = None , secret : ISecret = None ) hosts Optional \u00b6 hosts : typing . List [ str ] Type: typing.List[ str ] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 secret : ISecret Type: cdk8s_plus_22.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . JobProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . LabelSelectorRequirement ( key : str , operator : LabelSelectorRequirementOperator , values : typing . List [ str ] = None ) key Required \u00b6 key : str Type: str The label key that the selector applies to. operator Required \u00b6 operator : LabelSelectorRequirementOperator Type: cdk8s_plus_22.LabelSelectorRequirementOperator Represents a key\u2019s relationship to a set of values. values Optional \u00b6 values : typing . List [ str ] Type: typing.List[ str ] An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . MemoryResources ( limit : Size , request : Size ) limit Required \u00b6 limit : Size Type: cdk8s.Size request Required \u00b6 request : Size Type: cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . MountOptions ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PathMapping ( path : str , mode : typing . Union [ int , float ] = None ) path Required \u00b6 path : str Type: str The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 mode : typing . Union [ int , float ] Type: typing.Union[int, float] Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PersistentVolumeClaimProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , storage : Size = None , storage_class_name : str = None , volume : IPersistentVolume = None , volume_mode : PersistentVolumeMode = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 volume : IPersistentVolume Type: cdk8s_plus_22.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PersistentVolumeClaimVolumeOptions ( name : str = None , read_only : bool = None ) name Optional \u00b6 name : str Type: str Default: Derived from the PVC name. The volume name. read_only Optional \u00b6 read_only : bool Type: bool Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PersistentVolumeProps ( metadata : ApiObjectMetadata = None , access_modes : typing . List [ PersistentVolumeAccessMode ] = None , claim : IPersistentVolumeClaim = None , mount_options : typing . List [ str ] = None , reclaim_policy : PersistentVolumeReclaimPolicy = None , storage : Size = None , storage_class_name : str = None , volume_mode : PersistentVolumeMode = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. access_modes Optional \u00b6 access_modes : typing . List [ PersistentVolumeAccessMode ] Type: typing.List[ cdk8s_plus_22.PersistentVolumeAccessMode ] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 claim : IPersistentVolumeClaim Type: cdk8s_plus_22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mount_options Optional \u00b6 mount_options : typing . List [ str ] Type: typing.List[ str ] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaim_policy Optional \u00b6 reclaim_policy : PersistentVolumeReclaimPolicy Type: cdk8s_plus_22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 storage : Size Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storage_class_name Optional \u00b6 storage_class_name : str Type: str Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volume_mode Optional \u00b6 volume_mode : PersistentVolumeMode Type: cdk8s_plus_22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodDnsProps ( hostname : str = None , hostname_as_fqd_n : bool = None , nameservers : typing . List [ str ] = None , options : typing . List [ DnsOption ] = None , policy : DnsPolicy = None , searches : typing . List [ str ] = None , subdomain : str = None ) hostname Optional \u00b6 hostname : str Type: str Default: Set to a system-defined value. Specifies the hostname of the Pod. hostname_as_fqd_n Optional \u00b6 hostname_as_fqd_n : bool Type: bool Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 nameservers : typing . List [ str ] Type: typing.List[ str ] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 options : typing . List [ DnsOption ] Type: typing.List[ cdk8s_plus_22.DnsOption ] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 policy : DnsPolicy Type: cdk8s_plus_22.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 searches : typing . List [ str ] Type: typing.List[ str ] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 subdomain : str Type: str Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodSecurityContextProps ( ensure_non_root : bool = None , fs_group : typing . Union [ int , float ] = None , fs_group_change_policy : FsGroupChangePolicy = None , group : typing . Union [ int , float ] = None , sysctls : typing . List [ Sysctl ] = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 ensure_non_root : bool Type: bool Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fs_group Optional \u00b6 fs_group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fs_group_change_policy Optional \u00b6 fs_group_change_policy : FsGroupChangePolicy Type: cdk8s_plus_22.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 sysctls : typing . List [ Sysctl ] Type: typing.List[ cdk8s_plus_22.Sysctl ] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ResourceProps ( metadata : ApiObjectMetadata = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . RoleBindingProps ( metadata : ApiObjectMetadata = None , role : IRole ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 role : IRole Type: cdk8s_plus_22.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . RolePolicyRule ( resources : typing . List [ IApiResource ], verbs : typing . List [ str ] ) resources Required \u00b6 resources : typing . List [ IApiResource ] Type: typing.List[ cdk8s_plus_22.IApiResource ] Resources this rule applies to. verbs Required \u00b6 verbs : typing . List [ str ] Type: typing.List[ str ] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . RoleProps ( metadata : ApiObjectMetadata = None , rules : typing . List [ RolePolicyRule ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 rules : typing . List [ RolePolicyRule ] Type: typing.List[ cdk8s_plus_22.RolePolicyRule ] Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . SecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , string_data : typing . Mapping [ str ] = None , type : str = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. string_data Optional \u00b6 string_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 type : str Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . SecretValue ( key : str , secret : ISecret ) key Required \u00b6 key : str Type: str The JSON key. secret Required \u00b6 secret : ISecret Type: cdk8s_plus_22.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . SecretVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 default_mode : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 items : typing . Mapping [ PathMapping ] Type: typing.Mapping[ cdk8s_plus_22.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. optional Optional \u00b6 optional : bool Type: bool Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceAccountProps ( metadata : ApiObjectMetadata = None , automount_token : bool = None , secrets : typing . List [ ISecret ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_token Optional \u00b6 automount_token : bool Type: bool Default: true Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_22.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceAccountTokenSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , service_account : IServiceAccount ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. service_account Required \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount The service account to store a secret for. ServiceIngressBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceIngressBackendOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServicePort ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServicePortOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceProps ( metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 external_i_ps : typing . List [ str ] Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 external_name : str Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 load_balancer_source_ranges : typing . List [ str ] Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_22.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 type : ServiceType Type: cdk8s_plus_22.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . SshAuthSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , ssh_private_key : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ssh_private_key Required \u00b6 ssh_private_key : str Type: str The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . StatefulSetProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None , service : Service , min_ready : Duration = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None , strategy : StatefulSetUpdateStrategy = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. service Required \u00b6 service : Service Type: cdk8s_plus_22.Service Service to associate with the statefulset. min_ready Optional \u00b6 min_ready : Duration Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds pod_management_policy Optional \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_22.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. strategy Optional \u00b6 strategy : StatefulSetUpdateStrategy Type: cdk8s_plus_22.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . StatefulSetUpdateStrategyRollingUpdateOptions ( partition : typing . Union [ int , float ] = None ) partition Optional \u00b6 partition : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Sysctl ( name : str , value : str ) name Required \u00b6 name : str Type: str Name of a property to set. value Required \u00b6 value : str Type: str Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . TcpSocketProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , host : str = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 host : str Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . TlsSecretProps ( metadata : ApiObjectMetadata = None , immutable : bool = None , tls_cert : str , tls_key : str ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 immutable : bool Type: bool Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tls_cert Required \u00b6 tls_cert : str Type: str The TLS cert. tls_key Required \u00b6 tls_key : str Type: str The TLS key. UserProps \u00b6 Properties for User . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . UserProps ( name : str ) name Required \u00b6 name : str Type: str The name of the user. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . VolumeMount ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None , path : str , volume : Volume ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 path : str Type: str Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 volume : Volume Type: cdk8s_plus_22.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . WorkloadProps ( metadata : ApiObjectMetadata = None , automount_service_account_token : bool = None , containers : typing . List [ ContainerProps ] = None , dns : PodDnsProps = None , docker_registry_auth : DockerConfigSecret = None , host_aliases : typing . List [ HostAlias ] = None , init_containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , security_context : PodSecurityContextProps = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , select : bool = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automount_service_account_token Optional \u00b6 automount_service_account_token : bool Type: bool Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 dns : PodDnsProps Type: cdk8s_plus_22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ docker_registry_auth Optional \u00b6 docker_registry_auth : DockerConfigSecret Type: cdk8s_plus_22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. host_aliases Optional \u00b6 host_aliases : typing . List [ HostAlias ] Type: typing.List[ cdk8s_plus_22.HostAlias ] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. init_containers Optional \u00b6 init_containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy security_context Optional \u00b6 security_context : PodSecurityContextProps Type: cdk8s_plus_22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 select : bool Type: bool Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. Classes \u00b6 ApiResource \u00b6 Implements: cdk8s_plus_22.IApiResource , cdk8s_plus_22.IApiEndpoint Represents information about an API resource type. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Static Functions \u00b6 custom \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ApiResource . custom ( api_group : str , resource_type : str ) api_group Required \u00b6 Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Ingress. JOBS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Job. LEASES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: cdk8s_plus_22.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , lifecycle : ContainerLifecycle = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , resources : ContainerResources = None , security_context : ContainerSecurityContextProps = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 Type: cdk8s_plus_22.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 Type: cdk8s_plus_22.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ security_context Optional \u00b6 Type: cdk8s_plus_22.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_22.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 add_env \u00b6 def add_env ( name : str , value : EnvValue ) name Required \u00b6 Type: str The variable name. value Required \u00b6 Type: cdk8s_plus_22.EnvValue The variable value. mount \u00b6 def mount ( path : str , storage : IStorage , propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) path Required \u00b6 Type: str The desired path in the container. storage Required \u00b6 Type: cdk8s_plus_22.IStorage The storage to mount. propagation Optional \u00b6 Type: cdk8s_plus_22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. read_only Optional \u00b6 Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. Properties \u00b6 env Required \u00b6 env : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 image : str Type: str The container image. image_pull_policy Required \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_22.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_22.VolumeMount ] Volume mounts configured for this container. name Required \u00b6 name : str Type: str The name of the container. security_context Required \u00b6 security_context : ContainerSecurityContext Type: cdk8s_plus_22.ContainerSecurityContext The security context of the container. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Arguments to the entrypoint. command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port this container exposes. resources Optional \u00b6 resources : ContainerResources Type: cdk8s_plus_22.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ working_dir Optional \u00b6 working_dir : str Type: str The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ContainerSecurityContext ( ensure_non_root : bool = None , group : typing . Union [ int , float ] = None , privileged : bool = None , read_only_root_filesystem : bool = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 Type: bool Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. privileged Optional \u00b6 Type: bool Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. read_only_root_filesystem Optional \u00b6 Type: bool Default: false Whether this container has a read-only root filesystem. user Optional \u00b6 Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensure_non_root Required \u00b6 ensure_non_root : bool Type: bool privileged Required \u00b6 privileged : bool Type: bool read_only_root_filesystem Required \u00b6 read_only_root_filesystem : bool Type: bool group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Cpu . millis ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] units \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Cpu . units ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] Properties \u00b6 amount Required \u00b6 amount : str Type: str DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DeploymentStrategy . recreate () rolling_update \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DeploymentStrategy . rolling_update ( max_surge : PercentOrAbsolute = None , max_unavailable : PercentOrAbsolute = None ) max_surge Optional \u00b6 Type: cdk8s_plus_22.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. max_unavailable Optional \u00b6 Type: cdk8s_plus_22.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValue . from_config_map ( config_map : IConfigMap , key : str , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_22.IConfigMap The config map. key Required \u00b6 Type: str The key to extract the value from. optional Optional \u00b6 Type: bool Default: false Specify whether the ConfigMap or its key must be defined. from_field_ref \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValue . from_field_ref ( field_path : EnvFieldPaths , api_version : str = None , key : str = None ) field_path Required \u00b6 Type: cdk8s_plus_22.EnvFieldPaths : The field reference. api_version Optional \u00b6 Type: str Version of the schema the FieldPath is written in terms of. key Optional \u00b6 Type: str The key to select the pod label or annotation. from_process \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValue . from_process ( key : str , required : bool = None ) key Required \u00b6 Type: str The key to read. required Optional \u00b6 Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. from_resource \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValue . from_resource ( resource : ResourceFieldPaths , container : Container = None , divisor : str = None ) resource Required \u00b6 Type: cdk8s_plus_22.ResourceFieldPaths : Resource to select the value from. container Optional \u00b6 Type: cdk8s_plus_22.Container The container to select the value from. divisor Optional \u00b6 Type: str The output format of the exposed resource. from_secret_value \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValue . from_secret_value ( key : str , secret : ISecret , optional : bool = None ) key Required \u00b6 Type: str The JSON key. secret Required \u00b6 Type: cdk8s_plus_22.ISecret The secret. optional Optional \u00b6 Type: bool Default: false Specify whether the Secret or its key must be defined. from_value \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValue . from_value ( value : str ) value Required \u00b6 Type: str The value. Properties \u00b6 value Optional \u00b6 value : typing . Any Type: typing.Any value_from Optional \u00b6 value_from : typing . Any Type: typing.Any Group \u00b6 Implements: cdk8s_plus_22.ISubject Represents a group. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Group ( name : str ) name Required \u00b6 Type: str The name of the group. Properties \u00b6 kind Required \u00b6 kind : str Type: str Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 name : str Type: str Name of the object being referenced. api_group Optional \u00b6 api_group : str Type: str APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Handler . from_command ( command : typing . List [ str ] ) command Required \u00b6 Type: typing.List[ str ] The command to execute. from_http_get \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Handler . from_http_get ( path : str , port : typing . Union [ int , float ] = None ) path Required \u00b6 Type: str The URL path to hit. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. from_tcp_socket \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Handler . from_tcp_socket ( host : str = None , port : typing . Union [ int , float ] = None ) host Optional \u00b6 Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. IngressBackend \u00b6 The backend for an ingress path. Static Functions \u00b6 from_service \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . IngressBackend . from_service ( serv : Service , port : typing . Union [ int , float ] = None ) serv Required \u00b6 Type: cdk8s_plus_22.Service The service object. port Optional \u00b6 Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. LabelSelector \u00b6 A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors Static Functions \u00b6 does_not_exist \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . LabelSelector . does_not_exist ( key : str ) key Required \u00b6 Type: str exists \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . LabelSelector . exists ( key : str ) key Required \u00b6 Type: str in \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . LabelSelector . in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] is \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . LabelSelector . is ( key : str , value : str , apply_to_template : bool = None ) key Required \u00b6 Type: str value Required \u00b6 Type: str apply_to_template Optional \u00b6 Type: bool not_in \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . LabelSelector . not_in ( key : str , values : typing . List [ str ] ) key Required \u00b6 Type: str values Required \u00b6 Type: typing.List[ str ] Properties \u00b6 apply_to_template Required \u00b6 apply_to_template : bool Type: bool key Required \u00b6 key : str Type: str operator Optional \u00b6 operator : LabelSelectorRequirementOperator Type: cdk8s_plus_22.LabelSelectorRequirementOperator values Optional \u00b6 values : typing . List [ str ] Type: typing.List[ str ] NonApiResource \u00b6 Implements: cdk8s_plus_22.IApiEndpoint Factory for creating non api resources. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () Static Functions \u00b6 of \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . NonApiResource . of ( url : str ) url Required \u00b6 Type: str PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 is_zero \u00b6 def is_zero () Static Functions \u00b6 absolute \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PercentOrAbsolute . absolute ( num : typing . Union [ int , float ] ) num Required \u00b6 Type: typing.Union[int, float] percent \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PercentOrAbsolute . percent ( percent : typing . Union [ int , float ] ) percent Required \u00b6 Type: typing.Union[int, float] Properties \u00b6 value Required \u00b6 value : typing . Any Type: typing.Any PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodDns ( hostname : str = None , hostname_as_fqd_n : bool = None , nameservers : typing . List [ str ] = None , options : typing . List [ DnsOption ] = None , policy : DnsPolicy = None , searches : typing . List [ str ] = None , subdomain : str = None ) hostname Optional \u00b6 Type: str Default: Set to a system-defined value. Specifies the hostname of the Pod. hostname_as_fqd_n Optional \u00b6 Type: bool Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 Type: typing.List[ str ] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 Type: typing.List[ cdk8s_plus_22.DnsOption ] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 Type: cdk8s_plus_22.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 Type: typing.List[ str ] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 Type: str Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. Methods \u00b6 add_nameserver \u00b6 def add_nameserver ( nameservers : str ) nameservers Required \u00b6 Type: str add_option \u00b6 def add_option ( name : str , value : str = None ) name Required \u00b6 Type: str Option name. value Optional \u00b6 Type: str Default: No value. Option value. add_search \u00b6 def add_search ( searches : str ) searches Required \u00b6 Type: str Properties \u00b6 hostname_as_fqd_n Required \u00b6 hostname_as_fqd_n : bool Type: bool Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 nameservers : typing . List [ str ] Type: typing.List[ str ] Nameservers defined for this pod. options Required \u00b6 options : typing . List [ DnsOption ] Type: typing.List[ cdk8s_plus_22.DnsOption ] Custom dns options defined for this pod. policy Required \u00b6 policy : DnsPolicy Type: cdk8s_plus_22.DnsPolicy The DNS policy of this pod. searches Required \u00b6 searches : typing . List [ str ] Type: typing.List[ str ] Search domains defined for this pod. hostname Optional \u00b6 hostname : str Type: str The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 subdomain : str Type: str The configured subdomain of the pod. PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodSecurityContext ( ensure_non_root : bool = None , fs_group : typing . Union [ int , float ] = None , fs_group_change_policy : FsGroupChangePolicy = None , group : typing . Union [ int , float ] = None , sysctls : typing . List [ Sysctl ] = None , user : typing . Union [ int , float ] = None ) ensure_non_root Optional \u00b6 Type: bool Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fs_group Optional \u00b6 Type: typing.Union[int, float] Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fs_group_change_policy Optional \u00b6 Type: cdk8s_plus_22.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 Type: typing.Union[int, float] Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Sysctl ] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 Type: typing.Union[int, float] Default: User specified in image metadata The UID to run the entrypoint of the container process. Properties \u00b6 ensure_non_root Required \u00b6 ensure_non_root : bool Type: bool fs_group_change_policy Required \u00b6 fs_group_change_policy : FsGroupChangePolicy Type: cdk8s_plus_22.FsGroupChangePolicy sysctls Required \u00b6 sysctls : typing . List [ Sysctl ] Type: typing.List[ cdk8s_plus_22.Sysctl ] fs_group Optional \u00b6 fs_group : typing . Union [ int , float ] Type: typing.Union[int, float] group Optional \u00b6 group : typing . Union [ int , float ] Type: typing.Union[int, float] user Optional \u00b6 user : typing . Union [ int , float ] Type: typing.Union[int, float] Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Probe . from_command ( command : typing . List [ str ], failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) command Required \u00b6 Type: typing.List[ str ] The command to execute. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes from_http_get \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Probe . from_http_get ( path : str , failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) path Required \u00b6 Type: str The URL path to hit. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. from_tcp_socket \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Probe . from_tcp_socket ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , host : str = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 Type: str Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to connect to on the container. StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 on_delete \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . StatefulSetUpdateStrategy . on_delete () rolling_update \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . StatefulSetUpdateStrategy . rolling_update ( partition : typing . Union [ int , float ] = None ) partition Optional \u00b6 Type: typing.Union[int, float] Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions User \u00b6 Implements: cdk8s_plus_22.ISubject Represents a user. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . User ( name : str ) name Required \u00b6 Type: str The name of the user. Properties \u00b6 kind Required \u00b6 kind : str Type: str Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 name : str Type: str Name of the object being referenced. api_group Optional \u00b6 api_group : str Type: str APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Volume \u00b6 Implements: cdk8s_plus_22.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 as_volume \u00b6 def as_volume () Static Functions \u00b6 from_aws_elastic_block_store \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume . from_aws_elastic_block_store ( volume_id : str , fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) volume_id Required \u00b6 Type: str fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 Type: str Default: auto-generated The volume name. partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore from_azure_disk \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume . from_azure_disk ( disk_name : str , disk_uri : str , caching_mode : AzureDiskPersistentVolumeCachingMode = None , fs_type : str = None , kind : AzureDiskPersistentVolumeKind = None , name : str = None , read_only : bool = None ) disk_name Required \u00b6 Type: str disk_uri Required \u00b6 Type: str caching_mode Optional \u00b6 Type: cdk8s_plus_22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 Type: cdk8s_plus_22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 Type: str Default: auto-generated The volume name. read_only Optional \u00b6 Type: bool Default: false Force the ReadOnly setting in VolumeMounts. from_config_map \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume . from_config_map ( config_map : IConfigMap , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_22.IConfigMap The config map to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. from_empty_dir \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume . from_empty_dir ( name : str , medium : EmptyDirMedium = None , size_limit : Size = None ) name Required \u00b6 Type: str medium Optional \u00b6 Type: cdk8s_plus_22.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. from_gce_persistent_disk \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume . from_gce_persistent_disk ( pd_name : str , fs_type : str = None , name : str = None , partition : typing . Union [ int , float ] = None , read_only : bool = None ) pd_name Required \u00b6 Type: str fs_type Optional \u00b6 Type: str Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 Type: str Default: auto-generated The volume name. partition Optional \u00b6 Type: typing.Union[int, float] Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). read_only Optional \u00b6 Type: bool Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore from_persistent_volume_claim \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume . from_persistent_volume_claim ( claim : IPersistentVolumeClaim , name : str = None , read_only : bool = None ) claim Required \u00b6 Type: cdk8s_plus_22.IPersistentVolumeClaim name Optional \u00b6 Type: str Default: Derived from the PVC name. The volume name. read_only Optional \u00b6 Type: bool Default: false Will force the ReadOnly setting in VolumeMounts. from_secret \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume . from_secret ( secr : ISecret , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) secr Required \u00b6 Type: cdk8s_plus_22.ISecret The secret to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the secret or its keys must be defined. Properties \u00b6 name Required \u00b6 name : str Type: str Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.ApiResource , cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.BasicAuthSecret , cdk8s_plus_22.ClusterRole , cdk8s_plus_22.ClusterRoleBinding , cdk8s_plus_22.ConfigMap , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.DockerConfigSecret , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.Ingress , cdk8s_plus_22.Job , cdk8s_plus_22.NonApiResource , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.PersistentVolumeClaim , cdk8s_plus_22.Pod , cdk8s_plus_22.Resource , cdk8s_plus_22.Role , cdk8s_plus_22.RoleBinding , cdk8s_plus_22.Secret , cdk8s_plus_22.Service , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.ServiceAccountTokenSecret , cdk8s_plus_22.SshAuthSecret , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.TlsSecret , cdk8s_plus_22.Workload , cdk8s_plus_22.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 as_api_resource \u00b6 def as_api_resource () as_non_api_resource \u00b6 def as_non_api_resource () IApiResource \u00b6 Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.ApiResource , cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.BasicAuthSecret , cdk8s_plus_22.ClusterRole , cdk8s_plus_22.ClusterRoleBinding , cdk8s_plus_22.ConfigMap , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.DockerConfigSecret , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.Ingress , cdk8s_plus_22.Job , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.PersistentVolumeClaim , cdk8s_plus_22.Pod , cdk8s_plus_22.Resource , cdk8s_plus_22.Role , cdk8s_plus_22.RoleBinding , cdk8s_plus_22.Secret , cdk8s_plus_22.Service , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.ServiceAccountTokenSecret , cdk8s_plus_22.SshAuthSecret , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.TlsSecret , cdk8s_plus_22.Workload , cdk8s_plus_22.IApiResource Represents a resource or collection of resources. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). resource_type Required \u00b6 resource_type : str Type: str The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resource_name Optional \u00b6 resource_name : str Type: str The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ClusterRole , cdk8s_plus_22.IClusterRole Represents a cluster-level role. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IConfigMap \u00b6 Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ConfigMap , cdk8s_plus_22.IConfigMap Represents a config map. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IPersistentVolume \u00b6 Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.PersistentVolumeClaim , cdk8s_plus_22.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IResource \u00b6 Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.BasicAuthSecret , cdk8s_plus_22.ClusterRole , cdk8s_plus_22.ClusterRoleBinding , cdk8s_plus_22.ConfigMap , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.DockerConfigSecret , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.Ingress , cdk8s_plus_22.Job , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.PersistentVolumeClaim , cdk8s_plus_22.Pod , cdk8s_plus_22.Resource , cdk8s_plus_22.Role , cdk8s_plus_22.RoleBinding , cdk8s_plus_22.Secret , cdk8s_plus_22.Service , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.ServiceAccountTokenSecret , cdk8s_plus_22.SshAuthSecret , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.TlsSecret , cdk8s_plus_22.Workload , cdk8s_plus_22.IClusterRole , cdk8s_plus_22.IConfigMap , cdk8s_plus_22.IPersistentVolume , cdk8s_plus_22.IPersistentVolumeClaim , cdk8s_plus_22.IResource , cdk8s_plus_22.IRole , cdk8s_plus_22.ISecret , cdk8s_plus_22.IServiceAccount Represents a resource. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IRole \u00b6 Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ClusterRole , cdk8s_plus_22.Role , cdk8s_plus_22.IRole A reference to any Role or ClusterRole. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.BasicAuthSecret , cdk8s_plus_22.DockerConfigSecret , cdk8s_plus_22.Secret , cdk8s_plus_22.ServiceAccountTokenSecret , cdk8s_plus_22.SshAuthSecret , cdk8s_plus_22.TlsSecret , cdk8s_plus_22.ISecret Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.IServiceAccount Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 kind : str Type: str The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IStorage \u00b6 Implemented By: cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.Volume , cdk8s_plus_22.IStorage Represents a piece of storage in the cluster. Methods \u00b6 as_volume \u00b6 def as_volume () ISubject \u00b6 Implemented By: cdk8s_plus_22.Group , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.User , cdk8s_plus_22.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Properties \u00b6 kind Required \u00b6 kind : str Type: str Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 name : str Type: str Name of the object being referenced. api_group Optional \u00b6 api_group : str Type: str APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 namespace : str Type: str Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. HttpIngressPathType \u00b6 Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types PREFIX \u00b6 Matches the URL path exactly. EXACT \u00b6 Matches based on a URL path prefix split by \u2018/\u2019. IMPLEMENTATION_SPECIFIC \u00b6 Matching is specified by the underlying IngressClass. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. LabelSelectorRequirementOperator \u00b6 Possible operators. IN \u00b6 In. NOT_IN \u00b6 NotIn. EXISTS \u00b6 Exists. DOES_NOT_EXIST \u00b6 DoesNotExist. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"Python"},{"location":"reference/cdk8s-plus-22/python/#cdk8s-plus-22-python","text":"","title":"cdk8s-plus-22 (Python) "},{"location":"reference/cdk8s-plus-22/python/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-22/python/#abstractpod","text":"","title":"AbstractPod "},{"location":"reference/cdk8s-plus-22/python/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-22/python/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-22/python/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-22/python/#clusterrole","text":"Implements: cdk8s_plus_22.IClusterRole , cdk8s_plus_22.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-22/python/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-22/python/#configmap","text":"Implements: cdk8s_plus_22.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-22/python/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-22/python/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-22/python/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-22/python/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-22/python/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-22/python/#ingress","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"Ingress "},{"location":"reference/cdk8s-plus-22/python/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-22/python/#persistentvolume","text":"Implements: cdk8s_plus_22.IPersistentVolume , cdk8s_plus_22.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-22/python/#persistentvolumeclaim","text":"Implements: cdk8s_plus_22.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-22/python/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-22/python/#resource","text":"Implements: cdk8s_plus_22.IResource , cdk8s_plus_22.IApiResource , cdk8s_plus_22.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-22/python/#role","text":"Implements: cdk8s_plus_22.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-22/python/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-22/python/#secret","text":"Implements: cdk8s_plus_22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-22/python/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-22/python/#serviceaccount","text":"Implements: cdk8s_plus_22.IServiceAccount , cdk8s_plus_22.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-22/python/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-22/python/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-22/python/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-22/python/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-22/python/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-22/python/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-22/python/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-22/python/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-22/python/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-22/python/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-22/python/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-22/python/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/python/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-22/python/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/python/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-22/python/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-22/python/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-22/python/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-22/python/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-22/python/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-22/python/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-22/python/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-22/python/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-22/python/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-22/python/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-22/python/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-22/python/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-22/python/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-22/python/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-22/python/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-22/python/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-22/python/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-22/python/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-22/python/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-22/python/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-22/python/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-22/python/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-22/python/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-22/python/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-22/python/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-22/python/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-22/python/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-22/python/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/python/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-22/python/#groupprops","text":"Properties for Group .","title":"GroupProps "},{"location":"reference/cdk8s-plus-22/python/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-22/python/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-22/python/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-22/python/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-22/python/#ingressprops","text":"Properties for Ingress .","title":"IngressProps "},{"location":"reference/cdk8s-plus-22/python/#ingressrule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressRule "},{"location":"reference/cdk8s-plus-22/python/#ingresstls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressTls "},{"location":"reference/cdk8s-plus-22/python/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-22/python/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-22/python/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-22/python/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-22/python/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-22/python/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-22/python/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-22/python/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/python/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-22/python/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-22/python/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-22/python/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-22/python/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-22/python/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-22/python/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-22/python/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-22/python/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-22/python/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-22/python/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-22/python/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-22/python/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-22/python/#serviceingressbackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressBackendOptions "},{"location":"reference/cdk8s-plus-22/python/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-22/python/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-22/python/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-22/python/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-22/python/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-22/python/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-22/python/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-22/python/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-22/python/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-22/python/#userprops","text":"Properties for User .","title":"UserProps "},{"location":"reference/cdk8s-plus-22/python/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-22/python/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-22/python/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-22/python/#apiresource","text":"Implements: cdk8s_plus_22.IApiResource , cdk8s_plus_22.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-22/python/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-22/python/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-22/python/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-22/python/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-22/python/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-22/python/#group","text":"Implements: cdk8s_plus_22.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-22/python/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-22/python/#ingressbackend","text":"The backend for an ingress path.","title":"IngressBackend "},{"location":"reference/cdk8s-plus-22/python/#labelselector","text":"A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors","title":"LabelSelector "},{"location":"reference/cdk8s-plus-22/python/#nonapiresource","text":"Implements: cdk8s_plus_22.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-22/python/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-22/python/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-22/python/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-22/python/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-22/python/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-22/python/#user","text":"Implements: cdk8s_plus_22.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-22/python/#volume","text":"Implements: cdk8s_plus_22.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-22/python/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-22/python/#iapiendpoint","text":"Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.ApiResource , cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.BasicAuthSecret , cdk8s_plus_22.ClusterRole , cdk8s_plus_22.ClusterRoleBinding , cdk8s_plus_22.ConfigMap , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.DockerConfigSecret , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.Ingress , cdk8s_plus_22.Job , cdk8s_plus_22.NonApiResource , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.PersistentVolumeClaim , cdk8s_plus_22.Pod , cdk8s_plus_22.Resource , cdk8s_plus_22.Role , cdk8s_plus_22.RoleBinding , cdk8s_plus_22.Secret , cdk8s_plus_22.Service , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.ServiceAccountTokenSecret , cdk8s_plus_22.SshAuthSecret , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.TlsSecret , cdk8s_plus_22.Workload , cdk8s_plus_22.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-22/python/#iapiresource","text":"Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.ApiResource , cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.BasicAuthSecret , cdk8s_plus_22.ClusterRole , cdk8s_plus_22.ClusterRoleBinding , cdk8s_plus_22.ConfigMap , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.DockerConfigSecret , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.Ingress , cdk8s_plus_22.Job , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.PersistentVolumeClaim , cdk8s_plus_22.Pod , cdk8s_plus_22.Resource , cdk8s_plus_22.Role , cdk8s_plus_22.RoleBinding , cdk8s_plus_22.Secret , cdk8s_plus_22.Service , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.ServiceAccountTokenSecret , cdk8s_plus_22.SshAuthSecret , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.TlsSecret , cdk8s_plus_22.Workload , cdk8s_plus_22.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-22/python/#iclusterrole","text":"Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ClusterRole , cdk8s_plus_22.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-22/python/#iconfigmap","text":"Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ConfigMap , cdk8s_plus_22.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-22/python/#ipersistentvolume","text":"Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-22/python/#ipersistentvolumeclaim","text":"Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.PersistentVolumeClaim , cdk8s_plus_22.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-22/python/#iresource","text":"Implemented By: cdk8s_plus_22.AbstractPod , cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.BasicAuthSecret , cdk8s_plus_22.ClusterRole , cdk8s_plus_22.ClusterRoleBinding , cdk8s_plus_22.ConfigMap , cdk8s_plus_22.DaemonSet , cdk8s_plus_22.Deployment , cdk8s_plus_22.DockerConfigSecret , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.Ingress , cdk8s_plus_22.Job , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.PersistentVolumeClaim , cdk8s_plus_22.Pod , cdk8s_plus_22.Resource , cdk8s_plus_22.Role , cdk8s_plus_22.RoleBinding , cdk8s_plus_22.Secret , cdk8s_plus_22.Service , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.ServiceAccountTokenSecret , cdk8s_plus_22.SshAuthSecret , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.TlsSecret , cdk8s_plus_22.Workload , cdk8s_plus_22.IClusterRole , cdk8s_plus_22.IConfigMap , cdk8s_plus_22.IPersistentVolume , cdk8s_plus_22.IPersistentVolumeClaim , cdk8s_plus_22.IResource , cdk8s_plus_22.IRole , cdk8s_plus_22.ISecret , cdk8s_plus_22.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-22/python/#irole","text":"Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ClusterRole , cdk8s_plus_22.Role , cdk8s_plus_22.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-22/python/#isecret","text":"Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.BasicAuthSecret , cdk8s_plus_22.DockerConfigSecret , cdk8s_plus_22.Secret , cdk8s_plus_22.ServiceAccountTokenSecret , cdk8s_plus_22.SshAuthSecret , cdk8s_plus_22.TlsSecret , cdk8s_plus_22.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-22/python/#iserviceaccount","text":"Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-22/python/#istorage","text":"Implemented By: cdk8s_plus_22.AwsElasticBlockStorePersistentVolume , cdk8s_plus_22.AzureDiskPersistentVolume , cdk8s_plus_22.GCEPersistentDiskPersistentVolume , cdk8s_plus_22.PersistentVolume , cdk8s_plus_22.Volume , cdk8s_plus_22.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-22/python/#isubject","text":"Implemented By: cdk8s_plus_22.Group , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.User , cdk8s_plus_22.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"ISubject "},{"location":"reference/cdk8s-plus-22/python/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-22/python/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-22/python/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-22/python/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-22/python/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-22/python/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-22/python/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-22/python/#httpingresspathtype","text":"Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types","title":"HttpIngressPathType "},{"location":"reference/cdk8s-plus-22/python/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-22/python/#labelselectorrequirementoperator","text":"Possible operators.","title":"LabelSelectorRequirementOperator "},{"location":"reference/cdk8s-plus-22/python/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-22/python/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-22/python/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-22/python/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-22/python/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-22/python/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-22/python/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-22/python/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-22/python/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-22/typescript/","text":"cdk8s-plus-22 (TypeScript) \u00b6 Constructs \u00b6 AbstractPod \u00b6 Initializers \u00b6 import { AbstractPod } from 'cdk8s-plus-22' new AbstractPod ( scope : Construct , id : string , props? : AbstractPodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.AbstractPodProps Methods \u00b6 addContainer \u00b6 public addContainer ( cont : ContainerProps ) cont Required \u00b6 Type: cdk8s-plus-22.ContainerProps addHostAlias \u00b6 public addHostAlias ( hostAlias : HostAlias ) hostAlias Required \u00b6 Type: cdk8s-plus-22.HostAlias addInitContainer \u00b6 public addInitContainer ( cont : ContainerProps ) cont Required \u00b6 Type: cdk8s-plus-22.ContainerProps addVolume \u00b6 public addVolume ( vol : Volume ) vol Required \u00b6 Type: cdk8s-plus-22.Volume Properties \u00b6 automountServiceAccountToken Required \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-22.Container [] dns Required \u00b6 public readonly dns : PodDns ; Type: cdk8s-plus-22.PodDns hostAliases Required \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-22.HostAlias [] initContainers Required \u00b6 public readonly initContainers : Container []; Type: cdk8s-plus-22.Container [] securityContext Required \u00b6 public readonly securityContext : PodSecurityContext ; Type: cdk8s-plus-22.PodSecurityContext volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-22.DockerConfigSecret restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount AwsElasticBlockStorePersistentVolume \u00b6 Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore Initializers \u00b6 import { AwsElasticBlockStorePersistentVolume } from 'cdk8s-plus-22' new AwsElasticBlockStorePersistentVolume ( scope : Construct , id : string , props : AwsElasticBlockStorePersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.AwsElasticBlockStorePersistentVolumeProps Properties \u00b6 fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. volumeId Required \u00b6 public readonly volumeId : string ; Type: string Volume id of this volume. partition Optional \u00b6 public readonly partition : number ; Type: number Partition of this volume. AzureDiskPersistentVolume \u00b6 AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod. Initializers \u00b6 import { AzureDiskPersistentVolume } from 'cdk8s-plus-22' new AzureDiskPersistentVolume ( scope : Construct , id : string , props : AzureDiskPersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.AzureDiskPersistentVolumeProps Properties \u00b6 azureKind Required \u00b6 public readonly azureKind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-22.AzureDiskPersistentVolumeKind Azure kind of this volume. cachingMode Required \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-22.AzureDiskPersistentVolumeCachingMode Caching mode of this volume. diskName Required \u00b6 public readonly diskName : string ; Type: string Disk name of this volume. diskUri Required \u00b6 public readonly diskUri : string ; Type: string Disk URI of this volume. fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. BasicAuthSecret \u00b6 Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret Initializers \u00b6 import { BasicAuthSecret } from 'cdk8s-plus-22' new BasicAuthSecret ( scope : Construct , id : string , props : BasicAuthSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.BasicAuthSecretProps ClusterRole \u00b6 Implements: cdk8s-plus-22.IClusterRole , cdk8s-plus-22.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding. Initializers \u00b6 import { ClusterRole } from 'cdk8s-plus-22' new ClusterRole ( scope : Construct , id : string , props? : ClusterRoleProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.ClusterRoleProps Methods \u00b6 aggregate \u00b6 public aggregate ( key : string , value : string ) key Required \u00b6 Type: string value Required \u00b6 Type: string allow \u00b6 public allow ( verbs : string [], endpoints : IApiEndpoint ) verbs Required \u00b6 Type: string [] endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The endpoints(s) to apply to. allowCreate \u00b6 public allowCreate ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowGet \u00b6 public allowGet ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowList \u00b6 public allowList ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowRead \u00b6 public allowRead ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( endpoints : IApiEndpoint ) endpoints Required \u00b6 Type: cdk8s-plus-22.IApiEndpoint The resource(s) to apply to. bind \u00b6 public bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-22.ISubject a list of subjects to bind to. bindInNamespace \u00b6 public bindInNamespace ( namespace : string , subjects : ISubject ) namespace Required \u00b6 Type: string the namespace to limit permissions to. subjects Required \u00b6 Type: cdk8s-plus-22.ISubject a list of subjects to bind to. combine \u00b6 public combine ( rol : ClusterRole ) rol Required \u00b6 Type: cdk8s-plus-22.ClusterRole Static Functions \u00b6 fromClusterRoleName \u00b6 import { ClusterRole } from 'cdk8s-plus-22' ClusterRole . fromClusterRoleName ( name : string ) name Required \u00b6 Type: string The name of the role resource. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public readonly rules : ClusterRolePolicyRule []; Type: cdk8s-plus-22.ClusterRolePolicyRule [] Rules associaated with this Role. Returns a copy, use allow to add rules. ClusterRoleBinding \u00b6 A ClusterRoleBinding grants permissions cluster-wide to a user or set of users. Initializers \u00b6 import { ClusterRoleBinding } from 'cdk8s-plus-22' new ClusterRoleBinding ( scope : Construct , id : string , props : ClusterRoleBindingProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.ClusterRoleBindingProps Methods \u00b6 addSubjects \u00b6 public addSubjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-22.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public readonly role : IClusterRole ; Type: cdk8s-plus-22.IClusterRole subjects Required \u00b6 public readonly subjects : ISubject []; Type: cdk8s-plus-22.ISubject [] ConfigMap \u00b6 Implements: cdk8s-plus-22.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import { ConfigMap } from 'cdk8s-plus-22' new ConfigMap ( scope : Construct , id : string , props? : ConfigMapProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.ConfigMapProps Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addData \u00b6 public addData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addDirectory \u00b6 public addDirectory ( localDir : string , options? : AddDirectoryOptions ) localDir Required \u00b6 Type: string A path to a local directory. options Optional \u00b6 Type: cdk8s-plus-22.AddDirectoryOptions Options. addFile \u00b6 public addFile ( localFile : string , key? : string ) localFile Required \u00b6 Type: string The path to the local file. key Optional \u00b6 Type: string The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import { ConfigMap } from 'cdk8s-plus-22' ConfigMap . fromConfigMapName ( name : string ) name Required \u00b6 Type: string The name of the config map to import. Properties \u00b6 binaryData Required \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . immutable Required \u00b6 public readonly immutable : boolean ; Type: boolean Whether or not this config map is immutable. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. DaemonSet \u00b6 A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types. Initializers \u00b6 import { DaemonSet } from 'cdk8s-plus-22' new DaemonSet ( scope : Construct , id : string , props? : DaemonSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.DaemonSetProps Properties \u00b6 minReadySeconds Required \u00b6 public readonly minReadySeconds : number ; Type: number resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import { Deployment } from 'cdk8s-plus-22' new Deployment ( scope : Construct , id : string , props? : DeploymentProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.DeploymentProps Methods \u00b6 exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeDeploymentViaIngressOptions ) path Required \u00b6 Type: string The ingress path to register under. options Optional \u00b6 Type: cdk8s-plus-22.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService ( options? : ExposeDeploymentViaServiceOptions ) options Optional \u00b6 Type: cdk8s-plus-22.ExposeDeploymentViaServiceOptions Options to determine details of the service and port exposed. Properties \u00b6 minReady Required \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. progressDeadline Required \u00b6 public readonly progressDeadline : Duration ; Type: cdk8s.Duration The maximum duration for a deployment to make progress before it is considered to be failed. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public readonly strategy : DeploymentStrategy ; Type: cdk8s-plus-22.DeploymentStrategy DockerConfigSecret \u00b6 Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets Initializers \u00b6 import { DockerConfigSecret } from 'cdk8s-plus-22' new DockerConfigSecret ( scope : Construct , id : string , props : DockerConfigSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.DockerConfigSecretProps GCEPersistentDiskPersistentVolume \u00b6 GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk Initializers \u00b6 import { GCEPersistentDiskPersistentVolume } from 'cdk8s-plus-22' new GCEPersistentDiskPersistentVolume ( scope : Construct , id : string , props : GCEPersistentDiskPersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.GCEPersistentDiskPersistentVolumeProps Properties \u00b6 fsType Required \u00b6 public readonly fsType : string ; Type: string File system type of this volume. pdName Required \u00b6 public readonly pdName : string ; Type: string PD resource in GCE of this volume. readOnly Required \u00b6 public readonly readOnly : boolean ; Type: boolean Whether or not it is mounted as a read-only volume. partition Optional \u00b6 public readonly partition : number ; Type: number Partition of this volume. Ingress \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import { Ingress } from 'cdk8s-plus-22' new Ingress ( scope : Construct , id : string , props? : IngressProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.IngressProps Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( backend : IngressBackend ) backend Required \u00b6 Type: cdk8s-plus-22.IngressBackend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( host : string , backend : IngressBackend ) host Required \u00b6 Type: string The host name to match. backend Required \u00b6 Type: cdk8s-plus-22.IngressBackend The backend to route to. addHostRule \u00b6 public addHostRule ( host : string , path : string , backend : IngressBackend , pathType? : HttpIngressPathType ) host Required \u00b6 Type: string The host name. path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-22.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: cdk8s-plus-22.HttpIngressPathType How the path is matched against request paths. addRule \u00b6 public addRule ( path : string , backend : IngressBackend , pathType? : HttpIngressPathType ) path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-22.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: cdk8s-plus-22.HttpIngressPathType How the path is matched against request paths. addRules \u00b6 public addRules ( rules : IngressRule ) rules Required \u00b6 Type: cdk8s-plus-22.IngressRule The rules to add. addTls \u00b6 public addTls ( tls : IngressTls []) tls Required \u00b6 Type: cdk8s-plus-22.IngressTls [] Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import { Job } from 'cdk8s-plus-22' new Job ( scope : Construct , id : string , props? : JobProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.JobProps Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Number of retries before marking failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration TTL before the job is deleted after it is finished. PersistentVolume \u00b6 Implements: cdk8s-plus-22.IPersistentVolume , cdk8s-plus-22.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system. Initializers \u00b6 import { PersistentVolume } from 'cdk8s-plus-22' new PersistentVolume ( scope : Construct , id : string , props? : PersistentVolumeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.PersistentVolumeProps Methods \u00b6 asVolume \u00b6 public asVolume () bind \u00b6 public bind ( claim : IPersistentVolumeClaim ) claim Required \u00b6 Type: cdk8s-plus-22.IPersistentVolumeClaim The PVC to bind to. reserve \u00b6 public reserve () Static Functions \u00b6 fromPersistentVolumeName \u00b6 import { PersistentVolume } from 'cdk8s-plus-22' PersistentVolume . fromPersistentVolumeName ( volumeName : string ) volumeName Required \u00b6 Type: string The name of the pv to reference. Properties \u00b6 mode Required \u00b6 public readonly mode : PersistentVolumeMode ; Type: cdk8s-plus-22.PersistentVolumeMode Volume mode of this volume. reclaimPolicy Required \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-22.PersistentVolumeReclaimPolicy Reclaim policy of this volume. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-22.PersistentVolumeAccessMode [] Access modes requirement of this claim. claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-22.IPersistentVolumeClaim PVC this volume is bound to. Undefined means this volume is not yet claimed by any PVC. mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Mount options of this volume. storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Storage size of this volume. storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Storage class this volume belongs to. PersistentVolumeClaim \u00b6 Implements: cdk8s-plus-22.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes Initializers \u00b6 import { PersistentVolumeClaim } from 'cdk8s-plus-22' new PersistentVolumeClaim ( scope : Construct , id : string , props? : PersistentVolumeClaimProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.PersistentVolumeClaimProps Methods \u00b6 bind \u00b6 public bind ( vol : IPersistentVolume ) vol Required \u00b6 Type: cdk8s-plus-22.IPersistentVolume The PV to bind to. Static Functions \u00b6 fromClaimName \u00b6 import { PersistentVolumeClaim } from 'cdk8s-plus-22' PersistentVolumeClaim . fromClaimName ( claimName : string ) claimName Required \u00b6 Type: string The name of the pvc to reference. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. volumeMode Required \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-22.PersistentVolumeMode Volume mode requirement of this claim. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-22.PersistentVolumeAccessMode [] Access modes requirement of this claim. storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Storage requirement of this claim. storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Storage class requirment of this claim. volume Optional \u00b6 public readonly volume : IPersistentVolume ; Type: cdk8s-plus-22.IPersistentVolume PV this claim is bound to. Undefined means the claim is not bound to any specific volume. Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import { Pod } from 'cdk8s-plus-22' new Pod ( scope : Construct , id : string , props? : PodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.PodProps Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Resource \u00b6 Implements: cdk8s-plus-22.IResource , cdk8s-plus-22.IApiResource , cdk8s-plus-22.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import { Resource } from 'cdk8s-plus-22' new Resource ( scope : Construct , id : string , options? : ConstructOptions ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: string The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . options Optional \u00b6 Type: constructs.ConstructOptions Options. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). metadata Required \u00b6 public readonly metadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public readonly name : string ; Type: string The name of this API object. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. resourceName Optional \u00b6 public readonly resourceName : string ; Type: string The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. Role \u00b6 Implements: cdk8s-plus-22.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding. Initializers \u00b6 import { Role } from 'cdk8s-plus-22' new Role ( scope : Construct , id : string , props? : RoleProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.RoleProps Methods \u00b6 allow \u00b6 public allow ( verbs : string [], resources : IApiResource ) verbs Required \u00b6 Type: string [] resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowCreate \u00b6 public allowCreate ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowDelete \u00b6 public allowDelete ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowDeleteCollection \u00b6 public allowDeleteCollection ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowGet \u00b6 public allowGet ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowList \u00b6 public allowList ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowPatch \u00b6 public allowPatch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowRead \u00b6 public allowRead ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowReadWrite \u00b6 public allowReadWrite ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowUpdate \u00b6 public allowUpdate ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. allowWatch \u00b6 public allowWatch ( resources : IApiResource ) resources Required \u00b6 Type: cdk8s-plus-22.IApiResource The resource(s) to apply to. bind \u00b6 public bind ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-22.ISubject a list of subjects to bind to. Static Functions \u00b6 fromRoleName \u00b6 import { Role } from 'cdk8s-plus-22' Role . fromRoleName ( name : string ) name Required \u00b6 Type: string The name of the role resource. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. rules Required \u00b6 public readonly rules : RolePolicyRule []; Type: cdk8s-plus-22.RolePolicyRule [] Rules associaated with this Role. Returns a copy, use allow to add rules. RoleBinding \u00b6 A RoleBinding grants permissions within a specific namespace to a user or set of users. Initializers \u00b6 import { RoleBinding } from 'cdk8s-plus-22' new RoleBinding ( scope : Construct , id : string , props : RoleBindingProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.RoleBindingProps Methods \u00b6 addSubjects \u00b6 public addSubjects ( subjects : ISubject ) subjects Required \u00b6 Type: cdk8s-plus-22.ISubject The subjects to add. Properties \u00b6 resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. role Required \u00b6 public readonly role : IRole ; Type: cdk8s-plus-22.IRole subjects Required \u00b6 public readonly subjects : ISubject []; Type: cdk8s-plus-22.ISubject [] Secret \u00b6 Implements: cdk8s-plus-22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import { Secret } from 'cdk8s-plus-22' new Secret ( scope : Construct , id : string , props? : SecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.SecretProps Methods \u00b6 addStringData \u00b6 public addStringData ( key : string , value : string ) key Required \u00b6 Type: string Key. value Required \u00b6 Type: string Value. getStringData \u00b6 public getStringData ( key : string ) key Required \u00b6 Type: string Key. Static Functions \u00b6 fromSecretName \u00b6 import { Secret } from 'cdk8s-plus-22' Secret . fromSecretName ( name : string ) name Required \u00b6 Type: string The name of the secret to reference. Properties \u00b6 immutable Required \u00b6 public readonly immutable : boolean ; Type: boolean Whether or not the secret is immutable. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import { Service } from 'cdk8s-plus-22' new Service ( scope : Construct , id : string , props? : ServiceProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.ServiceProps Methods \u00b6 addDeployment \u00b6 public addDeployment ( depl : Deployment , options? : AddDeploymentOptions ) depl Required \u00b6 Type: cdk8s-plus-22.Deployment The deployment to expose. options Optional \u00b6 Type: cdk8s-plus-22.AddDeploymentOptions Optional settings for the port. addSelector \u00b6 public addSelector ( label : string , value : string ) label Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeServiceViaIngressOptions ) path Required \u00b6 Type: string The path to expose the service under. options Optional \u00b6 Type: cdk8s-plus-22.ExposeServiceViaIngressOptions Additional options. serve \u00b6 public serve ( port : number , options? : ServicePortOptions ) port Required \u00b6 Type: number The port definition. options Optional \u00b6 Type: cdk8s-plus-22.ServicePortOptions Properties \u00b6 ports Required \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-22.ServicePort [] Ports for this service. Use serve() to expose additional service ports. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. selector Required \u00b6 public readonly selector : {[ key : string ] : string }; Type: {[ key: string ]: string } Returns the labels which are used to select pods for this service. type Required \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-22.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public readonly externalName : string ; Type: string The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s-plus-22.IServiceAccount , cdk8s-plus-22.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import { ServiceAccount } from 'cdk8s-plus-22' new ServiceAccount ( scope : Construct , id : string , props? : ServiceAccountProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.ServiceAccountProps Methods \u00b6 addSecret \u00b6 public addSecret ( secr : ISecret ) secr Required \u00b6 Type: cdk8s-plus-22.ISecret The secret. Static Functions \u00b6 fromServiceAccountName \u00b6 import { ServiceAccount } from 'cdk8s-plus-22' ServiceAccount . fromServiceAccountName ( name : string ) name Required \u00b6 Type: string The name of the service account resource. Properties \u00b6 automountToken Required \u00b6 public readonly automountToken : boolean ; Type: boolean Whether or not a token is automatically mounted for this service account. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. secrets Required \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-22.ISecret [] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . ServiceAccountTokenSecret \u00b6 Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets Initializers \u00b6 import { ServiceAccountTokenSecret } from 'cdk8s-plus-22' new ServiceAccountTokenSecret ( scope : Construct , id : string , props : ServiceAccountTokenSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.ServiceAccountTokenSecretProps SshAuthSecret \u00b6 Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets Initializers \u00b6 import { SshAuthSecret } from 'cdk8s-plus-22' new SshAuthSecret ( scope : Construct , id : string , props : SshAuthSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.SshAuthSecretProps StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import { StatefulSet } from 'cdk8s-plus-22' new StatefulSet ( scope : Construct , id : string , props : StatefulSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.StatefulSetProps Properties \u00b6 minReady Required \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. podManagementPolicy Required \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-22.PodManagementPolicy Management policy to use for the set. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. strategy Required \u00b6 public readonly strategy : StatefulSetUpdateStrategy ; Type: cdk8s-plus-22.StatefulSetUpdateStrategy The update startegy of this stateful set. TlsSecret \u00b6 Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets Initializers \u00b6 import { TlsSecret } from 'cdk8s-plus-22' new TlsSecret ( scope : Construct , id : string , props : TlsSecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.TlsSecretProps Workload \u00b6 A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster. Initializers \u00b6 import { Workload } from 'cdk8s-plus-22' new Workload ( scope : Construct , id : string , props? : WorkloadProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.WorkloadProps Methods \u00b6 select \u00b6 public select ( selectors : LabelSelector ) selectors Required \u00b6 Type: cdk8s-plus-22.LabelSelector Properties \u00b6 matchExpressions Required \u00b6 public readonly matchExpressions : LabelSelectorRequirement []; Type: cdk8s-plus-22.LabelSelectorRequirement [] The expression matchers this workload will use in order to select pods. Returns a a copy. Use select() to add expression matchers. matchLabels Required \u00b6 public readonly matchLabels : {[ key : string ] : string }; Type: {[ key: string ]: string } The label matchers this workload will use in order to select pods. Returns a a copy. Use select() to add label matchers. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition The metadata of pods in this workload. Structs \u00b6 AbstractPodProps \u00b6 Properties for AbstractPod . Initializer \u00b6 import { AbstractPodProps } from 'cdk8s-plus-22' const abstractPodProps : AbstractPodProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-22.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import { AddDeploymentOptions } from 'cdk8s-plus-22' const addDeploymentOptions : AddDeploymentOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import { AddDirectoryOptions } from 'cdk8s-plus-22' const addDirectoryOptions : AddDirectoryOptions = { ... } exclude Optional \u00b6 public readonly exclude : string []; Type: string [] Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public readonly keyPrefix : string ; Type: string Default: \u201c\u201d A prefix to add to all keys in the config map. ApiResourceOptions \u00b6 Options for ApiResource . Initializer \u00b6 import { ApiResourceOptions } from 'cdk8s-plus-22' const apiResourceOptions : ApiResourceOptions = { ... } apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources AwsElasticBlockStorePersistentVolumeProps \u00b6 Properties for AwsElasticBlockStorePersistentVolume . Initializer \u00b6 import { AwsElasticBlockStorePersistentVolumeProps } from 'cdk8s-plus-22' const awsElasticBlockStorePersistentVolumeProps : AwsElasticBlockStorePersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-22.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. volumeId Required \u00b6 public readonly volumeId : string ; Type: string Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AwsElasticBlockStoreVolumeOptions \u00b6 Options of Volume.fromAwsElasticBlockStore . Initializer \u00b6 import { AwsElasticBlockStoreVolumeOptions } from 'cdk8s-plus-22' const awsElasticBlockStoreVolumeOptions : AwsElasticBlockStoreVolumeOptions = { ... } fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore AzureDiskPersistentVolumeProps \u00b6 Properties for AzureDiskPersistentVolume . Initializer \u00b6 import { AzureDiskPersistentVolumeProps } from 'cdk8s-plus-22' const azureDiskPersistentVolumeProps : AzureDiskPersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-22.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. diskName Required \u00b6 public readonly diskName : string ; Type: string The Name of the data disk in the blob storage. diskUri Required \u00b6 public readonly diskUri : string ; Type: string The URI the data disk in the blob storage. cachingMode Optional \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public readonly kind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Force the ReadOnly setting in VolumeMounts. AzureDiskVolumeOptions \u00b6 Options of Volume.fromAzureDisk . Initializer \u00b6 import { AzureDiskVolumeOptions } from 'cdk8s-plus-22' const azureDiskVolumeOptions : AzureDiskVolumeOptions = { ... } cachingMode Optional \u00b6 public readonly cachingMode : AzureDiskPersistentVolumeCachingMode ; Type: cdk8s-plus-22.AzureDiskPersistentVolumeCachingMode Default: AzureDiskPersistentVolumeCachingMode.NONE. Host Caching mode. fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type to mount. Must be a filesystem type supported by the host operating system. kind Optional \u00b6 public readonly kind : AzureDiskPersistentVolumeKind ; Type: cdk8s-plus-22.AzureDiskPersistentVolumeKind Default: AzureDiskPersistentVolumeKind.SHARED Kind of disk. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Force the ReadOnly setting in VolumeMounts. BasicAuthSecretProps \u00b6 Options for BasicAuthSecret . Initializer \u00b6 import { BasicAuthSecretProps } from 'cdk8s-plus-22' const basicAuthSecretProps : BasicAuthSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. password Required \u00b6 public readonly password : string ; Type: string The password or token for authentication. username Required \u00b6 public readonly username : string ; Type: string The user name for authentication. ClusterRoleBindingProps \u00b6 Properties for ClusterRoleBinding . Initializer \u00b6 import { ClusterRoleBindingProps } from 'cdk8s-plus-22' const clusterRoleBindingProps : ClusterRoleBindingProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public readonly role : IClusterRole ; Type: cdk8s-plus-22.IClusterRole The role to bind to. ClusterRolePolicyRule \u00b6 Policy rule of a `ClusterRole. Initializer \u00b6 import { ClusterRolePolicyRule } from 'cdk8s-plus-22' const clusterRolePolicyRule : ClusterRolePolicyRule = { ... } endpoints Required \u00b6 public readonly endpoints : IApiEndpoint []; Type: cdk8s-plus-22.IApiEndpoint [] Endpoints this rule applies to. Can be either api resources or non api resources. verbs Required \u00b6 public readonly verbs : string []; Type: string [] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) ClusterRoleProps \u00b6 Properties for ClusterRole . Initializer \u00b6 import { ClusterRoleProps } from 'cdk8s-plus-22' const clusterRoleProps : ClusterRoleProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. aggregationLabels Optional \u00b6 public readonly aggregationLabels : {[ key : string ] : string }; Type: {[ key: string ]: string } Specify labels that should be used to locate ClusterRoles, whose rules will be automatically filled into this ClusterRole\u2019s rules. rules Optional \u00b6 public readonly rules : ClusterRolePolicyRule []; Type: cdk8s-plus-22.ClusterRolePolicyRule [] Default: [] A list of rules the role should allow. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import { CommandProbeOptions } from 'cdk8s-plus-22' const commandProbeOptions : CommandProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes CommonSecretProps \u00b6 Common properties for Secret . Initializer \u00b6 import { CommonSecretProps } from 'cdk8s-plus-22' const commonSecretProps : CommonSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import { ConfigMapProps } from 'cdk8s-plus-22' const configMapProps : ConfigMapProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import { ConfigMapVolumeOptions } from 'cdk8s-plus-22' const configMapVolumeOptions : ConfigMapVolumeOptions = { ... } defaultMode Optional \u00b6 public readonly defaultMode : number ; Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public readonly items : {[ key : string ] : PathMapping }; Type: {[ key: string ]: cdk8s-plus-22.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerLifecycle \u00b6 Container lifecycle properties. Initializer \u00b6 import { ContainerLifecycle } from 'cdk8s-plus-22' const containerLifecycle : ContainerLifecycle = { ... } postStart Optional \u00b6 public readonly postStart : Handler ; Type: cdk8s-plus-22.Handler Default: No post start handler. This hook is executed immediately after a container is created. However, there is no guarantee that the hook will execute before the container ENTRYPOINT. preStop Optional \u00b6 public readonly preStop : Handler ; Type: cdk8s-plus-22.Handler Default: No pre stop handler. This hook is called immediately before a container is terminated due to an API request or management event such as a liveness/startup probe failure, preemption, resource contention and others. A call to the PreStop hook fails if the container is already in a terminated or completed state and the hook must complete before the TERM signal to stop the container can be sent. The Pod\u2019s termination grace period countdown begins before the PreStop hook is executed, so regardless of the outcome of the handler, the container will eventually terminate within the Pod\u2019s termination grace period. No parameters are passed to the handler. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import { ContainerProps } from 'cdk8s-plus-22' const containerProps : ContainerProps = { ... } image Required \u00b6 public readonly image : string ; Type: string Docker image name. args Optional \u00b6 public readonly args : string []; Type: string [] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public readonly command : string []; Type: string [] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 public readonly env : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-22.EnvValue } Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. lifecycle Optional \u00b6 public readonly lifecycle : ContainerLifecycle ; Type: cdk8s-plus-22.ContainerLifecycle Describes actions that the management system should take in response to container lifecycle events. liveness Optional \u00b6 public readonly liveness : Probe ; Type: cdk8s-plus-22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public readonly name : string ; Type: string Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 public readonly port : number ; Type: number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 public readonly readiness : Probe ; Type: cdk8s-plus-22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. resources Optional \u00b6 public readonly resources : ContainerResources ; Type: cdk8s-plus-22.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ securityContext Optional \u00b6 public readonly securityContext : ContainerSecurityContextProps ; Type: cdk8s-plus-22.ContainerSecurityContextProps Default: ensureNonRoot: false privileged: false readOnlyRootFilesystem: false SecurityContext defines the security options the container should be run with. If set, the fields override equivalent fields of the pod\u2019s security context. https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ startup Optional \u00b6 public readonly startup : Probe ; Type: cdk8s-plus-22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public readonly volumeMounts : VolumeMount []; Type: cdk8s-plus-22.VolumeMount [] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public readonly workingDir : string ; Type: string Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. ContainerResources \u00b6 CPU and memory compute resources. Initializer \u00b6 import { ContainerResources } from 'cdk8s-plus-22' const containerResources : ContainerResources = { ... } cpu Required \u00b6 public readonly cpu : CpuResources ; Type: cdk8s-plus-22.CpuResources memory Required \u00b6 public readonly memory : MemoryResources ; Type: cdk8s-plus-22.MemoryResources ContainerSecurityContextProps \u00b6 Properties for ContainerSecurityContext . Initializer \u00b6 import { ContainerSecurityContextProps } from 'cdk8s-plus-22' const containerSecurityContextProps : ContainerSecurityContextProps = { ... } ensureNonRoot Optional \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. group Optional \u00b6 public readonly group : number ; Type: number Default: Group configured by container runtime The GID to run the entrypoint of the container process. privileged Optional \u00b6 public readonly privileged : boolean ; Type: boolean Default: false Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. readOnlyRootFilesystem Optional \u00b6 public readonly readOnlyRootFilesystem : boolean ; Type: boolean Default: false Whether this container has a read-only root filesystem. user Optional \u00b6 public readonly user : number ; Type: number Default: User specified in image metadata The UID to run the entrypoint of the container process. CpuResources \u00b6 CPU request and limit. Initializer \u00b6 import { CpuResources } from 'cdk8s-plus-22' const cpuResources : CpuResources = { ... } limit Required \u00b6 public readonly limit : Cpu ; Type: cdk8s-plus-22.Cpu request Required \u00b6 public readonly request : Cpu ; Type: cdk8s-plus-22.Cpu DaemonSetProps \u00b6 Properties for DaemonSet . Initializer \u00b6 import { DaemonSetProps } from 'cdk8s-plus-22' const daemonSetProps : DaemonSetProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-22.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReadySeconds Optional \u00b6 public readonly minReadySeconds : number ; Type: number Default: 0 Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. DeploymentProps \u00b6 Properties for Deployment . Initializer \u00b6 import { DeploymentProps } from 'cdk8s-plus-22' const deploymentProps : DeploymentProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-22.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. minReady Optional \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds progressDeadline Optional \u00b6 public readonly progressDeadline : Duration ; Type: cdk8s.Duration Default: Duration.seconds(600) The maximum duration for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. strategy Optional \u00b6 public readonly strategy : DeploymentStrategy ; Type: cdk8s-plus-22.DeploymentStrategy Default: RollingUpdate with maxSurge and maxUnavailable set to 25%. Specifies the strategy used to replace old Pods by new ones. DeploymentStrategyRollingUpdateOptions \u00b6 Options for DeploymentStrategy.rollingUpdate . Initializer \u00b6 import { DeploymentStrategyRollingUpdateOptions } from 'cdk8s-plus-22' const deploymentStrategyRollingUpdateOptions : DeploymentStrategyRollingUpdateOptions = { ... } maxSurge Optional \u00b6 public readonly maxSurge : PercentOrAbsolute ; Type: cdk8s-plus-22.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. This can not be 0 if maxUnavailable is 0. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods. maxUnavailable Optional \u00b6 public readonly maxUnavailable : PercentOrAbsolute ; Type: cdk8s-plus-22.PercentOrAbsolute Default: \u201825%\u2019 The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if maxSurge is 0. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods. DnsOption \u00b6 Custom DNS option. Initializer \u00b6 import { DnsOption } from 'cdk8s-plus-22' const dnsOption : DnsOption = { ... } name Required \u00b6 public readonly name : string ; Type: string Option name. value Optional \u00b6 public readonly value : string ; Type: string Default: No value. Option value. DockerConfigSecretProps \u00b6 Options for DockerConfigSecret . Initializer \u00b6 import { DockerConfigSecretProps } from 'cdk8s-plus-22' const dockerConfigSecretProps : DockerConfigSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. data Required \u00b6 public readonly data : {[ key : string ] : any }; Type: {[ key: string ]: any } JSON content to provide for the ~/.docker/config.json file. This will be stringified and inserted as stringData. https://docs.docker.com/engine/reference/commandline/cli/#sample-configuration-file EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import { EmptyDirVolumeOptions } from 'cdk8s-plus-22' const emptyDirVolumeOptions : EmptyDirVolumeOptions = { ... } medium Optional \u00b6 public readonly medium : EmptyDirMedium ; Type: cdk8s-plus-22.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public readonly sizeLimit : Size ; Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import { EnvValueFromConfigMapOptions } from 'cdk8s-plus-22' const envValueFromConfigMapOptions : EnvValueFromConfigMapOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromFieldRefOptions \u00b6 Options to specify an environment variable value from a field reference. Initializer \u00b6 import { EnvValueFromFieldRefOptions } from 'cdk8s-plus-22' const envValueFromFieldRefOptions : EnvValueFromFieldRefOptions = { ... } apiVersion Optional \u00b6 public readonly apiVersion : string ; Type: string Version of the schema the FieldPath is written in terms of. key Optional \u00b6 public readonly key : string ; Type: string The key to select the pod label or annotation. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import { EnvValueFromProcessOptions } from 'cdk8s-plus-22' const envValueFromProcessOptions : EnvValueFromProcessOptions = { ... } required Optional \u00b6 public readonly required : boolean ; Type: boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromResourceOptions \u00b6 Options to specify an environment variable value from a resource. Initializer \u00b6 import { EnvValueFromResourceOptions } from 'cdk8s-plus-22' const envValueFromResourceOptions : EnvValueFromResourceOptions = { ... } container Optional \u00b6 public readonly container : Container ; Type: cdk8s-plus-22.Container The container to select the value from. divisor Optional \u00b6 public readonly divisor : string ; Type: string The output format of the exposed resource. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import { EnvValueFromSecretOptions } from 'cdk8s-plus-22' const envValueFromSecretOptions : EnvValueFromSecretOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import { ExposeDeploymentViaIngressOptions } from 'cdk8s-plus-22' const exposeDeploymentViaIngressOptions : ExposeDeploymentViaIngressOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-22.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 public readonly ingress : Ingress ; Type: cdk8s-plus-22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public readonly pathType : HttpIngressPathType ; Type: cdk8s-plus-22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import { ExposeDeploymentViaServiceOptions } from 'cdk8s-plus-22' const exposeDeploymentViaServiceOptions : ExposeDeploymentViaServiceOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-22.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import { ExposeServiceViaIngressOptions } from 'cdk8s-plus-22' const exposeServiceViaIngressOptions : ExposeServiceViaIngressOptions = { ... } ingress Optional \u00b6 public readonly ingress : Ingress ; Type: cdk8s-plus-22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public readonly pathType : HttpIngressPathType ; Type: cdk8s-plus-22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. GCEPersistentDiskPersistentVolumeProps \u00b6 Properties for GCEPersistentDiskPersistentVolume . Initializer \u00b6 import { GCEPersistentDiskPersistentVolumeProps } from 'cdk8s-plus-22' const gCEPersistentDiskPersistentVolumeProps : GCEPersistentDiskPersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-22.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. pdName Required \u00b6 public readonly pdName : string ; Type: string Unique name of the PD resource in GCE. Used to identify the disk in GCE. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GCEPersistentDiskVolumeOptions \u00b6 Options of Volume.fromGcePersistentDisk . Initializer \u00b6 import { GCEPersistentDiskVolumeOptions } from 'cdk8s-plus-22' const gCEPersistentDiskVolumeOptions : GCEPersistentDiskVolumeOptions = { ... } fsType Optional \u00b6 public readonly fsType : string ; Type: string Default: \u2018ext4\u2019 Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. partition Optional \u00b6 public readonly partition : number ; Type: number Default: No partition. The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as \u201c1\u201d. Similarly, the volume partition for /dev/sda is \u201c0\u201d (or you can leave the property empty). readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Specify \u201ctrue\u201d to force and set the ReadOnly property in VolumeMounts to \u201ctrue\u201d. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore GroupProps \u00b6 Properties for Group . Initializer \u00b6 import { GroupProps } from 'cdk8s-plus-22' const groupProps : GroupProps = { ... } name Required \u00b6 public readonly name : string ; Type: string The name of the group. HandlerFromHttpGetOptions \u00b6 Options for Handler.fromHttpGet . Initializer \u00b6 import { HandlerFromHttpGetOptions } from 'cdk8s-plus-22' const handlerFromHttpGetOptions : HandlerFromHttpGetOptions = { ... } port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. HandlerFromTcpSocketOptions \u00b6 Options for Handler.fromTcpSocket . Initializer \u00b6 import { HandlerFromTcpSocketOptions } from 'cdk8s-plus-22' const handlerFromTcpSocketOptions : HandlerFromTcpSocketOptions = { ... } host Optional \u00b6 public readonly host : string ; Type: string Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to connect to on the container. HostAlias \u00b6 HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file. Initializer \u00b6 import { HostAlias } from 'cdk8s-plus-22' const hostAlias : HostAlias = { ... } hostnames Required \u00b6 public readonly hostnames : string []; Type: string [] Hostnames for the chosen IP address. ip Required \u00b6 public readonly ip : string ; Type: string IP address of the host file entry. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import { HttpGetProbeOptions } from 'cdk8s-plus-22' const httpGetProbeOptions : HttpGetProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. IngressProps \u00b6 Properties for Ingress . Initializer \u00b6 import { IngressProps } from 'cdk8s-plus-22' const ingressProps : IngressProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public readonly defaultBackend : IngressBackend ; Type: cdk8s-plus-22.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public readonly rules : IngressRule []; Type: cdk8s-plus-22.IngressRule [] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public readonly tls : IngressTls []; Type: cdk8s-plus-22.IngressTls [] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressRule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import { IngressRule } from 'cdk8s-plus-22' const ingressRule : IngressRule = { ... } backend Required \u00b6 public readonly backend : IngressBackend ; Type: cdk8s-plus-22.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public readonly host : string ; Type: string Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public readonly path : string ; Type: string Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. pathType Optional \u00b6 public readonly pathType : HttpIngressPathType ; Type: cdk8s-plus-22.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types IngressTls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import { IngressTls } from 'cdk8s-plus-22' const ingressTls : IngressTls = { ... } hosts Optional \u00b6 public readonly hosts : string []; Type: string [] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-22.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for Job . Initializer \u00b6 import { JobProps } from 'cdk8s-plus-22' const jobProps : JobProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-22.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. LabelSelectorRequirement \u00b6 A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Initializer \u00b6 import { LabelSelectorRequirement } from 'cdk8s-plus-22' const labelSelectorRequirement : LabelSelectorRequirement = { ... } key Required \u00b6 public readonly key : string ; Type: string The label key that the selector applies to. operator Required \u00b6 public readonly operator : LabelSelectorRequirementOperator ; Type: cdk8s-plus-22.LabelSelectorRequirementOperator Represents a key\u2019s relationship to a set of values. values Optional \u00b6 public readonly values : string []; Type: string [] An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. MemoryResources \u00b6 Memory request and limit. Initializer \u00b6 import { MemoryResources } from 'cdk8s-plus-22' const memoryResources : MemoryResources = { ... } limit Required \u00b6 public readonly limit : Size ; Type: cdk8s.Size request Required \u00b6 public readonly request : Size ; Type: cdk8s.Size MountOptions \u00b6 Options for mounts. Initializer \u00b6 import { MountOptions } from 'cdk8s-plus-22' const mountOptions : MountOptions = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import { PathMapping } from 'cdk8s-plus-22' const pathMapping : PathMapping = { ... } path Required \u00b6 public readonly path : string ; Type: string The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public readonly mode : number ; Type: number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PersistentVolumeClaimProps \u00b6 Properties for PersistentVolumeClaim . Initializer \u00b6 import { PersistentVolumeClaimProps } from 'cdk8s-plus-22' const persistentVolumeClaimProps : PersistentVolumeClaimProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-22.PersistentVolumeAccessMode [] Default: No access modes requirement. Contains the access modes the volume should support. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1 storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No storage requirement. Minimum storage size the volume should have. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Not set. Name of the StorageClass required by the claim. When this property is not set, the behavior is as follows:. If the admission plugin is turned on, the storage class marked as default will be used. - If the admission plugin is turned off, the pvc can only be bound to volumes without a storage class. https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 volume Optional \u00b6 public readonly volume : IPersistentVolume ; Type: cdk8s-plus-22.IPersistentVolume Default: No specific volume binding. The PersistentVolume backing this claim. The control plane still checks that storage class, access modes, and requested storage size on the volume are valid. Note that in order to guarantee a proper binding, the volume should also define a claimRef referring to this claim. Otherwise, the volume may be claimed be other pvc\u2019s before it gets a chance to bind to this one. If the volume is managed (i.e not imported), you can use pv.claim() to easily create a bi-directional bounded claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PersistentVolumeClaimVolumeOptions \u00b6 Options for a PersistentVolumeClaim-based volume. Initializer \u00b6 import { PersistentVolumeClaimVolumeOptions } from 'cdk8s-plus-22' const persistentVolumeClaimVolumeOptions : PersistentVolumeClaimVolumeOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: Derived from the PVC name. The volume name. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Will force the ReadOnly setting in VolumeMounts. PersistentVolumeProps \u00b6 Properties for PersistentVolume . Initializer \u00b6 import { PersistentVolumeProps } from 'cdk8s-plus-22' const persistentVolumeProps : PersistentVolumeProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. accessModes Optional \u00b6 public readonly accessModes : PersistentVolumeAccessMode []; Type: cdk8s-plus-22.PersistentVolumeAccessMode [] Default: No access modes. Contains all ways the volume can be mounted. https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes claim Optional \u00b6 public readonly claim : IPersistentVolumeClaim ; Type: cdk8s-plus-22.IPersistentVolumeClaim Default: Not bound to a specific claim. Part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding mountOptions Optional \u00b6 public readonly mountOptions : string []; Type: string [] Default: No options. A list of mount options, e.g. [\u201cro\u201d, \u201csoft\u201d]. Not validated - mount will simply fail if one is invalid. https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options reclaimPolicy Optional \u00b6 public readonly reclaimPolicy : PersistentVolumeReclaimPolicy ; Type: cdk8s-plus-22.PersistentVolumeReclaimPolicy Default: PersistentVolumeReclaimPolicy.RETAIN When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy tells the cluster what to do with the volume after it has been released of its claim. https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming storage Optional \u00b6 public readonly storage : Size ; Type: cdk8s.Size Default: No specified. What is the storage capacity of this volume. https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources storageClassName Optional \u00b6 public readonly storageClassName : string ; Type: string Default: Volume does not belong to any storage class. Name of StorageClass to which this persistent volume belongs. volumeMode Optional \u00b6 public readonly volumeMode : PersistentVolumeMode ; Type: cdk8s-plus-22.PersistentVolumeMode Default: VolumeMode.FILE_SYSTEM Defines what type of volume is required by the claim. PodDnsProps \u00b6 Properties for PodDns . Initializer \u00b6 import { PodDnsProps } from 'cdk8s-plus-22' const podDnsProps : PodDnsProps = { ... } hostname Optional \u00b6 public readonly hostname : string ; Type: string Default: Set to a system-defined value. Specifies the hostname of the Pod. hostnameAsFQDN Optional \u00b6 public readonly hostnameAsFQDN : boolean ; Type: boolean Default: false If true the pod\u2019s hostname will be configured as the pod\u2019s FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. nameservers Optional \u00b6 public readonly nameservers : string []; Type: string [] A list of IP addresses that will be used as DNS servers for the Pod. There can be at most 3 IP addresses specified. When the policy is set to \u201cNONE\u201d, the list must contain at least one IP address, otherwise this property is optional. The servers listed will be combined to the base nameservers generated from the specified DNS policy with duplicate addresses removed. options Optional \u00b6 public readonly options : DnsOption []; Type: cdk8s-plus-22.DnsOption [] List of objects where each object may have a name property (required) and a value property (optional). The contents in this property will be merged to the options generated from the specified DNS policy. Duplicate entries are removed. policy Optional \u00b6 public readonly policy : DnsPolicy ; Type: cdk8s-plus-22.DnsPolicy Default: DnsPolicy.CLUSTER_FIRST Set DNS policy for the pod. If policy is set to None , other configuration must be supplied. searches Optional \u00b6 public readonly searches : string []; Type: string [] A list of DNS search domains for hostname lookup in the Pod. When specified, the provided list will be merged into the base search domain names generated from the chosen DNS policy. Duplicate domain names are removed. Kubernetes allows for at most 6 search domains. subdomain Optional \u00b6 public readonly subdomain : string ; Type: string Default: No subdomain. If specified, the fully qualified Pod hostname will be \u201c . . .svc. \u201c. PodProps \u00b6 Properties for Pod . Initializer \u00b6 import { PodProps } from 'cdk8s-plus-22' const podProps : PodProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-22.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSecurityContextProps \u00b6 Properties for PodSecurityContext . Initializer \u00b6 import { PodSecurityContextProps } from 'cdk8s-plus-22' const podSecurityContextProps : PodSecurityContextProps = { ... } ensureNonRoot Optional \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean Default: false Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. fsGroup Optional \u00b6 public readonly fsGroup : number ; Type: number Default: Volume ownership is not changed. Modify the ownership and permissions of pod volumes to this GID. fsGroupChangePolicy Optional \u00b6 public readonly fsGroupChangePolicy : FsGroupChangePolicy ; Type: cdk8s-plus-22.FsGroupChangePolicy Default: FsGroupChangePolicy.ALWAYS Defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. group Optional \u00b6 public readonly group : number ; Type: number Default: Group configured by container runtime The GID to run the entrypoint of the container process. sysctls Optional \u00b6 public readonly sysctls : Sysctl []; Type: cdk8s-plus-22.Sysctl [] Default: No sysctls Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. user Optional \u00b6 public readonly user : number ; Type: number Default: User specified in image metadata The UID to run the entrypoint of the container process. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import { ProbeOptions } from 'cdk8s-plus-22' const probeOptions : ProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import { ResourceProps } from 'cdk8s-plus-22' const resourceProps : ResourceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. RoleBindingProps \u00b6 Properties for RoleBinding . Initializer \u00b6 import { RoleBindingProps } from 'cdk8s-plus-22' const roleBindingProps : RoleBindingProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. role Required \u00b6 public readonly role : IRole ; Type: cdk8s-plus-22.IRole The role to bind to. A RoleBinding can reference a Role or a ClusterRole. RolePolicyRule \u00b6 Policy rule of a `Role. Initializer \u00b6 import { RolePolicyRule } from 'cdk8s-plus-22' const rolePolicyRule : RolePolicyRule = { ... } resources Required \u00b6 public readonly resources : IApiResource []; Type: cdk8s-plus-22.IApiResource [] Resources this rule applies to. verbs Required \u00b6 public readonly verbs : string []; Type: string [] Verbs to allow. (e.g [\u2018get\u2019, \u2018watch\u2019]) RoleProps \u00b6 Properties for Role . Initializer \u00b6 import { RoleProps } from 'cdk8s-plus-22' const roleProps : RoleProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. rules Optional \u00b6 public readonly rules : RolePolicyRule []; Type: cdk8s-plus-22.RolePolicyRule [] Default: [] A list of rules the role should allow. SecretProps \u00b6 Options for Secret . Initializer \u00b6 import { SecretProps } from 'cdk8s-plus-22' const secretProps : SecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. stringData Optional \u00b6 public readonly stringData : {[ key : string ] : string }; Type: {[ key: string ]: string } stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public readonly type : string ; Type: string Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import { SecretValue } from 'cdk8s-plus-22' const secretValue : SecretValue = { ... } key Required \u00b6 public readonly key : string ; Type: string The JSON key. secret Required \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-22.ISecret The secret. SecretVolumeOptions \u00b6 Options for the Secret-based volume. Initializer \u00b6 import { SecretVolumeOptions } from 'cdk8s-plus-22' const secretVolumeOptions : SecretVolumeOptions = { ... } defaultMode Optional \u00b6 public readonly defaultMode : number ; Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public readonly items : {[ key : string ] : PathMapping }; Type: {[ key: string ]: cdk8s-plus-22.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: undocumented Specify whether the secret or its keys must be defined. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Initializer \u00b6 import { ServiceAccountProps } from 'cdk8s-plus-22' const serviceAccountProps : ServiceAccountProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountToken Optional \u00b6 public readonly automountToken : boolean ; Type: boolean Default: true Indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server secrets Optional \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-22.ISecret [] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceAccountTokenSecretProps \u00b6 Options for ServiceAccountTokenSecret . Initializer \u00b6 import { ServiceAccountTokenSecretProps } from 'cdk8s-plus-22' const serviceAccountTokenSecretProps : ServiceAccountTokenSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. serviceAccount Required \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount The service account to store a secret for. ServiceIngressBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import { ServiceIngressBackendOptions } from 'cdk8s-plus-22' const serviceIngressBackendOptions : ServiceIngressBackendOptions = { ... } port Optional \u00b6 public readonly port : number ; Type: number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import { ServicePort } from 'cdk8s-plus-22' const servicePort : ServicePort = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public readonly port : number ; Type: number The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import { ServicePortOptions } from 'cdk8s-plus-22' const servicePortOptions : ServicePortOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import { ServiceProps } from 'cdk8s-plus-22' const serviceProps : ServiceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public readonly externalIPs : string []; Type: string [] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public readonly externalName : string ; Type: string Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public readonly loadBalancerSourceRanges : string []; Type: string [] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-22.ServicePort [] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-22.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types SshAuthSecretProps \u00b6 Options for SshAuthSecret . Initializer \u00b6 import { SshAuthSecretProps } from 'cdk8s-plus-22' const sshAuthSecretProps : SshAuthSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. sshPrivateKey Required \u00b6 public readonly sshPrivateKey : string ; Type: string The SSH private key to use. StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import { StatefulSetProps } from 'cdk8s-plus-22' const statefulSetProps : StatefulSetProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-22.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. service Required \u00b6 public readonly service : Service ; Type: cdk8s-plus-22.Service Service to associate with the statefulset. minReady Optional \u00b6 public readonly minReady : Duration ; Type: cdk8s.Duration Default: Duration.seconds(0) Minimum duration for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Zero means the pod will be considered available as soon as it is ready. This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds podManagementPolicy Optional \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-22.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. strategy Optional \u00b6 public readonly strategy : StatefulSetUpdateStrategy ; Type: cdk8s-plus-22.StatefulSetUpdateStrategy Default: RollingUpdate with partition set to 0 Indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template. StatefulSetUpdateStrategyRollingUpdateOptions \u00b6 Options for StatefulSetUpdateStrategy.rollingUpdate . Initializer \u00b6 import { StatefulSetUpdateStrategyRollingUpdateOptions } from 'cdk8s-plus-22' const statefulSetUpdateStrategyRollingUpdateOptions : StatefulSetUpdateStrategyRollingUpdateOptions = { ... } partition Optional \u00b6 public readonly partition : number ; Type: number Default: 0 If specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet\u2019s .spec.template is updated. All Pods with an ordinal that is less than the partition will not be updated, and, even if they are deleted, they will be recreated at the previous version. If the partition is greater than replicas, updates to the pod template will not be propagated to Pods. In most cases you will not need to use a partition, but they are useful if you want to stage an update, roll out a canary, or perform a phased roll out. https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions Sysctl \u00b6 Sysctl defines a kernel parameter to be set. Initializer \u00b6 import { Sysctl } from 'cdk8s-plus-22' const sysctl : Sysctl = { ... } name Required \u00b6 public readonly name : string ; Type: string Name of a property to set. value Required \u00b6 public readonly value : string ; Type: string Value of a property to set. TcpSocketProbeOptions \u00b6 Options for Probe.fromTcpSocket() . Initializer \u00b6 import { TcpSocketProbeOptions } from 'cdk8s-plus-22' const tcpSocketProbeOptions : TcpSocketProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes host Optional \u00b6 public readonly host : string ; Type: string Default: defaults to the pod IP The host name to connect to on the container. port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to connect to on the container. TlsSecretProps \u00b6 Options for TlsSecret . Initializer \u00b6 import { TlsSecretProps } from 'cdk8s-plus-22' const tlsSecretProps : TlsSecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. immutable Optional \u00b6 public readonly immutable : boolean ; Type: boolean Default: false If set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. tlsCert Required \u00b6 public readonly tlsCert : string ; Type: string The TLS cert. tlsKey Required \u00b6 public readonly tlsKey : string ; Type: string The TLS key. UserProps \u00b6 Properties for User . Initializer \u00b6 import { UserProps } from 'cdk8s-plus-22' const userProps : UserProps = { ... } name Required \u00b6 public readonly name : string ; Type: string The name of the user. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import { VolumeMount } from 'cdk8s-plus-22' const volumeMount : VolumeMount = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). subPathExpr and subPath are mutually exclusive. path Required \u00b6 public readonly path : string ; Type: string Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public readonly volume : Volume ; Type: cdk8s-plus-22.Volume The volume to mount. WorkloadProps \u00b6 Properties for Workload . Initializer \u00b6 import { WorkloadProps } from 'cdk8s-plus-22' const workloadProps : WorkloadProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. automountServiceAccountToken Optional \u00b6 public readonly automountServiceAccountToken : boolean ; Type: boolean Default: true Indicates whether a service account token should be automatically mounted. https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() dns Optional \u00b6 public readonly dns : PodDnsProps ; Type: cdk8s-plus-22.PodDnsProps Default: policy: DnsPolicy.CLUSTER_FIRST hostnameAsFQDN: false DNS settings for the pod. https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ dockerRegistryAuth Optional \u00b6 public readonly dockerRegistryAuth : DockerConfigSecret ; Type: cdk8s-plus-22.DockerConfigSecret Default: No auth. Images are assumed to be publicly available. A secret containing docker credentials for authenticating to a registry. hostAliases Optional \u00b6 public readonly hostAliases : HostAlias []; Type: cdk8s-plus-22.HostAlias [] HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s hosts file. initContainers Optional \u00b6 public readonly initContainers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No init containers. List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added ,removed or updated. https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy securityContext Optional \u00b6 public readonly securityContext : PodSecurityContextProps ; Type: cdk8s-plus-22.PodSecurityContextProps Default: fsGroupChangePolicy: FsGroupChangePolicy.FsGroupChangePolicy.ALWAYS ensureNonRoot: false SecurityContext holds pod-level security attributes and common container settings. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata of this workload. select Optional \u00b6 public readonly select : boolean ; Type: boolean Default: true Automatically allocates a pod label selector for this workload and add it to the pod metadata. This ensures this workload manages pods created by its pod template. Classes \u00b6 ApiResource \u00b6 Implements: cdk8s-plus-22.IApiResource , cdk8s-plus-22.IApiEndpoint Represents information about an API resource type. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 custom \u00b6 import { ApiResource } from 'cdk8s-plus-22' ApiResource . custom ( options : ApiResourceOptions ) options Required \u00b6 Type: cdk8s-plus-22.ApiResourceOptions Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of the resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources Constants \u00b6 API_SERVICES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for APIService. BINDINGS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Binding. CERTIFICATE_SIGNING_REQUESTS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for CertificateSigningRequest. CLUSTER_ROLE_BINDINGS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ClusterRoleBinding. CLUSTER_ROLES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ClusterRole. COMPONENT_STATUSES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ComponentStatus. CONFIG_MAPS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ConfigMap. CONTROLLER_REVISIONS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ControllerRevision. CRON_JOBS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for CronJob. CSI_DRIVERS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for CSIDriver. CSI_NODES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for CSINode. CSI_STORAGE_CAPACITIES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for CSIStorageCapacity. CUSTOM_RESOURCE_DEFINITIONS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for CustomResourceDefinition. DAEMON_SETS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for DaemonSet. DEPLOYMENTS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Deployment. ENDPOINT_SLICES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for EndpointSlice. ENDPOINTS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Endpoints. EVENTS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Event. FLOW_SCHEMAS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for FlowSchema. HORIZONTAL_POD_AUTOSCALERS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for HorizontalPodAutoscaler. INGRESS_CLASSES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for IngressClass. INGRESSES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Ingress. JOBS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Job. LEASES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Lease. LIMIT_RANGES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for LimitRange. LOCAL_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for LocalSubjectAccessReview. MUTATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for MutatingWebhookConfiguration. NAMESPACES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Namespace. NETWORK_POLICIES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for NetworkPolicy. NODES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Node. PERSISTENT_VOLUME_CLAIMS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for PersistentVolumeClaim. PERSISTENT_VOLUMES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for PersistentVolume. POD_DISRUPTION_BUDGETS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for PodDisruptionBudget. POD_SECURITY_POLICIES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for PodSecurityPolicy. POD_TEMPLATES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for PodTemplate. PODS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Pod. PRIORITY_CLASSES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for PriorityClass. PRIORITY_LEVEL_CONFIGURATIONS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for PriorityLevelConfiguration. REPLICA_SETS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ReplicaSet. REPLICATION_CONTROLLERS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ReplicationController. RESOURCE_QUOTAS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ResourceQuota. ROLE_BINDINGS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for RoleBinding. ROLES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Role. RUNTIME_CLASSES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for RuntimeClass. SECRETS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Secret. SELF_SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for SelfSubjectAccessReview. SELF_SUBJECT_RULES_REVIEWS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for SelfSubjectRulesReview. SERVICE_ACCOUNTS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ServiceAccount. SERVICES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for Service. STATEFUL_SETS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for StatefulSet. STORAGE_CLASSES \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for StorageClass. SUBJECT_ACCESS_REVIEWS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for SubjectAccessReview. TOKEN_REVIEWS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for TokenReview. VALIDATING_WEBHOOK_CONFIGURATIONS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for ValidatingWebhookConfiguration. VOLUME_ATTACHMENTS \u00b6 Type: cdk8s-plus-22.ApiResource API resource information for VolumeAttachment. Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import { Container } from 'cdk8s-plus-22' new Container ( props : ContainerProps ) props Required \u00b6 Type: cdk8s-plus-22.ContainerProps Methods \u00b6 addEnv \u00b6 public addEnv ( name : string , value : EnvValue ) name Required \u00b6 Type: string The variable name. value Required \u00b6 Type: cdk8s-plus-22.EnvValue The variable value. mount \u00b6 public mount ( path : string , storage : IStorage , options? : MountOptions ) path Required \u00b6 Type: string The desired path in the container. storage Required \u00b6 Type: cdk8s-plus-22.IStorage The storage to mount. options Optional \u00b6 Type: cdk8s-plus-22.MountOptions Properties \u00b6 env Required \u00b6 public readonly env : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-22.EnvValue } The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 public readonly image : string ; Type: string The container image. imagePullPolicy Required \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-22.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public readonly mounts : VolumeMount []; Type: cdk8s-plus-22.VolumeMount [] Volume mounts configured for this container. name Required \u00b6 public readonly name : string ; Type: string The name of the container. securityContext Required \u00b6 public readonly securityContext : ContainerSecurityContext ; Type: cdk8s-plus-22.ContainerSecurityContext The security context of the container. args Optional \u00b6 public readonly args : string []; Type: string [] Arguments to the entrypoint. command Optional \u00b6 public readonly command : string []; Type: string [] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 public readonly port : number ; Type: number The port this container exposes. resources Optional \u00b6 public readonly resources : ContainerResources ; Type: cdk8s-plus-22.ContainerResources Compute resources (CPU and memory requests and limits) required by the container. https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ workingDir Optional \u00b6 public readonly workingDir : string ; Type: string The working directory inside the container. ContainerSecurityContext \u00b6 Container security attributes and settings. Initializers \u00b6 import { ContainerSecurityContext } from 'cdk8s-plus-22' new ContainerSecurityContext ( props? : ContainerSecurityContextProps ) props Optional \u00b6 Type: cdk8s-plus-22.ContainerSecurityContextProps Properties \u00b6 ensureNonRoot Required \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean privileged Required \u00b6 public readonly privileged : boolean ; Type: boolean readOnlyRootFilesystem Required \u00b6 public readonly readOnlyRootFilesystem : boolean ; Type: boolean group Optional \u00b6 public readonly group : number ; Type: number user Optional \u00b6 public readonly user : number ; Type: number Cpu \u00b6 Represents the amount of CPU. The amount can be passed as millis or units. Static Functions \u00b6 millis \u00b6 import { Cpu } from 'cdk8s-plus-22' Cpu . millis ( amount : number ) amount Required \u00b6 Type: number units \u00b6 import { Cpu } from 'cdk8s-plus-22' Cpu . units ( amount : number ) amount Required \u00b6 Type: number Properties \u00b6 amount Required \u00b6 public readonly amount : string ; Type: string DeploymentStrategy \u00b6 Deployment strategies. Static Functions \u00b6 recreate \u00b6 import { DeploymentStrategy } from 'cdk8s-plus-22' DeploymentStrategy . recreate () rollingUpdate \u00b6 import { DeploymentStrategy } from 'cdk8s-plus-22' DeploymentStrategy . rollingUpdate ( options? : DeploymentStrategyRollingUpdateOptions ) options Optional \u00b6 Type: cdk8s-plus-22.DeploymentStrategyRollingUpdateOptions EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import { EnvValue } from 'cdk8s-plus-22' EnvValue . fromConfigMap ( configMap : IConfigMap , key : string , options? : EnvValueFromConfigMapOptions ) configMap Required \u00b6 Type: cdk8s-plus-22.IConfigMap The config map. key Required \u00b6 Type: string The key to extract the value from. options Optional \u00b6 Type: cdk8s-plus-22.EnvValueFromConfigMapOptions Additional options. fromFieldRef \u00b6 import { EnvValue } from 'cdk8s-plus-22' EnvValue . fromFieldRef ( fieldPath : EnvFieldPaths , options? : EnvValueFromFieldRefOptions ) fieldPath Required \u00b6 Type: cdk8s-plus-22.EnvFieldPaths : The field reference. options Optional \u00b6 Type: cdk8s-plus-22.EnvValueFromFieldRefOptions : Additional options. fromProcess \u00b6 import { EnvValue } from 'cdk8s-plus-22' EnvValue . fromProcess ( key : string , options? : EnvValueFromProcessOptions ) key Required \u00b6 Type: string The key to read. options Optional \u00b6 Type: cdk8s-plus-22.EnvValueFromProcessOptions Additional options. fromResource \u00b6 import { EnvValue } from 'cdk8s-plus-22' EnvValue . fromResource ( resource : ResourceFieldPaths , options? : EnvValueFromResourceOptions ) resource Required \u00b6 Type: cdk8s-plus-22.ResourceFieldPaths : Resource to select the value from. options Optional \u00b6 Type: cdk8s-plus-22.EnvValueFromResourceOptions : Additional options. fromSecretValue \u00b6 import { EnvValue } from 'cdk8s-plus-22' EnvValue . fromSecretValue ( secretValue : SecretValue , options? : EnvValueFromSecretOptions ) secretValue Required \u00b6 Type: cdk8s-plus-22.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: cdk8s-plus-22.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import { EnvValue } from 'cdk8s-plus-22' EnvValue . fromValue ( value : string ) value Required \u00b6 Type: string The value. Properties \u00b6 value Optional \u00b6 public readonly value : any ; Type: any valueFrom Optional \u00b6 public readonly valueFrom : any ; Type: any Group \u00b6 Implements: cdk8s-plus-22.ISubject Represents a group. Initializers \u00b6 import { Group } from 'cdk8s-plus-22' new Group ( props : GroupProps ) props Required \u00b6 Type: cdk8s-plus-22.GroupProps Properties \u00b6 kind Required \u00b6 public readonly kind : string ; Type: string Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public readonly name : string ; Type: string Name of the object being referenced. apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Handler \u00b6 Defines a specific action that should be taken. Static Functions \u00b6 fromCommand \u00b6 import { Handler } from 'cdk8s-plus-22' Handler . fromCommand ( command : string []) command Required \u00b6 Type: string [] The command to execute. fromHttpGet \u00b6 import { Handler } from 'cdk8s-plus-22' Handler . fromHttpGet ( path : string , options? : HandlerFromHttpGetOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-22.HandlerFromHttpGetOptions Options. fromTcpSocket \u00b6 import { Handler } from 'cdk8s-plus-22' Handler . fromTcpSocket ( options? : HandlerFromTcpSocketOptions ) options Optional \u00b6 Type: cdk8s-plus-22.HandlerFromTcpSocketOptions Options. IngressBackend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromService \u00b6 import { IngressBackend } from 'cdk8s-plus-22' IngressBackend . fromService ( serv : Service , options? : ServiceIngressBackendOptions ) serv Required \u00b6 Type: cdk8s-plus-22.Service The service object. options Optional \u00b6 Type: cdk8s-plus-22.ServiceIngressBackendOptions LabelSelector \u00b6 A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors Static Functions \u00b6 doesNotExist \u00b6 import { LabelSelector } from 'cdk8s-plus-22' LabelSelector . doesNotExist ( key : string ) key Required \u00b6 Type: string exists \u00b6 import { LabelSelector } from 'cdk8s-plus-22' LabelSelector . exists ( key : string ) key Required \u00b6 Type: string in \u00b6 import { LabelSelector } from 'cdk8s-plus-22' LabelSelector . in ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] is \u00b6 import { LabelSelector } from 'cdk8s-plus-22' LabelSelector . is ( key : string , value : string , applyToTemplate? : boolean ) key Required \u00b6 Type: string value Required \u00b6 Type: string applyToTemplate Optional \u00b6 Type: boolean notIn \u00b6 import { LabelSelector } from 'cdk8s-plus-22' LabelSelector . notIn ( key : string , values : string []) key Required \u00b6 Type: string values Required \u00b6 Type: string [] Properties \u00b6 applyToTemplate Required \u00b6 public readonly applyToTemplate : boolean ; Type: boolean key Required \u00b6 public readonly key : string ; Type: string operator Optional \u00b6 public readonly operator : LabelSelectorRequirementOperator ; Type: cdk8s-plus-22.LabelSelectorRequirementOperator values Optional \u00b6 public readonly values : string []; Type: string [] NonApiResource \u00b6 Implements: cdk8s-plus-22.IApiEndpoint Factory for creating non api resources. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () Static Functions \u00b6 of \u00b6 import { NonApiResource } from 'cdk8s-plus-22' NonApiResource . of ( url : string ) url Required \u00b6 Type: string PercentOrAbsolute \u00b6 Union like class repsenting either a ration in percents or an absolute number. Methods \u00b6 isZero \u00b6 public isZero () Static Functions \u00b6 absolute \u00b6 import { PercentOrAbsolute } from 'cdk8s-plus-22' PercentOrAbsolute . absolute ( num : number ) num Required \u00b6 Type: number percent \u00b6 import { PercentOrAbsolute } from 'cdk8s-plus-22' PercentOrAbsolute . percent ( percent : number ) percent Required \u00b6 Type: number Properties \u00b6 value Required \u00b6 public readonly value : any ; Type: any PodDns \u00b6 Holds dns settings of the pod. Initializers \u00b6 import { PodDns } from 'cdk8s-plus-22' new PodDns ( props? : PodDnsProps ) props Optional \u00b6 Type: cdk8s-plus-22.PodDnsProps Methods \u00b6 addNameserver \u00b6 public addNameserver ( nameservers : string ) nameservers Required \u00b6 Type: string addOption \u00b6 public addOption ( options : DnsOption ) options Required \u00b6 Type: cdk8s-plus-22.DnsOption addSearch \u00b6 public addSearch ( searches : string ) searches Required \u00b6 Type: string Properties \u00b6 hostnameAsFQDN Required \u00b6 public readonly hostnameAsFQDN : boolean ; Type: boolean Whether or not the pods hostname is set to its FQDN. nameservers Required \u00b6 public readonly nameservers : string []; Type: string [] Nameservers defined for this pod. options Required \u00b6 public readonly options : DnsOption []; Type: cdk8s-plus-22.DnsOption [] Custom dns options defined for this pod. policy Required \u00b6 public readonly policy : DnsPolicy ; Type: cdk8s-plus-22.DnsPolicy The DNS policy of this pod. searches Required \u00b6 public readonly searches : string []; Type: string [] Search domains defined for this pod. hostname Optional \u00b6 public readonly hostname : string ; Type: string The configured hostname of the pod. Undefined means its set to a system-defined value. subdomain Optional \u00b6 public readonly subdomain : string ; Type: string The configured subdomain of the pod. PodSecurityContext \u00b6 Holds pod-level security attributes and common container settings. Initializers \u00b6 import { PodSecurityContext } from 'cdk8s-plus-22' new PodSecurityContext ( props? : PodSecurityContextProps ) props Optional \u00b6 Type: cdk8s-plus-22.PodSecurityContextProps Properties \u00b6 ensureNonRoot Required \u00b6 public readonly ensureNonRoot : boolean ; Type: boolean fsGroupChangePolicy Required \u00b6 public readonly fsGroupChangePolicy : FsGroupChangePolicy ; Type: cdk8s-plus-22.FsGroupChangePolicy sysctls Required \u00b6 public readonly sysctls : Sysctl []; Type: cdk8s-plus-22.Sysctl [] fsGroup Optional \u00b6 public readonly fsGroup : number ; Type: number group Optional \u00b6 public readonly group : number ; Type: number user Optional \u00b6 public readonly user : number ; Type: number Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Static Functions \u00b6 fromCommand \u00b6 import { Probe } from 'cdk8s-plus-22' Probe . fromCommand ( command : string [], options? : CommandProbeOptions ) command Required \u00b6 Type: string [] The command to execute. options Optional \u00b6 Type: cdk8s-plus-22.CommandProbeOptions Options. fromHttpGet \u00b6 import { Probe } from 'cdk8s-plus-22' Probe . fromHttpGet ( path : string , options? : HttpGetProbeOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-22.HttpGetProbeOptions Options. fromTcpSocket \u00b6 import { Probe } from 'cdk8s-plus-22' Probe . fromTcpSocket ( options? : TcpSocketProbeOptions ) options Optional \u00b6 Type: cdk8s-plus-22.TcpSocketProbeOptions Options. StatefulSetUpdateStrategy \u00b6 StatefulSet update strategies. Static Functions \u00b6 onDelete \u00b6 import { StatefulSetUpdateStrategy } from 'cdk8s-plus-22' StatefulSetUpdateStrategy . onDelete () rollingUpdate \u00b6 import { StatefulSetUpdateStrategy } from 'cdk8s-plus-22' StatefulSetUpdateStrategy . rollingUpdate ( options? : StatefulSetUpdateStrategyRollingUpdateOptions ) options Optional \u00b6 Type: cdk8s-plus-22.StatefulSetUpdateStrategyRollingUpdateOptions User \u00b6 Implements: cdk8s-plus-22.ISubject Represents a user. Initializers \u00b6 import { User } from 'cdk8s-plus-22' new User ( props : UserProps ) props Required \u00b6 Type: cdk8s-plus-22.UserProps Properties \u00b6 kind Required \u00b6 public readonly kind : string ; Type: string Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public readonly name : string ; Type: string Name of the object being referenced. apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. Volume \u00b6 Implements: cdk8s-plus-22.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Methods \u00b6 asVolume \u00b6 public asVolume () Static Functions \u00b6 fromAwsElasticBlockStore \u00b6 import { Volume } from 'cdk8s-plus-22' Volume . fromAwsElasticBlockStore ( volumeId : string , options? : AwsElasticBlockStoreVolumeOptions ) volumeId Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-22.AwsElasticBlockStoreVolumeOptions fromAzureDisk \u00b6 import { Volume } from 'cdk8s-plus-22' Volume . fromAzureDisk ( diskName : string , diskUri : string , options? : AzureDiskVolumeOptions ) diskName Required \u00b6 Type: string diskUri Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-22.AzureDiskVolumeOptions fromConfigMap \u00b6 import { Volume } from 'cdk8s-plus-22' Volume . fromConfigMap ( configMap : IConfigMap , options? : ConfigMapVolumeOptions ) configMap Required \u00b6 Type: cdk8s-plus-22.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-22.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import { Volume } from 'cdk8s-plus-22' Volume . fromEmptyDir ( name : string , options? : EmptyDirVolumeOptions ) name Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-22.EmptyDirVolumeOptions Additional options. fromGcePersistentDisk \u00b6 import { Volume } from 'cdk8s-plus-22' Volume . fromGcePersistentDisk ( pdName : string , options? : GCEPersistentDiskVolumeOptions ) pdName Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-22.GCEPersistentDiskVolumeOptions fromPersistentVolumeClaim \u00b6 import { Volume } from 'cdk8s-plus-22' Volume . fromPersistentVolumeClaim ( claim : IPersistentVolumeClaim , options? : PersistentVolumeClaimVolumeOptions ) claim Required \u00b6 Type: cdk8s-plus-22.IPersistentVolumeClaim options Optional \u00b6 Type: cdk8s-plus-22.PersistentVolumeClaimVolumeOptions fromSecret \u00b6 import { Volume } from 'cdk8s-plus-22' Volume . fromSecret ( secr : ISecret , options? : SecretVolumeOptions ) secr Required \u00b6 Type: cdk8s-plus-22.ISecret The secret to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-22.SecretVolumeOptions Options. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string Protocols \u00b6 IApiEndpoint \u00b6 Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.ApiResource , cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.BasicAuthSecret , cdk8s-plus-22.ClusterRole , cdk8s-plus-22.ClusterRoleBinding , cdk8s-plus-22.ConfigMap , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.DockerConfigSecret , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.Ingress , cdk8s-plus-22.Job , cdk8s-plus-22.NonApiResource , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.PersistentVolumeClaim , cdk8s-plus-22.Pod , cdk8s-plus-22.Resource , cdk8s-plus-22.Role , cdk8s-plus-22.RoleBinding , cdk8s-plus-22.Secret , cdk8s-plus-22.Service , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.ServiceAccountTokenSecret , cdk8s-plus-22.SshAuthSecret , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.TlsSecret , cdk8s-plus-22.Workload , cdk8s-plus-22.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both. Methods \u00b6 asApiResource \u00b6 public asApiResource () asNonApiResource \u00b6 public asNonApiResource () IApiResource \u00b6 Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.ApiResource , cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.BasicAuthSecret , cdk8s-plus-22.ClusterRole , cdk8s-plus-22.ClusterRoleBinding , cdk8s-plus-22.ConfigMap , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.DockerConfigSecret , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.Ingress , cdk8s-plus-22.Job , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.PersistentVolumeClaim , cdk8s-plus-22.Pod , cdk8s-plus-22.Resource , cdk8s-plus-22.Role , cdk8s-plus-22.RoleBinding , cdk8s-plus-22.Secret , cdk8s-plus-22.Service , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.ServiceAccountTokenSecret , cdk8s-plus-22.SshAuthSecret , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.TlsSecret , cdk8s-plus-22.Workload , cdk8s-plus-22.IApiResource Represents a resource or collection of resources. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). resourceType Required \u00b6 public readonly resourceType : string ; Type: string The name of a resource type as it appears in the relevant API endpoint. https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources resourceName Optional \u00b6 public readonly resourceName : string ; Type: string The unique, namespace-global, name of an object inside the Kubernetes cluster. If this is omitted, the ApiResource should represent all objects of the given type. IClusterRole \u00b6 Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ClusterRole , cdk8s-plus-22.IClusterRole Represents a cluster-level role. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IConfigMap \u00b6 Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ConfigMap , cdk8s-plus-22.IConfigMap Represents a config map. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IPersistentVolume \u00b6 Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.IPersistentVolume Contract of a PersistentVolumeClaim . Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IPersistentVolumeClaim \u00b6 Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.PersistentVolumeClaim , cdk8s-plus-22.IPersistentVolumeClaim Contract of a PersistentVolumeClaim . Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IResource \u00b6 Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.BasicAuthSecret , cdk8s-plus-22.ClusterRole , cdk8s-plus-22.ClusterRoleBinding , cdk8s-plus-22.ConfigMap , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.DockerConfigSecret , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.Ingress , cdk8s-plus-22.Job , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.PersistentVolumeClaim , cdk8s-plus-22.Pod , cdk8s-plus-22.Resource , cdk8s-plus-22.Role , cdk8s-plus-22.RoleBinding , cdk8s-plus-22.Secret , cdk8s-plus-22.Service , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.ServiceAccountTokenSecret , cdk8s-plus-22.SshAuthSecret , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.TlsSecret , cdk8s-plus-22.Workload , cdk8s-plus-22.IClusterRole , cdk8s-plus-22.IConfigMap , cdk8s-plus-22.IPersistentVolume , cdk8s-plus-22.IPersistentVolumeClaim , cdk8s-plus-22.IResource , cdk8s-plus-22.IRole , cdk8s-plus-22.ISecret , cdk8s-plus-22.IServiceAccount Represents a resource. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IRole \u00b6 Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ClusterRole , cdk8s-plus-22.Role , cdk8s-plus-22.IRole A reference to any Role or ClusterRole. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.BasicAuthSecret , cdk8s-plus-22.DockerConfigSecret , cdk8s-plus-22.Secret , cdk8s-plus-22.ServiceAccountTokenSecret , cdk8s-plus-22.SshAuthSecret , cdk8s-plus-22.TlsSecret , cdk8s-plus-22.ISecret Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.IServiceAccount Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. \u201cauthorization.k8s.io\u201d). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. \u201cauthorization.k8s.io/v1\u201d). kind Required \u00b6 public readonly kind : string ; Type: string The object kind (e.g. \u201cDeployment\u201d). name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IStorage \u00b6 Implemented By: cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.Volume , cdk8s-plus-22.IStorage Represents a piece of storage in the cluster. Methods \u00b6 asVolume \u00b6 public asVolume () ISubject \u00b6 Implemented By: cdk8s-plus-22.Group , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.User , cdk8s-plus-22.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names. Properties \u00b6 kind Required \u00b6 public readonly kind : string ; Type: string Kind of object being referenced. Values defined by this API group are \u201cUser\u201d, \u201cGroup\u201d, and \u201cServiceAccount\u201d. If the Authorizer does not recognized the kind value, the Authorizer should report an error. name Required \u00b6 public readonly name : string ; Type: string Name of the object being referenced. apiGroup Optional \u00b6 public readonly apiGroup : string ; Type: string APIGroup holds the API group of the referenced subject. Defaults to \u201c\u201d for ServiceAccount subjects. Defaults to \u201crbac.authorization.k8s.io\u201d for User and Group subjects. namespace Optional \u00b6 public readonly namespace : string ; Type: string Namespace of the referenced object. If the object kind is non-namespace, such as \u201cUser\u201d or \u201cGroup\u201d, and this value is not empty the Authorizer should report an error. Enums \u00b6 AzureDiskPersistentVolumeCachingMode \u00b6 Azure disk caching modes. NONE \u00b6 None. READ_ONLY \u00b6 ReadOnly. READ_WRITE \u00b6 ReadWrite. AzureDiskPersistentVolumeKind \u00b6 Azure Disk kinds. SHARED \u00b6 Multiple blob disks per storage account. DEDICATED \u00b6 Single blob disk per storage account. MANAGED \u00b6 Azure managed data disk. DnsPolicy \u00b6 Pod DNS policies. CLUSTER_FIRST \u00b6 Any DNS query that does not match the configured cluster domain suffix, such as \u201cwww.kubernetes.io\u201d, is forwarded to the upstream nameserver inherited from the node. Cluster administrators may have extra stub-domain and upstream DNS servers configured. CLUSTER_FIRST_WITH_HOST_NET \u00b6 For Pods running with hostNetwork, you should explicitly set its DNS policy \u201cClusterFirstWithHostNet\u201d. DEFAULT \u00b6 The Pod inherits the name resolution configuration from the node that the pods run on. NONE \u00b6 It allows a Pod to ignore DNS settings from the Kubernetes environment. All DNS settings are supposed to be provided using the dnsConfig field in the Pod Spec. EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. EnvFieldPaths \u00b6 POD_NAME \u00b6 The name of the pod. POD_NAMESPACE \u00b6 The namespace of the pod. POD_UID \u00b6 The uid of the pod. POD_LABEL \u00b6 The labels of the pod. POD_ANNOTATION \u00b6 The annotations of the pod. POD_IP \u00b6 The ipAddress of the pod. SERVICE_ACCOUNT_NAME \u00b6 The service account name of the pod. NODE_NAME \u00b6 The name of the node. NODE_IP \u00b6 The ipAddress of the node. POD_IPS \u00b6 The ipAddresess of the pod. FsGroupChangePolicy \u00b6 ON_ROOT_MISMATCH \u00b6 Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This could help shorten the time it takes to change ownership and permission of a volume ALWAYS \u00b6 Always change permission and ownership of the volume when volume is mounted. HttpIngressPathType \u00b6 Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types PREFIX \u00b6 Matches the URL path exactly. EXACT \u00b6 Matches based on a URL path prefix split by \u2018/\u2019. IMPLEMENTATION_SPECIFIC \u00b6 Matching is specified by the underlying IngressClass. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. LabelSelectorRequirementOperator \u00b6 Possible operators. IN \u00b6 In. NOT_IN \u00b6 NotIn. EXISTS \u00b6 Exists. DOES_NOT_EXIST \u00b6 DoesNotExist. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PersistentVolumeAccessMode \u00b6 Access Modes. READ_WRITE_ONCE \u00b6 The volume can be mounted as read-write by a single node. ReadWriteOnce access mode still can allow multiple pods to access the volume when the pods are running on the same node. READ_ONLY_MANY \u00b6 The volume can be mounted as read-only by many nodes. READ_WRITE_MANY \u00b6 The volume can be mounted as read-write by many nodes. READ_WRITE_ONCE_POD \u00b6 The volume can be mounted as read-write by a single Pod. Use ReadWriteOncePod access mode if you want to ensure that only one pod across whole cluster can read that PVC or write to it. This is only supported for CSI volumes and Kubernetes version 1.22+. PersistentVolumeMode \u00b6 Volume Modes. FILE_SYSTEM \u00b6 Volume is ounted into Pods into a directory. If the volume is backed by a block device and the device is empty, Kubernetes creates a filesystem on the device before mounting it for the first time. BLOCK \u00b6 Use a volume as a raw block device. Such volume is presented into a Pod as a block device, without any filesystem on it. This mode is useful to provide a Pod the fastest possible way to access a volume, without any filesystem layer between the Pod and the volume. On the other hand, the application running in the Pod must know how to handle a raw block device PersistentVolumeReclaimPolicy \u00b6 Reclaim Policies. RETAIN \u00b6 The Retain reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered \u201creleased\u201d. But it is not yet available for another claim because the previous claimant\u2019s data remains on the volume. An administrator can manually reclaim the volume with the following steps: Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted. Manually clean up the data on the associated storage asset accordingly. Manually delete the associated storage asset. If you want to reuse the same storage asset, create a new PersistentVolume with the same storage asset definition. DELETE \u00b6 For volume plugins that support the Delete reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the reclaim policy of their StorageClass, which defaults to Delete. The administrator should configure the StorageClass according to users\u2019 expectations; otherwise, the PV must be edited or patched after it is created PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 ResourceFieldPaths \u00b6 CPU_LIMIT \u00b6 CPU limit of the container. MEMORY_LIMIT \u00b6 Memory limit of the container. CPU_REQUEST \u00b6 CPU request of the container. MEMORY_REQUEST \u00b6 Memory request of the container. STORAGE_LIMIT \u00b6 Ephemeral storage limit of the container. STORAGE_REQUEST \u00b6 Ephemeral storage request of the container. RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"TypeScript"},{"location":"reference/cdk8s-plus-22/typescript/#cdk8s-plus-22-typescript","text":"","title":"cdk8s-plus-22 (TypeScript) "},{"location":"reference/cdk8s-plus-22/typescript/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-22/typescript/#abstractpod","text":"","title":"AbstractPod "},{"location":"reference/cdk8s-plus-22/typescript/#awselasticblockstorepersistentvolume","text":"Represents an AWS Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore","title":"AwsElasticBlockStorePersistentVolume "},{"location":"reference/cdk8s-plus-22/typescript/#azurediskpersistentvolume","text":"AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.","title":"AzureDiskPersistentVolume "},{"location":"reference/cdk8s-plus-22/typescript/#basicauthsecret","text":"Create a secret for basic authentication. https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret","title":"BasicAuthSecret "},{"location":"reference/cdk8s-plus-22/typescript/#clusterrole","text":"Implements: cdk8s-plus-22.IClusterRole , cdk8s-plus-22.IRole ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.","title":"ClusterRole "},{"location":"reference/cdk8s-plus-22/typescript/#clusterrolebinding","text":"A ClusterRoleBinding grants permissions cluster-wide to a user or set of users.","title":"ClusterRoleBinding "},{"location":"reference/cdk8s-plus-22/typescript/#configmap","text":"Implements: cdk8s-plus-22.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-22/typescript/#daemonset","text":"A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created. Some typical uses of a DaemonSet are: running a cluster storage daemon on every node running a logs collection daemon on every node running a node monitoring daemon on every node In a simple case, one DaemonSet, covering all nodes, would be used for each type of daemon. A more complex setup might use multiple DaemonSets for a single type of daemon, but with different flags and/or different memory and cpu requests for different hardware types.","title":"DaemonSet "},{"location":"reference/cdk8s-plus-22/typescript/#deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-22/typescript/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-22/typescript/#dockerconfigsecret","text":"Create a secret for storing credentials for accessing a container image registry. https://kubernetes.io/docs/concepts/configuration/secret/#docker-config-secrets","title":"DockerConfigSecret "},{"location":"reference/cdk8s-plus-22/typescript/#gcepersistentdiskpersistentvolume","text":"GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet\u2019s host machine and then exposed to the pod. Provisioned by an admin. https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk","title":"GCEPersistentDiskPersistentVolume "},{"location":"reference/cdk8s-plus-22/typescript/#ingress","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"Ingress "},{"location":"reference/cdk8s-plus-22/typescript/#job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-22/typescript/#persistentvolume","text":"Implements: cdk8s-plus-22.IPersistentVolume , cdk8s-plus-22.IStorage A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.","title":"PersistentVolume "},{"location":"reference/cdk8s-plus-22/typescript/#persistentvolumeclaim","text":"Implements: cdk8s-plus-22.IPersistentVolumeClaim A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes","title":"PersistentVolumeClaim "},{"location":"reference/cdk8s-plus-22/typescript/#pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-22/typescript/#resource","text":"Implements: cdk8s-plus-22.IResource , cdk8s-plus-22.IApiResource , cdk8s-plus-22.IApiEndpoint Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-22/typescript/#role","text":"Implements: cdk8s-plus-22.IRole Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.","title":"Role "},{"location":"reference/cdk8s-plus-22/typescript/#rolebinding","text":"A RoleBinding grants permissions within a specific namespace to a user or set of users.","title":"RoleBinding "},{"location":"reference/cdk8s-plus-22/typescript/#secret","text":"Implements: cdk8s-plus-22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-22/typescript/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-22/typescript/#serviceaccount","text":"Implements: cdk8s-plus-22.IServiceAccount , cdk8s-plus-22.ISubject A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-22/typescript/#serviceaccounttokensecret","text":"Create a secret for a service account token. https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets","title":"ServiceAccountTokenSecret "},{"location":"reference/cdk8s-plus-22/typescript/#sshauthsecret","text":"Create a secret for ssh authentication. https://kubernetes.io/docs/concepts/configuration/secret/#ssh-authentication-secrets","title":"SshAuthSecret "},{"location":"reference/cdk8s-plus-22/typescript/#statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-22/typescript/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-22/typescript/#tlssecret","text":"Create a secret for storing a TLS certificate and its associated key. https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets","title":"TlsSecret "},{"location":"reference/cdk8s-plus-22/typescript/#workload","text":"A workload is an application running on Kubernetes. Whether your workload is a single component or several that work together, on Kubernetes you run it inside a set of pods. In Kubernetes, a Pod represents a set of running containers on your cluster.","title":"Workload "},{"location":"reference/cdk8s-plus-22/typescript/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-22/typescript/#abstractpodprops","text":"Properties for AbstractPod .","title":"AbstractPodProps "},{"location":"reference/cdk8s-plus-22/typescript/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-22/typescript/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-22/typescript/#apiresourceoptions","text":"Options for ApiResource .","title":"ApiResourceOptions "},{"location":"reference/cdk8s-plus-22/typescript/#awselasticblockstorepersistentvolumeprops","text":"Properties for AwsElasticBlockStorePersistentVolume .","title":"AwsElasticBlockStorePersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/typescript/#awselasticblockstorevolumeoptions","text":"Options of Volume.fromAwsElasticBlockStore .","title":"AwsElasticBlockStoreVolumeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#azurediskpersistentvolumeprops","text":"Properties for AzureDiskPersistentVolume .","title":"AzureDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/typescript/#azurediskvolumeoptions","text":"Options of Volume.fromAzureDisk .","title":"AzureDiskVolumeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#basicauthsecretprops","text":"Options for BasicAuthSecret .","title":"BasicAuthSecretProps "},{"location":"reference/cdk8s-plus-22/typescript/#clusterrolebindingprops","text":"Properties for ClusterRoleBinding .","title":"ClusterRoleBindingProps "},{"location":"reference/cdk8s-plus-22/typescript/#clusterrolepolicyrule","text":"Policy rule of a `ClusterRole.","title":"ClusterRolePolicyRule "},{"location":"reference/cdk8s-plus-22/typescript/#clusterroleprops","text":"Properties for ClusterRole .","title":"ClusterRoleProps "},{"location":"reference/cdk8s-plus-22/typescript/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#commonsecretprops","text":"Common properties for Secret .","title":"CommonSecretProps "},{"location":"reference/cdk8s-plus-22/typescript/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-22/typescript/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#containerlifecycle","text":"Container lifecycle properties.","title":"ContainerLifecycle "},{"location":"reference/cdk8s-plus-22/typescript/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-22/typescript/#containerresources","text":"CPU and memory compute resources.","title":"ContainerResources "},{"location":"reference/cdk8s-plus-22/typescript/#containersecuritycontextprops","text":"Properties for ContainerSecurityContext .","title":"ContainerSecurityContextProps "},{"location":"reference/cdk8s-plus-22/typescript/#cpuresources","text":"CPU request and limit.","title":"CpuResources "},{"location":"reference/cdk8s-plus-22/typescript/#daemonsetprops","text":"Properties for DaemonSet .","title":"DaemonSetProps "},{"location":"reference/cdk8s-plus-22/typescript/#deploymentprops","text":"Properties for Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-22/typescript/#deploymentstrategyrollingupdateoptions","text":"Options for DeploymentStrategy.rollingUpdate .","title":"DeploymentStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-22/typescript/#dnsoption","text":"Custom DNS option.","title":"DnsOption "},{"location":"reference/cdk8s-plus-22/typescript/#dockerconfigsecretprops","text":"Options for DockerConfigSecret .","title":"DockerConfigSecretProps "},{"location":"reference/cdk8s-plus-22/typescript/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-22/typescript/#envvaluefromfieldrefoptions","text":"Options to specify an environment variable value from a field reference.","title":"EnvValueFromFieldRefOptions "},{"location":"reference/cdk8s-plus-22/typescript/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-22/typescript/#envvaluefromresourceoptions","text":"Options to specify an environment variable value from a resource.","title":"EnvValueFromResourceOptions "},{"location":"reference/cdk8s-plus-22/typescript/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-22/typescript/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-22/typescript/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-22/typescript/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-22/typescript/#gcepersistentdiskpersistentvolumeprops","text":"Properties for GCEPersistentDiskPersistentVolume .","title":"GCEPersistentDiskPersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/typescript/#gcepersistentdiskvolumeoptions","text":"Options of Volume.fromGcePersistentDisk .","title":"GCEPersistentDiskVolumeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#groupprops","text":"Properties for Group .","title":"GroupProps "},{"location":"reference/cdk8s-plus-22/typescript/#handlerfromhttpgetoptions","text":"Options for Handler.fromHttpGet .","title":"HandlerFromHttpGetOptions "},{"location":"reference/cdk8s-plus-22/typescript/#handlerfromtcpsocketoptions","text":"Options for Handler.fromTcpSocket .","title":"HandlerFromTcpSocketOptions "},{"location":"reference/cdk8s-plus-22/typescript/#hostalias","text":"HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod\u2019s /etc/hosts file.","title":"HostAlias "},{"location":"reference/cdk8s-plus-22/typescript/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#ingressprops","text":"Properties for Ingress .","title":"IngressProps "},{"location":"reference/cdk8s-plus-22/typescript/#ingressrule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressRule "},{"location":"reference/cdk8s-plus-22/typescript/#ingresstls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressTls "},{"location":"reference/cdk8s-plus-22/typescript/#jobprops","text":"Properties for Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-22/typescript/#labelselectorrequirement","text":"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.","title":"LabelSelectorRequirement "},{"location":"reference/cdk8s-plus-22/typescript/#memoryresources","text":"Memory request and limit.","title":"MemoryResources "},{"location":"reference/cdk8s-plus-22/typescript/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-22/typescript/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-22/typescript/#persistentvolumeclaimprops","text":"Properties for PersistentVolumeClaim .","title":"PersistentVolumeClaimProps "},{"location":"reference/cdk8s-plus-22/typescript/#persistentvolumeclaimvolumeoptions","text":"Options for a PersistentVolumeClaim-based volume.","title":"PersistentVolumeClaimVolumeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#persistentvolumeprops","text":"Properties for PersistentVolume .","title":"PersistentVolumeProps "},{"location":"reference/cdk8s-plus-22/typescript/#poddnsprops","text":"Properties for PodDns .","title":"PodDnsProps "},{"location":"reference/cdk8s-plus-22/typescript/#podprops","text":"Properties for Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-22/typescript/#podsecuritycontextprops","text":"Properties for PodSecurityContext .","title":"PodSecurityContextProps "},{"location":"reference/cdk8s-plus-22/typescript/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-22/typescript/#rolebindingprops","text":"Properties for RoleBinding .","title":"RoleBindingProps "},{"location":"reference/cdk8s-plus-22/typescript/#rolepolicyrule","text":"Policy rule of a `Role.","title":"RolePolicyRule "},{"location":"reference/cdk8s-plus-22/typescript/#roleprops","text":"Properties for Role .","title":"RoleProps "},{"location":"reference/cdk8s-plus-22/typescript/#secretprops","text":"Options for Secret .","title":"SecretProps "},{"location":"reference/cdk8s-plus-22/typescript/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-22/typescript/#secretvolumeoptions","text":"Options for the Secret-based volume.","title":"SecretVolumeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#serviceaccountprops","text":"Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-22/typescript/#serviceaccounttokensecretprops","text":"Options for ServiceAccountTokenSecret .","title":"ServiceAccountTokenSecretProps "},{"location":"reference/cdk8s-plus-22/typescript/#serviceingressbackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressBackendOptions "},{"location":"reference/cdk8s-plus-22/typescript/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-22/typescript/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-22/typescript/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-22/typescript/#sshauthsecretprops","text":"Options for SshAuthSecret .","title":"SshAuthSecretProps "},{"location":"reference/cdk8s-plus-22/typescript/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-22/typescript/#statefulsetupdatestrategyrollingupdateoptions","text":"Options for StatefulSetUpdateStrategy.rollingUpdate .","title":"StatefulSetUpdateStrategyRollingUpdateOptions "},{"location":"reference/cdk8s-plus-22/typescript/#sysctl","text":"Sysctl defines a kernel parameter to be set.","title":"Sysctl "},{"location":"reference/cdk8s-plus-22/typescript/#tcpsocketprobeoptions","text":"Options for Probe.fromTcpSocket() .","title":"TcpSocketProbeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#tlssecretprops","text":"Options for TlsSecret .","title":"TlsSecretProps "},{"location":"reference/cdk8s-plus-22/typescript/#userprops","text":"Properties for User .","title":"UserProps "},{"location":"reference/cdk8s-plus-22/typescript/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-22/typescript/#workloadprops","text":"Properties for Workload .","title":"WorkloadProps "},{"location":"reference/cdk8s-plus-22/typescript/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-22/typescript/#apiresource","text":"Implements: cdk8s-plus-22.IApiResource , cdk8s-plus-22.IApiEndpoint Represents information about an API resource type.","title":"ApiResource "},{"location":"reference/cdk8s-plus-22/typescript/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-22/typescript/#containersecuritycontext","text":"Container security attributes and settings.","title":"ContainerSecurityContext "},{"location":"reference/cdk8s-plus-22/typescript/#cpu","text":"Represents the amount of CPU. The amount can be passed as millis or units.","title":"Cpu "},{"location":"reference/cdk8s-plus-22/typescript/#deploymentstrategy","text":"Deployment strategies.","title":"DeploymentStrategy "},{"location":"reference/cdk8s-plus-22/typescript/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-22/typescript/#group","text":"Implements: cdk8s-plus-22.ISubject Represents a group.","title":"Group "},{"location":"reference/cdk8s-plus-22/typescript/#handler","text":"Defines a specific action that should be taken.","title":"Handler "},{"location":"reference/cdk8s-plus-22/typescript/#ingressbackend","text":"The backend for an ingress path.","title":"IngressBackend "},{"location":"reference/cdk8s-plus-22/typescript/#labelselector","text":"A label selector is a label query over a set of resources. https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors","title":"LabelSelector "},{"location":"reference/cdk8s-plus-22/typescript/#nonapiresource","text":"Implements: cdk8s-plus-22.IApiEndpoint Factory for creating non api resources.","title":"NonApiResource "},{"location":"reference/cdk8s-plus-22/typescript/#percentorabsolute","text":"Union like class repsenting either a ration in percents or an absolute number.","title":"PercentOrAbsolute "},{"location":"reference/cdk8s-plus-22/typescript/#poddns","text":"Holds dns settings of the pod.","title":"PodDns "},{"location":"reference/cdk8s-plus-22/typescript/#podsecuritycontext","text":"Holds pod-level security attributes and common container settings.","title":"PodSecurityContext "},{"location":"reference/cdk8s-plus-22/typescript/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-22/typescript/#statefulsetupdatestrategy","text":"StatefulSet update strategies.","title":"StatefulSetUpdateStrategy "},{"location":"reference/cdk8s-plus-22/typescript/#user","text":"Implements: cdk8s-plus-22.ISubject Represents a user.","title":"User "},{"location":"reference/cdk8s-plus-22/typescript/#volume","text":"Implements: cdk8s-plus-22.IStorage Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-22/typescript/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-22/typescript/#iapiendpoint","text":"Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.ApiResource , cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.BasicAuthSecret , cdk8s-plus-22.ClusterRole , cdk8s-plus-22.ClusterRoleBinding , cdk8s-plus-22.ConfigMap , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.DockerConfigSecret , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.Ingress , cdk8s-plus-22.Job , cdk8s-plus-22.NonApiResource , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.PersistentVolumeClaim , cdk8s-plus-22.Pod , cdk8s-plus-22.Resource , cdk8s-plus-22.Role , cdk8s-plus-22.RoleBinding , cdk8s-plus-22.Secret , cdk8s-plus-22.Service , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.ServiceAccountTokenSecret , cdk8s-plus-22.SshAuthSecret , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.TlsSecret , cdk8s-plus-22.Workload , cdk8s-plus-22.IApiEndpoint An API Endpoint can either be a resource descriptor (e.g /pods) or a non resource url (e.g /healthz). It must be one or the other, and not both.","title":"IApiEndpoint "},{"location":"reference/cdk8s-plus-22/typescript/#iapiresource","text":"Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.ApiResource , cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.BasicAuthSecret , cdk8s-plus-22.ClusterRole , cdk8s-plus-22.ClusterRoleBinding , cdk8s-plus-22.ConfigMap , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.DockerConfigSecret , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.Ingress , cdk8s-plus-22.Job , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.PersistentVolumeClaim , cdk8s-plus-22.Pod , cdk8s-plus-22.Resource , cdk8s-plus-22.Role , cdk8s-plus-22.RoleBinding , cdk8s-plus-22.Secret , cdk8s-plus-22.Service , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.ServiceAccountTokenSecret , cdk8s-plus-22.SshAuthSecret , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.TlsSecret , cdk8s-plus-22.Workload , cdk8s-plus-22.IApiResource Represents a resource or collection of resources.","title":"IApiResource "},{"location":"reference/cdk8s-plus-22/typescript/#iclusterrole","text":"Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ClusterRole , cdk8s-plus-22.IClusterRole Represents a cluster-level role.","title":"IClusterRole "},{"location":"reference/cdk8s-plus-22/typescript/#iconfigmap","text":"Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ConfigMap , cdk8s-plus-22.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-22/typescript/#ipersistentvolume","text":"Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.IPersistentVolume Contract of a PersistentVolumeClaim .","title":"IPersistentVolume "},{"location":"reference/cdk8s-plus-22/typescript/#ipersistentvolumeclaim","text":"Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.PersistentVolumeClaim , cdk8s-plus-22.IPersistentVolumeClaim Contract of a PersistentVolumeClaim .","title":"IPersistentVolumeClaim "},{"location":"reference/cdk8s-plus-22/typescript/#iresource","text":"Implemented By: cdk8s-plus-22.AbstractPod , cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.BasicAuthSecret , cdk8s-plus-22.ClusterRole , cdk8s-plus-22.ClusterRoleBinding , cdk8s-plus-22.ConfigMap , cdk8s-plus-22.DaemonSet , cdk8s-plus-22.Deployment , cdk8s-plus-22.DockerConfigSecret , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.Ingress , cdk8s-plus-22.Job , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.PersistentVolumeClaim , cdk8s-plus-22.Pod , cdk8s-plus-22.Resource , cdk8s-plus-22.Role , cdk8s-plus-22.RoleBinding , cdk8s-plus-22.Secret , cdk8s-plus-22.Service , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.ServiceAccountTokenSecret , cdk8s-plus-22.SshAuthSecret , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.TlsSecret , cdk8s-plus-22.Workload , cdk8s-plus-22.IClusterRole , cdk8s-plus-22.IConfigMap , cdk8s-plus-22.IPersistentVolume , cdk8s-plus-22.IPersistentVolumeClaim , cdk8s-plus-22.IResource , cdk8s-plus-22.IRole , cdk8s-plus-22.ISecret , cdk8s-plus-22.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-22/typescript/#irole","text":"Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ClusterRole , cdk8s-plus-22.Role , cdk8s-plus-22.IRole A reference to any Role or ClusterRole.","title":"IRole "},{"location":"reference/cdk8s-plus-22/typescript/#isecret","text":"Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.BasicAuthSecret , cdk8s-plus-22.DockerConfigSecret , cdk8s-plus-22.Secret , cdk8s-plus-22.ServiceAccountTokenSecret , cdk8s-plus-22.SshAuthSecret , cdk8s-plus-22.TlsSecret , cdk8s-plus-22.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-22/typescript/#iserviceaccount","text":"Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-22/typescript/#istorage","text":"Implemented By: cdk8s-plus-22.AwsElasticBlockStorePersistentVolume , cdk8s-plus-22.AzureDiskPersistentVolume , cdk8s-plus-22.GCEPersistentDiskPersistentVolume , cdk8s-plus-22.PersistentVolume , cdk8s-plus-22.Volume , cdk8s-plus-22.IStorage Represents a piece of storage in the cluster.","title":"IStorage "},{"location":"reference/cdk8s-plus-22/typescript/#isubject","text":"Implemented By: cdk8s-plus-22.Group , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.User , cdk8s-plus-22.ISubject Subject contains a reference to the object or user identities a role binding applies to. This can either hold a direct API object reference, or a value for non-objects such as user and group names.","title":"ISubject "},{"location":"reference/cdk8s-plus-22/typescript/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-22/typescript/#azurediskpersistentvolumecachingmode","text":"Azure disk caching modes.","title":"AzureDiskPersistentVolumeCachingMode "},{"location":"reference/cdk8s-plus-22/typescript/#azurediskpersistentvolumekind","text":"Azure Disk kinds.","title":"AzureDiskPersistentVolumeKind "},{"location":"reference/cdk8s-plus-22/typescript/#dnspolicy","text":"Pod DNS policies.","title":"DnsPolicy "},{"location":"reference/cdk8s-plus-22/typescript/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-22/typescript/#envfieldpaths","text":"","title":"EnvFieldPaths "},{"location":"reference/cdk8s-plus-22/typescript/#fsgroupchangepolicy","text":"","title":"FsGroupChangePolicy "},{"location":"reference/cdk8s-plus-22/typescript/#httpingresspathtype","text":"Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types","title":"HttpIngressPathType "},{"location":"reference/cdk8s-plus-22/typescript/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-22/typescript/#labelselectorrequirementoperator","text":"Possible operators.","title":"LabelSelectorRequirementOperator "},{"location":"reference/cdk8s-plus-22/typescript/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-22/typescript/#persistentvolumeaccessmode","text":"Access Modes.","title":"PersistentVolumeAccessMode "},{"location":"reference/cdk8s-plus-22/typescript/#persistentvolumemode","text":"Volume Modes.","title":"PersistentVolumeMode "},{"location":"reference/cdk8s-plus-22/typescript/#persistentvolumereclaimpolicy","text":"Reclaim Policies.","title":"PersistentVolumeReclaimPolicy "},{"location":"reference/cdk8s-plus-22/typescript/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-22/typescript/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-22/typescript/#resourcefieldpaths","text":"","title":"ResourceFieldPaths "},{"location":"reference/cdk8s-plus-22/typescript/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-22/typescript/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "}]}