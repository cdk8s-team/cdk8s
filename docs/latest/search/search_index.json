{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 CDK8s is a software development framework for defining Kubernetes applications and reusable abstractions using familiar programming languages and rich object-oriented APIs. CDK8s generates pure Kubernetes YAML - you can use CDK8s to define applications for any Kubernetes cluster running anywhere. Read our blog or watch our CNCF webinar to learn more and see a live demo of CDK8s in action. How does it work \u00b6 CDK8s apps are programs written in one of the supported programming languages. They are structured as a tree of constructs . The root of the tree is an App construct. Within an app, users define any number of charts (classes that extend the Chart class). Each chart is synthesized into a separate Kubernetes manifest file. Charts are, in turn, composed of any number of constructs, and eventually from resources, which represent any Kubernetes resource, such as Pod , Service , Deployment , ReplicaSet , etc. CDK8s apps only define Kubernetes applications, they don\u2019t actually apply them to the cluster. When an app is executed, it synthesizes all the charts defined within the app into the dist directory, and then those charts can be applied to any Kubernetes cluster using kubectl apply -f dist/chart.k8s.yaml or a GitOps tool like Flux . CDK8s is based on the design concepts and technologies behind the AWS Cloud Development Kit , and can interoperate with AWS CDK constructs to define cloud-native applications that include both Kubernetes resources and other CDK constructs as first class citizens.","title":"Overview"},{"location":"#overview","text":"CDK8s is a software development framework for defining Kubernetes applications and reusable abstractions using familiar programming languages and rich object-oriented APIs. CDK8s generates pure Kubernetes YAML - you can use CDK8s to define applications for any Kubernetes cluster running anywhere. Read our blog or watch our CNCF webinar to learn more and see a live demo of CDK8s in action.","title":"Overview"},{"location":"#how-does-it-work","text":"CDK8s apps are programs written in one of the supported programming languages. They are structured as a tree of constructs . The root of the tree is an App construct. Within an app, users define any number of charts (classes that extend the Chart class). Each chart is synthesized into a separate Kubernetes manifest file. Charts are, in turn, composed of any number of constructs, and eventually from resources, which represent any Kubernetes resource, such as Pod , Service , Deployment , ReplicaSet , etc. CDK8s apps only define Kubernetes applications, they don\u2019t actually apply them to the cluster. When an app is executed, it synthesizes all the charts defined within the app into the dist directory, and then those charts can be applied to any Kubernetes cluster using kubectl apply -f dist/chart.k8s.yaml or a GitOps tool like Flux . CDK8s is based on the design concepts and technologies behind the AWS Cloud Development Kit , and can interoperate with AWS CDK constructs to define cloud-native applications that include both Kubernetes resources and other CDK constructs as first class citizens.","title":"How does it work"},{"location":"getting-started/","text":"Getting Started \u00b6 This guide will walk you through the following steps: Installing the CDK8s CLI. Creating a new CDK8s project in one of the supported programming languages. Define & deploy your first CDK8s application. Define a custom CDK8s construct. Prerequisites \u00b6 TypeScript Node.js >= 10.x Your favorite editor/IDE yarn (optional) Python Python >= 3.7.7 pipenv version 2018.11.26 or above. Java Maven >= 3.6.3 Go Go >= 1.16 Install the CLI \u00b6 CDK8s has a cute little CLI that has a few useful commands. Let\u2019s start by installing the CDK8s CLI globally. We have two options for this. npm $ npm install -g cdk8s-cli yarn $ yarn global add cdk8s-cli New Project \u00b6 Now, we\u2019ll use the cdk8s init command to create a new CDK8s app: TypeScript $ mkdir hello $ cd hello $ cdk8s init typescript-app Initializing a project from the typescript-app template ... Since TypeScript is a compiled language, we will need to compile .ts files to .js in order to execute our CDK app. You can do that continuously in the background like this: $ npm run watch Python $ mkdir hello $ cd hello $ cdk8s init python-app Initializing a project from the python-app template ... Java $ mkdir hello $ cd hello $ cdk8s init java-app Initializing a project from the java-app template ... Go $ mkdir hello $ cd hello $ cdk8s init go-app Initializing a project from the go-app template This will perform the following: Create a new project directory Install CDK8s as a dependency Import all Kubernetes API objects Apps & Charts \u00b6 At this point, if you will see something like this: TypeScript main.ts import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); // define resources here } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Python main.py #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here app = App () MyChart ( app , \"hello\" ) app . synth () Java src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // define resources here } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } Go main.go package main import ( \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) // define resources here return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } Apps are structured as a tree of constructs , which are composable units of abstraction. We will learn more about constructs soon. This initial code created by cdk8s init defines an app with a single, empty, chart. When you run cdk8s synth , a Kubernetes manifest YAML will be synthesized for each Chart in your app and will write it to the dist directory. You can try: $ cdk8s synth dist/hello.k8s.yaml $ cat dist/hello.k8s.yaml <EMPTY> Importing Constructs for the Kubernetes API \u00b6 OK, now let\u2019s define some Kubernetes API objects inside our chart. Similarly to charts and apps , Kubernetes API Objects are also represented in CDK8s as constructs . These constructs are imported to your project using the cdk8s import command which will add source files to your project that include constructs that represent the Kubernetes API. Info When cdk8s init created your project it already executed cdk8s import for you, so you should see an imports directory already there. You can either commit this directory to source-control or generate it as part of your build process. Now, let\u2019s use these constructs to define a simple Kubernetes application which contains Service and a Deployment resources inspired by paulbouwer \u2018s hello-kubernetes project. TypeScript import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; // imported constructs import { KubeDeployment , KubeService , IntOrString } from './imports/k8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); const label = { app : 'hello-k8s' }; new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port : 80 , targetPort : IntOrString.fromNumber ( 8080 ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas : 2 , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'hello-kubernetes' , image : 'paulbouwer/hello-kubernetes:1.7' , ports : [ { containerPort : 8080 } ] } ] } } } }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Python #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from imports import k8s class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here label = { \"app\" : \"hello-k8s\" } k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = 80 , target_port = k8s . IntOrString . from_number ( 8080 ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = 2 , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'hello-kubernetes' , image = 'paulbouwer/hello-kubernetes:1.7' , ports = [ k8s . ContainerPort ( container_port = 8080 )])])))) app = App () MyChart ( app , \"hello\" ) app . synth () Java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( 80 ) . targetPort ( IntOrString . fromNumber ( 8080 )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( 8080 ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"hello-kubernetes\" ) . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( 1 ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } Go package main import ( \"example.com/hello-k8s/imports/k8s\" \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) label := map [ string ] * string { \"app\" : jsii . String ( \"hello-k8s\" )} k8s . NewKubeService ( chart , jsii . String ( \"service\" ), & k8s . KubeServiceProps { Spec : & k8s . ServiceSpec { Type : jsii . String ( \"LoadBalancer\" ), Ports : & [] * k8s . ServicePort {{ Port : jsii . Number ( 80 ), TargetPort : k8s . IntOrString_FromNumber ( jsii . Number ( 8000 )), }}, Selector : & label , }, }) k8s . NewKubeDeployment ( chart , jsii . String ( \"deployment\" ), & k8s . KubeDeploymentProps { Spec : & k8s . DeploymentSpec { Replicas : jsii . Number ( 2 ), Selector : & k8s . LabelSelector { MatchLabels : & label , }, Template : & k8s . PodTemplateSpec { Metadata : & k8s . ObjectMeta { Labels : & label , }, Spec : & k8s . PodSpec { Containers : & [] * k8s . Container {{ Name : jsii . String ( \"hello-kubernetes\" ), Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), Ports : & [] * k8s . ContainerPort {{ ContainerPort : jsii . Number ( 8080 )}}, }}, }, }, }, }) return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } Now, compile & synth this project: cdk8s synth Notice In compiled languages, like Java and TypeScript, you\u2019ll need to compile your program before running cdk8s synth . This will be contents of hello.k8s.yaml : apiVersion : \"v1\" kind : \"Service\" metadata : name : \"hello-service-c8c17160\" spec : ports : - port : 80 targetPort : 8080 selector : app : \"hello-k8s\" type : \"LoadBalancer\" --- apiVersion : \"apps/v1\" kind : \"Deployment\" metadata : name : \"hello-deployment-c8c7fda7\" spec : replicas : 2 selector : matchLabels : app : \"hello-k8s\" template : metadata : labels : app : \"hello-k8s\" spec : containers : - image : \"paulbouwer/hello-kubernetes:1.7\" name : \"hello-kubernetes\" ports : - containerPort : 8080 The manifest synthesized by your app is ready to be applied to any Kubernetes cluster using standard tools like kubectl apply : kubectl apply -f dist/hello.k8s.yaml Abstraction through Constructs \u00b6 Constructs are the basic building block of CDK8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years. So let\u2019s create our first Kubernetes construct. We\u2019ll call it WebService and it will basically be a generalization of the hello world program. It\u2019s actually quite useful. For example, this one line will add a hello world service to our chart: TypeScript new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' }); It can also be customized through an API: new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' , containerPort : 8080 , replicas : 10 }); Python WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' ) It can also be customized through an API: WebService ( self , 'hello-k8s' , image = 'paulbouwer/hello-kubernetes:1.7' , container_port = 8080 , replicas = 10 ) Java new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . build ()); It can also be customized through an API: new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); Go NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), }) It can also be customized through an API: NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), ContainerPort : jsii . Number ( 8080 ), Replicas : jsii . Number ( 10 ), }) Here\u2019s how to implement WebService : TypeScript Create a file lib/web-service.ts (the convention is to use lib for reusable components): import { Construct } from 'constructs' ; import { Names } from 'cdk8s' ; import { KubeDeployment , KubeService , IntOrString } from '../imports/k8s' ; export interface WebServiceProps { /** * The Docker image to use for this service. */ readonly image : string ; /** * Number of replicas. * * @default 1 */ readonly replicas? : number ; /** * External port. * * @default 80 */ readonly port? : number ; /** * Internal port. * * @default 8080 */ readonly containerPort? : number ; } export class WebService extends Construct { constructor ( scope : Construct , id : string , props : WebServiceProps ) { super ( scope , id ); const port = props . port || 80 ; const containerPort = props . containerPort || 8080 ; const label = { app : Names.toDnsLabel ( this ) }; const replicas = props . replicas ?? 1 ; new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port , targetPort : IntOrString.fromNumber ( containerPort ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'app' , image : props.image , ports : [ { containerPort } ] } ] } } } }); } } Now, let\u2019s edit main.ts and use our new construct: import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; import { WebService } from './lib/web-service' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); new WebService ( this , 'hello' , { image : 'paulbouwer/hello-kubernetes:1.7' , replicas : 2 }); new WebService ( this , 'ghost' , { image : 'ghost' , containerPort : 2368 }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Python Create a file webservice.py with the following content: from constructs import Construct , Node from imports import k8s class WebService ( Construct ): def __init__ ( self , scope : Construct , id : str , * , image : str , replicas : int = 1 , port : int = 80 , container_port : int = 8080 ): super () . __init__ ( scope , id ) label = { 'app' : Node . of ( self ) . unique_id } k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = port , target_port = k8s . IntOrString . from_number ( container_port ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = replicas , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'app' , image = image , ports = [ k8s . ContainerPort ( container_port = container_port )])])))) Now, let\u2019s edit main.py and use our new construct: #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from webservice import WebService class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' , replicas = 2 ) WebService ( self , 'ghost' , image = 'ghost' , container_port = 2368 ) app = App () MyChart ( app , \"hello\" ) app . synth () Java src/main/java/com/mycompany/app/WebService.java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import java.util.Optional ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class WebService extends Construct { public WebService ( final Construct scope , final String id ) { this ( scope , id , null ); } public WebService ( final Construct scope , final String id , final WebServiceProps options ) { super ( scope , id ); final int portNumber = Optional . of ( options . getPort ()). orElse ( 80 ); final int containerPortNumber = Optional . of ( options . getContainerPort ()). orElse ( 8080 ); final int replicas = Optional . of ( options . getReplicas ()). orElse ( 1 ); final String image = options . getImage (); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( portNumber ) . targetPort ( IntOrString . fromNumber ( containerPortNumber )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( containerPortNumber ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"web\" ) . image ( image ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( replicas ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } } src/main/java/com/mycompany/app/WebServiceProps.java package com.mycompany.app ; public class WebServiceProps { private String image ; private int replicas ; private int port ; private int containerPort ; public WebServiceProps ( final String image , final int replicas , final int port , final int containerPort ) { this . image = image ; this . replicas = replicas ; this . port = port ; this . containerPort = containerPort ; } public String getImage () { return this . image ; } public int getReplicas () { return this . replicas ; } public int getPort () { return this . port ; } public int getContainerPort () { return this . containerPort ; } public static final class Builder { private String image ; private int replicas = 1 ; private int port = 80 ; private int containerPort = 8080 ; public Builder image ( String image ) { this . image = image ; return this ; } public Builder replicas ( int replicas ) { this . replicas = replicas ; return this ; } public Builder port ( int port ) { this . port = port ; return this ; } public Builder containerPort ( int containerPort ) { this . containerPort = containerPort ; return this ; } public WebServiceProps build () { return new WebServiceProps ( image , replicas , port , containerPort ); } } } src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); new WebService ( this , \"hello\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); new WebService ( this , \"ghost\" , new WebServiceProps . Builder () . image ( \"ghost\" ) . containerPort ( 2368 ) . build ()); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"web-service-java\" ); app . synth (); } } Go Create a file webservice.go with the following content: package main import ( \"example.com/hello/imports/k8s\" \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" ) type WebServiceProps struct { constructs . ConstructOptions Image * string Replicas * float64 Port * float64 ContainerPort * float64 } func NewWebService ( scope constructs . Construct , id * string , props * WebServiceProps ) constructs . Construct { var cprops constructs . ConstructOptions if props != nil { cprops = props . ConstructOptions } construct := constructs . NewConstruct ( scope , id , & cprops ) replicas := props . Replicas if replicas == nil { replicas = jsii . Number ( 1 ) } port := props . Port if port == nil { port = jsii . Number ( 80 ) } containerPort := props . ContainerPort if containerPort == nil { containerPort = jsii . Number ( 8080 ) } label := map [ string ] * string { \"app\" : constructs . Node_Of ( construct ). Id (), } k8s . NewKubeService ( construct , jsii . String ( \"service\" ), & k8s . KubeServiceProps { Spec : & k8s . ServiceSpec { Type : jsii . String ( \"LoadBalancer\" ), Ports : & [] * k8s . ServicePort {{ Port : port , TargetPort : k8s . IntOrString_FromNumber ( containerPort ), }}, Selector : & label , }, }) k8s . NewKubeDeployment ( construct , jsii . String ( \"deployment\" ), & k8s . KubeDeploymentProps { Spec : & k8s . DeploymentSpec { Replicas : replicas , Selector : & k8s . LabelSelector { MatchLabels : & label }, Template : & k8s . PodTemplateSpec { Metadata : & k8s . ObjectMeta { Labels : & label }, Spec : & k8s . PodSpec { Containers : & [] * k8s . Container {{ Name : jsii . String ( \"web\" ), Image : props . Image , Ports : & [] * k8s . ContainerPort {{ ContainerPort : containerPort }}, }}, }, }, }, }) return construct } Now, let\u2019s edit main.go and use our new construct: package main import ( \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), Replicas : jsii . Number ( 2 ), }) NewWebService ( chart , jsii . String ( \"ghost\" ), & WebServiceProps { Image : jsii . String ( \"ghost\" ), ContainerPort : jsii . Number ( 2368 ), }) return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } As you can see, we now add WebService constructs inside our chart: one that runs the paulbouwer/hello-kubernetes image and one with an installation of ghost .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"This guide will walk you through the following steps: Installing the CDK8s CLI. Creating a new CDK8s project in one of the supported programming languages. Define & deploy your first CDK8s application. Define a custom CDK8s construct.","title":"Getting Started"},{"location":"getting-started/#prerequisites","text":"TypeScript Node.js >= 10.x Your favorite editor/IDE yarn (optional) Python Python >= 3.7.7 pipenv version 2018.11.26 or above. Java Maven >= 3.6.3 Go Go >= 1.16","title":"Prerequisites"},{"location":"getting-started/#install-the-cli","text":"CDK8s has a cute little CLI that has a few useful commands. Let\u2019s start by installing the CDK8s CLI globally. We have two options for this. npm $ npm install -g cdk8s-cli yarn $ yarn global add cdk8s-cli","title":"Install the CLI"},{"location":"getting-started/#new-project","text":"Now, we\u2019ll use the cdk8s init command to create a new CDK8s app: TypeScript $ mkdir hello $ cd hello $ cdk8s init typescript-app Initializing a project from the typescript-app template ... Since TypeScript is a compiled language, we will need to compile .ts files to .js in order to execute our CDK app. You can do that continuously in the background like this: $ npm run watch Python $ mkdir hello $ cd hello $ cdk8s init python-app Initializing a project from the python-app template ... Java $ mkdir hello $ cd hello $ cdk8s init java-app Initializing a project from the java-app template ... Go $ mkdir hello $ cd hello $ cdk8s init go-app Initializing a project from the go-app template This will perform the following: Create a new project directory Install CDK8s as a dependency Import all Kubernetes API objects","title":"New Project"},{"location":"getting-started/#apps-charts","text":"At this point, if you will see something like this: TypeScript main.ts import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); // define resources here } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Python main.py #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here app = App () MyChart ( app , \"hello\" ) app . synth () Java src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // define resources here } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } Go main.go package main import ( \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) // define resources here return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } Apps are structured as a tree of constructs , which are composable units of abstraction. We will learn more about constructs soon. This initial code created by cdk8s init defines an app with a single, empty, chart. When you run cdk8s synth , a Kubernetes manifest YAML will be synthesized for each Chart in your app and will write it to the dist directory. You can try: $ cdk8s synth dist/hello.k8s.yaml $ cat dist/hello.k8s.yaml <EMPTY>","title":"Apps &amp; Charts"},{"location":"getting-started/#importing-constructs-for-the-kubernetes-api","text":"OK, now let\u2019s define some Kubernetes API objects inside our chart. Similarly to charts and apps , Kubernetes API Objects are also represented in CDK8s as constructs . These constructs are imported to your project using the cdk8s import command which will add source files to your project that include constructs that represent the Kubernetes API. Info When cdk8s init created your project it already executed cdk8s import for you, so you should see an imports directory already there. You can either commit this directory to source-control or generate it as part of your build process. Now, let\u2019s use these constructs to define a simple Kubernetes application which contains Service and a Deployment resources inspired by paulbouwer \u2018s hello-kubernetes project. TypeScript import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; // imported constructs import { KubeDeployment , KubeService , IntOrString } from './imports/k8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); const label = { app : 'hello-k8s' }; new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port : 80 , targetPort : IntOrString.fromNumber ( 8080 ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas : 2 , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'hello-kubernetes' , image : 'paulbouwer/hello-kubernetes:1.7' , ports : [ { containerPort : 8080 } ] } ] } } } }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Python #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from imports import k8s class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here label = { \"app\" : \"hello-k8s\" } k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = 80 , target_port = k8s . IntOrString . from_number ( 8080 ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = 2 , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'hello-kubernetes' , image = 'paulbouwer/hello-kubernetes:1.7' , ports = [ k8s . ContainerPort ( container_port = 8080 )])])))) app = App () MyChart ( app , \"hello\" ) app . synth () Java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( 80 ) . targetPort ( IntOrString . fromNumber ( 8080 )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( 8080 ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"hello-kubernetes\" ) . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( 1 ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } Go package main import ( \"example.com/hello-k8s/imports/k8s\" \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) label := map [ string ] * string { \"app\" : jsii . String ( \"hello-k8s\" )} k8s . NewKubeService ( chart , jsii . String ( \"service\" ), & k8s . KubeServiceProps { Spec : & k8s . ServiceSpec { Type : jsii . String ( \"LoadBalancer\" ), Ports : & [] * k8s . ServicePort {{ Port : jsii . Number ( 80 ), TargetPort : k8s . IntOrString_FromNumber ( jsii . Number ( 8000 )), }}, Selector : & label , }, }) k8s . NewKubeDeployment ( chart , jsii . String ( \"deployment\" ), & k8s . KubeDeploymentProps { Spec : & k8s . DeploymentSpec { Replicas : jsii . Number ( 2 ), Selector : & k8s . LabelSelector { MatchLabels : & label , }, Template : & k8s . PodTemplateSpec { Metadata : & k8s . ObjectMeta { Labels : & label , }, Spec : & k8s . PodSpec { Containers : & [] * k8s . Container {{ Name : jsii . String ( \"hello-kubernetes\" ), Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), Ports : & [] * k8s . ContainerPort {{ ContainerPort : jsii . Number ( 8080 )}}, }}, }, }, }, }) return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } Now, compile & synth this project: cdk8s synth Notice In compiled languages, like Java and TypeScript, you\u2019ll need to compile your program before running cdk8s synth . This will be contents of hello.k8s.yaml : apiVersion : \"v1\" kind : \"Service\" metadata : name : \"hello-service-c8c17160\" spec : ports : - port : 80 targetPort : 8080 selector : app : \"hello-k8s\" type : \"LoadBalancer\" --- apiVersion : \"apps/v1\" kind : \"Deployment\" metadata : name : \"hello-deployment-c8c7fda7\" spec : replicas : 2 selector : matchLabels : app : \"hello-k8s\" template : metadata : labels : app : \"hello-k8s\" spec : containers : - image : \"paulbouwer/hello-kubernetes:1.7\" name : \"hello-kubernetes\" ports : - containerPort : 8080 The manifest synthesized by your app is ready to be applied to any Kubernetes cluster using standard tools like kubectl apply : kubectl apply -f dist/hello.k8s.yaml","title":"Importing Constructs for the Kubernetes API"},{"location":"getting-started/#abstraction-through-constructs","text":"Constructs are the basic building block of CDK8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years. So let\u2019s create our first Kubernetes construct. We\u2019ll call it WebService and it will basically be a generalization of the hello world program. It\u2019s actually quite useful. For example, this one line will add a hello world service to our chart: TypeScript new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' }); It can also be customized through an API: new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' , containerPort : 8080 , replicas : 10 }); Python WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' ) It can also be customized through an API: WebService ( self , 'hello-k8s' , image = 'paulbouwer/hello-kubernetes:1.7' , container_port = 8080 , replicas = 10 ) Java new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . build ()); It can also be customized through an API: new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); Go NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), }) It can also be customized through an API: NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), ContainerPort : jsii . Number ( 8080 ), Replicas : jsii . Number ( 10 ), }) Here\u2019s how to implement WebService : TypeScript Create a file lib/web-service.ts (the convention is to use lib for reusable components): import { Construct } from 'constructs' ; import { Names } from 'cdk8s' ; import { KubeDeployment , KubeService , IntOrString } from '../imports/k8s' ; export interface WebServiceProps { /** * The Docker image to use for this service. */ readonly image : string ; /** * Number of replicas. * * @default 1 */ readonly replicas? : number ; /** * External port. * * @default 80 */ readonly port? : number ; /** * Internal port. * * @default 8080 */ readonly containerPort? : number ; } export class WebService extends Construct { constructor ( scope : Construct , id : string , props : WebServiceProps ) { super ( scope , id ); const port = props . port || 80 ; const containerPort = props . containerPort || 8080 ; const label = { app : Names.toDnsLabel ( this ) }; const replicas = props . replicas ?? 1 ; new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port , targetPort : IntOrString.fromNumber ( containerPort ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'app' , image : props.image , ports : [ { containerPort } ] } ] } } } }); } } Now, let\u2019s edit main.ts and use our new construct: import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; import { WebService } from './lib/web-service' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); new WebService ( this , 'hello' , { image : 'paulbouwer/hello-kubernetes:1.7' , replicas : 2 }); new WebService ( this , 'ghost' , { image : 'ghost' , containerPort : 2368 }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Python Create a file webservice.py with the following content: from constructs import Construct , Node from imports import k8s class WebService ( Construct ): def __init__ ( self , scope : Construct , id : str , * , image : str , replicas : int = 1 , port : int = 80 , container_port : int = 8080 ): super () . __init__ ( scope , id ) label = { 'app' : Node . of ( self ) . unique_id } k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = port , target_port = k8s . IntOrString . from_number ( container_port ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = replicas , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'app' , image = image , ports = [ k8s . ContainerPort ( container_port = container_port )])])))) Now, let\u2019s edit main.py and use our new construct: #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from webservice import WebService class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' , replicas = 2 ) WebService ( self , 'ghost' , image = 'ghost' , container_port = 2368 ) app = App () MyChart ( app , \"hello\" ) app . synth () Java src/main/java/com/mycompany/app/WebService.java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import java.util.Optional ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class WebService extends Construct { public WebService ( final Construct scope , final String id ) { this ( scope , id , null ); } public WebService ( final Construct scope , final String id , final WebServiceProps options ) { super ( scope , id ); final int portNumber = Optional . of ( options . getPort ()). orElse ( 80 ); final int containerPortNumber = Optional . of ( options . getContainerPort ()). orElse ( 8080 ); final int replicas = Optional . of ( options . getReplicas ()). orElse ( 1 ); final String image = options . getImage (); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( portNumber ) . targetPort ( IntOrString . fromNumber ( containerPortNumber )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( containerPortNumber ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"web\" ) . image ( image ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( replicas ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } } src/main/java/com/mycompany/app/WebServiceProps.java package com.mycompany.app ; public class WebServiceProps { private String image ; private int replicas ; private int port ; private int containerPort ; public WebServiceProps ( final String image , final int replicas , final int port , final int containerPort ) { this . image = image ; this . replicas = replicas ; this . port = port ; this . containerPort = containerPort ; } public String getImage () { return this . image ; } public int getReplicas () { return this . replicas ; } public int getPort () { return this . port ; } public int getContainerPort () { return this . containerPort ; } public static final class Builder { private String image ; private int replicas = 1 ; private int port = 80 ; private int containerPort = 8080 ; public Builder image ( String image ) { this . image = image ; return this ; } public Builder replicas ( int replicas ) { this . replicas = replicas ; return this ; } public Builder port ( int port ) { this . port = port ; return this ; } public Builder containerPort ( int containerPort ) { this . containerPort = containerPort ; return this ; } public WebServiceProps build () { return new WebServiceProps ( image , replicas , port , containerPort ); } } } src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); new WebService ( this , \"hello\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); new WebService ( this , \"ghost\" , new WebServiceProps . Builder () . image ( \"ghost\" ) . containerPort ( 2368 ) . build ()); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"web-service-java\" ); app . synth (); } } Go Create a file webservice.go with the following content: package main import ( \"example.com/hello/imports/k8s\" \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" ) type WebServiceProps struct { constructs . ConstructOptions Image * string Replicas * float64 Port * float64 ContainerPort * float64 } func NewWebService ( scope constructs . Construct , id * string , props * WebServiceProps ) constructs . Construct { var cprops constructs . ConstructOptions if props != nil { cprops = props . ConstructOptions } construct := constructs . NewConstruct ( scope , id , & cprops ) replicas := props . Replicas if replicas == nil { replicas = jsii . Number ( 1 ) } port := props . Port if port == nil { port = jsii . Number ( 80 ) } containerPort := props . ContainerPort if containerPort == nil { containerPort = jsii . Number ( 8080 ) } label := map [ string ] * string { \"app\" : constructs . Node_Of ( construct ). Id (), } k8s . NewKubeService ( construct , jsii . String ( \"service\" ), & k8s . KubeServiceProps { Spec : & k8s . ServiceSpec { Type : jsii . String ( \"LoadBalancer\" ), Ports : & [] * k8s . ServicePort {{ Port : port , TargetPort : k8s . IntOrString_FromNumber ( containerPort ), }}, Selector : & label , }, }) k8s . NewKubeDeployment ( construct , jsii . String ( \"deployment\" ), & k8s . KubeDeploymentProps { Spec : & k8s . DeploymentSpec { Replicas : replicas , Selector : & k8s . LabelSelector { MatchLabels : & label }, Template : & k8s . PodTemplateSpec { Metadata : & k8s . ObjectMeta { Labels : & label }, Spec : & k8s . PodSpec { Containers : & [] * k8s . Container {{ Name : jsii . String ( \"web\" ), Image : props . Image , Ports : & [] * k8s . ContainerPort {{ ContainerPort : containerPort }}, }}, }, }, }, }) return construct } Now, let\u2019s edit main.go and use our new construct: package main import ( \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), Replicas : jsii . Number ( 2 ), }) NewWebService ( chart , jsii . String ( \"ghost\" ), & WebServiceProps { Image : jsii . String ( \"ghost\" ), ContainerPort : jsii . Number ( 2368 ), }) return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } As you can see, we now add WebService constructs inside our chart: one that runs the paulbouwer/hello-kubernetes image and one with an installation of ghost .","title":"Abstraction through Constructs"},{"location":"support/","text":"Support \u00b6 Interacting with the community and the development team is a great way to contribute to the project. Please consider the following venues (in order): Search open issues Stack Overflow: cdk8s File a new issue Mailing list: cdk8s Slack: #cdk8s channel in cdk.dev","title":"Support"},{"location":"support/#support","text":"Interacting with the community and the development team is a great way to contribute to the project. Please consider the following venues (in order): Search open issues Stack Overflow: cdk8s File a new issue Mailing list: cdk8s Slack: #cdk8s channel in cdk.dev","title":"Support"},{"location":"assets/logos/readme/","text":"CDK8s Logos \u00b6 PNG SVG horizontal stacked icon horizontal stacked icon color black white","title":"CDK8s Logos"},{"location":"assets/logos/readme/#cdk8s-logos","text":"PNG SVG horizontal stacked icon horizontal stacked icon color black white","title":"CDK8s Logos"},{"location":"cli/","text":"Overview \u00b6 CDK8s is shipped with a command-line interface called cdk8s which can be used to work with CDK8s apps. The CLI is not required to use CDK8s but it includes some useful utilities.","title":"Overview"},{"location":"cli/#overview","text":"CDK8s is shipped with a command-line interface called cdk8s which can be used to work with CDK8s apps. The CLI is not required to use CDK8s but it includes some useful utilities.","title":"Overview"},{"location":"cli/import/","text":"import \u00b6 The import command generates low-level (L1) constructs for Kubernetes API objects and Custom Resources (CRDs). General Options \u00b6 Target programming language ( --language ) \u00b6 You can specify your desired language with the --language flag. For example: CLI: cdk8s import --language typescript cdk8s.yaml : language : typescript Output directory ( --output ) \u00b6 The --output (or -o ) option can be used to specify the output directory for your imports. Class name prefix ( --class-prefix ) \u00b6 For k8s imports, all imported classes will have a Kube prefix to denote that those are core Kubernetes APIs. For CRD imports, the class name will match the resource kind. You can use the --class-prefix option to specify an alternative prefix or --no-class-prefix to disable this behavior for k8s imports. Module name \u00b6 You can also override the default behavior for cdk8s importing. This will be helpful to you if you would like to name your CRD imports differently from their kind. Here is how you do it: CLI: cdk8s import example: = my_crd.yaml cdk8s.yaml : imports : - example:=my_crd.yaml If your CRD contained two kinds, Cluster and Autoscaler , you would have two imports. You could use them in this fashion: Typescript import { Cluster } from './imports/example-cluster' ; import { Autoscaler } from './imports/example-autoscaler' ; Python not yet supported Import Types \u00b6 The import command supports two types of imports: k8s : generates constructs from the core Kubernetes API CRDs: generates constructs from custom resource definitions This section describes specific behavior related to each type of import. Kubernetes APIs \u00b6 To generate constructs for all Kubernetes API objects of a certain version, use: cdk8s import k8s The import command will generate files under an \u201cimports\u201d directory inside your project with constructs for each API object in the Kubernetes spec. Note It is recommended to commit these generated files into your source control. By default, generated class names will be named KubeXyz where Xyz is the API object kind (e.g. KubeDeployment ). Kubernetes Versions \u00b6 Use the @version notation to import a specific Kubernetes version: cdk8s import k8s@1.16.0 Alternatively, you can specify your k8s import in the cdk8s.yaml config file: imports : - k8s@1.17.0 API Object Versions \u00b6 When importing the core Kubernetes API objects, cdk8s import will generate constructs both for stable APIs (e.g. v1 ) and pre-stable APIs ( v1beta1 ). To ensure compatibility across Kubernetes versions, construct classes generated for non-stable resources will include a postfix with the API level. For example, the import for k8s@1.18 includes KubeIngressV1Beta1 as the only Ingress resource. This is because Ingress has not been stabilized yet. The import for k8s@1.19 will also include an Ingress construct which represents the v1 resource. CRDs \u00b6 You can import CRDs from local files or URLs: cdk8s import my_crd.yaml Or from cdk8s.yaml : imports : - my_crd.yaml A CRD with group mygroup.io and kind Foo will be imported to the following locations: TypeScript: imports/mygroup.io.ts Python: imports/mygroup/io Importing CRDs from a cluster \u00b6 If the imported YAML is a List of CRDs, all these CRDs will be imported. This is useful, for example, to import all the CRDs from a running cluster: kubectl get crds -o json | cdk8s import /dev/stdin Yes, this works!","title":"import"},{"location":"cli/import/#import","text":"The import command generates low-level (L1) constructs for Kubernetes API objects and Custom Resources (CRDs).","title":"import"},{"location":"cli/import/#general-options","text":"","title":"General Options"},{"location":"cli/import/#target-programming-language-language","text":"You can specify your desired language with the --language flag. For example: CLI: cdk8s import --language typescript cdk8s.yaml : language : typescript","title":"Target programming language (--language)"},{"location":"cli/import/#output-directory-output","text":"The --output (or -o ) option can be used to specify the output directory for your imports.","title":"Output directory (--output)"},{"location":"cli/import/#class-name-prefix-class-prefix","text":"For k8s imports, all imported classes will have a Kube prefix to denote that those are core Kubernetes APIs. For CRD imports, the class name will match the resource kind. You can use the --class-prefix option to specify an alternative prefix or --no-class-prefix to disable this behavior for k8s imports.","title":"Class name prefix (--class-prefix)"},{"location":"cli/import/#module-name","text":"You can also override the default behavior for cdk8s importing. This will be helpful to you if you would like to name your CRD imports differently from their kind. Here is how you do it: CLI: cdk8s import example: = my_crd.yaml cdk8s.yaml : imports : - example:=my_crd.yaml If your CRD contained two kinds, Cluster and Autoscaler , you would have two imports. You could use them in this fashion: Typescript import { Cluster } from './imports/example-cluster' ; import { Autoscaler } from './imports/example-autoscaler' ; Python not yet supported","title":"Module name"},{"location":"cli/import/#import-types","text":"The import command supports two types of imports: k8s : generates constructs from the core Kubernetes API CRDs: generates constructs from custom resource definitions This section describes specific behavior related to each type of import.","title":"Import Types"},{"location":"cli/import/#kubernetes-apis","text":"To generate constructs for all Kubernetes API objects of a certain version, use: cdk8s import k8s The import command will generate files under an \u201cimports\u201d directory inside your project with constructs for each API object in the Kubernetes spec. Note It is recommended to commit these generated files into your source control. By default, generated class names will be named KubeXyz where Xyz is the API object kind (e.g. KubeDeployment ).","title":"Kubernetes APIs"},{"location":"cli/import/#crds","text":"You can import CRDs from local files or URLs: cdk8s import my_crd.yaml Or from cdk8s.yaml : imports : - my_crd.yaml A CRD with group mygroup.io and kind Foo will be imported to the following locations: TypeScript: imports/mygroup.io.ts Python: imports/mygroup/io","title":"CRDs"},{"location":"cli/init/","text":"init \u00b6 This command creates new cdk8s projects from built-in templates: cdk8s init TEMPLATE The following example will create a new TypeScript app project: mkdir my-fun-little-project cd my-fun-little-project cdk8s init typescript-app","title":"init"},{"location":"cli/init/#init","text":"This command creates new cdk8s projects from built-in templates: cdk8s init TEMPLATE The following example will create a new TypeScript app project: mkdir my-fun-little-project cd my-fun-little-project cdk8s init typescript-app","title":"init"},{"location":"cli/installation/","text":"Installation \u00b6 To install the CLI use one of the following methods: npm npm i -g cdk8s-cli yarn yarn global add cdk8s-cli Homebrew brew install cdk8s Note: the latest version of the cdk8s cli available via Homebrew is 0.33.0 because Homebrew does not accept beta versions. Once a stable 1.0.0 version is released it will be available on Homebrew as well. In the meantime, please use npm or yarn to install the latest cli.","title":"Installation"},{"location":"cli/installation/#installation","text":"To install the CLI use one of the following methods: npm npm i -g cdk8s-cli yarn yarn global add cdk8s-cli Homebrew brew install cdk8s Note: the latest version of the cdk8s cli available via Homebrew is 0.33.0 because Homebrew does not accept beta versions. Once a stable 1.0.0 version is released it will be available on Homebrew as well. In the meantime, please use npm or yarn to install the latest cli.","title":"Installation"},{"location":"cli/synth/","text":"synth \u00b6 The cdk8s synth command is a convenience command which will simply execute the application defined in cdk8s.yaml under app . For example, if your cdk8s.yaml file looks like this: app : node app.js Then, cdk8s synth will execute node app.js .","title":"synth"},{"location":"cli/synth/#synth","text":"The cdk8s synth command is a convenience command which will simply execute the application defined in cdk8s.yaml under app . For example, if your cdk8s.yaml file looks like this: app : node app.js Then, cdk8s synth will execute node app.js .","title":"synth"},{"location":"concepts/","text":"Overview \u00b6 This section discusses core concepts in CDK8s.","title":"Overview"},{"location":"concepts/#overview","text":"This section discusses core concepts in CDK8s.","title":"Overview"},{"location":"concepts/api-object/","text":"ApiObject \u00b6 An ApiObject is a construct that represents an entry in a Kubernetes manifest (level 0). In most cases, you won\u2019t use ApiObject directly but rather use classes that are imported through cdk8s import and which extend this base class. By default, when you import API objects from k8s, all class names will all be prefixed with Kube to differentiate them from the high-level APIs in CDK8s+. It is possible to customize the prefix by providing a string value to the --class-prefix flag, or by passing --no-class-prefix . (Note: if no prefix is used for k8s resources, this may lead to conflicts - see https://github.com/cdk8s-team/cdk8s/issues/140).","title":"ApiObject"},{"location":"concepts/api-object/#apiobject","text":"An ApiObject is a construct that represents an entry in a Kubernetes manifest (level 0). In most cases, you won\u2019t use ApiObject directly but rather use classes that are imported through cdk8s import and which extend this base class. By default, when you import API objects from k8s, all class names will all be prefixed with Kube to differentiate them from the high-level APIs in CDK8s+. It is possible to customize the prefix by providing a string value to the --class-prefix flag, or by passing --no-class-prefix . (Note: if no prefix is used for k8s resources, this may lead to conflicts - see https://github.com/cdk8s-team/cdk8s/issues/140).","title":"ApiObject"},{"location":"concepts/chart/","text":"Chart \u00b6 The Chart is a container that synthesizes a single Kubernetes manifest. class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns ); // add contents here } } During synthesis, charts collect all the ApiObject nodes (recursively) and emit a single YAML manifest that includes all these objects. When a chart is defined, you can specify chart-level namespace and labels . Those will be applied to all API objects defined within the chart (recursively): class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns , { namespace : 'my-namespace' , labels : { app : 'my-app' , }, }); new ApiObject ( this , 'my-object' , { apiVersion : 'v1' , kind : 'Foo' }); } } Will synthesize into: apiVersion : v1 kind : Foo metadata : namespace : my-namespace labels : app : my-app","title":"Chart"},{"location":"concepts/chart/#chart","text":"The Chart is a container that synthesizes a single Kubernetes manifest. class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns ); // add contents here } } During synthesis, charts collect all the ApiObject nodes (recursively) and emit a single YAML manifest that includes all these objects. When a chart is defined, you can specify chart-level namespace and labels . Those will be applied to all API objects defined within the chart (recursively): class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns , { namespace : 'my-namespace' , labels : { app : 'my-app' , }, }); new ApiObject ( this , 'my-object' , { apiVersion : 'v1' , kind : 'Foo' }); } } Will synthesize into: apiVersion : v1 kind : Foo metadata : namespace : my-namespace labels : app : my-app","title":"Chart"},{"location":"concepts/constructs/","text":"Constructs \u00b6 Constructs are the basic building block of CDK8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years.","title":"Constructs"},{"location":"concepts/constructs/#constructs","text":"Constructs are the basic building block of CDK8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years.","title":"Constructs"},{"location":"concepts/deps/","text":"Dependencies \u00b6 You can declare dependencies between any two cdk8s constructs using the addDependency() method. ApiObjects \u00b6 For example, you can force kubernetes to first apply a Namespace before applying the Service in the scope of that namespace: const namespace = new k8s . KubeNamespace ( chart , 'backend' ); const service = new k8s . KubeService ( chart , 'Service' , { metadata : { namespace : namespace.name }}); // declare the dependency. this is just a syntactic sugar for Node.of(service).addDependency(namespace) service . addDependency ( namespace ); cdk8s will ensure that the Namespace object is placed before the Service object in the resulting manifest: apiVersion : v1 kind : Namespace metadata : name : chart-backend-a59d2e47 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 namespace : chart-backend-a59d2e47 Charts \u00b6 You can also specify dependencies between charts, in exactly the same manner. For example, if we have a chart that provisions our namespace , we need that chart to be applied first: const namespaceChart = new Chart ( app , 'namespace' ); const applicationChart = new Chart ( app , 'application' ); // declare the dependency. this is just a syntactic sugar for Node.of(applicationChart).addDependency(namespaceChart) applicationChart . addDependency ( namespaceChart ); Running cdk8s synth will produce the following dist directory: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml Notice that the namespace chart appears first with the 0000 prefix. This will ensure that a subsequent execution of kubectl apply -f dist/ will apply the namespace first, and the application second. Custom Constructs \u00b6 The behavior above applies in the same way to custom constructs that you create or use. class Database extends Construct { constructor ( scope : Construct , name : string ) { super ( scope , name ); new k8s . KubeStatefulSet ( this , 'StatefulSet' ); new k8s . KubeConfigMap ( this , 'ConfigMap' ); } } const app = new App (); const chart = new Chart ( app , 'Chart' ); const service = new k8s . KubeService ( chart , 'Service' ) const database = new Database ( chart , 'Database' ); service . addDependency ( database ); Declaring such a dependency will cause each ApiObject in the source construct, to depend on every ApiObject in the target construct. Note that in the example above, the source construct is actually an ApiObject , which is also ok since it is essentially a construct with a single ApiObject . Note that if the source of your dependency is a custom construct, it won\u2019t have the addDependency syntactic sugar by default, so you\u2019ll have to use Node.of() . The resulting manifest will be: apiVersion : apps/v1 kind : StatefulSet metadata : name : chart-database-statefulset-4627f8e2 --- apiVersion : v1 kind : ConfigMap metadata : name : chart-database-configmap-676f8640 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 You can see that all ApiObject s of the Database construct, appear before the Service object. Things just got cool \u00b6 If you simply declare a dependency between two ApiObject s (or Constructs ), that belong to two different Chart s, cdk8s will create the chart dependency automatically for you. const namespaceChart = new Chart ( app , 'namespace' ); const applicationChart = new Chart ( app , 'application' ); const namespace = new k8s . KubeNamespace ( namespaceChart , 'namespace' ); const deployment = new k8s . KubeDeployment ( applicationChart , 'Deployment' ); // dependency between ApiObjects, not Charts! deployment . addDependency ( namespace ); Running cdk8s synth will produce the same result as if explicit chart dependencies were declared: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml This means you need not be bothered with managing chart dependencies, simply work with the ApiObject s you create, and let cdk8s infer the chart dependencies.","title":"Dependencies"},{"location":"concepts/deps/#dependencies","text":"You can declare dependencies between any two cdk8s constructs using the addDependency() method.","title":"Dependencies"},{"location":"concepts/deps/#apiobjects","text":"For example, you can force kubernetes to first apply a Namespace before applying the Service in the scope of that namespace: const namespace = new k8s . KubeNamespace ( chart , 'backend' ); const service = new k8s . KubeService ( chart , 'Service' , { metadata : { namespace : namespace.name }}); // declare the dependency. this is just a syntactic sugar for Node.of(service).addDependency(namespace) service . addDependency ( namespace ); cdk8s will ensure that the Namespace object is placed before the Service object in the resulting manifest: apiVersion : v1 kind : Namespace metadata : name : chart-backend-a59d2e47 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 namespace : chart-backend-a59d2e47","title":"ApiObjects"},{"location":"concepts/deps/#charts","text":"You can also specify dependencies between charts, in exactly the same manner. For example, if we have a chart that provisions our namespace , we need that chart to be applied first: const namespaceChart = new Chart ( app , 'namespace' ); const applicationChart = new Chart ( app , 'application' ); // declare the dependency. this is just a syntactic sugar for Node.of(applicationChart).addDependency(namespaceChart) applicationChart . addDependency ( namespaceChart ); Running cdk8s synth will produce the following dist directory: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml Notice that the namespace chart appears first with the 0000 prefix. This will ensure that a subsequent execution of kubectl apply -f dist/ will apply the namespace first, and the application second.","title":"Charts"},{"location":"concepts/deps/#custom-constructs","text":"The behavior above applies in the same way to custom constructs that you create or use. class Database extends Construct { constructor ( scope : Construct , name : string ) { super ( scope , name ); new k8s . KubeStatefulSet ( this , 'StatefulSet' ); new k8s . KubeConfigMap ( this , 'ConfigMap' ); } } const app = new App (); const chart = new Chart ( app , 'Chart' ); const service = new k8s . KubeService ( chart , 'Service' ) const database = new Database ( chart , 'Database' ); service . addDependency ( database ); Declaring such a dependency will cause each ApiObject in the source construct, to depend on every ApiObject in the target construct. Note that in the example above, the source construct is actually an ApiObject , which is also ok since it is essentially a construct with a single ApiObject . Note that if the source of your dependency is a custom construct, it won\u2019t have the addDependency syntactic sugar by default, so you\u2019ll have to use Node.of() . The resulting manifest will be: apiVersion : apps/v1 kind : StatefulSet metadata : name : chart-database-statefulset-4627f8e2 --- apiVersion : v1 kind : ConfigMap metadata : name : chart-database-configmap-676f8640 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 You can see that all ApiObject s of the Database construct, appear before the Service object.","title":"Custom Constructs"},{"location":"concepts/deps/#things-just-got-cool","text":"If you simply declare a dependency between two ApiObject s (or Constructs ), that belong to two different Chart s, cdk8s will create the chart dependency automatically for you. const namespaceChart = new Chart ( app , 'namespace' ); const applicationChart = new Chart ( app , 'application' ); const namespace = new k8s . KubeNamespace ( namespaceChart , 'namespace' ); const deployment = new k8s . KubeDeployment ( applicationChart , 'Deployment' ); // dependency between ApiObjects, not Charts! deployment . addDependency ( namespace ); Running cdk8s synth will produce the same result as if explicit chart dependencies were declared: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml This means you need not be bothered with managing chart dependencies, simply work with the ApiObject s you create, and let cdk8s infer the chart dependencies.","title":"Things just got cool"},{"location":"concepts/escape-hatches/","text":"Escape Hatches \u00b6 An \u201cescape hatch\u201d is an intentional leak in the abstraction layer. It allows users to \u201cescape the abstraction\u201d and reach out to a lower layer. Similarly, in CDKs, escape hatches are mechanisms that allow users to tweak the synthesized output when the abstraction they use does not \u201chold water\u201d. You may need to use an escape hatch in the following cases: You are using an imported API object (e.g. KubeDeployment ) and there is an issue with the schema or a bug in \u201cimport\u201d which results in an invalid manifest or missing fields (as an example see issue #140 ). You are using a high-level API (e.g. CDK8s+) which does not expose some functionality which exists in the lower-level resources. Patching API objects directly \u00b6 The ApiObject class, which is the base of all objects synthesized into a Kubernetes manifest offers an API for patching the synthesized output at the wire level using JSON Patch ( RFC-6902 ): import { JsonPatch } from 'cdk8s' ; apiObject . addJsonPatch ( JsonPatch . replace ( '/foo' , 'bar' )); apiObject . addJsonPatch ( JsonPatch . add ( '/foo/bar/0' , { bar : 123 })); During synthesis, patches are applied in-order after the API object synthesized itself. All classes generated using the CLI import command extend ApiObject , and therefore include the addJsonPatch() method. Patching API objects behind higher-level APIs \u00b6 The second use case for using escape hatches is when you are working against a higher-level construct which, for some reason, does not allow you to achieve what you need. For example, let\u2019s say you are using the Pod class from CDK8s+ and you wish to set [ enableServiceLinks ] to true . This feature is currently not supported in the CDK8s+ Pod API, so you\u2019ll want to patch the underlying KubePod and set this value. To do that, you will need to \u201cpeak\u201d into the construct tree and find the underlying API object, so you can apply the patch to it: import { Pod } from 'cdk8s-plus-17' ; import { ApiObject } from 'cdk8s' ; const pod = new Pod (...); const kubePod = ApiObject . of ( pod ); kubePod . addJsonPatch (...); The ApiObject.of() method uses capabilities of the constructs programming model to find the \u201cdefault child\u201d of a construct ( Node.of(c).defaultChild ). When a construct is initialized, it can either explicitly assign the value of Node.of(this).defaultChild = xxx or it can use the identity Default for one of its child constructs. This will automatically identify it as the default child. Tip The ApiObject.of() method recursively searches down the construct tree through child constructs called Default until it finds a child of type ApiObject . This means, for example, that ApiObject.of(apiObject) returns the same object. There could be situations where a default child is not recorded by a high-level construct. This still does not mean you are blocked from patching the underlying API objects. You can still use Node.of(x) to traverse the construct tree to obtain the child. For example, you can use Node.of(x).findChild(id) to retrieve any child by its ID.","title":"Escape Hatches"},{"location":"concepts/escape-hatches/#escape-hatches","text":"An \u201cescape hatch\u201d is an intentional leak in the abstraction layer. It allows users to \u201cescape the abstraction\u201d and reach out to a lower layer. Similarly, in CDKs, escape hatches are mechanisms that allow users to tweak the synthesized output when the abstraction they use does not \u201chold water\u201d. You may need to use an escape hatch in the following cases: You are using an imported API object (e.g. KubeDeployment ) and there is an issue with the schema or a bug in \u201cimport\u201d which results in an invalid manifest or missing fields (as an example see issue #140 ). You are using a high-level API (e.g. CDK8s+) which does not expose some functionality which exists in the lower-level resources.","title":"Escape Hatches"},{"location":"concepts/escape-hatches/#patching-api-objects-directly","text":"The ApiObject class, which is the base of all objects synthesized into a Kubernetes manifest offers an API for patching the synthesized output at the wire level using JSON Patch ( RFC-6902 ): import { JsonPatch } from 'cdk8s' ; apiObject . addJsonPatch ( JsonPatch . replace ( '/foo' , 'bar' )); apiObject . addJsonPatch ( JsonPatch . add ( '/foo/bar/0' , { bar : 123 })); During synthesis, patches are applied in-order after the API object synthesized itself. All classes generated using the CLI import command extend ApiObject , and therefore include the addJsonPatch() method.","title":"Patching API objects directly"},{"location":"concepts/escape-hatches/#patching-api-objects-behind-higher-level-apis","text":"The second use case for using escape hatches is when you are working against a higher-level construct which, for some reason, does not allow you to achieve what you need. For example, let\u2019s say you are using the Pod class from CDK8s+ and you wish to set [ enableServiceLinks ] to true . This feature is currently not supported in the CDK8s+ Pod API, so you\u2019ll want to patch the underlying KubePod and set this value. To do that, you will need to \u201cpeak\u201d into the construct tree and find the underlying API object, so you can apply the patch to it: import { Pod } from 'cdk8s-plus-17' ; import { ApiObject } from 'cdk8s' ; const pod = new Pod (...); const kubePod = ApiObject . of ( pod ); kubePod . addJsonPatch (...); The ApiObject.of() method uses capabilities of the constructs programming model to find the \u201cdefault child\u201d of a construct ( Node.of(c).defaultChild ). When a construct is initialized, it can either explicitly assign the value of Node.of(this).defaultChild = xxx or it can use the identity Default for one of its child constructs. This will automatically identify it as the default child. Tip The ApiObject.of() method recursively searches down the construct tree through child constructs called Default until it finds a child of type ApiObject . This means, for example, that ApiObject.of(apiObject) returns the same object. There could be situations where a default child is not recorded by a high-level construct. This still does not mean you are blocked from patching the underlying API objects. You can still use Node.of(x) to traverse the construct tree to obtain the child. For example, you can use Node.of(x).findChild(id) to retrieve any child by its ID.","title":"Patching API objects behind higher-level APIs"},{"location":"concepts/helm/","text":"Helm Support \u00b6 You can use the Helm construct in order to include Helm charts. In order to use this construct, you must have helm installed on your system. See Installing Helm in the Helm documentation for details. The following example adds the bitnami/redis Helm chart with sentinel containers enabled: The Bitnami helm repo needs to be added through: helm repo add bitnami https://charts.bitnami.com/bitnami class MyChart extends cdk8s . Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const redis = new Helm ( this , 'redis' , { chart : 'bitnami/redis' , values : { sentinel : { enabled : true } } }); } } The Helm construct will render the manifest from the specified chart by executing helm template . If values is specified, these values will override the default values included with the chart. The name option can be used to specify the chart\u2019s release name . If not specified, a valid and unique release name will be allocated based on the construct path. The Helm construct extends Include and inherits it\u2019s API. For example, you can use the apiObjects property to find and interact with included API objects. The following example shows how to add an annotation to the Redis master deployment: const master = redis . apiObjects . find ( o => o . name === 'foo-redis-master' ); master . metadata . addAnnotation ( 'my.annotation' , 'hey-there' );","title":"Helm Support"},{"location":"concepts/helm/#helm-support","text":"You can use the Helm construct in order to include Helm charts. In order to use this construct, you must have helm installed on your system. See Installing Helm in the Helm documentation for details. The following example adds the bitnami/redis Helm chart with sentinel containers enabled: The Bitnami helm repo needs to be added through: helm repo add bitnami https://charts.bitnami.com/bitnami class MyChart extends cdk8s . Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const redis = new Helm ( this , 'redis' , { chart : 'bitnami/redis' , values : { sentinel : { enabled : true } } }); } } The Helm construct will render the manifest from the specified chart by executing helm template . If values is specified, these values will override the default values included with the chart. The name option can be used to specify the chart\u2019s release name . If not specified, a valid and unique release name will be allocated based on the construct path. The Helm construct extends Include and inherits it\u2019s API. For example, you can use the apiObjects property to find and interact with included API objects. The following example shows how to add an annotation to the Redis master deployment: const master = redis . apiObjects . find ( o => o . name === 'foo-redis-master' ); master . metadata . addAnnotation ( 'my.annotation' , 'hey-there' );","title":"Helm Support"},{"location":"concepts/include/","text":"Include \u00b6 The Include construct can be used to include an existing manifest in a chart. The following example will include the Kubernetes Dashboard in MyChart : import { Include } from 'cdk8s' ; class MyChart extends Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const dashboard = new Include ( this , 'dashboard' , { url : 'https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml' , // or url : 'dashboard.yaml' }); // ...other resources } } All API objects defined in the included manifest will be added as children ApiObject s under the Include construct\u2019s scope and can be accessed through the apiObject property: The following example queries for all the Deployment resources in the dashboard: const deploymentApiObject = dashboard . apiObjects . find ( c => c . kind === ' Deployment ); NOTE: names of included objects ( metadata.name ) are preserved. This means that if you try to include the same manifest twice into the same chart, your manifest will have duplicate definitions of the same objects.","title":"Include"},{"location":"concepts/include/#include","text":"The Include construct can be used to include an existing manifest in a chart. The following example will include the Kubernetes Dashboard in MyChart : import { Include } from 'cdk8s' ; class MyChart extends Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const dashboard = new Include ( this , 'dashboard' , { url : 'https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml' , // or url : 'dashboard.yaml' }); // ...other resources } } All API objects defined in the included manifest will be added as children ApiObject s under the Include construct\u2019s scope and can be accessed through the apiObject property: The following example queries for all the Deployment resources in the dashboard: const deploymentApiObject = dashboard . apiObjects . find ( c => c . kind === ' Deployment ); NOTE: names of included objects ( metadata.name ) are preserved. This means that if you try to include the same manifest twice into the same chart, your manifest will have duplicate definitions of the same objects.","title":"Include"},{"location":"concepts/testing/","text":"Testing \u00b6 cdk8s bundles a set of test utilities under the Testing class: Testing.app() returns an App object bound to a temporary output directory. Testing.chart() returns a Chart object bound to a testing app. Testing.synth(chart) returns the Kubernetes manifest synthesized from a chart.","title":"Testing"},{"location":"concepts/testing/#testing","text":"cdk8s bundles a set of test utilities under the Testing class: Testing.app() returns an App object bound to a temporary output directory. Testing.chart() returns a Chart object bound to a testing app. Testing.synth(chart) returns the Kubernetes manifest synthesized from a chart.","title":"Testing"},{"location":"examples/","text":"CDK8s Examples Directory \u00b6 This section includes various examples for CDK8s and CDK8s+.","title":"Overview"},{"location":"examples/#cdk8s-examples-directory","text":"This section includes various examples for CDK8s and CDK8s+.","title":"CDK8s Examples Directory"},{"location":"examples/crd/","text":"CRDs \u00b6 Shows how to import and use Custom Resource Definitions TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"CRDs"},{"location":"examples/crd/#crds","text":"Shows how to import and use Custom Resource Definitions TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"CRDs"},{"location":"examples/hello/","text":"Hello, Kubernetes! \u00b6 Deploys hello-kubernetes as a Service behind a LoadBalancer. TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Hello, Kubernetes!"},{"location":"examples/hello/#hello-kubernetes","text":"Deploys hello-kubernetes as a Service behind a LoadBalancer. TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Hello, Kubernetes!"},{"location":"examples/plus-elasticsearch/","text":"Elasticsearch (CDK8s+) \u00b6 Creating a query service on top of Elasticsearch with CDK8s+ TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Elasticsearch (CDK8s+)"},{"location":"examples/plus-elasticsearch/#elasticsearch-cdk8s","text":"Creating a query service on top of Elasticsearch with CDK8s+ TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Elasticsearch (CDK8s+)"},{"location":"examples/plus-ingress/","text":"Ingress (CDK8s+) \u00b6 Example of using CDK8s+ Ingress resource. TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Ingress (CDK8s+)"},{"location":"examples/plus-ingress/#ingress-cdk8s","text":"Example of using CDK8s+ Ingress resource. TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Ingress (CDK8s+)"},{"location":"examples/podinfo/","text":"Podinfo \u00b6 Exploration of high-level APIs for Deployment , Service , AutoScaler and Ingress based on the podinfo project . TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Podinfo"},{"location":"examples/podinfo/#podinfo","text":"Exploration of high-level APIs for Deployment , Service , AutoScaler and Ingress based on the podinfo project . TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Podinfo"},{"location":"examples/web-service/","text":"WebService Abstraction \u00b6 Demonstrates how to make your first high-level construct which represents a web service which abstracts the hello example from earlier into a reusable piece of infrastructure. TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"WebService Abstraction"},{"location":"examples/web-service/#webservice-abstraction","text":"Demonstrates how to make your first high-level construct which represents a web service which abstracts the hello example from earlier into a reusable piece of infrastructure. TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"WebService Abstraction"},{"location":"plus/","text":"Overview \u00b6 cdk8s+ is a library with high level abstractions for authoring Kubernetes applications. Built on top of the auto-generated building blocks provided by CDK8s, this library includes a hand crafted construct for each native kubernetes object, exposing richer API\u2019s with reduced complexity. cdk8s+ is vended as a separate library for each kubernetes spec version. The documentation presented here represents version 1.17.0 and is vended as the cdk8s-plus-17 library. Naming conventions \u00b6 Stable resources are represented by a construct of the same kind . For example, the io.k8s.api.core.v1.Pod resource maps to the Pod construct . Non stable resources are suffixed with their api version . For example, the io.k8s.api.networking.v1beta1.Ingress maps to the IngressV1Beta1 construct . Spec Compatibility \u00b6 Per kubernetes compatibility guarantees , stable resources in this library are compatible with any spec version higher or equal to 1.17.0 . Non-stable resources are not guaranteed to be compatible, as they may be removed in future spec versions. Notice If you are deploying manifests produced by cdk8s-plus-17 onto clusters of a lower version, you might encounter some unsupported spec properties or invalid manifests. At a glance \u00b6 import * as kplus from 'cdk8s-plus-17' ; import * as cdk8s from 'cdk8s' ; import * as path from 'path' ; // our cdk app const app = new cdk8s . App (); // our kubernetes chart const chart = new cdk8s . Chart ( app , 'my-chart' ); // lets create a volume that contains our app. // we use a trick with a config map! const appData = new kplus . ConfigMap ( chart , 'AppData' ); appData . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appData ); // lets create a deployment to run a few instances of a pod const deployment = new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , }); // now we create a container that runs our app const appPath = '/var/lib/app' ; const port = 80 ; const container = deployment . addContainer ({ image : 'node:14.4.0-alpine3.12' , command : [ 'node' , 'index.js' , ` ${ port } ` ], port : port , workingDir : appPath , }); // make the app accessible to the container container . mount ( appPath , appVolume ); // finally, we expose the deployment as a load balancer service and make it run deployment . expose ( 8080 , { serviceType : kplus.ServiceType.LOAD_BALANCER }) // we are done, synth app . synth (); dist/my-chart.yaml apiVersion : v1 data : index.js : |- var http = require('http'); var port = process.argv[2]; //create a server object: http.createServer(function (req, res) { res.write('Hello World!'); //write a response to the client res.end(); //end the response }).listen(port); //the server object listens on port 80 kind : ConfigMap metadata : annotations : {} labels : {} name : chart-appdata-configmap-da4c63ab --- apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-deployment-pod-d4285cc9 spec : replicas : 3 selector : matchLabels : cdk8s.deployment : ChartDeploymentCFC2E30C template : metadata : annotations : {} labels : cdk8s.deployment : ChartDeploymentCFC2E30C spec : containers : - command : - node - index.js - \"80\" env : [] image : node:14.4.0-alpine3.12 name : main ports : - containerPort : 80 volumeMounts : - mountPath : /var/lib/app name : configmap-chart-appdata-configmap-da4c63ab workingDir : /var/lib/app volumes : - configMap : name : chart-appdata-configmap-da4c63ab name : configmap-chart-appdata-configmap-da4c63ab --- apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-deployment-service-pod-42f50c26 spec : externalIPs : [] ports : - port : 8080 targetPort : 80 selector : cdk8s.deployment : ChartDeploymentCFC2E30C type : LoadBalancer Getting Started \u00b6 TypeScript/JavaScript \u276f npm install cdk8s-plus-17 cdk8s import * as kplus from 'cdk8s-plus-17' ; import * as cdk8s from 'cdk8s' ; const app = new cdk8s . App (); const chart = new cdk8s . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , containers : [{ image : 'ubuntu' , }], }); Python \u276f pip install --pre cdk8s-plus-17 cdk8s import cdk8s_plus_17 as kplus import cdk8s app = cdk8s . App () chart = cdk8s . Chart ( app , 'Chart' ) kplus . Deployment ( chart , 'Deployment' , replicas = 1 , containers = [ kplus . Container ( image = 'ubuntu' )] )","title":"Overview"},{"location":"plus/#overview","text":"cdk8s+ is a library with high level abstractions for authoring Kubernetes applications. Built on top of the auto-generated building blocks provided by CDK8s, this library includes a hand crafted construct for each native kubernetes object, exposing richer API\u2019s with reduced complexity. cdk8s+ is vended as a separate library for each kubernetes spec version. The documentation presented here represents version 1.17.0 and is vended as the cdk8s-plus-17 library.","title":"Overview"},{"location":"plus/#naming-conventions","text":"Stable resources are represented by a construct of the same kind . For example, the io.k8s.api.core.v1.Pod resource maps to the Pod construct . Non stable resources are suffixed with their api version . For example, the io.k8s.api.networking.v1beta1.Ingress maps to the IngressV1Beta1 construct .","title":"Naming conventions"},{"location":"plus/#spec-compatibility","text":"Per kubernetes compatibility guarantees , stable resources in this library are compatible with any spec version higher or equal to 1.17.0 . Non-stable resources are not guaranteed to be compatible, as they may be removed in future spec versions. Notice If you are deploying manifests produced by cdk8s-plus-17 onto clusters of a lower version, you might encounter some unsupported spec properties or invalid manifests.","title":"Spec Compatibility"},{"location":"plus/#at-a-glance","text":"import * as kplus from 'cdk8s-plus-17' ; import * as cdk8s from 'cdk8s' ; import * as path from 'path' ; // our cdk app const app = new cdk8s . App (); // our kubernetes chart const chart = new cdk8s . Chart ( app , 'my-chart' ); // lets create a volume that contains our app. // we use a trick with a config map! const appData = new kplus . ConfigMap ( chart , 'AppData' ); appData . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appData ); // lets create a deployment to run a few instances of a pod const deployment = new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , }); // now we create a container that runs our app const appPath = '/var/lib/app' ; const port = 80 ; const container = deployment . addContainer ({ image : 'node:14.4.0-alpine3.12' , command : [ 'node' , 'index.js' , ` ${ port } ` ], port : port , workingDir : appPath , }); // make the app accessible to the container container . mount ( appPath , appVolume ); // finally, we expose the deployment as a load balancer service and make it run deployment . expose ( 8080 , { serviceType : kplus.ServiceType.LOAD_BALANCER }) // we are done, synth app . synth (); dist/my-chart.yaml apiVersion : v1 data : index.js : |- var http = require('http'); var port = process.argv[2]; //create a server object: http.createServer(function (req, res) { res.write('Hello World!'); //write a response to the client res.end(); //end the response }).listen(port); //the server object listens on port 80 kind : ConfigMap metadata : annotations : {} labels : {} name : chart-appdata-configmap-da4c63ab --- apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-deployment-pod-d4285cc9 spec : replicas : 3 selector : matchLabels : cdk8s.deployment : ChartDeploymentCFC2E30C template : metadata : annotations : {} labels : cdk8s.deployment : ChartDeploymentCFC2E30C spec : containers : - command : - node - index.js - \"80\" env : [] image : node:14.4.0-alpine3.12 name : main ports : - containerPort : 80 volumeMounts : - mountPath : /var/lib/app name : configmap-chart-appdata-configmap-da4c63ab workingDir : /var/lib/app volumes : - configMap : name : chart-appdata-configmap-da4c63ab name : configmap-chart-appdata-configmap-da4c63ab --- apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-deployment-service-pod-42f50c26 spec : externalIPs : [] ports : - port : 8080 targetPort : 80 selector : cdk8s.deployment : ChartDeploymentCFC2E30C type : LoadBalancer","title":"At a glance"},{"location":"plus/#getting-started","text":"TypeScript/JavaScript \u276f npm install cdk8s-plus-17 cdk8s import * as kplus from 'cdk8s-plus-17' ; import * as cdk8s from 'cdk8s' ; const app = new cdk8s . App (); const chart = new cdk8s . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , containers : [{ image : 'ubuntu' , }], }); Python \u276f pip install --pre cdk8s-plus-17 cdk8s import cdk8s_plus_17 as kplus import cdk8s app = cdk8s . App () chart = cdk8s . Chart ( app , 'Chart' ) kplus . Deployment ( chart , 'Deployment' , replicas = 1 , containers = [ kplus . Container ( image = 'ubuntu' )] )","title":"Getting Started"},{"location":"plus/config-map/","text":"ConfigMap \u00b6 ConfigMap are used to store configuration data. They provide a dictionary based data structure that can be consumed in various shapes and forms. API Reference Use an existing ConfigMap \u00b6 You can reference to an existing ConfigMap like so. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-17' ; const config : kplus.IConfigMap = kplus . ConfigMap . fromConfigMapName ( 'config' ); // the 'config' constant can later be used by API's that require an IConfigMap. // for example when creating a volume. const volume = kplus . Volume . fromConfigMap ( config ); Adding data \u00b6 You can create config maps and add some data to them like so: import * as kplus from 'cdk8s-plus-17' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const config = new kplus . ConfigMap ( chart , 'Config' ); config . addData ( 'url' , 'https://my-endpoint:8080' ); Creating a volume from a directory \u00b6 Here is a nifty little trick you can use to create a volume that contains a directory on the client machine (machine that runs cdk8s synth ): import * as kplus from 'cdk8s-plus-17' ; import * as k from 'cdk8s' ; import * as path from 'path' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const appMap = new kplus . ConfigMap ( chart , 'Config' ); // add the files in the directory to the config map. // this will create a key for each file. // note that only top level files will be included, sub-directories are not yet supported. appMap . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appMap ); const mountPath = '/var/app' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , command : [ 'node' , 'app.js' ], workingDir : mountPath , }); // from here, just mount the volume to a container, and run your app! container . mount ( mountPath , appVolume );","title":"ConfigMap"},{"location":"plus/config-map/#configmap","text":"ConfigMap are used to store configuration data. They provide a dictionary based data structure that can be consumed in various shapes and forms. API Reference","title":"ConfigMap"},{"location":"plus/config-map/#use-an-existing-configmap","text":"You can reference to an existing ConfigMap like so. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-17' ; const config : kplus.IConfigMap = kplus . ConfigMap . fromConfigMapName ( 'config' ); // the 'config' constant can later be used by API's that require an IConfigMap. // for example when creating a volume. const volume = kplus . Volume . fromConfigMap ( config );","title":"Use an existing ConfigMap"},{"location":"plus/config-map/#adding-data","text":"You can create config maps and add some data to them like so: import * as kplus from 'cdk8s-plus-17' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const config = new kplus . ConfigMap ( chart , 'Config' ); config . addData ( 'url' , 'https://my-endpoint:8080' );","title":"Adding data"},{"location":"plus/config-map/#creating-a-volume-from-a-directory","text":"Here is a nifty little trick you can use to create a volume that contains a directory on the client machine (machine that runs cdk8s synth ): import * as kplus from 'cdk8s-plus-17' ; import * as k from 'cdk8s' ; import * as path from 'path' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const appMap = new kplus . ConfigMap ( chart , 'Config' ); // add the files in the directory to the config map. // this will create a key for each file. // note that only top level files will be included, sub-directories are not yet supported. appMap . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appMap ); const mountPath = '/var/app' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , command : [ 'node' , 'app.js' ], workingDir : mountPath , }); // from here, just mount the volume to a container, and run your app! container . mount ( mountPath , appVolume );","title":"Creating a volume from a directory"},{"location":"plus/container/","text":"Container \u00b6 Define containers that run in a pod using the Container class. API Reference Environment variables \u00b6 Environment variables can be added to containers using various sources, via semantically explicit API\u2019s: import * as kplus from 'cdk8s-plus-17' const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }); // explicitly use a value. container . addEnv ( 'endpoint' , kplus . EnvValue . fromValue ( 'value' )); // use a specific key from a config map. const backendsConfig = kplus . ConfigMap . fromConfigMapName ( 'backends' ); container . addEnv ( 'endpoint' , kplus . EnvValue . fromConfigMap ( backendsConfig , 'endpoint' )); // use a specific key from a secret. const credentials = kplus . Secret . fromSecretName ( 'credentials' ); container . addEnv ( 'password' , kplus . EnvValue . fromSecret ( credentials , 'password' )); Volume Mounts \u00b6 A very common capability is to mount a volume with some data onto a container. Using pure kubernetes API, this would require writing something like: kind : Pod apiVersion : v1 spec : containers : - name : main volumeMounts : - mountPath : /path/to/mount name : 'config-volume' volumes : - name : 'config-volume' configMap : name : 'config' Notice the apparent redundancy of having to specify the volume name twice. Also, if you happen to need the same mount in other pods, you would need to duplicate this configuration. This can get complex and cluttered very fast. In contrast, here is how to do this with cdk8s+ : import * as kplus from 'cdk8s-plus-17' ; const config = kplus . ConfigMap . fromConfigMapName ( 'config' ); const volume = kplus . Volume . fromConfigMap ( config ); const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }) // Cool alert: every pod that will later be configured with this container, // will automatically have access to this volume, so you don't need to explicitly add it to the pod spec!. container . mount ( '/path/to/mount' , volume ); Probes \u00b6 A Probe is a diagnostic performed periodically by the kubelet on a Container. To perform a diagnostic, the kubelet calls a Handler implemented by the container. A Probe instance can be created through one of the fromXxx static methods: Probe.fromHttpGet() Probe.fromCommand() Readiness, liveness, and startup probes can be configured at the container-level through the readiness , liveness , and startup options: new kplus . Pod ( this , 'Pod' , { containers : [ { // ... readiness : kplus.Probe.fromHttpGet ( '/ping' ), } ] }); See the API reference for details.","title":"Container"},{"location":"plus/container/#container","text":"Define containers that run in a pod using the Container class. API Reference","title":"Container"},{"location":"plus/container/#environment-variables","text":"Environment variables can be added to containers using various sources, via semantically explicit API\u2019s: import * as kplus from 'cdk8s-plus-17' const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }); // explicitly use a value. container . addEnv ( 'endpoint' , kplus . EnvValue . fromValue ( 'value' )); // use a specific key from a config map. const backendsConfig = kplus . ConfigMap . fromConfigMapName ( 'backends' ); container . addEnv ( 'endpoint' , kplus . EnvValue . fromConfigMap ( backendsConfig , 'endpoint' )); // use a specific key from a secret. const credentials = kplus . Secret . fromSecretName ( 'credentials' ); container . addEnv ( 'password' , kplus . EnvValue . fromSecret ( credentials , 'password' ));","title":"Environment variables"},{"location":"plus/container/#volume-mounts","text":"A very common capability is to mount a volume with some data onto a container. Using pure kubernetes API, this would require writing something like: kind : Pod apiVersion : v1 spec : containers : - name : main volumeMounts : - mountPath : /path/to/mount name : 'config-volume' volumes : - name : 'config-volume' configMap : name : 'config' Notice the apparent redundancy of having to specify the volume name twice. Also, if you happen to need the same mount in other pods, you would need to duplicate this configuration. This can get complex and cluttered very fast. In contrast, here is how to do this with cdk8s+ : import * as kplus from 'cdk8s-plus-17' ; const config = kplus . ConfigMap . fromConfigMapName ( 'config' ); const volume = kplus . Volume . fromConfigMap ( config ); const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }) // Cool alert: every pod that will later be configured with this container, // will automatically have access to this volume, so you don't need to explicitly add it to the pod spec!. container . mount ( '/path/to/mount' , volume );","title":"Volume Mounts"},{"location":"plus/container/#probes","text":"A Probe is a diagnostic performed periodically by the kubelet on a Container. To perform a diagnostic, the kubelet calls a Handler implemented by the container. A Probe instance can be created through one of the fromXxx static methods: Probe.fromHttpGet() Probe.fromCommand() Readiness, liveness, and startup probes can be configured at the container-level through the readiness , liveness , and startup options: new kplus . Pod ( this , 'Pod' , { containers : [ { // ... readiness : kplus.Probe.fromHttpGet ( '/ping' ), } ] }); See the API reference for details.","title":"Probes"},{"location":"plus/deployment/","text":"Deployment \u00b6 Create a deployment to govern the lifecycle and orchestration of a set of identical pods. API Reference Automatic pod selection \u00b6 When you specify pods in a deployment, you normally have to configure the appropriate labels and selectors to make the deployment control the relevant pods. This construct does this automatically. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'FrontEnds' , { containers : [ { image : 'node' } ], }); Note the resulting manifest contains a special cdk8s.deployment label that is applied to the pods, and is used as the selector for the deployment. apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-frontends-pod-a48e7f2e spec : replicas : 1 selector : matchLabels : cdk8s.deployment : ChartFrontEndsDD8A97CE template : metadata : annotations : {} labels : cdk8s.deployment : ChartFrontEndsDD8A97CE Exposing via a service \u00b6 Following up on pod selection, you can also easily create a service that will select the pods relevant to the deployment. // store the deployment to created in a constant const frontends = new kplus . Deployment ( chart , 'FrontEnds' ); // create a ClusterIP service that listens on port 9000 and redirects to port 9000 on the containers. frontends . expose ( 9000 ) Notice the resulting manifest, will have the same cdk8s.deployment magic label as the selector. This will cause the service to attach to the pods that were configured as part of the said deployment. apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-frontends-service-pod-1f70150b spec : externalIPs : [] ports : - port : 9000 selector : cdk8s.deployment : ChartFrontEndsDD8A97CE type : ClusterIP","title":"Deployment"},{"location":"plus/deployment/#deployment","text":"Create a deployment to govern the lifecycle and orchestration of a set of identical pods. API Reference","title":"Deployment"},{"location":"plus/deployment/#automatic-pod-selection","text":"When you specify pods in a deployment, you normally have to configure the appropriate labels and selectors to make the deployment control the relevant pods. This construct does this automatically. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'FrontEnds' , { containers : [ { image : 'node' } ], }); Note the resulting manifest contains a special cdk8s.deployment label that is applied to the pods, and is used as the selector for the deployment. apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-frontends-pod-a48e7f2e spec : replicas : 1 selector : matchLabels : cdk8s.deployment : ChartFrontEndsDD8A97CE template : metadata : annotations : {} labels : cdk8s.deployment : ChartFrontEndsDD8A97CE","title":"Automatic pod selection"},{"location":"plus/deployment/#exposing-via-a-service","text":"Following up on pod selection, you can also easily create a service that will select the pods relevant to the deployment. // store the deployment to created in a constant const frontends = new kplus . Deployment ( chart , 'FrontEnds' ); // create a ClusterIP service that listens on port 9000 and redirects to port 9000 on the containers. frontends . expose ( 9000 ) Notice the resulting manifest, will have the same cdk8s.deployment magic label as the selector. This will cause the service to attach to the pods that were configured as part of the said deployment. apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-frontends-service-pod-1f70150b spec : externalIPs : [] ports : - port : 9000 selector : cdk8s.deployment : ChartFrontEndsDD8A97CE type : ClusterIP","title":"Exposing via a service"},{"location":"plus/ingress/","text":"Ingress \u00b6 Ingress manages external access to services in a cluster, typically through HTTP. Ingress may provide load balancing, SSL termination and name-based virtual hosting. API Reference You must have an Ingress controller to satisfy an Ingress. Only creating an Ingress resource has no effect. The following example will route HTTP requests sent to the /hello url prefix to a service associated with a deployment of the hashicorp/http-echo image. const helloDeployment = new kplus . Deployment ( this , text , { containers : [ { image : 'hashicorp/http-echo' , args : [ '-text' , 'hello ingress' ] } ] }); const helloService = helloDeployment . expose ( 5678 ); const ingress = new IngressV1Beta1 ( this , 'ingress' ); ingress . addRule ( '/hello' , kplus . IngressV1Beta1Backend . fromService ( helloService )); You can use addHostRule(host, path, backend) to define a route that will only apply to requests with this Host header. This can be used to implement virtual hosts. The addDefaultBackend(backend) and addHostDefaultBackend(host, backend) methods can be used to define backends that will accept all requests that do not match any other rules. The TCP port used to route requests to services will be determined based on which ports are exposed by the service (e.g. through serve() ). If the service exposes multiple ports, then a port must be specified via IngressBackend.fromService(service, { port } .","title":"Ingress"},{"location":"plus/ingress/#ingress","text":"Ingress manages external access to services in a cluster, typically through HTTP. Ingress may provide load balancing, SSL termination and name-based virtual hosting. API Reference You must have an Ingress controller to satisfy an Ingress. Only creating an Ingress resource has no effect. The following example will route HTTP requests sent to the /hello url prefix to a service associated with a deployment of the hashicorp/http-echo image. const helloDeployment = new kplus . Deployment ( this , text , { containers : [ { image : 'hashicorp/http-echo' , args : [ '-text' , 'hello ingress' ] } ] }); const helloService = helloDeployment . expose ( 5678 ); const ingress = new IngressV1Beta1 ( this , 'ingress' ); ingress . addRule ( '/hello' , kplus . IngressV1Beta1Backend . fromService ( helloService )); You can use addHostRule(host, path, backend) to define a route that will only apply to requests with this Host header. This can be used to implement virtual hosts. The addDefaultBackend(backend) and addHostDefaultBackend(host, backend) methods can be used to define backends that will accept all requests that do not match any other rules. The TCP port used to route requests to services will be determined based on which ports are exposed by the service (e.g. through serve() ). If the service exposes multiple ports, then a port must be specified via IngressBackend.fromService(service, { port } .","title":"Ingress"},{"location":"plus/job/","text":"Job \u00b6 Jobs are a very useful concept in kubernetes deployments. They can be used for add-hoc provisioning tasks, as well as long running processing jobs. In configuration, they don\u2019t differ much from regular pods, but offer some additional properties. API Reference Delete a Job after its finished \u00b6 You can configure a TTL for the job after it finished its execution successfully. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // let's define a job spec, and set a 1 second TTL. const load = new kplus . Job ( chart , 'LoadData' , { ttlAfterFinished : kplus.Duration.seconds ( 1 ) }); // now add a container to all the pods created by this job job . addContainer ({ image : 'loader' });","title":"Job"},{"location":"plus/job/#job","text":"Jobs are a very useful concept in kubernetes deployments. They can be used for add-hoc provisioning tasks, as well as long running processing jobs. In configuration, they don\u2019t differ much from regular pods, but offer some additional properties. API Reference","title":"Job"},{"location":"plus/job/#delete-a-job-after-its-finished","text":"You can configure a TTL for the job after it finished its execution successfully. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // let's define a job spec, and set a 1 second TTL. const load = new kplus . Job ( chart , 'LoadData' , { ttlAfterFinished : kplus.Duration.seconds ( 1 ) }); // now add a container to all the pods created by this job job . addContainer ({ image : 'loader' });","title":"Delete a Job after its finished"},{"location":"plus/pod/","text":"Pod \u00b6 A pod is essentially a collection of containers. It is the most fundamental computation unit that can be provisioned. API Reference Adding Containers/Volumes \u00b6 Containers and volumes can be added to pod definition like so: import * as kplus from 'cdk8s-plus-17' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , }); const storage = kplus . Volume . fromEmptyDir ( 'storage' ); container . mount ( '/data' , storage ); const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // this will automatically add the volume as well. pod . addContainer ( container ); // but if you want to explicitly add it, simply use: pod . addVolume ( storage ); Applying a restart policy \u00b6 import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' , { restartPolicy : kplus.RestartPolicy.NEVER , }); Assigning a ServiceAccount \u00b6 import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' , { serviceAccount : kplus.ServiceAccount.fromServiceAccountName ( 'aws' ), });","title":"Pod"},{"location":"plus/pod/#pod","text":"A pod is essentially a collection of containers. It is the most fundamental computation unit that can be provisioned. API Reference","title":"Pod"},{"location":"plus/pod/#adding-containersvolumes","text":"Containers and volumes can be added to pod definition like so: import * as kplus from 'cdk8s-plus-17' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , }); const storage = kplus . Volume . fromEmptyDir ( 'storage' ); container . mount ( '/data' , storage ); const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // this will automatically add the volume as well. pod . addContainer ( container ); // but if you want to explicitly add it, simply use: pod . addVolume ( storage );","title":"Adding Containers/Volumes"},{"location":"plus/pod/#applying-a-restart-policy","text":"import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' , { restartPolicy : kplus.RestartPolicy.NEVER , });","title":"Applying a restart policy"},{"location":"plus/pod/#assigning-a-serviceaccount","text":"import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' , { serviceAccount : kplus.ServiceAccount.fromServiceAccountName ( 'aws' ), });","title":"Assigning a ServiceAccount"},{"location":"plus/secret/","text":"Secret \u00b6 Secrets are used to store confidential information. Never store such information on the definition of the pod itself. API Reference Use an existing Secret \u00b6 To reference a secret created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-17' ; const secret = kplus . Secret . fromSecretName ( 'aws-creds' ); Adding data \u00b6 To create a new secret with some data, use: import * as kplus from 'cdk8s-plus-17' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const secret = new kplus . Secret ( chart , 'Secret' ); secret . addStringData ( 'password' , 'some-encrypted-data' );","title":"Secret"},{"location":"plus/secret/#secret","text":"Secrets are used to store confidential information. Never store such information on the definition of the pod itself. API Reference","title":"Secret"},{"location":"plus/secret/#use-an-existing-secret","text":"To reference a secret created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-17' ; const secret = kplus . Secret . fromSecretName ( 'aws-creds' );","title":"Use an existing Secret"},{"location":"plus/secret/#adding-data","text":"To create a new secret with some data, use: import * as kplus from 'cdk8s-plus-17' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const secret = new kplus . Secret ( chart , 'Secret' ); secret . addStringData ( 'password' , 'some-encrypted-data' );","title":"Adding data"},{"location":"plus/service-account/","text":"ServiceAccount \u00b6 Use service accounts to provide an identity for pods. API Reference Use an existing ServiceAccount \u00b6 To reference a service account created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-17' ; const serviceAccount = kplus . ServiceAccount . fromServiceAccountName ( 'aws-service' ); Allowing access to secrets \u00b6 To create a new service account, and give it access to some secrets, use the following: import * as kplus from 'cdk8s-plus-17' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const awsCreds = kplus . Secret . fromSecretName ( 'aws-creds' ); const awsService = new kplus . ServiceAccount ( chart , 'AWS' ); // give access to the aws creds secret. awsService . addSecret ( awsCreds );","title":"ServiceAccount"},{"location":"plus/service-account/#serviceaccount","text":"Use service accounts to provide an identity for pods. API Reference","title":"ServiceAccount"},{"location":"plus/service-account/#use-an-existing-serviceaccount","text":"To reference a service account created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-17' ; const serviceAccount = kplus . ServiceAccount . fromServiceAccountName ( 'aws-service' );","title":"Use an existing ServiceAccount"},{"location":"plus/service-account/#allowing-access-to-secrets","text":"To create a new service account, and give it access to some secrets, use the following: import * as kplus from 'cdk8s-plus-17' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const awsCreds = kplus . Secret . fromSecretName ( 'aws-creds' ); const awsService = new kplus . ServiceAccount ( chart , 'AWS' ); // give access to the aws creds secret. awsService . addSecret ( awsCreds );","title":"Allowing access to secrets"},{"location":"plus/service/","text":"Service \u00b6 Use services when you want to expose a set of pods using a stable network identity. They can also be used for externalizing endpoints to clients outside of the kubernetes cluster. API Reference Selectors \u00b6 Services must be configured with selectors that tell it which pods should it serve. The most common selector method is using labels. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // this will cause the service to select all pods with the 'run: frontend' label. frontends . selectByLabel ( 'run' , 'frontend' ) Ports \u00b6 Ports that the service will listen and redirect to can be configured like so: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // make the service bind to port 9000 and redirect to port 80 on the associated containers. frontends . serve ({ port : 9000 , targetPort : 80 )","title":"Service"},{"location":"plus/service/#service","text":"Use services when you want to expose a set of pods using a stable network identity. They can also be used for externalizing endpoints to clients outside of the kubernetes cluster. API Reference","title":"Service"},{"location":"plus/service/#selectors","text":"Services must be configured with selectors that tell it which pods should it serve. The most common selector method is using labels. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // this will cause the service to select all pods with the 'run: frontend' label. frontends . selectByLabel ( 'run' , 'frontend' )","title":"Selectors"},{"location":"plus/service/#ports","text":"Ports that the service will listen and redirect to can be configured like so: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // make the service bind to port 9000 and redirect to port 80 on the associated containers. frontends . serve ({ port : 9000 , targetPort : 80 )","title":"Ports"},{"location":"plus/volume/","text":"Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. API Reference Create from a ConfigMap \u00b6 A very useful operation is to create a volume from a ConfigMap . Kubernetes will translate every key in the config map to a file, who\u2019s content is the value of the key. import * as kplus from 'cdk8s-plus-17' ; const configMap = kplus . ConfigMap . fromConfigMapName ( 'redis-config' ); const configVolume = kplus . Volume . fromConfigMap ( configMap ); Create from an EmptyDir \u00b6 The easiest way to allocate some persistent storage to your container is to create a volume from an empty directory. This volume, as the name suggests, is initially empty, and can be written to by containers who mount it. The data in the volume is preserved throughout the lifecycle of the pod, but is deleted forever as soon as the pod itself is removed. import * as kplus from 'cdk8s-plus-17' ; const data = kplus . Volume . fromEmptyDir ( configMap ); const pod = new kplus . Pod ( this , 'Pod' ); const redis = pod . addContainer ({ image : 'redis' }) // mount to the redis container. redis . mount ( '/var/lib/redis' , data );","title":"Volume"},{"location":"plus/volume/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. API Reference","title":"Volume"},{"location":"plus/volume/#create-from-a-configmap","text":"A very useful operation is to create a volume from a ConfigMap . Kubernetes will translate every key in the config map to a file, who\u2019s content is the value of the key. import * as kplus from 'cdk8s-plus-17' ; const configMap = kplus . ConfigMap . fromConfigMapName ( 'redis-config' ); const configVolume = kplus . Volume . fromConfigMap ( configMap );","title":"Create from a ConfigMap"},{"location":"plus/volume/#create-from-an-emptydir","text":"The easiest way to allocate some persistent storage to your container is to create a volume from an empty directory. This volume, as the name suggests, is initially empty, and can be written to by containers who mount it. The data in the volume is preserved throughout the lifecycle of the pod, but is deleted forever as soon as the pod itself is removed. import * as kplus from 'cdk8s-plus-17' ; const data = kplus . Volume . fromEmptyDir ( configMap ); const pod = new kplus . Pod ( this , 'Pod' ); const redis = pod . addContainer ({ image : 'redis' }) // mount to the redis container. redis . mount ( '/var/lib/redis' , data );","title":"Create from an EmptyDir"},{"location":"project/CHANGELOG/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. See standard-version for commit guidelines. 1.0.0-beta.11 (2021-03-30) \u00b6 Dependency upgrades. 1.0.0-beta.10 (2021-03-02) \u00b6 Features \u00b6 Dependency upgrades. 1.0.0-beta.9 (2021-02-22) \u00b6 Features \u00b6 lib: flag to disable dictionary sort ( #534 ) ( a4eca40 ), closes #525 Bug Fixes \u00b6 lib: ENOBUFS for large helm charts ( #529 ) ( 4164f38 ), closes #454 1.0.0-beta.8 (2021-02-04) \u00b6 Bug Fixes \u00b6 go: invalid go module name ( 87af61b ) 1.0.0-beta.7 (2021-02-04) \u00b6 \u26a0 BREAKING CHANGES \u00b6 lib: the deprecated API Duration.toISOString() has been removed. Use Duration.toIsoString() instead. Features \u00b6 plus-17: add StatefulSet construct ( #400 ) ( 98aad99 ) plus-17: restrict CIDR IP addresses for a LoadBalancer ( #446 ) ( cf96ae2 ), closes #435 experimental golang bindings ( #523 ) ( 6737351 ) only publish doc site on release commits ( #507 ) ( 5acc54b ) Bug Fixes \u00b6 cli: allow any python 3 to be used ( #518 ) ( 2a49196 ) lib: deprecated toISOString() conflicts with toIsoString() ( #524 ) ( d4e0c3d ) not folding strings ( #495 ) ( 8dda8bd ), closes #494 1.0.0-beta.6 (2021-01-21) \u00b6 Features \u00b6 cli: new version notifications ( #454 ) ( 065756e ), closes #452 plus-17: Add type option for secrets in kplus. ( #425 ) ( 28d660f ) Bug Fixes \u00b6 set yaml default schema to 1.1 ( #505 ) ( 266c094 ) docs: correct logo paths ( #503 ) ( 9426047 ) plus-17: adds externalName to service props ( #424 ) ( b4b7c55 ) plus-17: multiple mounts per volume result in duplicate volumes for pod spec ( #489 ) ( 47c913e ) 1.0.0-beta.5 (2020-12-15) \u00b6 Features \u00b6 cli: enable using imported resources as raw manifests ( #447 ) ( aa2422e ) Bug Fixes \u00b6 cli: importing local files is broken on windows ( #427 ) ( 2c4a185 ) 1.0.0-beta.4 (2020-12-13) \u00b6 Features \u00b6 cli: import a single module per api group ( #402 ) ( ac295fe ), closes #378 #401 lib: allow hash to be optionally included in Names functions. ( #396 ) ( 2c86526 ) plus-17: additional options for the Job construct. ( #398 ) ( 17e8801 ) Bug Fixes \u00b6 lib: Lazy is not resolved in metadata ( #443 ) ( 914d4a8 ) cli: which command missing for windows ( #417 ) ( 38a7034 ) docs: align getting started with new code ( #410 ) ( c61e109 ) docs: WebService typescript example formatting ( #408 ) ( e2470f9 ) plus-17: don\u2019t allow containers to be contructed from containers ( #404 ) ( 5d11533 ) 1.0.0-beta.3 (2020-11-19) \u00b6 Features \u00b6 cli: stdout option for cdk8s synth ( #361 ) ( bbf116b ) add contributor instructions about using jsii docker image ( #397 ) ( bb0a5cc ) Bug Fixes \u00b6 cli: python init template doesn\u2019t install cdk8s-plus in the correct env ( #399 ) ( 0d3017b ) 1.0.0-beta.2 (2020-11-19) \u00b6 \u26a0 BREAKING CHANGES \u00b6 lib: CAUTION! Auto-generated resource names will change with this release. Resource names in manifests synthesized by a previous version of the CDK8s will be invalidated. Deploying new manifests will cause resources to be replaced . Temporarily, you can opt to use the legacy hashing mechanism by setting the environment variable CDK8S_LEGACY_HASH=1 . lib: Names.toDnsLabel() now accepts a construct scope instead of a string path, and a set of options instead of maxLen . lib: Names.toLabelValue() now accepts a construct scope instead of a string path, and a set of options instead of maxLen . Features \u00b6 cli: import from crds.dev ( #378 ) ( c62d0a4 ), closes #377 Bug Fixes \u00b6 cli: python init templates are broken ( #393 ) ( d786001 ) lib: names generated using non-FIPS compliant algorithm ( #392 ) ( a1acae7 ), closes #334 1.0.0-beta.1 (2020-11-18) \u00b6 \u26a0 BREAKING CHANGES \u00b6 plus-17: All L2 resource names will undergo a name change (e.g test-chart-config-configmap-233db8e7 -> test-chart-config-c3f7d3c0 ) cli: Construct input types generated by cdk8s import are now called XxxProps instead of XxxOptions to conform with the CDK ecosystem. lib: ApiObjectOptions is now called ApiObjectProps lib: AppOptions is now called AppProps lib: ChartOptions is now called ChartProps lib: HelmOptions is now called HelmProps lib: IncludeOptions is now called IncludeProps cli: when importing k8s api objects using cdk8s import , non-stable APIs will be have an API level postfix. For example, k8s@1.18 will have an IngressV1Beta1 API object. cli: The --include CLI option has been removed since all API objects are always imported. cli: When using the CLI to import the core Kubernetes API objects, the imported classes will now have a Kube prefix in order to make it easier to differentiate them from the classes offered by the high-level APIs in CDK8s+ (e.g. k8s.Deployment is now k8s.KubeDeployment ). You can disable through the --no-class-prefix option: cdk8s import --no-class-prefix k8s . plus-17: Containers now need to be inputed as interfaces rather than classes. Instead of passing new kplus.Container(props) , simply pass in props . Features \u00b6 plus: renamed to cdk8s-plus-17 . The 17 marks the minimum supported version of the kubernetes spec. website: documentation website ( #367 ) ( 505f946 ), closes #366 cdk8s: escape hatches ( #372 ) ( 12b0f01 ), closes #144 cli: class prefix for imported constructs ( #370 ) ( 0b18df3 ), closes #140 cli: import constructs for all API levels ( #379 ) ( b0d7621 ), closes #380 plus-17: add liveness and startup probes to Container ( #358 ) ( f3f9a6a ) plus-17: Container is now inputed as an interface instead of class ( #376 ) ( 33bf97a ) plus-17: expose service options in expose() ( #357 ) ( 7137698 ) switch to 1.0.0-beta version line ( #384 ) ( ffce8c6 ) Bug Fixes \u00b6 cli: input type names are \u201cXxxOptions\u201d instead of \u201cXxxProps\u201d ( #381 ) ( b2bd34e ), closes #371 plus-17: L2 default child ( #389 ) ( a8337e8 ) 0.33.0 (2020-10-21) \u00b6 Features \u00b6 chart-level labels ( #355 ) ( c545c1e ) 0.32.0 (2020-10-20) \u00b6 \u26a0 BREAKING CHANGES \u00b6 lib: EnvValue.fromSecret(secret, key) has been removed in favor of EnvValue.fromSecretValue({ secret, key }) . Features \u00b6 lib: SecretValue ( #351 ) ( dd7cf58 ) plus: readiness probes ( #353 ) ( a57e466 ) Bug Fixes \u00b6 lib: corrupted manifests when including large files ( #350 ) ( 649f41b ) lib: fail to import octal numbers via include (and helm) ( #349 ) ( bed9eed ), closes #348 0.31.0 (2020-10-19) \u00b6 \u26a0 BREAKING CHANGES \u00b6 plus: spec was removed from all cdk8s+ constructs and that now have a flat structure. See Example for new usage. plus : Construct id\u2019s for deployment will change due to a latent bug that appended the word pod to them. plus: deployment.expose() now takes port as a positional argument (before: deployment.expose({ port }) , now: deployment.expose(port) ). lib: auto-generated resource names that included duplicate hyphens will change will be replaced when applied. lib: cdk8s-plus\u2019s value of a label cdk8s.deployment of Pods are changed Features \u00b6 lib: helm construct ( #346 ) ( 6ee449f ), closes #65 plus: Ingress ( #340 ) ( 14ac668 ), closes #125 plus: service.addDeployment() ( #342 ) ( 5413b3b ) migrate to cdk.dev slack workspace ( #336 ) ( b203e5a ) Bug Fixes \u00b6 lib: uniqueId is not compatible with the k8s labels ( #326 ) ( 161f368 ), closes #323 lib: duplicate hyphens in generated resource names ( #341 ) ( 6f6366a ) allow tests to run without write access to os.tmpdir parent ( #338 ) ( dc17022 ) Fix yaml quote serialization 325 ( #327 ) ( 6b1f662 ), closes #325 plus: Remove the spec nesting level on both input and output ( #347 ) ( 5e34850 ) 0.30.0 (2020-10-04) \u00b6 Features \u00b6 plus: Bump k8s imports to use spec version 1.17.0 ( #331 ) ( 23fea73 ) Features \u00b6 lib: Expose DependecyGraph for upstream use ( #329 ) ( ee88402 ), closes #328 0.29.0 (2020-09-27) \u00b6 Features \u00b6 lib: Upgrade constructs ( #324 ) ( 070b600 ) 0.28.0 (2020-09-14) \u00b6 Features \u00b6 plus: ImagePullPolicy support for cdk8s-plus Container ( #313 ) ( 8307757 ) Bug Fixes \u00b6 examples: Add missing dependencies on python examples. ( #290 ) ( 36e6fab ), closes #289 plus: support node ports for cdk8s-plus service ( #315 ) ( 85ec225 ), closes #296 website: doc links are broken due to wrong version number ( #312 ) ( f2f9402 ), closes #307 0.27.0 (2020-08-05) \u00b6 \u26a0 BREAKING CHANGES \u00b6 lib: resource names will now be rendered differently, omitting adjacent duplicate components. Features \u00b6 examples: Elasticsearch query using CDK8s+ and CRD ( #281 ) ( 3be1a96 ) lib: omit duplicate components in generated names ( #258 ) ( 473b5ef ) Bug Fixes \u00b6 cli: Conform python and java package names to language standards (no hyphens) ( #283 ) ( f0b33c0 ) cli: java importing crd fails ( #257 ) ( f0ef3b4 ) 0.26.0 (2020-06-29) \u00b6 Features \u00b6 cli: cdk8s init template for java ( #245 ) ( 2bec62a ) Introducing \u201ccdk8s+\u201d: high-level APIs for Kubernetes ( #239 ) ( 1b991f6 ) Bug Fixes \u00b6 move output of java imports into /src/main/java ( #240 ) ( 9445358 ) 0.25.0 (2020-06-09) \u00b6 \u26a0 BREAKING CHANGES \u00b6 lib: cdk8s discontinues support for the onPrepare and onSynthesis construct hooks. These methods will eventually be removed from the constructs programming model. Features \u00b6 cli: java import support ( #226 ) ( 9619a73 ) lib: dependencies and ordering of charts and objects ( #223 ) ( 701579e ), closes #111 Bug Fixes \u00b6 cli: options type not generated for certain CRDs ( #229 ) ( 0cbaf19 ), closes #219 0.24.0 (2020-05-27) \u00b6 \u26a0 BREAKING CHANGES \u00b6 cli: enum string values are now proper enums instead of just string s. Features \u00b6 cli: import - support enum string fields ( #210 ) ( 8b8ad44 ), closes #196 Bug Fixes \u00b6 cli: unable to import CRDs with non-trivial \u201cxxxOf\u201d constraints ( #212 ) ( 18136ed ), closes #171 cli: unable to import types with all-caps TLAs ( #211 ) ( a11d0e8 ), closes #209 0.23.0 (2020-05-26) \u00b6 \u26a0 BREAKING CHANGES \u00b6 cli : the generated module names of imported CRDs now include the resource\u2019s group and not just its kind in order to ensure uniqueness. For example, when importing the Jenkins CRD, instead of \u2018imports/jenkins.ts , we now have imports/jenkins.io/jenkins.ts`. cli : class names of imported apis are now normalized to PascalCase . Features \u00b6 cli: import CRDs from a running cluster ( #207 ) ( 5153422 ), closes #197 lib: introduce \u201cinclude\u201d ( #202 ) ( 75d13e8 ), closes #199 lib: yaml utility functions ( #198 ) ( 9e0f030 ) Bug Fixes \u00b6 cli: impossible to import two crds with the same kind ( #203 ) ( f6248ce ) docs: do not mark arguments as optional in python getting-started ( #191 ) ( be090d0 ) lib: unable to express empty objects and array ( #200 ) ( 9ae5efb ) 0.22.0 (2020-05-22) \u00b6 Features \u00b6 cli: jest tests in typescript-app template ( b6aed5a ) cli: support CRDs with apiVersion \u201capiextensions.k8s.io/v1\u201d ( #142 ) ( f5111b0 ) cli: support import module name overriding in python ( #107 ) ( 327ba47 ) docs: add python and pipenv prerequisites ( db23fa1 ), closes #166 examples: central readme for all examples ( #176 ) ( 9cab302 ), closes #174 examples: reorganize examples by language ( #138 ) ( 85cf631 ) readme: add link to \u201cawesome cdk8s\u201d ( 0889a6e ) 0.21.0 (2020-05-14) \u00b6 Features \u00b6 new website ( #143 ) ( fcc59b0 ) example: python hello example ( #101 ) ( e792d2b ) website: add reference docs links ( 2034ec0 ) Bug Fixes \u00b6 cli: unable to import a crd that has no schema ( #132 ) ( b8115cb ) crd: Ensure yaml doc is defined before casting to CustomResourceApiObject ( #130 ) ( 03e6d84 ) redirect: Handle 302 redirect case when importing from remote url ( #131 ) ( 1ed88ca ) 0.20.0 (2020-04-27) \u00b6 Features \u00b6 surface cdk8s in awscdk.io ( 45e188e ) Bug Fixes \u00b6 docs: top-level \u201cgetting started\u201d page not found ( #120 ) ( eb9d2ad ), closes #106 readme: missing information about imports in cdk8s-cli readme ( #108 ) ( e9f291e ) 0.19.0 (2020-04-12) \u00b6 Bug Fixes \u00b6 cli-import: unable to import a CRD from an insecure server ( #102 ) ( 4dde096 ), closes #94 homebrew: homebrew release trigger is broken ( 5ecb143 ) Features \u00b6 cli-import: allow overriding module name in imports ( #84 ) ( 63daf78 ) 0.18.0 (2020-04-10) \u00b6 Features \u00b6 cdk8s website ( #89 ) ( 430d9b7 ) cli: ignore hidden files in \u201ccdk8s init\u201d ( #99 ) ( 5681e14 ) Bug Fixes \u00b6 crd: fix multi-resource importing of CRDs ( #78 ) ( fd8f753 ) examples: \u201creplicas\u201d option is not respected in the web-service example ( #87 ) ( 97ca582 ) gha: prevent gha from running on forks ( 26eb407 ) 0.17.0 (2020-03-21) \u00b6 \u26a0 BREAKING CHANGES \u00b6 please upgrade your dependency requirement for \u201cconstructs\u201d to ^2.0.0 Bug Fixes \u00b6 gh_actions: fix release-next script to use correct npx publishing ( 27c7f9d ) readme: hello example link is broken #74 ( 0b858cf ) upgrade jsii & constructs ( #80 ) ( f917e0a ) 0.16.0 (2020-03-17) \u00b6 Features \u00b6 cli: cdk8s import crd.yaml ( #70 ) ( 5d1c278 ), closes #27 0.15.1 (2020-03-13) \u00b6 Bug Fixes \u00b6 cli-init: install \u201cconstructs\u201d instead of \u201c@aws-cdk/core\u201d ( 6ccc03f ) 0.15.0 (2020-03-12) \u00b6 Features \u00b6 default chart namespaces ( #68 ) ( 36b9ff1 ) peer-depend on \u201cconstructs\u201d instead of \u201c@aws-cdk/core\u201d ( #66 ) ( c336c95 ) sort keys of ApiObject manifests ( #67 ) ( 1fe89bd ), closes #17 0.14.0 (2020-03-10) \u00b6 Features \u00b6 allow arbitrary construct names ( #64 ) ( 1309960 ), closes #48 chart.toJson() and apiObject.toJson() ( #63 ) ( 80e8402 ), closes #48 0.13.1 (2020-03-09) \u00b6 Bug Fixes \u00b6 cli: init could not find a version that matches cdk8s0-13-0 ( e1267f6 ) 0.13.0 (2020-03-09) \u00b6 This release adds Python support for cdk8s and includes; - The cdk8s library is released to PyPI - cdk8s init python-app creates new Python apps - cdk8s import generates python classes for Kubernetes API objects \u26a0 BREAKING CHANGES \u00b6 cli: cdk8s import now generates a single file with all types, which means you will have to modify TypeScript code to import { Deployment, Pod, ... } from './imports/k8s' instead of importing multiple files. cli: cdk8s gen is now cdk8s import k8s and output goes to imports/k8s.ts instead of .gen/index.ts . Features \u00b6 cli: \u201ccdk8s gen\u201d is now \u201ccdk8s import k8s\u201d ( #43 ) ( fb9e0b5 ), closes #31 #40 cli: \u201ccdk8s synth\u201d ( #44 ) ( d457ea9 ), closes #41 cli: cdk8s.yaml ( #52 ) ( e6834d3 ), closes #42 cli: import only one class for every api object ( #39 ) ( 2db4cfb ) cli: python project template ( #36 ) ( 30f3bb7 ) cli: python support for \u201cimport\u201d ( #47 ) ( 3b93d64 ) cli: typescript project - \u201cnpm run upgrade\u201d & \u201cupgrade:next\u201d ( 735e840 ) cli: typescript project - \u201cnpm run build\u201d now includes \u201csynth\u201d ( 7b15e3a ) docs: getting started in python ( #60 ) ( 27d3bac ) examples: updates to hello-world example and directory reorganization ( #33 ) ( 1c8f694 ) Bug Fixes \u00b6 cli: new typescript apps cannot be created with @next versions ( #55 ) ( 119d95c ) 0.12.0 (2020-03-03) \u00b6 Bug Fixes \u00b6 yaml not found in jsii languages ( 39ef409 ) 0.11.0 (2020-03-03) \u00b6 Bug Fixes \u00b6 yaml not found in jsii languages ( 39ef409 ) 0.10.0 (2020-02-28) \u00b6 Bug Fixes \u00b6 cdk8s: autogenerated names fail validation for some resource types ( #18 ) ( b70e4fe ), closes #16 0.9.0 (2020-02-27) \u00b6 Features \u00b6 cdk8s: the App root construct ( #15 ) ( c595240 ) 0.8.0 (2020-02-27) \u00b6 Features \u00b6 cli: remove the cookiecutter prerequisite ( #13 ) ( 10ab259 ) 0.7.0 (2020-02-26) \u00b6 Bug Fixes \u00b6 cli: typescript-app does not include main.ts ( 43b435a ) 0.6.0 (2020-02-26) \u00b6 Bug Fixes \u00b6 cli does not work when used from a symlink ( #11 ) ( 4bd3a37 ) 0.5.0 (2020-02-26) \u00b6 Features \u00b6 cli: project templates with \u201ccdk8s init\u201d ( #10 ) ( 4aa59d9 ) cookiecutter template for typescript app projects ( #9 ) ( 55087e2 ) 0.4.0 (2020-02-23) \u00b6 Features \u00b6 podinfo: allow containers to bind to deployment ( 45237c0 ) 0.3.0 (2020-02-23) \u00b6 Features \u00b6 chart.generateObjectName ( 03a1d26 ) Chart.of(node) ( d6a9dc0 ) 0.1.2 (2020-02-12) \u00b6 Features \u00b6 getting started documentation ( 2616372 )","title":"Changelog"},{"location":"project/CHANGELOG/#changelog","text":"All notable changes to this project will be documented in this file. See standard-version for commit guidelines.","title":"Changelog"},{"location":"project/CHANGELOG/#100-beta11-2021-03-30","text":"Dependency upgrades.","title":"1.0.0-beta.11 (2021-03-30)"},{"location":"project/CHANGELOG/#100-beta10-2021-03-02","text":"","title":"1.0.0-beta.10 (2021-03-02)"},{"location":"project/CHANGELOG/#features","text":"Dependency upgrades.","title":"Features"},{"location":"project/CHANGELOG/#100-beta9-2021-02-22","text":"","title":"1.0.0-beta.9 (2021-02-22)"},{"location":"project/CHANGELOG/#features_1","text":"lib: flag to disable dictionary sort ( #534 ) ( a4eca40 ), closes #525","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes","text":"lib: ENOBUFS for large helm charts ( #529 ) ( 4164f38 ), closes #454","title":"Bug Fixes"},{"location":"project/CHANGELOG/#100-beta8-2021-02-04","text":"","title":"1.0.0-beta.8 (2021-02-04)"},{"location":"project/CHANGELOG/#bug-fixes_1","text":"go: invalid go module name ( 87af61b )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#100-beta7-2021-02-04","text":"","title":"1.0.0-beta.7 (2021-02-04)"},{"location":"project/CHANGELOG/#breaking-changes","text":"lib: the deprecated API Duration.toISOString() has been removed. Use Duration.toIsoString() instead.","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG/#features_2","text":"plus-17: add StatefulSet construct ( #400 ) ( 98aad99 ) plus-17: restrict CIDR IP addresses for a LoadBalancer ( #446 ) ( cf96ae2 ), closes #435 experimental golang bindings ( #523 ) ( 6737351 ) only publish doc site on release commits ( #507 ) ( 5acc54b )","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_2","text":"cli: allow any python 3 to be used ( #518 ) ( 2a49196 ) lib: deprecated toISOString() conflicts with toIsoString() ( #524 ) ( d4e0c3d ) not folding strings ( #495 ) ( 8dda8bd ), closes #494","title":"Bug Fixes"},{"location":"project/CHANGELOG/#100-beta6-2021-01-21","text":"","title":"1.0.0-beta.6 (2021-01-21)"},{"location":"project/CHANGELOG/#features_3","text":"cli: new version notifications ( #454 ) ( 065756e ), closes #452 plus-17: Add type option for secrets in kplus. ( #425 ) ( 28d660f )","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_3","text":"set yaml default schema to 1.1 ( #505 ) ( 266c094 ) docs: correct logo paths ( #503 ) ( 9426047 ) plus-17: adds externalName to service props ( #424 ) ( b4b7c55 ) plus-17: multiple mounts per volume result in duplicate volumes for pod spec ( #489 ) ( 47c913e )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#100-beta5-2020-12-15","text":"","title":"1.0.0-beta.5 (2020-12-15)"},{"location":"project/CHANGELOG/#features_4","text":"cli: enable using imported resources as raw manifests ( #447 ) ( aa2422e )","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_4","text":"cli: importing local files is broken on windows ( #427 ) ( 2c4a185 )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#100-beta4-2020-12-13","text":"","title":"1.0.0-beta.4 (2020-12-13)"},{"location":"project/CHANGELOG/#features_5","text":"cli: import a single module per api group ( #402 ) ( ac295fe ), closes #378 #401 lib: allow hash to be optionally included in Names functions. ( #396 ) ( 2c86526 ) plus-17: additional options for the Job construct. ( #398 ) ( 17e8801 )","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_5","text":"lib: Lazy is not resolved in metadata ( #443 ) ( 914d4a8 ) cli: which command missing for windows ( #417 ) ( 38a7034 ) docs: align getting started with new code ( #410 ) ( c61e109 ) docs: WebService typescript example formatting ( #408 ) ( e2470f9 ) plus-17: don\u2019t allow containers to be contructed from containers ( #404 ) ( 5d11533 )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#100-beta3-2020-11-19","text":"","title":"1.0.0-beta.3 (2020-11-19)"},{"location":"project/CHANGELOG/#features_6","text":"cli: stdout option for cdk8s synth ( #361 ) ( bbf116b ) add contributor instructions about using jsii docker image ( #397 ) ( bb0a5cc )","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_6","text":"cli: python init template doesn\u2019t install cdk8s-plus in the correct env ( #399 ) ( 0d3017b )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#100-beta2-2020-11-19","text":"","title":"1.0.0-beta.2 (2020-11-19)"},{"location":"project/CHANGELOG/#breaking-changes_1","text":"lib: CAUTION! Auto-generated resource names will change with this release. Resource names in manifests synthesized by a previous version of the CDK8s will be invalidated. Deploying new manifests will cause resources to be replaced . Temporarily, you can opt to use the legacy hashing mechanism by setting the environment variable CDK8S_LEGACY_HASH=1 . lib: Names.toDnsLabel() now accepts a construct scope instead of a string path, and a set of options instead of maxLen . lib: Names.toLabelValue() now accepts a construct scope instead of a string path, and a set of options instead of maxLen .","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG/#features_7","text":"cli: import from crds.dev ( #378 ) ( c62d0a4 ), closes #377","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_7","text":"cli: python init templates are broken ( #393 ) ( d786001 ) lib: names generated using non-FIPS compliant algorithm ( #392 ) ( a1acae7 ), closes #334","title":"Bug Fixes"},{"location":"project/CHANGELOG/#100-beta1-2020-11-18","text":"","title":"1.0.0-beta.1 (2020-11-18)"},{"location":"project/CHANGELOG/#breaking-changes_2","text":"plus-17: All L2 resource names will undergo a name change (e.g test-chart-config-configmap-233db8e7 -> test-chart-config-c3f7d3c0 ) cli: Construct input types generated by cdk8s import are now called XxxProps instead of XxxOptions to conform with the CDK ecosystem. lib: ApiObjectOptions is now called ApiObjectProps lib: AppOptions is now called AppProps lib: ChartOptions is now called ChartProps lib: HelmOptions is now called HelmProps lib: IncludeOptions is now called IncludeProps cli: when importing k8s api objects using cdk8s import , non-stable APIs will be have an API level postfix. For example, k8s@1.18 will have an IngressV1Beta1 API object. cli: The --include CLI option has been removed since all API objects are always imported. cli: When using the CLI to import the core Kubernetes API objects, the imported classes will now have a Kube prefix in order to make it easier to differentiate them from the classes offered by the high-level APIs in CDK8s+ (e.g. k8s.Deployment is now k8s.KubeDeployment ). You can disable through the --no-class-prefix option: cdk8s import --no-class-prefix k8s . plus-17: Containers now need to be inputed as interfaces rather than classes. Instead of passing new kplus.Container(props) , simply pass in props .","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG/#features_8","text":"plus: renamed to cdk8s-plus-17 . The 17 marks the minimum supported version of the kubernetes spec. website: documentation website ( #367 ) ( 505f946 ), closes #366 cdk8s: escape hatches ( #372 ) ( 12b0f01 ), closes #144 cli: class prefix for imported constructs ( #370 ) ( 0b18df3 ), closes #140 cli: import constructs for all API levels ( #379 ) ( b0d7621 ), closes #380 plus-17: add liveness and startup probes to Container ( #358 ) ( f3f9a6a ) plus-17: Container is now inputed as an interface instead of class ( #376 ) ( 33bf97a ) plus-17: expose service options in expose() ( #357 ) ( 7137698 ) switch to 1.0.0-beta version line ( #384 ) ( ffce8c6 )","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_8","text":"cli: input type names are \u201cXxxOptions\u201d instead of \u201cXxxProps\u201d ( #381 ) ( b2bd34e ), closes #371 plus-17: L2 default child ( #389 ) ( a8337e8 )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0330-2020-10-21","text":"","title":"0.33.0 (2020-10-21)"},{"location":"project/CHANGELOG/#features_9","text":"chart-level labels ( #355 ) ( c545c1e )","title":"Features"},{"location":"project/CHANGELOG/#0320-2020-10-20","text":"","title":"0.32.0 (2020-10-20)"},{"location":"project/CHANGELOG/#breaking-changes_3","text":"lib: EnvValue.fromSecret(secret, key) has been removed in favor of EnvValue.fromSecretValue({ secret, key }) .","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG/#features_10","text":"lib: SecretValue ( #351 ) ( dd7cf58 ) plus: readiness probes ( #353 ) ( a57e466 )","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_9","text":"lib: corrupted manifests when including large files ( #350 ) ( 649f41b ) lib: fail to import octal numbers via include (and helm) ( #349 ) ( bed9eed ), closes #348","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0310-2020-10-19","text":"","title":"0.31.0 (2020-10-19)"},{"location":"project/CHANGELOG/#breaking-changes_4","text":"plus: spec was removed from all cdk8s+ constructs and that now have a flat structure. See Example for new usage. plus : Construct id\u2019s for deployment will change due to a latent bug that appended the word pod to them. plus: deployment.expose() now takes port as a positional argument (before: deployment.expose({ port }) , now: deployment.expose(port) ). lib: auto-generated resource names that included duplicate hyphens will change will be replaced when applied. lib: cdk8s-plus\u2019s value of a label cdk8s.deployment of Pods are changed","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG/#features_11","text":"lib: helm construct ( #346 ) ( 6ee449f ), closes #65 plus: Ingress ( #340 ) ( 14ac668 ), closes #125 plus: service.addDeployment() ( #342 ) ( 5413b3b ) migrate to cdk.dev slack workspace ( #336 ) ( b203e5a )","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_10","text":"lib: uniqueId is not compatible with the k8s labels ( #326 ) ( 161f368 ), closes #323 lib: duplicate hyphens in generated resource names ( #341 ) ( 6f6366a ) allow tests to run without write access to os.tmpdir parent ( #338 ) ( dc17022 ) Fix yaml quote serialization 325 ( #327 ) ( 6b1f662 ), closes #325 plus: Remove the spec nesting level on both input and output ( #347 ) ( 5e34850 )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0300-2020-10-04","text":"","title":"0.30.0 (2020-10-04)"},{"location":"project/CHANGELOG/#features_12","text":"plus: Bump k8s imports to use spec version 1.17.0 ( #331 ) ( 23fea73 )","title":"Features"},{"location":"project/CHANGELOG/#features_13","text":"lib: Expose DependecyGraph for upstream use ( #329 ) ( ee88402 ), closes #328","title":"Features"},{"location":"project/CHANGELOG/#0290-2020-09-27","text":"","title":"0.29.0 (2020-09-27)"},{"location":"project/CHANGELOG/#features_14","text":"lib: Upgrade constructs ( #324 ) ( 070b600 )","title":"Features"},{"location":"project/CHANGELOG/#0280-2020-09-14","text":"","title":"0.28.0 (2020-09-14)"},{"location":"project/CHANGELOG/#features_15","text":"plus: ImagePullPolicy support for cdk8s-plus Container ( #313 ) ( 8307757 )","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_11","text":"examples: Add missing dependencies on python examples. ( #290 ) ( 36e6fab ), closes #289 plus: support node ports for cdk8s-plus service ( #315 ) ( 85ec225 ), closes #296 website: doc links are broken due to wrong version number ( #312 ) ( f2f9402 ), closes #307","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0270-2020-08-05","text":"","title":"0.27.0 (2020-08-05)"},{"location":"project/CHANGELOG/#breaking-changes_5","text":"lib: resource names will now be rendered differently, omitting adjacent duplicate components.","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG/#features_16","text":"examples: Elasticsearch query using CDK8s+ and CRD ( #281 ) ( 3be1a96 ) lib: omit duplicate components in generated names ( #258 ) ( 473b5ef )","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_12","text":"cli: Conform python and java package names to language standards (no hyphens) ( #283 ) ( f0b33c0 ) cli: java importing crd fails ( #257 ) ( f0ef3b4 )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0260-2020-06-29","text":"","title":"0.26.0 (2020-06-29)"},{"location":"project/CHANGELOG/#features_17","text":"cli: cdk8s init template for java ( #245 ) ( 2bec62a ) Introducing \u201ccdk8s+\u201d: high-level APIs for Kubernetes ( #239 ) ( 1b991f6 )","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_13","text":"move output of java imports into /src/main/java ( #240 ) ( 9445358 )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0250-2020-06-09","text":"","title":"0.25.0 (2020-06-09)"},{"location":"project/CHANGELOG/#breaking-changes_6","text":"lib: cdk8s discontinues support for the onPrepare and onSynthesis construct hooks. These methods will eventually be removed from the constructs programming model.","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG/#features_18","text":"cli: java import support ( #226 ) ( 9619a73 ) lib: dependencies and ordering of charts and objects ( #223 ) ( 701579e ), closes #111","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_14","text":"cli: options type not generated for certain CRDs ( #229 ) ( 0cbaf19 ), closes #219","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0240-2020-05-27","text":"","title":"0.24.0 (2020-05-27)"},{"location":"project/CHANGELOG/#breaking-changes_7","text":"cli: enum string values are now proper enums instead of just string s.","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG/#features_19","text":"cli: import - support enum string fields ( #210 ) ( 8b8ad44 ), closes #196","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_15","text":"cli: unable to import CRDs with non-trivial \u201cxxxOf\u201d constraints ( #212 ) ( 18136ed ), closes #171 cli: unable to import types with all-caps TLAs ( #211 ) ( a11d0e8 ), closes #209","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0230-2020-05-26","text":"","title":"0.23.0 (2020-05-26)"},{"location":"project/CHANGELOG/#breaking-changes_8","text":"cli : the generated module names of imported CRDs now include the resource\u2019s group and not just its kind in order to ensure uniqueness. For example, when importing the Jenkins CRD, instead of \u2018imports/jenkins.ts , we now have imports/jenkins.io/jenkins.ts`. cli : class names of imported apis are now normalized to PascalCase .","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG/#features_20","text":"cli: import CRDs from a running cluster ( #207 ) ( 5153422 ), closes #197 lib: introduce \u201cinclude\u201d ( #202 ) ( 75d13e8 ), closes #199 lib: yaml utility functions ( #198 ) ( 9e0f030 )","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_16","text":"cli: impossible to import two crds with the same kind ( #203 ) ( f6248ce ) docs: do not mark arguments as optional in python getting-started ( #191 ) ( be090d0 ) lib: unable to express empty objects and array ( #200 ) ( 9ae5efb )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0220-2020-05-22","text":"","title":"0.22.0 (2020-05-22)"},{"location":"project/CHANGELOG/#features_21","text":"cli: jest tests in typescript-app template ( b6aed5a ) cli: support CRDs with apiVersion \u201capiextensions.k8s.io/v1\u201d ( #142 ) ( f5111b0 ) cli: support import module name overriding in python ( #107 ) ( 327ba47 ) docs: add python and pipenv prerequisites ( db23fa1 ), closes #166 examples: central readme for all examples ( #176 ) ( 9cab302 ), closes #174 examples: reorganize examples by language ( #138 ) ( 85cf631 ) readme: add link to \u201cawesome cdk8s\u201d ( 0889a6e )","title":"Features"},{"location":"project/CHANGELOG/#0210-2020-05-14","text":"","title":"0.21.0 (2020-05-14)"},{"location":"project/CHANGELOG/#features_22","text":"new website ( #143 ) ( fcc59b0 ) example: python hello example ( #101 ) ( e792d2b ) website: add reference docs links ( 2034ec0 )","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_17","text":"cli: unable to import a crd that has no schema ( #132 ) ( b8115cb ) crd: Ensure yaml doc is defined before casting to CustomResourceApiObject ( #130 ) ( 03e6d84 ) redirect: Handle 302 redirect case when importing from remote url ( #131 ) ( 1ed88ca )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0200-2020-04-27","text":"","title":"0.20.0 (2020-04-27)"},{"location":"project/CHANGELOG/#features_23","text":"surface cdk8s in awscdk.io ( 45e188e )","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_18","text":"docs: top-level \u201cgetting started\u201d page not found ( #120 ) ( eb9d2ad ), closes #106 readme: missing information about imports in cdk8s-cli readme ( #108 ) ( e9f291e )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0190-2020-04-12","text":"","title":"0.19.0 (2020-04-12)"},{"location":"project/CHANGELOG/#bug-fixes_19","text":"cli-import: unable to import a CRD from an insecure server ( #102 ) ( 4dde096 ), closes #94 homebrew: homebrew release trigger is broken ( 5ecb143 )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#features_24","text":"cli-import: allow overriding module name in imports ( #84 ) ( 63daf78 )","title":"Features"},{"location":"project/CHANGELOG/#0180-2020-04-10","text":"","title":"0.18.0 (2020-04-10)"},{"location":"project/CHANGELOG/#features_25","text":"cdk8s website ( #89 ) ( 430d9b7 ) cli: ignore hidden files in \u201ccdk8s init\u201d ( #99 ) ( 5681e14 )","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_20","text":"crd: fix multi-resource importing of CRDs ( #78 ) ( fd8f753 ) examples: \u201creplicas\u201d option is not respected in the web-service example ( #87 ) ( 97ca582 ) gha: prevent gha from running on forks ( 26eb407 )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0170-2020-03-21","text":"","title":"0.17.0 (2020-03-21)"},{"location":"project/CHANGELOG/#breaking-changes_9","text":"please upgrade your dependency requirement for \u201cconstructs\u201d to ^2.0.0","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG/#bug-fixes_21","text":"gh_actions: fix release-next script to use correct npx publishing ( 27c7f9d ) readme: hello example link is broken #74 ( 0b858cf ) upgrade jsii & constructs ( #80 ) ( f917e0a )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0160-2020-03-17","text":"","title":"0.16.0 (2020-03-17)"},{"location":"project/CHANGELOG/#features_26","text":"cli: cdk8s import crd.yaml ( #70 ) ( 5d1c278 ), closes #27","title":"Features"},{"location":"project/CHANGELOG/#0151-2020-03-13","text":"","title":"0.15.1 (2020-03-13)"},{"location":"project/CHANGELOG/#bug-fixes_22","text":"cli-init: install \u201cconstructs\u201d instead of \u201c@aws-cdk/core\u201d ( 6ccc03f )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0150-2020-03-12","text":"","title":"0.15.0 (2020-03-12)"},{"location":"project/CHANGELOG/#features_27","text":"default chart namespaces ( #68 ) ( 36b9ff1 ) peer-depend on \u201cconstructs\u201d instead of \u201c@aws-cdk/core\u201d ( #66 ) ( c336c95 ) sort keys of ApiObject manifests ( #67 ) ( 1fe89bd ), closes #17","title":"Features"},{"location":"project/CHANGELOG/#0140-2020-03-10","text":"","title":"0.14.0 (2020-03-10)"},{"location":"project/CHANGELOG/#features_28","text":"allow arbitrary construct names ( #64 ) ( 1309960 ), closes #48 chart.toJson() and apiObject.toJson() ( #63 ) ( 80e8402 ), closes #48","title":"Features"},{"location":"project/CHANGELOG/#0131-2020-03-09","text":"","title":"0.13.1 (2020-03-09)"},{"location":"project/CHANGELOG/#bug-fixes_23","text":"cli: init could not find a version that matches cdk8s0-13-0 ( e1267f6 )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0130-2020-03-09","text":"This release adds Python support for cdk8s and includes; - The cdk8s library is released to PyPI - cdk8s init python-app creates new Python apps - cdk8s import generates python classes for Kubernetes API objects","title":"0.13.0 (2020-03-09)"},{"location":"project/CHANGELOG/#breaking-changes_10","text":"cli: cdk8s import now generates a single file with all types, which means you will have to modify TypeScript code to import { Deployment, Pod, ... } from './imports/k8s' instead of importing multiple files. cli: cdk8s gen is now cdk8s import k8s and output goes to imports/k8s.ts instead of .gen/index.ts .","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG/#features_29","text":"cli: \u201ccdk8s gen\u201d is now \u201ccdk8s import k8s\u201d ( #43 ) ( fb9e0b5 ), closes #31 #40 cli: \u201ccdk8s synth\u201d ( #44 ) ( d457ea9 ), closes #41 cli: cdk8s.yaml ( #52 ) ( e6834d3 ), closes #42 cli: import only one class for every api object ( #39 ) ( 2db4cfb ) cli: python project template ( #36 ) ( 30f3bb7 ) cli: python support for \u201cimport\u201d ( #47 ) ( 3b93d64 ) cli: typescript project - \u201cnpm run upgrade\u201d & \u201cupgrade:next\u201d ( 735e840 ) cli: typescript project - \u201cnpm run build\u201d now includes \u201csynth\u201d ( 7b15e3a ) docs: getting started in python ( #60 ) ( 27d3bac ) examples: updates to hello-world example and directory reorganization ( #33 ) ( 1c8f694 )","title":"Features"},{"location":"project/CHANGELOG/#bug-fixes_24","text":"cli: new typescript apps cannot be created with @next versions ( #55 ) ( 119d95c )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0120-2020-03-03","text":"","title":"0.12.0 (2020-03-03)"},{"location":"project/CHANGELOG/#bug-fixes_25","text":"yaml not found in jsii languages ( 39ef409 )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0110-2020-03-03","text":"","title":"0.11.0 (2020-03-03)"},{"location":"project/CHANGELOG/#bug-fixes_26","text":"yaml not found in jsii languages ( 39ef409 )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#0100-2020-02-28","text":"","title":"0.10.0 (2020-02-28)"},{"location":"project/CHANGELOG/#bug-fixes_27","text":"cdk8s: autogenerated names fail validation for some resource types ( #18 ) ( b70e4fe ), closes #16","title":"Bug Fixes"},{"location":"project/CHANGELOG/#090-2020-02-27","text":"","title":"0.9.0 (2020-02-27)"},{"location":"project/CHANGELOG/#features_30","text":"cdk8s: the App root construct ( #15 ) ( c595240 )","title":"Features"},{"location":"project/CHANGELOG/#080-2020-02-27","text":"","title":"0.8.0 (2020-02-27)"},{"location":"project/CHANGELOG/#features_31","text":"cli: remove the cookiecutter prerequisite ( #13 ) ( 10ab259 )","title":"Features"},{"location":"project/CHANGELOG/#070-2020-02-26","text":"","title":"0.7.0 (2020-02-26)"},{"location":"project/CHANGELOG/#bug-fixes_28","text":"cli: typescript-app does not include main.ts ( 43b435a )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#060-2020-02-26","text":"","title":"0.6.0 (2020-02-26)"},{"location":"project/CHANGELOG/#bug-fixes_29","text":"cli does not work when used from a symlink ( #11 ) ( 4bd3a37 )","title":"Bug Fixes"},{"location":"project/CHANGELOG/#050-2020-02-26","text":"","title":"0.5.0 (2020-02-26)"},{"location":"project/CHANGELOG/#features_32","text":"cli: project templates with \u201ccdk8s init\u201d ( #10 ) ( 4aa59d9 ) cookiecutter template for typescript app projects ( #9 ) ( 55087e2 )","title":"Features"},{"location":"project/CHANGELOG/#040-2020-02-23","text":"","title":"0.4.0 (2020-02-23)"},{"location":"project/CHANGELOG/#features_33","text":"podinfo: allow containers to bind to deployment ( 45237c0 )","title":"Features"},{"location":"project/CHANGELOG/#030-2020-02-23","text":"","title":"0.3.0 (2020-02-23)"},{"location":"project/CHANGELOG/#features_34","text":"chart.generateObjectName ( 03a1d26 ) Chart.of(node) ( d6a9dc0 )","title":"Features"},{"location":"project/CHANGELOG/#012-2020-02-12","text":"","title":"0.1.2 (2020-02-12)"},{"location":"project/CHANGELOG/#features_35","text":"getting started documentation ( 2616372 )","title":"Features"},{"location":"project/CONTRIBUTING/","text":"Contribution Guide \u00b6 cdk8s is licensed under Apache 2.0 and accepts contributions via GitHub pull requests. This document outlines some of the conventions on commit message formatting, contact points for developers, and other resources to help get contributions into cdk8s. You can contribute to cdk8s in many ways. Contributions of all shapes and sizes are welcome and celebrated: Reporting Issues Code Contributions RFCs For Maintainers We follows the CNCF Community Code of Conduct Reporting Issues \u00b6 If any part of the project has bugs or documentation mistakes, please let us know by raising an issue . We treat bugs and mistakes very seriously and believe no issue is too small. Before creating a bug report, please check that an issue reporting the same problem does not already exist. An issue can either be a bug report or a suggestion . If you wish to ask a question or seek guidance, please consider one of the other support channels . Bug reports \u00b6 To make the bug report accurate and easy to understand, please try to create bug reports that are: Specific : Include as much details as possible: which version, what environment, what configuration, etc. Reproducible : Include the steps to reproduce the problem. We understand some issues might be hard to reproduce, please includes the steps that might lead to the problem. If possible, please provide a minimal code snippet that reproduces the bug. Isolated : Please try to isolate and reproduce the bug with minimum dependencies. It would significantly slow down the speed to fix a bug if too many dependencies are involved in a bug report. Unique : Do not duplicate existing bug report. Scoped : One bug per report. Do not follow up with another bug inside one report. We might ask for further information to locate a bug. A duplicated bug report will be closed. Submit a bug report here . Suggestions \u00b6 We also accept suggestions for new features or missing capabilities as GitHub issues. The most important aspect of a suggestion issue is to provide as many details as possible about your use case and less focus on the solution. It is usually possible to support different use cases in many different ways, and we need to understand the motivation before we dive into a solution. If you wish to suggest a major change to the project, please consider to submit an RFC instead of a simple issue. An RFC also starts with a GitHub issue. Submit a suggestion here Code Contributions \u00b6 The general workflow for code contributions: Submit/find an issue in this repository Clone the relevant repo Make your code change Write tests & update docs Build & test locally Submit a pull request (Iterate) Your PR will be approved and merged Tracking issue \u00b6 All pull requests should be tracked with a GitHub issue. You should search for an existing issue or raise a new bug or suggestion . Add a comment indicating you are willing to pick it up in order to ensure no one else is currently working on it. If this is a major contribution, consider submitting an RFC to obtain feedback from the community and maintainers. Repositories \u00b6 This project consists of multiple modules, maintained and released via the following repositories: cdk8s-cli : command-line interface cdk8s-core : core library cdk8s-plus-17 : high-level constructs for Kubernetes core 1.17 and above. Development environment \u00b6 Prerequisites: Node.js >= 12.14.0 yarn >= 1.22.0 Prepare your environment: Fork the relevant repo and obtain a local clone. Install all dependencies: yarn install Run yarn build to build all modules. Unit tests \u00b6 Unit tests are located under the test/ directory within each module and use the jest framework. To run unit tests, execute yarn test either from the root of the repo (to unit test all modules) or from individual module directories: yarn test Out tests utilize jest snapshot testing . In case a snapshot needs to be updated, just run: yarn test -u Integration Tests \u00b6 Integration tests are executed against the latest published modules . This means that in order to execute integration tests against a development version, you\u2019lol need to yarn link your local version to this repository (all deps are at the root): $ cd cdk8s-core $ yarn link $ cd ../cdk8s $ yarn link cdk8s Now, you can run integration tests via: yarn integ Our integration tests also utilize snapshot testing. To update integration test snapshots, run: yarn integ:update Running Integration Tests \u00b6 The test directory contains integration tests for the cdk8s project. Each subdirectory represents a single test, with an entrypoint of test.sh . Tests are written as simple shell scripts and can simulate user activity. You can either run individual tests by executing their entrypoint directly (e.g. test-python-app/test.sh ) or run all tests by executing the script ./test-all.sh . Writing Integration Tests \u00b6 Create a new subdirectory with a test- prefix. Create a file named test.sh , make it executable. Test Environment: The script test.sh is executed within a temporary working directory under /tmp/xxxx/test (where xxxx is some random tmp file). See existing tests as examples on how to bring in auxiliary files to the test. Test MUST NOT install any dependencies or the cdk8s CLI. They can expect it to be available in the environment. To install dependencies from package managers, use yarn , npm , pipenv , mvn and nuget . Those programs will be shimmed to allow consuming local dependencies. Snapshot Testing \u00b6 Some integration tests utilize a simple snapshot testing mechanism. To update snapshots, run tests with: UPDATE_SNAPSHOTS=1 Or, run this from the root of the repo: yarn integ:update Docker environment for integration tests \u00b6 Due to the polyglot nature of the jsii tools used by cdk8s, the toolchain requirements are somewhat more complicated than for most projects. To help with this, you can use the jsii/superchain docker image that includes all the required tools. In order to get an interactive shell within a superchain container you can use the following command. docker run --rm --net=host -it -v $PWD:$PWD -w $PWD jsii/superchain Then once in the docker shell, you can package and execute the tests as normal. $ pip install pipenv # Currently not included in jsii docker image $ yarn build $ yarn run package $ yarn integ:update Note: this may leave some files owned as the docker root user id. These will need to be cleaned up manually. Pull Requests \u00b6 We use the PR title when we automatically generate the change log for each release. Therefore please following these guidelines to the letter: PR title : Must adhere to conventional commits . All lowercase with no period at the end of the title If this is a fix (bug) the title should describe the bug If this is a feat (feature) the title should describe the feature PR description : Describe how did you fix the bug or what changes you had to make in order to implement the feature Indicate fixes #NNN or resolves #NNN with the tracking issue number. If you had to test your change manually, describe how you tested it and paste the test results. If this is a breaking change, the last paragraph should describe the breaking change with the prefix BREAKING CHANGE: xxxxxx . Documentation \u00b6 Documentation is rendered from markdown using mkdocs-material and sourced from the docs directory. API documentation for cdk8s and all cdk8s-plus-* packages is auto-generated from inline docstrings during build. To test locally, install python3 deps: $ pip3 install -r docs/requirements.txt And then: $ mkdocs serve This will serve a local web server with the website. A good reference for syntax and capabilities is the mkdocs-material website. Examples \u00b6 Examples are stored under examples and organized according to programming language. Every example also has an entry under docs/examples/xxx which describes the example and includes links to the source code (on the main branch). RFCs \u00b6 An RFC (request for comments) is a document that proposes and details a change or addition to cdk8s. It also is a process for reviewing and discussing the proposal and tracking its implementation. \u201cRequest for comments\u201d means a request for discussion and oversight about the future of cdk8s from contributors and users. It is an open forum for suggestions, questions, and feedback. To create an RFC follow this process: Create an issue which will be the tracking issue for this RFC. Title should represent the title of the RFC. Description should provide the motivation for the RFC. Create a markdown file based off of rfc/0000-template.md under the rfc/<nnnn>-<title-of-rfc> where <nnnn> is the tracking issue number and <title-of-rfc> is a symbolic name for the title. For example: rfc/0030-construct-operators.md . File a pull request with this markdown file. The title of the PR should indicate rfc: <nnnn> <same as issue title> . The RFC will be reviewed as a pull request and once merged it means it is ready for implementation. Community Meeting \u00b6 Join us for the CDK8s community meeting which takes place the 2nd Monday of the month at 9:00am Pacific Time . Meeting link: https://chime.aws/7929414778 Agenda For Maintainers \u00b6 This section includes information that is relevant for the maintainers of the project. Version \u00b6 The current version of the project is mastered in the root lerna.json file. All other package.json files use 0.0.0 . This allows bumping a new version without needing to modify multiple files and avoid merge conflicts in post-release rebases. Release Protocol \u00b6 To release a new version of cdk8s following these steps: $ yarn bump This will create a new CHANGELOG entry (from conventional commits), bump the version in package.json and create a bump commit. Now, push to master (in the future we will release from a release branch, but in the meantime we release directly from master): $ git push origin master This will trigger the release workflow which will release to all package managers and will also create a GitHub release with a tag. Portions of this guide were adopted from the contribution guides of the AWS CDK and etcd .","title":"Contribution Guide"},{"location":"project/CONTRIBUTING/#contribution-guide","text":"cdk8s is licensed under Apache 2.0 and accepts contributions via GitHub pull requests. This document outlines some of the conventions on commit message formatting, contact points for developers, and other resources to help get contributions into cdk8s. You can contribute to cdk8s in many ways. Contributions of all shapes and sizes are welcome and celebrated: Reporting Issues Code Contributions RFCs For Maintainers We follows the CNCF Community Code of Conduct","title":"Contribution Guide"},{"location":"project/CONTRIBUTING/#reporting-issues","text":"If any part of the project has bugs or documentation mistakes, please let us know by raising an issue . We treat bugs and mistakes very seriously and believe no issue is too small. Before creating a bug report, please check that an issue reporting the same problem does not already exist. An issue can either be a bug report or a suggestion . If you wish to ask a question or seek guidance, please consider one of the other support channels .","title":"Reporting Issues"},{"location":"project/CONTRIBUTING/#bug-reports","text":"To make the bug report accurate and easy to understand, please try to create bug reports that are: Specific : Include as much details as possible: which version, what environment, what configuration, etc. Reproducible : Include the steps to reproduce the problem. We understand some issues might be hard to reproduce, please includes the steps that might lead to the problem. If possible, please provide a minimal code snippet that reproduces the bug. Isolated : Please try to isolate and reproduce the bug with minimum dependencies. It would significantly slow down the speed to fix a bug if too many dependencies are involved in a bug report. Unique : Do not duplicate existing bug report. Scoped : One bug per report. Do not follow up with another bug inside one report. We might ask for further information to locate a bug. A duplicated bug report will be closed. Submit a bug report here .","title":"Bug reports"},{"location":"project/CONTRIBUTING/#suggestions","text":"We also accept suggestions for new features or missing capabilities as GitHub issues. The most important aspect of a suggestion issue is to provide as many details as possible about your use case and less focus on the solution. It is usually possible to support different use cases in many different ways, and we need to understand the motivation before we dive into a solution. If you wish to suggest a major change to the project, please consider to submit an RFC instead of a simple issue. An RFC also starts with a GitHub issue. Submit a suggestion here","title":"Suggestions"},{"location":"project/CONTRIBUTING/#code-contributions","text":"The general workflow for code contributions: Submit/find an issue in this repository Clone the relevant repo Make your code change Write tests & update docs Build & test locally Submit a pull request (Iterate) Your PR will be approved and merged","title":"Code Contributions"},{"location":"project/CONTRIBUTING/#tracking-issue","text":"All pull requests should be tracked with a GitHub issue. You should search for an existing issue or raise a new bug or suggestion . Add a comment indicating you are willing to pick it up in order to ensure no one else is currently working on it. If this is a major contribution, consider submitting an RFC to obtain feedback from the community and maintainers.","title":"Tracking issue"},{"location":"project/CONTRIBUTING/#repositories","text":"This project consists of multiple modules, maintained and released via the following repositories: cdk8s-cli : command-line interface cdk8s-core : core library cdk8s-plus-17 : high-level constructs for Kubernetes core 1.17 and above.","title":"Repositories"},{"location":"project/CONTRIBUTING/#development-environment","text":"Prerequisites: Node.js >= 12.14.0 yarn >= 1.22.0 Prepare your environment: Fork the relevant repo and obtain a local clone. Install all dependencies: yarn install Run yarn build to build all modules.","title":"Development environment"},{"location":"project/CONTRIBUTING/#unit-tests","text":"Unit tests are located under the test/ directory within each module and use the jest framework. To run unit tests, execute yarn test either from the root of the repo (to unit test all modules) or from individual module directories: yarn test Out tests utilize jest snapshot testing . In case a snapshot needs to be updated, just run: yarn test -u","title":"Unit tests"},{"location":"project/CONTRIBUTING/#integration-tests","text":"Integration tests are executed against the latest published modules . This means that in order to execute integration tests against a development version, you\u2019lol need to yarn link your local version to this repository (all deps are at the root): $ cd cdk8s-core $ yarn link $ cd ../cdk8s $ yarn link cdk8s Now, you can run integration tests via: yarn integ Our integration tests also utilize snapshot testing. To update integration test snapshots, run: yarn integ:update","title":"Integration Tests"},{"location":"project/CONTRIBUTING/#pull-requests","text":"We use the PR title when we automatically generate the change log for each release. Therefore please following these guidelines to the letter: PR title : Must adhere to conventional commits . All lowercase with no period at the end of the title If this is a fix (bug) the title should describe the bug If this is a feat (feature) the title should describe the feature PR description : Describe how did you fix the bug or what changes you had to make in order to implement the feature Indicate fixes #NNN or resolves #NNN with the tracking issue number. If you had to test your change manually, describe how you tested it and paste the test results. If this is a breaking change, the last paragraph should describe the breaking change with the prefix BREAKING CHANGE: xxxxxx .","title":"Pull Requests"},{"location":"project/CONTRIBUTING/#documentation","text":"Documentation is rendered from markdown using mkdocs-material and sourced from the docs directory. API documentation for cdk8s and all cdk8s-plus-* packages is auto-generated from inline docstrings during build. To test locally, install python3 deps: $ pip3 install -r docs/requirements.txt And then: $ mkdocs serve This will serve a local web server with the website. A good reference for syntax and capabilities is the mkdocs-material website.","title":"Documentation"},{"location":"project/CONTRIBUTING/#examples","text":"Examples are stored under examples and organized according to programming language. Every example also has an entry under docs/examples/xxx which describes the example and includes links to the source code (on the main branch).","title":"Examples"},{"location":"project/CONTRIBUTING/#rfcs","text":"An RFC (request for comments) is a document that proposes and details a change or addition to cdk8s. It also is a process for reviewing and discussing the proposal and tracking its implementation. \u201cRequest for comments\u201d means a request for discussion and oversight about the future of cdk8s from contributors and users. It is an open forum for suggestions, questions, and feedback. To create an RFC follow this process: Create an issue which will be the tracking issue for this RFC. Title should represent the title of the RFC. Description should provide the motivation for the RFC. Create a markdown file based off of rfc/0000-template.md under the rfc/<nnnn>-<title-of-rfc> where <nnnn> is the tracking issue number and <title-of-rfc> is a symbolic name for the title. For example: rfc/0030-construct-operators.md . File a pull request with this markdown file. The title of the PR should indicate rfc: <nnnn> <same as issue title> . The RFC will be reviewed as a pull request and once merged it means it is ready for implementation.","title":"RFCs"},{"location":"project/CONTRIBUTING/#community-meeting","text":"Join us for the CDK8s community meeting which takes place the 2nd Monday of the month at 9:00am Pacific Time . Meeting link: https://chime.aws/7929414778 Agenda","title":"Community Meeting"},{"location":"project/CONTRIBUTING/#for-maintainers","text":"This section includes information that is relevant for the maintainers of the project.","title":"For Maintainers"},{"location":"project/CONTRIBUTING/#version","text":"The current version of the project is mastered in the root lerna.json file. All other package.json files use 0.0.0 . This allows bumping a new version without needing to modify multiple files and avoid merge conflicts in post-release rebases.","title":"Version"},{"location":"project/CONTRIBUTING/#release-protocol","text":"To release a new version of cdk8s following these steps: $ yarn bump This will create a new CHANGELOG entry (from conventional commits), bump the version in package.json and create a bump commit. Now, push to master (in the future we will release from a release branch, but in the meantime we release directly from master): $ git push origin master This will trigger the release workflow which will release to all package managers and will also create a GitHub release with a tag. Portions of this guide were adopted from the contribution guides of the AWS CDK and etcd .","title":"Release Protocol"},{"location":"project/ROADMAP/","text":"Roadmap \u00b6 cdk8s is in alpha. To see items we are working on, visit the roadmap . You can submit an idea here .","title":"Roadmap"},{"location":"project/ROADMAP/#roadmap","text":"cdk8s is in alpha. To see items we are working on, visit the roadmap . You can submit an idea here .","title":"Roadmap"},{"location":"reference/","text":"Overview \u00b6 This section includes API reference for the various components of CDK8s: cdk8s : Core library TypeScript Python Go cdk8s-plus-17 : Intent-based APIs for Kubernetes resources. (spec version 1.17.0 ) TypeScript Python Go","title":"Overview"},{"location":"reference/#overview","text":"This section includes API reference for the various components of CDK8s: cdk8s : Core library TypeScript Python Go cdk8s-plus-17 : Intent-based APIs for Kubernetes resources. (spec version 1.17.0 ) TypeScript Python Go","title":"Overview"},{"location":"reference/cdk8s/go/","text":"cdk8s (Go) \u00b6 For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-core-go/cdk8s .","title":"Go"},{"location":"reference/cdk8s/go/#cdk8s-go","text":"For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-core-go/cdk8s .","title":"cdk8s (Go) "},{"location":"reference/cdk8s/python/","text":"cdk8s (Python) \u00b6 Constructs \u00b6 ApiObject \u00b6 Initializer \u00b6 import cdk8s cdk8s . ApiObject ( scope : Construct , id : str , api_version : str , kind : str , metadata : ApiObjectMetadata = None ) scope Required \u00b6 Type: constructs.Construct the construct scope. id Required \u00b6 Type: str namespace. api_version Required \u00b6 Type: str API version. kind Required \u00b6 Type: str Resource kind. metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. Methods \u00b6 add_dependency \u00b6 def add_dependency ( dependencies : IConstruct ) dependencies Required \u00b6 Type: constructs.IConstruct the dependencies to add. add_json_patch \u00b6 def add_json_patch ( ops : JsonPatch ) ops Required \u00b6 Type: cdk8s.JsonPatch The JSON-Patch operations to apply. to_json \u00b6 def to_json () Static Functions \u00b6 of \u00b6 import cdk8s cdk8s . ApiObject . of ( c : IConstruct ) c Required \u00b6 Type: constructs.IConstruct The higher-level construct. Properties \u00b6 api_group Required \u00b6 Type: str The group portion of the API version (e.g. authorization.k8s.io ). api_version Required \u00b6 Type: str The object\u2019s API version (e.g. authorization.k8s.io/v1 ). chart Required \u00b6 Type: cdk8s.Chart The chart in which this object is defined. kind Required \u00b6 Type: str The object kind. metadata Required \u00b6 Type: cdk8s.ApiObjectMetadataDefinition Metadata associated with this API object. name Required \u00b6 Type: str The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. App \u00b6 Represents a cdk8s application. Initializer \u00b6 import cdk8s cdk8s . App ( outdir : str = None , yaml_output_type : YamlOutputType = None ) outdir Optional \u00b6 Type: str Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. yaml_output_type Optional \u00b6 Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Methods \u00b6 synth \u00b6 def synth () Properties \u00b6 outdir Required \u00b6 Type: str The output directory into which manifests will be synthesized. yaml_output_type Required \u00b6 Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Chart \u00b6 Initializer \u00b6 import cdk8s cdk8s . Chart ( scope : Construct , id : str , labels : typing . Mapping [ str ] = None , namespace : str = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str labels Optional \u00b6 Type: typing.Mapping[ str ] Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 Type: str Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. Methods \u00b6 add_dependency \u00b6 def add_dependency ( dependencies : IConstruct ) dependencies Required \u00b6 Type: constructs.IConstruct the dependencies to add. generate_object_name \u00b6 def generate_object_name ( api_object : ApiObject ) api_object Required \u00b6 Type: cdk8s.ApiObject The API object to generate a name for. to_json \u00b6 def to_json () Static Functions \u00b6 of \u00b6 import cdk8s cdk8s . Chart . of ( c : IConstruct ) c Required \u00b6 Type: constructs.IConstruct a construct node. Properties \u00b6 labels Required \u00b6 Type: typing.Mapping[ str ] Labels applied to all resources in this chart. This is an immutable copy. namespace Optional \u00b6 Type: str The default namespace for all objects in this chart. Helm \u00b6 Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs. Initializer \u00b6 import cdk8s cdk8s . Helm ( scope : Construct , id : str , chart : str , helm_executable : str = None , helm_flags : typing . List [ str ] = None , release_name : str = None , values : typing . Mapping [ typing . Any ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str chart Required \u00b6 Type: str The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helm_executable Optional \u00b6 Type: str Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helm_flags Optional \u00b6 Type: typing.List[ str ] Default: [] Additional flags to add to the helm execution. release_name Optional \u00b6 Type: str Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 Type: typing.Mapping[ typing.Any ] Default: If no values are specified, chart will use the defaults. Values to pass to the chart. Properties \u00b6 release_name Required \u00b6 Type: str The helm release name. Include \u00b6 Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest. Initializer \u00b6 import cdk8s cdk8s . Include ( scope : Construct , id : str , url : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str url Required \u00b6 Type: str Local file path or URL which includes a Kubernetes YAML manifest. Properties \u00b6 api_objects Required \u00b6 Type: typing.List[ cdk8s.ApiObject ] Returns all the included API objects. Structs \u00b6 ApiObjectMetadata \u00b6 Metadata associated with this object. Initializer \u00b6 import cdk8s cdk8s . ApiObjectMetadata ( annotations : typing . Mapping [ str ] = None , labels : typing . Mapping [ str ] = None , name : str = None , namespace : str = None ) annotations Optional \u00b6 Type: typing.Mapping[ str ] Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations labels Optional \u00b6 Type: typing.Mapping[ str ] Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 Type: str Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 Type: str Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces ApiObjectProps \u00b6 Options for defining API objects. Initializer \u00b6 import cdk8s cdk8s . ApiObjectProps ( api_version : str , kind : str , metadata : ApiObjectMetadata = None ) api_version Required \u00b6 Type: str API version. kind Required \u00b6 Type: str Resource kind. metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. AppProps \u00b6 Initializer \u00b6 import cdk8s cdk8s . AppProps ( outdir : str = None , yaml_output_type : YamlOutputType = None ) outdir Optional \u00b6 Type: str Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. yaml_output_type Optional \u00b6 Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. ChartProps \u00b6 Initializer \u00b6 import cdk8s cdk8s . ChartProps ( labels : typing . Mapping [ str ] = None , namespace : str = None ) labels Optional \u00b6 Type: typing.Mapping[ str ] Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 Type: str Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. GroupVersionKind \u00b6 Initializer \u00b6 import cdk8s cdk8s . GroupVersionKind ( api_version : str , kind : str ) api_version Required \u00b6 Type: str The object\u2019s API version (e.g. authorization.k8s.io/v1 ). kind Required \u00b6 Type: str The object kind. HelmProps \u00b6 Options for Helm . Initializer \u00b6 import cdk8s cdk8s . HelmProps ( chart : str , helm_executable : str = None , helm_flags : typing . List [ str ] = None , release_name : str = None , values : typing . Mapping [ typing . Any ] = None ) chart Required \u00b6 Type: str The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helm_executable Optional \u00b6 Type: str Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helm_flags Optional \u00b6 Type: typing.List[ str ] Default: [] Additional flags to add to the helm execution. release_name Optional \u00b6 Type: str Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 Type: typing.Mapping[ typing.Any ] Default: If no values are specified, chart will use the defaults. Values to pass to the chart. IncludeProps \u00b6 Initializer \u00b6 import cdk8s cdk8s . IncludeProps ( url : str ) url Required \u00b6 Type: str Local file path or URL which includes a Kubernetes YAML manifest. NameOptions \u00b6 Options for name generation. Initializer \u00b6 import cdk8s cdk8s . NameOptions ( delimiter : str = None , extra : typing . List [ str ] = None , include_hash : bool = None , max_len : typing . Union [ int , float ] = None ) delimiter Optional \u00b6 Type: str Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 Type: typing.List[ str ] Default: [] use the construct path components Extra components to include in the name. include_hash Optional \u00b6 Type: bool Default: true Include a short hash as last part of the name. max_len Optional \u00b6 Type: typing.Union[int, float] Default: 63 Maximum allowed length for the name. SizeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import cdk8s cdk8s . SizeConversionOptions ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. TimeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import cdk8s cdk8s . TimeConversionOptions ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Classes \u00b6 ApiObjectMetadataDefinition \u00b6 Object metadata. Initializer \u00b6 import cdk8s cdk8s . ApiObjectMetadataDefinition ( annotations : typing . Mapping [ str ] = None , labels : typing . Mapping [ str ] = None , name : str = None , namespace : str = None ) annotations Optional \u00b6 Type: typing.Mapping[ str ] Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations labels Optional \u00b6 Type: typing.Mapping[ str ] Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 Type: str Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 Type: str Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces Methods \u00b6 add \u00b6 def add ( key : str , value : typing . Any ) key Required \u00b6 Type: str Metadata key. value Required \u00b6 Type: typing.Any Metadata value. add_annotation \u00b6 def add_annotation ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_label \u00b6 def add_label ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. get_label \u00b6 def get_label ( key : str ) key Required \u00b6 Type: str the label. to_json \u00b6 def to_json () Properties \u00b6 name Optional \u00b6 Type: str The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. namespace Optional \u00b6 Type: str The object\u2019s namespace. DependencyGraph \u00b6 Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph. Initializer \u00b6 import cdk8s cdk8s . DependencyGraph ( node : Node ) node Required \u00b6 Type: constructs.Node Methods \u00b6 topology \u00b6 def topology () Properties \u00b6 root Required \u00b6 Type: cdk8s.DependencyVertex Returns the root of the graph. Note that this vertex will always have null as its .value since it is an artifical root that binds all the connected spaces of the graph. DependencyVertex \u00b6 Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter. Initializer \u00b6 import cdk8s cdk8s . DependencyVertex ( value : IConstruct = None ) value Optional \u00b6 Type: constructs.IConstruct Methods \u00b6 add_child \u00b6 def add_child ( dep : DependencyVertex ) dep Required \u00b6 Type: cdk8s.DependencyVertex The dependency. topology \u00b6 def topology () Properties \u00b6 inbound Required \u00b6 Type: typing.List[ cdk8s.DependencyVertex ] Returns the parents of the vertex (i.e dependants). outbound Required \u00b6 Type: typing.List[ cdk8s.DependencyVertex ] Returns the children of the vertex (i.e dependencies). value Optional \u00b6 Type: constructs.IConstruct Returns the IConstruct this graph vertex represents. null in case this is the root of the graph. Duration \u00b6 Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. Methods \u00b6 to_days \u00b6 def to_days ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. to_hours \u00b6 def to_hours ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. to_human_string \u00b6 def to_human_string () to_iso_string \u00b6 def to_iso_string () to_milliseconds \u00b6 def to_milliseconds ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. to_minutes \u00b6 def to_minutes ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. to_seconds \u00b6 def to_seconds ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Static Functions \u00b6 days \u00b6 import cdk8s cdk8s . Duration . days ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Days the Duration will represent. hours \u00b6 import cdk8s cdk8s . Duration . hours ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Hours the Duration will represent. millis \u00b6 import cdk8s cdk8s . Duration . millis ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Milliseconds the Duration will represent. minutes \u00b6 import cdk8s cdk8s . Duration . minutes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Minutes the Duration will represent. parse \u00b6 import cdk8s cdk8s . Duration . parse ( duration : str ) duration Required \u00b6 Type: str an ISO-formtted duration to be parsed. seconds \u00b6 import cdk8s cdk8s . Duration . seconds ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Seconds the Duration will represent. JsonPatch \u00b6 Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc. Static Functions \u00b6 add \u00b6 import cdk8s cdk8s . JsonPatch . add ( path : str , value : typing . Any ) path Required \u00b6 Type: str value Required \u00b6 Type: typing.Any apply \u00b6 import cdk8s cdk8s . JsonPatch . apply ( document : typing . Any , ops : JsonPatch ) document Required \u00b6 Type: typing.Any The document to patch. ops Required \u00b6 Type: cdk8s.JsonPatch The operations to apply. copy \u00b6 import cdk8s cdk8s . JsonPatch . copy ( from : str , path : str ) from Required \u00b6 Type: str path Required \u00b6 Type: str move \u00b6 import cdk8s cdk8s . JsonPatch . move ( from : str , path : str ) from Required \u00b6 Type: str path Required \u00b6 Type: str remove \u00b6 import cdk8s cdk8s . JsonPatch . remove ( path : str ) path Required \u00b6 Type: str replace \u00b6 import cdk8s cdk8s . JsonPatch . replace ( path : str , value : typing . Any ) path Required \u00b6 Type: str value Required \u00b6 Type: typing.Any test \u00b6 import cdk8s cdk8s . JsonPatch . test ( path : str , value : typing . Any ) path Required \u00b6 Type: str value Required \u00b6 Type: typing.Any Lazy \u00b6 Methods \u00b6 produce \u00b6 def produce () Static Functions \u00b6 any \u00b6 import cdk8s cdk8s . Lazy . any ( producer : IAnyProducer ) producer Required \u00b6 Type: cdk8s.IAnyProducer Names \u00b6 Utilities for generating unique and stable names. Static Functions \u00b6 to_dns_label \u00b6 import cdk8s cdk8s . Names . to_dns_label ( scope : Construct , delimiter : str = None , extra : typing . List [ str ] = None , include_hash : bool = None , max_len : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct The construct for which to render the DNS label. delimiter Optional \u00b6 Type: str Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 Type: typing.List[ str ] Default: [] use the construct path components Extra components to include in the name. include_hash Optional \u00b6 Type: bool Default: true Include a short hash as last part of the name. max_len Optional \u00b6 Type: typing.Union[int, float] Default: 63 Maximum allowed length for the name. to_label_value \u00b6 import cdk8s cdk8s . Names . to_label_value ( scope : Construct , delimiter : str = None , extra : typing . List [ str ] = None , include_hash : bool = None , max_len : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct The construct for which to render the DNS label. delimiter Optional \u00b6 Type: str Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 Type: typing.List[ str ] Default: [] use the construct path components Extra components to include in the name. include_hash Optional \u00b6 Type: bool Default: true Include a short hash as last part of the name. max_len Optional \u00b6 Type: typing.Union[int, float] Default: 63 Maximum allowed length for the name. Size \u00b6 Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible. Methods \u00b6 to_gibibytes \u00b6 def to_gibibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. to_kibibytes \u00b6 def to_kibibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. to_mebibytes \u00b6 def to_mebibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. to_pebibytes \u00b6 def to_pebibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. to_tebibytes \u00b6 def to_tebibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. Static Functions \u00b6 gibibytes \u00b6 import cdk8s cdk8s . Size . gibibytes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] kibibytes \u00b6 import cdk8s cdk8s . Size . kibibytes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] mebibytes \u00b6 import cdk8s cdk8s . Size . mebibytes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] pebibyte \u00b6 import cdk8s cdk8s . Size . pebibyte ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] tebibytes \u00b6 import cdk8s cdk8s . Size . tebibytes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] Testing \u00b6 Testing utilities for cdk8s applications. Static Functions \u00b6 app \u00b6 import cdk8s cdk8s . Testing . app ( outdir : str = None , yaml_output_type : YamlOutputType = None ) outdir Optional \u00b6 Type: str Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. yaml_output_type Optional \u00b6 Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. chart \u00b6 import cdk8s cdk8s . Testing . chart () synth \u00b6 import cdk8s cdk8s . Testing . synth ( chart : Chart ) chart Required \u00b6 Type: cdk8s.Chart Yaml \u00b6 YAML utilities. Static Functions \u00b6 load \u00b6 import cdk8s cdk8s . Yaml . load ( url_or_file : str ) url_or_file Required \u00b6 Type: str a URL of a file path to load from. save \u00b6 import cdk8s cdk8s . Yaml . save ( file_path : str , docs : typing . List [ typing . Any ] ) file_path Required \u00b6 Type: str The output path. docs Required \u00b6 Type: typing.List[ typing.Any ] The set of objects. stringify \u00b6 import cdk8s cdk8s . Yaml . stringify ( doc : typing . Any ) doc Required \u00b6 Type: typing.Any An object. tmp \u00b6 import cdk8s cdk8s . Yaml . tmp ( docs : typing . List [ typing . Any ] ) docs Required \u00b6 Type: typing.List[ typing.Any ] the set of documents to save. Protocols \u00b6 IAnyProducer \u00b6 Implemented By: cdk8s.IAnyProducer Methods \u00b6 produce \u00b6 def produce () Enums \u00b6 SizeRoundingBehavior \u00b6 Rounding behaviour when converting between units of Size . FAIL \u00b6 Fail the conversion if the result is not an integer. FLOOR \u00b6 If the result is not an integer, round it to the closest integer less than the result. NONE \u00b6 Don\u2019t round. Return even if the result is a fraction. YamlOutputType \u00b6 The method to divide YAML output into files. FILE_PER_APP \u00b6 All resources are output into a single YAML file. FILE_PER_CHART \u00b6 Resources are split into seperate files by chart. FILE_PER_RESOURCE \u00b6 Each resource is output to its own file.","title":"Python"},{"location":"reference/cdk8s/python/#cdk8s-python","text":"","title":"cdk8s (Python) "},{"location":"reference/cdk8s/python/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s/python/#apiobject","text":"","title":"ApiObject "},{"location":"reference/cdk8s/python/#app","text":"Represents a cdk8s application.","title":"App "},{"location":"reference/cdk8s/python/#chart","text":"","title":"Chart "},{"location":"reference/cdk8s/python/#helm","text":"Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs.","title":"Helm "},{"location":"reference/cdk8s/python/#include","text":"Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest.","title":"Include "},{"location":"reference/cdk8s/python/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s/python/#apiobjectmetadata","text":"Metadata associated with this object.","title":"ApiObjectMetadata "},{"location":"reference/cdk8s/python/#apiobjectprops","text":"Options for defining API objects.","title":"ApiObjectProps "},{"location":"reference/cdk8s/python/#appprops","text":"","title":"AppProps "},{"location":"reference/cdk8s/python/#chartprops","text":"","title":"ChartProps "},{"location":"reference/cdk8s/python/#groupversionkind","text":"","title":"GroupVersionKind "},{"location":"reference/cdk8s/python/#helmprops","text":"Options for Helm .","title":"HelmProps "},{"location":"reference/cdk8s/python/#includeprops","text":"","title":"IncludeProps "},{"location":"reference/cdk8s/python/#nameoptions","text":"Options for name generation.","title":"NameOptions "},{"location":"reference/cdk8s/python/#sizeconversionoptions","text":"Options for how to convert time to a different unit.","title":"SizeConversionOptions "},{"location":"reference/cdk8s/python/#timeconversionoptions","text":"Options for how to convert time to a different unit.","title":"TimeConversionOptions "},{"location":"reference/cdk8s/python/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s/python/#apiobjectmetadatadefinition","text":"Object metadata.","title":"ApiObjectMetadataDefinition "},{"location":"reference/cdk8s/python/#dependencygraph","text":"Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph.","title":"DependencyGraph "},{"location":"reference/cdk8s/python/#dependencyvertex","text":"Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter.","title":"DependencyVertex "},{"location":"reference/cdk8s/python/#duration","text":"Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative.","title":"Duration "},{"location":"reference/cdk8s/python/#jsonpatch","text":"Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc.","title":"JsonPatch "},{"location":"reference/cdk8s/python/#lazy","text":"","title":"Lazy "},{"location":"reference/cdk8s/python/#names","text":"Utilities for generating unique and stable names.","title":"Names "},{"location":"reference/cdk8s/python/#size","text":"Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible.","title":"Size "},{"location":"reference/cdk8s/python/#testing","text":"Testing utilities for cdk8s applications.","title":"Testing "},{"location":"reference/cdk8s/python/#yaml","text":"YAML utilities.","title":"Yaml "},{"location":"reference/cdk8s/python/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s/python/#ianyproducer","text":"Implemented By: cdk8s.IAnyProducer","title":"IAnyProducer "},{"location":"reference/cdk8s/python/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s/python/#sizeroundingbehavior","text":"Rounding behaviour when converting between units of Size .","title":"SizeRoundingBehavior "},{"location":"reference/cdk8s/python/#yamloutputtype","text":"The method to divide YAML output into files.","title":"YamlOutputType "},{"location":"reference/cdk8s/typescript/","text":"cdk8s (TypeScript) \u00b6 Constructs \u00b6 ApiObject \u00b6 Initializer \u00b6 import { ApiObject } from 'cdk8s' new ApiObject ( scope : Construct , id : string , props : ApiObjectProps ) scope Required \u00b6 Type: constructs.Construct the construct scope. id Required \u00b6 Type: string namespace. props Required \u00b6 Type: cdk8s.ApiObjectProps options. Methods \u00b6 addDependency \u00b6 public addDependency ( dependencies : IConstruct ) dependencies Required \u00b6 Type: constructs.IConstruct the dependencies to add. addJsonPatch \u00b6 public addJsonPatch ( ops : JsonPatch ) ops Required \u00b6 Type: cdk8s.JsonPatch The JSON-Patch operations to apply. toJson \u00b6 public toJson () Static Functions \u00b6 of \u00b6 import { ApiObject } from 'cdk8s' ApiObject . of ( c : IConstruct ) c Required \u00b6 Type: constructs.IConstruct The higher-level construct. Properties \u00b6 apiGroup Required \u00b6 Type: string The group portion of the API version (e.g. authorization.k8s.io ). apiVersion Required \u00b6 Type: string The object\u2019s API version (e.g. authorization.k8s.io/v1 ). chart Required \u00b6 Type: cdk8s.Chart The chart in which this object is defined. kind Required \u00b6 Type: string The object kind. metadata Required \u00b6 Type: cdk8s.ApiObjectMetadataDefinition Metadata associated with this API object. name Required \u00b6 Type: string The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. App \u00b6 Represents a cdk8s application. Initializer \u00b6 import { App } from 'cdk8s' new App ( props? : AppProps ) props Optional \u00b6 Type: cdk8s.AppProps configuration options. Methods \u00b6 synth \u00b6 public synth () Properties \u00b6 outdir Required \u00b6 Type: string The output directory into which manifests will be synthesized. yamlOutputType Required \u00b6 Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Chart \u00b6 Initializer \u00b6 import { Chart } from 'cdk8s' new Chart ( scope : Construct , id : string , props? : ChartProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s.ChartProps Methods \u00b6 addDependency \u00b6 public addDependency ( dependencies : IConstruct ) dependencies Required \u00b6 Type: constructs.IConstruct the dependencies to add. generateObjectName \u00b6 public generateObjectName ( apiObject : ApiObject ) apiObject Required \u00b6 Type: cdk8s.ApiObject The API object to generate a name for. toJson \u00b6 public toJson () Static Functions \u00b6 of \u00b6 import { Chart } from 'cdk8s' Chart . of ( c : IConstruct ) c Required \u00b6 Type: constructs.IConstruct a construct node. Properties \u00b6 labels Required \u00b6 Type: {[ key: string ]: string } Labels applied to all resources in this chart. This is an immutable copy. namespace Optional \u00b6 Type: string The default namespace for all objects in this chart. Helm \u00b6 Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs. Initializer \u00b6 import { Helm } from 'cdk8s' new Helm ( scope : Construct , id : string , props : HelmProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s.HelmProps Properties \u00b6 releaseName Required \u00b6 Type: string The helm release name. Include \u00b6 Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest. Initializer \u00b6 import { Include } from 'cdk8s' new Include ( scope : Construct , id : string , props : IncludeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s.IncludeProps Properties \u00b6 apiObjects Required \u00b6 Type: cdk8s.ApiObject [] Returns all the included API objects. Structs \u00b6 ApiObjectMetadata \u00b6 Metadata associated with this object. Initializer \u00b6 import { ApiObjectMetadata } from 'cdk8s' const apiObjectMetadata : ApiObjectMetadata = { ... } annotations Optional \u00b6 Type: {[ key: string ]: string } Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations labels Optional \u00b6 Type: {[ key: string ]: string } Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 Type: string Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 Type: string Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces ApiObjectProps \u00b6 Options for defining API objects. Initializer \u00b6 import { ApiObjectProps } from 'cdk8s' const apiObjectProps : ApiObjectProps = { ... } apiVersion Required \u00b6 Type: string API version. kind Required \u00b6 Type: string Resource kind. metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. AppProps \u00b6 Initializer \u00b6 import { AppProps } from 'cdk8s' const appProps : AppProps = { ... } outdir Optional \u00b6 Type: string Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. yamlOutputType Optional \u00b6 Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. ChartProps \u00b6 Initializer \u00b6 import { ChartProps } from 'cdk8s' const chartProps : ChartProps = { ... } labels Optional \u00b6 Type: {[ key: string ]: string } Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 Type: string Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. GroupVersionKind \u00b6 Initializer \u00b6 import { GroupVersionKind } from 'cdk8s' const groupVersionKind : GroupVersionKind = { ... } apiVersion Required \u00b6 Type: string The object\u2019s API version (e.g. authorization.k8s.io/v1 ). kind Required \u00b6 Type: string The object kind. HelmProps \u00b6 Options for Helm . Initializer \u00b6 import { HelmProps } from 'cdk8s' const helmProps : HelmProps = { ... } chart Required \u00b6 Type: string The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helmExecutable Optional \u00b6 Type: string Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helmFlags Optional \u00b6 Type: string [] Default: [] Additional flags to add to the helm execution. releaseName Optional \u00b6 Type: string Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 Type: {[ key: string ]: any } Default: If no values are specified, chart will use the defaults. Values to pass to the chart. IncludeProps \u00b6 Initializer \u00b6 import { IncludeProps } from 'cdk8s' const includeProps : IncludeProps = { ... } url Required \u00b6 Type: string Local file path or URL which includes a Kubernetes YAML manifest. NameOptions \u00b6 Options for name generation. Initializer \u00b6 import { NameOptions } from 'cdk8s' const nameOptions : NameOptions = { ... } delimiter Optional \u00b6 Type: string Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 Type: string [] Default: [] use the construct path components Extra components to include in the name. includeHash Optional \u00b6 Type: boolean Default: true Include a short hash as last part of the name. maxLen Optional \u00b6 Type: number Default: 63 Maximum allowed length for the name. SizeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import { SizeConversionOptions } from 'cdk8s' const sizeConversionOptions : SizeConversionOptions = { ... } rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. TimeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import { TimeConversionOptions } from 'cdk8s' const timeConversionOptions : TimeConversionOptions = { ... } integral Optional \u00b6 Type: boolean Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Classes \u00b6 ApiObjectMetadataDefinition \u00b6 Object metadata. Initializer \u00b6 import { ApiObjectMetadataDefinition } from 'cdk8s' new ApiObjectMetadataDefinition ( options? : ApiObjectMetadata ) options Optional \u00b6 Type: cdk8s.ApiObjectMetadata Methods \u00b6 add \u00b6 public add ( key : string , value : any ) key Required \u00b6 Type: string Metadata key. value Required \u00b6 Type: any Metadata value. addAnnotation \u00b6 public addAnnotation ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addLabel \u00b6 public addLabel ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. getLabel \u00b6 public getLabel ( key : string ) key Required \u00b6 Type: string the label. toJson \u00b6 public toJson () Properties \u00b6 name Optional \u00b6 Type: string The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. namespace Optional \u00b6 Type: string The object\u2019s namespace. DependencyGraph \u00b6 Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph. Initializer \u00b6 import { DependencyGraph } from 'cdk8s' new DependencyGraph ( node : Node ) node Required \u00b6 Type: constructs.Node Methods \u00b6 topology \u00b6 public topology () Properties \u00b6 root Required \u00b6 Type: cdk8s.DependencyVertex Returns the root of the graph. Note that this vertex will always have null as its .value since it is an artifical root that binds all the connected spaces of the graph. DependencyVertex \u00b6 Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter. Initializer \u00b6 import { DependencyVertex } from 'cdk8s' new DependencyVertex ( value? : IConstruct ) value Optional \u00b6 Type: constructs.IConstruct Methods \u00b6 addChild \u00b6 public addChild ( dep : DependencyVertex ) dep Required \u00b6 Type: cdk8s.DependencyVertex The dependency. topology \u00b6 public topology () Properties \u00b6 inbound Required \u00b6 Type: cdk8s.DependencyVertex [] Returns the parents of the vertex (i.e dependants). outbound Required \u00b6 Type: cdk8s.DependencyVertex [] Returns the children of the vertex (i.e dependencies). value Optional \u00b6 Type: constructs.IConstruct Returns the IConstruct this graph vertex represents. null in case this is the root of the graph. Duration \u00b6 Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. Methods \u00b6 toDays \u00b6 public toDays ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions toHours \u00b6 public toHours ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions toHumanString \u00b6 public toHumanString () toIsoString \u00b6 public toIsoString () toMilliseconds \u00b6 public toMilliseconds ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions toMinutes \u00b6 public toMinutes ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions toSeconds \u00b6 public toSeconds ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions Static Functions \u00b6 days \u00b6 import { Duration } from 'cdk8s' Duration . days ( amount : number ) amount Required \u00b6 Type: number the amount of Days the Duration will represent. hours \u00b6 import { Duration } from 'cdk8s' Duration . hours ( amount : number ) amount Required \u00b6 Type: number the amount of Hours the Duration will represent. millis \u00b6 import { Duration } from 'cdk8s' Duration . millis ( amount : number ) amount Required \u00b6 Type: number the amount of Milliseconds the Duration will represent. minutes \u00b6 import { Duration } from 'cdk8s' Duration . minutes ( amount : number ) amount Required \u00b6 Type: number the amount of Minutes the Duration will represent. parse \u00b6 import { Duration } from 'cdk8s' Duration . parse ( duration : string ) duration Required \u00b6 Type: string an ISO-formtted duration to be parsed. seconds \u00b6 import { Duration } from 'cdk8s' Duration . seconds ( amount : number ) amount Required \u00b6 Type: number the amount of Seconds the Duration will represent. JsonPatch \u00b6 Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc. Static Functions \u00b6 add \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . add ( path : string , value : any ) path Required \u00b6 Type: string value Required \u00b6 Type: any apply \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . apply ( document : any , ops : JsonPatch ) document Required \u00b6 Type: any The document to patch. ops Required \u00b6 Type: cdk8s.JsonPatch The operations to apply. copy \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . copy ( from : string , path : string ) from Required \u00b6 Type: string path Required \u00b6 Type: string move \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . move ( from : string , path : string ) from Required \u00b6 Type: string path Required \u00b6 Type: string remove \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . remove ( path : string ) path Required \u00b6 Type: string replace \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . replace ( path : string , value : any ) path Required \u00b6 Type: string value Required \u00b6 Type: any test \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . test ( path : string , value : any ) path Required \u00b6 Type: string value Required \u00b6 Type: any Lazy \u00b6 Methods \u00b6 produce \u00b6 public produce () Static Functions \u00b6 any \u00b6 import { Lazy } from 'cdk8s' Lazy . any ( producer : IAnyProducer ) producer Required \u00b6 Type: cdk8s.IAnyProducer Names \u00b6 Utilities for generating unique and stable names. Static Functions \u00b6 toDnsLabel \u00b6 import { Names } from 'cdk8s' Names . toDnsLabel ( scope : Construct , options? : NameOptions ) scope Required \u00b6 Type: constructs.Construct The construct for which to render the DNS label. options Optional \u00b6 Type: cdk8s.NameOptions Name options. toLabelValue \u00b6 import { Names } from 'cdk8s' Names . toLabelValue ( scope : Construct , options? : NameOptions ) scope Required \u00b6 Type: constructs.Construct The construct for which to render the DNS label. options Optional \u00b6 Type: cdk8s.NameOptions Name options. Size \u00b6 Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible. Methods \u00b6 toGibibytes \u00b6 public toGibibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions toKibibytes \u00b6 public toKibibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions toMebibytes \u00b6 public toMebibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions toPebibytes \u00b6 public toPebibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions toTebibytes \u00b6 public toTebibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions Static Functions \u00b6 gibibytes \u00b6 import { Size } from 'cdk8s' Size . gibibytes ( amount : number ) amount Required \u00b6 Type: number kibibytes \u00b6 import { Size } from 'cdk8s' Size . kibibytes ( amount : number ) amount Required \u00b6 Type: number mebibytes \u00b6 import { Size } from 'cdk8s' Size . mebibytes ( amount : number ) amount Required \u00b6 Type: number pebibyte \u00b6 import { Size } from 'cdk8s' Size . pebibyte ( amount : number ) amount Required \u00b6 Type: number tebibytes \u00b6 import { Size } from 'cdk8s' Size . tebibytes ( amount : number ) amount Required \u00b6 Type: number Testing \u00b6 Testing utilities for cdk8s applications. Static Functions \u00b6 app \u00b6 import { Testing } from 'cdk8s' Testing . app ( props? : AppProps ) props Optional \u00b6 Type: cdk8s.AppProps chart \u00b6 import { Testing } from 'cdk8s' Testing . chart () synth \u00b6 import { Testing } from 'cdk8s' Testing . synth ( chart : Chart ) chart Required \u00b6 Type: cdk8s.Chart Yaml \u00b6 YAML utilities. Static Functions \u00b6 load \u00b6 import { Yaml } from 'cdk8s' Yaml . load ( urlOrFile : string ) urlOrFile Required \u00b6 Type: string a URL of a file path to load from. save \u00b6 import { Yaml } from 'cdk8s' Yaml . save ( filePath : string , docs : any []) filePath Required \u00b6 Type: string The output path. docs Required \u00b6 Type: any [] The set of objects. stringify \u00b6 import { Yaml } from 'cdk8s' Yaml . stringify ( doc : any ) doc Required \u00b6 Type: any An object. tmp \u00b6 import { Yaml } from 'cdk8s' Yaml . tmp ( docs : any []) docs Required \u00b6 Type: any [] the set of documents to save. Protocols \u00b6 IAnyProducer \u00b6 Implemented By: cdk8s.IAnyProducer Methods \u00b6 produce \u00b6 public produce () Enums \u00b6 SizeRoundingBehavior \u00b6 Rounding behaviour when converting between units of Size . FAIL \u00b6 Fail the conversion if the result is not an integer. FLOOR \u00b6 If the result is not an integer, round it to the closest integer less than the result. NONE \u00b6 Don\u2019t round. Return even if the result is a fraction. YamlOutputType \u00b6 The method to divide YAML output into files. FILE_PER_APP \u00b6 All resources are output into a single YAML file. FILE_PER_CHART \u00b6 Resources are split into seperate files by chart. FILE_PER_RESOURCE \u00b6 Each resource is output to its own file.","title":"TypeScript"},{"location":"reference/cdk8s/typescript/#cdk8s-typescript","text":"","title":"cdk8s (TypeScript) "},{"location":"reference/cdk8s/typescript/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s/typescript/#apiobject","text":"","title":"ApiObject "},{"location":"reference/cdk8s/typescript/#app","text":"Represents a cdk8s application.","title":"App "},{"location":"reference/cdk8s/typescript/#chart","text":"","title":"Chart "},{"location":"reference/cdk8s/typescript/#helm","text":"Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs.","title":"Helm "},{"location":"reference/cdk8s/typescript/#include","text":"Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest.","title":"Include "},{"location":"reference/cdk8s/typescript/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s/typescript/#apiobjectmetadata","text":"Metadata associated with this object.","title":"ApiObjectMetadata "},{"location":"reference/cdk8s/typescript/#apiobjectprops","text":"Options for defining API objects.","title":"ApiObjectProps "},{"location":"reference/cdk8s/typescript/#appprops","text":"","title":"AppProps "},{"location":"reference/cdk8s/typescript/#chartprops","text":"","title":"ChartProps "},{"location":"reference/cdk8s/typescript/#groupversionkind","text":"","title":"GroupVersionKind "},{"location":"reference/cdk8s/typescript/#helmprops","text":"Options for Helm .","title":"HelmProps "},{"location":"reference/cdk8s/typescript/#includeprops","text":"","title":"IncludeProps "},{"location":"reference/cdk8s/typescript/#nameoptions","text":"Options for name generation.","title":"NameOptions "},{"location":"reference/cdk8s/typescript/#sizeconversionoptions","text":"Options for how to convert time to a different unit.","title":"SizeConversionOptions "},{"location":"reference/cdk8s/typescript/#timeconversionoptions","text":"Options for how to convert time to a different unit.","title":"TimeConversionOptions "},{"location":"reference/cdk8s/typescript/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s/typescript/#apiobjectmetadatadefinition","text":"Object metadata.","title":"ApiObjectMetadataDefinition "},{"location":"reference/cdk8s/typescript/#dependencygraph","text":"Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph.","title":"DependencyGraph "},{"location":"reference/cdk8s/typescript/#dependencyvertex","text":"Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter.","title":"DependencyVertex "},{"location":"reference/cdk8s/typescript/#duration","text":"Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative.","title":"Duration "},{"location":"reference/cdk8s/typescript/#jsonpatch","text":"Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc.","title":"JsonPatch "},{"location":"reference/cdk8s/typescript/#lazy","text":"","title":"Lazy "},{"location":"reference/cdk8s/typescript/#names","text":"Utilities for generating unique and stable names.","title":"Names "},{"location":"reference/cdk8s/typescript/#size","text":"Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible.","title":"Size "},{"location":"reference/cdk8s/typescript/#testing","text":"Testing utilities for cdk8s applications.","title":"Testing "},{"location":"reference/cdk8s/typescript/#yaml","text":"YAML utilities.","title":"Yaml "},{"location":"reference/cdk8s/typescript/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s/typescript/#ianyproducer","text":"Implemented By: cdk8s.IAnyProducer","title":"IAnyProducer "},{"location":"reference/cdk8s/typescript/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s/typescript/#sizeroundingbehavior","text":"Rounding behaviour when converting between units of Size .","title":"SizeRoundingBehavior "},{"location":"reference/cdk8s/typescript/#yamloutputtype","text":"The method to divide YAML output into files.","title":"YamlOutputType "},{"location":"reference/cdk8s-plus-17/go/","text":"cdk8s-plus-17 (Go) \u00b6 For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-17-go/cdk8splus17 .","title":"Go"},{"location":"reference/cdk8s-plus-17/go/#cdk8s-plus-17-go","text":"For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-17-go/cdk8splus17 .","title":"cdk8s-plus-17 (Go) "},{"location":"reference/cdk8s-plus-17/python/","text":"cdk8s-plus-17 (Python) \u00b6 Constructs \u00b6 ConfigMap \u00b6 Implements: cdk8s_plus_17.IConfigMap ConfigMap holds configuration data for pods to consume. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ConfigMap ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . Methods \u00b6 add_binary_data \u00b6 def add_binary_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_data \u00b6 def add_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_directory \u00b6 def add_directory ( local_dir : str , exclude : typing . List [ str ] = None , key_prefix : str = None ) local_dir Required \u00b6 Type: str A path to a local directory. exclude Optional \u00b6 Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. add_file \u00b6 def add_file ( local_file : str , key : str = None ) local_file Required \u00b6 Type: str The path to the local file. key Optional \u00b6 Type: str The ConfigMap key (default to the file name). Static Functions \u00b6 from_config_map_name \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ConfigMap . from_config_map_name ( name : str ) name Required \u00b6 Type: str The name of the config map to import. Properties \u00b6 binary_data Required \u00b6 Type: typing.Mapping[ str ] The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 Type: typing.Mapping[ str ] The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . Deployment \u00b6 Implements: cdk8s_plus_17.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Deployment ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , default_selector : bool = None , replicas : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. default_selector Optional \u00b6 Type: bool Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume expose \u00b6 def expose ( port : typing . Union [ int , float ], name : str = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) port Required \u00b6 Type: typing.Union[int, float] The port number the service will bind to. name Optional \u00b6 Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL protocol Optional \u00b6 Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 Type: cdk8s_plus_17.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. select_by_label \u00b6 def select_by_label ( key : str , value : str ) key Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. Properties \u00b6 containers Required \u00b6 Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. label_selector Required \u00b6 Type: typing.Mapping[ str ] The labels this deployment will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. pod_metadata Required \u00b6 Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 Type: typing.Union[int, float] Number of desired pods. volumes Required \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . IngressV1Beta1 ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , default_backend : IngressV1Beta1Backend = None , rules : typing . List [ IngressV1Beta1Rule ] = None , tls : typing . List [ IngressV1Beta1Tls ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_17.IngressV1Beta1Rule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: typing.List[ cdk8s_plus_17.IngressV1Beta1Tls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 add_default_backend \u00b6 def add_default_backend ( backend : IngressV1Beta1Backend ) backend Required \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend The backend to use for requests that do not match any rule. add_host_default_backend \u00b6 def add_host_default_backend ( host : str , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: str The host name to match. backend Required \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend The backend to route to. add_host_rule \u00b6 def add_host_rule ( host : str , path : str , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: str The host name. path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend The backend to route requests to. add_rule \u00b6 def add_rule ( path : str , backend : IngressV1Beta1Backend ) path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend The backend to route requests to. add_rules \u00b6 def add_rules ( backend : IngressV1Beta1Backend , host : str = None , path : str = None ) backend Required \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. add_tls \u00b6 def add_tls ( tls : typing . List [ IngressV1Beta1Tls ] ) tls Required \u00b6 Type: typing.List[ cdk8s_plus_17.IngressV1Beta1Tls ] Job \u00b6 Implements: cdk8s_plus_17.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Job ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. active_deadline Optional \u00b6 Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume Properties \u00b6 containers Required \u00b6 Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. pod_metadata Required \u00b6 Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Required \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. active_deadline Optional \u00b6 Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoff_limit Optional \u00b6 Type: typing.Union[int, float] Number of retries before marking failed. restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. ttl_after_finished Optional \u00b6 Type: cdk8s.Duration TTL before the job is deleted after it is finished. Pod \u00b6 Implements: cdk8s_plus_17.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Pod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume Properties \u00b6 containers Required \u00b6 Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. Resource \u00b6 Implements: cdk8s_plus_17.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Resource ( scope : Construct , id : str , node_factory : INodeFactory = None ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: str The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . node_factory Optional \u00b6 Type: constructs.INodeFactory Default: the default Node is associated A factory for attaching Node s to the construct. Properties \u00b6 metadata Required \u00b6 Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 Type: str The name of this API object. Secret \u00b6 Implements: cdk8s_plus_17.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Secret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , string_data : typing . Mapping [ str ] = None , type : str = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. string_data Optional \u00b6 Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 add_string_data \u00b6 def add_string_data ( key : str , value : str ) key Required \u00b6 Type: str Key. value Required \u00b6 Type: str Value. get_string_data \u00b6 def get_string_data ( key : str ) key Required \u00b6 Type: str Key. Static Functions \u00b6 from_secret_name \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Secret . from_secret_name ( name : str ) name Required \u00b6 Type: str The name of the secret to reference. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Service ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: cdk8s_plus_17.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 add_deployment \u00b6 def add_deployment ( deployment : Deployment , port : typing . Union [ int , float ], name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) deployment Required \u00b6 Type: cdk8s_plus_17.Deployment The deployment to expose. port Required \u00b6 Type: typing.Union[int, float] The external port. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. add_selector \u00b6 def add_selector ( label : str , value : str ) label Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. serve \u00b6 def serve ( port : typing . Union [ int , float ], name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) port Required \u00b6 Type: typing.Union[int, float] The port definition. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. Properties \u00b6 ports Required \u00b6 Type: typing.List[ cdk8s_plus_17.ServicePort ] Ports for this service. Use serve() to expose additional service ports. selector Required \u00b6 Type: typing.Mapping[ str ] Returns the labels which are used to select pods for this service. type Required \u00b6 Type: cdk8s_plus_17.ServiceType Determines how the Service is exposed. cluster_i_p Optional \u00b6 Type: str The IP address of the service and is usually assigned randomly by the master. external_name Optional \u00b6 Type: str The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s_plus_17.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServiceAccount ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , secrets : typing . List [ ISecret ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 add_secret \u00b6 def add_secret ( secret : ISecret ) secret Required \u00b6 Type: cdk8s_plus_17.ISecret The secret. Static Functions \u00b6 from_service_account_name \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServiceAccount . from_service_account_name ( name : str ) name Required \u00b6 Type: str The name of the service account resource. Properties \u00b6 secrets Required \u00b6 Type: typing.List[ cdk8s_plus_17.ISecret ] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . StatefulSet \u00b6 Implements: cdk8s_plus_17.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . StatefulSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , service : Service , default_selector : bool = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 Type: cdk8s_plus_17.Service Service to associate with the statefulset. default_selector Optional \u00b6 Type: bool Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . pod_management_policy Optional \u00b6 Type: cdk8s_plus_17.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume select_by_label \u00b6 def select_by_label ( key : str , value : str ) key Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. Properties \u00b6 containers Required \u00b6 Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. label_selector Required \u00b6 Type: typing.Mapping[ str ] The labels this statefulset will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. pod_management_policy Required \u00b6 Type: cdk8s_plus_17.PodManagementPolicy Management policy to use for the set. pod_metadata Required \u00b6 Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 Type: typing.Union[int, float] Number of desired pods. volumes Required \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. Structs \u00b6 AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . AddDirectoryOptions ( exclude : typing . List [ str ] = None , key_prefix : str = None ) exclude Optional \u00b6 Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . CommandProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ConfigMapProps ( metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None ) metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ConfigMapVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ContainerProps ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. DeploymentProps \u00b6 Properties for initialization of Deployment . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . DeploymentProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , default_selector : bool = None , replicas : typing . Union [ int , float ] = None ) metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. default_selector Optional \u00b6 Type: bool Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EmptyDirVolumeOptions ( medium : EmptyDirMedium = None , size_limit : Size = None ) medium Optional \u00b6 Type: cdk8s_plus_17.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValueFromConfigMapOptions ( optional : bool = None ) optional Optional \u00b6 Type: bool Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValueFromProcessOptions ( required : bool = None ) required Optional \u00b6 Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValueFromSecretOptions ( optional : bool = None ) optional Optional \u00b6 Type: bool Default: false Specify whether the Secret or its key must be defined. ExposeOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ExposeOptions ( name : str = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL protocol Optional \u00b6 Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 Type: cdk8s_plus_17.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . HttpGetProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . IngressV1Beta1Props ( metadata : ApiObjectMetadata = None , default_backend : IngressV1Beta1Backend = None , rules : typing . List [ IngressV1Beta1Rule ] = None , tls : typing . List [ IngressV1Beta1Tls ] = None ) metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_17.IngressV1Beta1Rule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: typing.List[ cdk8s_plus_17.IngressV1Beta1Tls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . IngressV1Beta1Rule ( backend : IngressV1Beta1Backend , host : str = None , path : str = None ) backend Required \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . IngressV1Beta1Tls ( hosts : typing . List [ str ] = None , secret : ISecret = None ) hosts Optional \u00b6 Type: typing.List[ str ] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 Type: cdk8s_plus_17.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for initialization of Job . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . JobProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. active_deadline Optional \u00b6 Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. MountOptions \u00b6 Options for mounts. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . MountOptions ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) propagation Optional \u00b6 Type: cdk8s_plus_17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PathMapping ( path : str , mode : typing . Union [ int , float ] = None ) path Required \u00b6 Type: str The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 Type: typing.Union[int, float] Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PodProps \u00b6 Properties for initialization of Pod . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PodProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSpecProps \u00b6 Properties of a PodSpec . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PodSpecProps ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PodTemplateProps ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None ) containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ResourceProps ( metadata : ApiObjectMetadata = None ) metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. SecretProps \u00b6 Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . SecretProps ( metadata : ApiObjectMetadata = None , string_data : typing . Mapping [ str ] = None , type : str = None ) metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. string_data Optional \u00b6 Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . SecretValue ( key : str , secret : ISecret ) key Required \u00b6 Type: str The JSON key. secret Required \u00b6 Type: cdk8s_plus_17.ISecret The secret. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServiceAccountProps ( metadata : ApiObjectMetadata = None , secrets : typing . List [ ISecret ] = None ) metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServiceIngressV1BetaBackendOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServicePort ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] ) name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 Type: typing.Union[int, float] The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServicePortOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServiceProps ( metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: cdk8s_plus_17.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . StatefulSetProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , service : Service , default_selector : bool = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None ) metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 Type: cdk8s_plus_17.Service Service to associate with the statefulset. default_selector Optional \u00b6 Type: bool Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . pod_management_policy Optional \u00b6 Type: cdk8s_plus_17.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . VolumeMount ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None , path : str , volume : Volume ) propagation Optional \u00b6 Type: cdk8s_plus_17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. path Required \u00b6 Type: str Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 Type: cdk8s_plus_17.Volume The volume to mount. Classes \u00b6 Container \u00b6 A single application container that you want to run within a pod. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 add_env \u00b6 def add_env ( name : str , value : EnvValue ) name Required \u00b6 Type: str The variable name. value Required \u00b6 Type: cdk8s_plus_17.EnvValue The variable value. mount \u00b6 def mount ( path : str , volume : Volume , propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) path Required \u00b6 Type: str The desired path in the container. volume Required \u00b6 Type: cdk8s_plus_17.Volume The volume to mount. propagation Optional \u00b6 Type: cdk8s_plus_17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. Properties \u00b6 env Required \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 Type: str The container image. image_pull_policy Required \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Volume mounts configured for this container. name Required \u00b6 Type: str The name of the container. args Optional \u00b6 Type: typing.List[ str ] Arguments to the entrypoint. command Optional \u00b6 Type: typing.List[ str ] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 Type: typing.Union[int, float] The port this container exposes. working_dir Optional \u00b6 Type: str The working directory inside the container. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValue . from_config_map ( config_map : IConfigMap , key : str , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_17.IConfigMap The config map. key Required \u00b6 Type: str The key to extract the value from. optional Optional \u00b6 Type: bool Default: false Specify whether the ConfigMap or its key must be defined. from_process \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValue . from_process ( key : str , required : bool = None ) key Required \u00b6 Type: str The key to read. required Optional \u00b6 Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. from_secret_value \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValue . from_secret_value ( key : str , secret : ISecret , optional : bool = None ) key Required \u00b6 Type: str The JSON key. secret Required \u00b6 Type: cdk8s_plus_17.ISecret The secret. optional Optional \u00b6 Type: bool Default: false Specify whether the Secret or its key must be defined. from_value \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValue . from_value ( value : str ) value Required \u00b6 Type: str The value. Properties \u00b6 value Optional \u00b6 Type: typing.Any value_from Optional \u00b6 Type: typing.Any IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 from_service \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . IngressV1Beta1Backend . from_service ( service : Service , port : typing . Union [ int , float ] = None ) service Required \u00b6 Type: cdk8s_plus_17.Service The service object. port Optional \u00b6 Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. PodSpec \u00b6 Implements: cdk8s_plus_17.IPodSpec Provides read/write capabilities ontop of a PodSpecProps . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PodSpec ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume Properties \u00b6 containers Required \u00b6 Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. PodTemplate \u00b6 Implements: cdk8s_plus_17.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PodTemplate ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None ) containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. Properties \u00b6 pod_metadata Required \u00b6 Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Probe () Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Probe . from_command ( command : typing . List [ str ], failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) command Required \u00b6 Type: typing.List[ str ] The command to execute. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes from_http_get \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Probe . from_http_get ( path : str , failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) path Required \u00b6 Type: str The URL path to hit. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Volume ( name : str , config : typing . Any ) name Required \u00b6 Type: str config Required \u00b6 Type: typing.Any Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Volume . from_config_map ( config_map : IConfigMap , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_17.IConfigMap The config map to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. from_empty_dir \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Volume . from_empty_dir ( name : str , medium : EmptyDirMedium = None , size_limit : Size = None ) name Required \u00b6 Type: str medium Optional \u00b6 Type: cdk8s_plus_17.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. Properties \u00b6 name Required \u00b6 Type: str Protocols \u00b6 IConfigMap \u00b6 Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.ConfigMap , cdk8s_plus_17.IConfigMap Represents a config map. Properties \u00b6 name Required \u00b6 Type: str The Kubernetes name of this resource. IPodSpec \u00b6 Implemented By: cdk8s_plus_17.Deployment , cdk8s_plus_17.Job , cdk8s_plus_17.Pod , cdk8s_plus_17.PodSpec , cdk8s_plus_17.PodTemplate , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IPodSpec , cdk8s_plus_17.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume The volume. Properties \u00b6 containers Required \u00b6 Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. IPodTemplate \u00b6 Extends: cdk8s_plus_17.IPodSpec Implemented By: cdk8s_plus_17.Deployment , cdk8s_plus_17.Job , cdk8s_plus_17.PodTemplate , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 containers Required \u00b6 Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. pod_metadata Required \u00b6 Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. IResource \u00b6 Implemented By: cdk8s_plus_17.ConfigMap , cdk8s_plus_17.Deployment , cdk8s_plus_17.IngressV1Beta1 , cdk8s_plus_17.Job , cdk8s_plus_17.Pod , cdk8s_plus_17.Resource , cdk8s_plus_17.Secret , cdk8s_plus_17.Service , cdk8s_plus_17.ServiceAccount , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IConfigMap , cdk8s_plus_17.IResource , cdk8s_plus_17.ISecret , cdk8s_plus_17.IServiceAccount Represents a resource. Properties \u00b6 name Required \u00b6 Type: str The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.Secret , cdk8s_plus_17.ISecret Properties \u00b6 name Required \u00b6 Type: str The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.ServiceAccount , cdk8s_plus_17.IServiceAccount Properties \u00b6 name Required \u00b6 Type: str The Kubernetes name of this resource. Enums \u00b6 EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"Python"},{"location":"reference/cdk8s-plus-17/python/#cdk8s-plus-17-python","text":"","title":"cdk8s-plus-17 (Python) "},{"location":"reference/cdk8s-plus-17/python/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-17/python/#configmap","text":"Implements: cdk8s_plus_17.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-17/python/#deployment","text":"Implements: cdk8s_plus_17.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-17/python/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-17/python/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-17/python/#job","text":"Implements: cdk8s_plus_17.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-17/python/#pod","text":"Implements: cdk8s_plus_17.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-17/python/#resource","text":"Implements: cdk8s_plus_17.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-17/python/#secret","text":"Implements: cdk8s_plus_17.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-17/python/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-17/python/#serviceaccount","text":"Implements: cdk8s_plus_17.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-17/python/#statefulset","text":"Implements: cdk8s_plus_17.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-17/python/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-17/python/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-17/python/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-17/python/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-17/python/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-17/python/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-17/python/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-17/python/#deploymentprops","text":"Properties for initialization of Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-17/python/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-17/python/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-17/python/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-17/python/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-17/python/#exposeoptions","text":"Options for exposing a deployment via a service.","title":"ExposeOptions "},{"location":"reference/cdk8s-plus-17/python/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-17/python/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-17/python/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-17/python/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-17/python/#jobprops","text":"Properties for initialization of Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-17/python/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-17/python/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-17/python/#podprops","text":"Properties for initialization of Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-17/python/#podspecprops","text":"Properties of a PodSpec .","title":"PodSpecProps "},{"location":"reference/cdk8s-plus-17/python/#podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec.","title":"PodTemplateProps "},{"location":"reference/cdk8s-plus-17/python/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-17/python/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-17/python/#secretprops","text":"","title":"SecretProps "},{"location":"reference/cdk8s-plus-17/python/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-17/python/#serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-17/python/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-17/python/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-17/python/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-17/python/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-17/python/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-17/python/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-17/python/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-17/python/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-17/python/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-17/python/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-17/python/#podspec","text":"Implements: cdk8s_plus_17.IPodSpec Provides read/write capabilities ontop of a PodSpecProps .","title":"PodSpec "},{"location":"reference/cdk8s-plus-17/python/#podtemplate","text":"Implements: cdk8s_plus_17.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps .","title":"PodTemplate "},{"location":"reference/cdk8s-plus-17/python/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-17/python/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-17/python/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-17/python/#iconfigmap","text":"Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.ConfigMap , cdk8s_plus_17.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-17/python/#ipodspec","text":"Implemented By: cdk8s_plus_17.Deployment , cdk8s_plus_17.Job , cdk8s_plus_17.Pod , cdk8s_plus_17.PodSpec , cdk8s_plus_17.PodTemplate , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IPodSpec , cdk8s_plus_17.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"IPodSpec "},{"location":"reference/cdk8s-plus-17/python/#ipodtemplate","text":"Extends: cdk8s_plus_17.IPodSpec Implemented By: cdk8s_plus_17.Deployment , cdk8s_plus_17.Job , cdk8s_plus_17.PodTemplate , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"IPodTemplate "},{"location":"reference/cdk8s-plus-17/python/#iresource","text":"Implemented By: cdk8s_plus_17.ConfigMap , cdk8s_plus_17.Deployment , cdk8s_plus_17.IngressV1Beta1 , cdk8s_plus_17.Job , cdk8s_plus_17.Pod , cdk8s_plus_17.Resource , cdk8s_plus_17.Secret , cdk8s_plus_17.Service , cdk8s_plus_17.ServiceAccount , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IConfigMap , cdk8s_plus_17.IResource , cdk8s_plus_17.ISecret , cdk8s_plus_17.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-17/python/#isecret","text":"Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.Secret , cdk8s_plus_17.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-17/python/#iserviceaccount","text":"Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.ServiceAccount , cdk8s_plus_17.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-17/python/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-17/python/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-17/python/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-17/python/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-17/python/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-17/python/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-17/python/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-17/python/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-17/typescript/","text":"cdk8s-plus-17 (TypeScript) \u00b6 Constructs \u00b6 ConfigMap \u00b6 Implements: cdk8s-plus-17.IConfigMap ConfigMap holds configuration data for pods to consume. Initializer \u00b6 import { ConfigMap } from 'cdk8s-plus-17' new ConfigMap ( scope : Construct , id : string , props? : ConfigMapProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.ConfigMapProps Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addData \u00b6 public addData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addDirectory \u00b6 public addDirectory ( localDir : string , options? : AddDirectoryOptions ) localDir Required \u00b6 Type: string A path to a local directory. options Optional \u00b6 Type: cdk8s-plus-17.AddDirectoryOptions Options. addFile \u00b6 public addFile ( localFile : string , key? : string ) localFile Required \u00b6 Type: string The path to the local file. key Optional \u00b6 Type: string The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import { ConfigMap } from 'cdk8s-plus-17' ConfigMap . fromConfigMapName ( name : string ) name Required \u00b6 Type: string The name of the config map to import. Properties \u00b6 binaryData Required \u00b6 Type: {[ key: string ]: string } The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 Type: {[ key: string ]: string } The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . Deployment \u00b6 Implements: cdk8s-plus-17.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializer \u00b6 import { Deployment } from 'cdk8s-plus-17' new Deployment ( scope : Construct , id : string , props? : DeploymentProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.DeploymentProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume expose \u00b6 public expose ( port : number , options? : ExposeOptions ) port Required \u00b6 Type: number The port number the service will bind to. options Optional \u00b6 Type: cdk8s-plus-17.ExposeOptions Options to determine details of the service and port exposed. selectByLabel \u00b6 public selectByLabel ( key : string , value : string ) key Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. Properties \u00b6 containers Required \u00b6 Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 Type: {[ key: string ]: string } The labels this deployment will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podMetadata Required \u00b6 Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 Type: number Number of desired pods. volumes Required \u00b6 Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializer \u00b6 import { IngressV1Beta1 } from 'cdk8s-plus-17' new IngressV1Beta1 ( scope : Construct , id : string , props? : IngressV1Beta1Props ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Props Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( backend : IngressV1Beta1Backend ) backend Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Backend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( host : string , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: string The host name to match. backend Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Backend The backend to route to. addHostRule \u00b6 public addHostRule ( host : string , path : string , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: string The host name. path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Backend The backend to route requests to. addRule \u00b6 public addRule ( path : string , backend : IngressV1Beta1Backend ) path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Backend The backend to route requests to. addRules \u00b6 public addRules ( rules : IngressV1Beta1Rule ) rules Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Rule The rules to add. addTls \u00b6 public addTls ( tls : IngressV1Beta1Tls []) tls Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Tls [] Job \u00b6 Implements: cdk8s-plus-17.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializer \u00b6 import { Job } from 'cdk8s-plus-17' new Job ( scope : Construct , id : string , props? : JobProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.JobProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume Properties \u00b6 containers Required \u00b6 Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. podMetadata Required \u00b6 Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Required \u00b6 Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. activeDeadline Optional \u00b6 Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 Type: number Number of retries before marking failed. restartPolicy Optional \u00b6 Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. ttlAfterFinished Optional \u00b6 Type: cdk8s.Duration TTL before the job is deleted after it is finished. Pod \u00b6 Implements: cdk8s-plus-17.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializer \u00b6 import { Pod } from 'cdk8s-plus-17' new Pod ( scope : Construct , id : string , props? : PodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.PodProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume Properties \u00b6 containers Required \u00b6 Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. Resource \u00b6 Implements: cdk8s-plus-17.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializer \u00b6 import { Resource } from 'cdk8s-plus-17' new Resource ( scope : Construct , id : string , options? : ConstructOptions ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: string The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . options Optional \u00b6 Type: constructs.ConstructOptions Options. Properties \u00b6 metadata Required \u00b6 Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 Type: string The name of this API object. Secret \u00b6 Implements: cdk8s-plus-17.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializer \u00b6 import { Secret } from 'cdk8s-plus-17' new Secret ( scope : Construct , id : string , props? : SecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.SecretProps Methods \u00b6 addStringData \u00b6 public addStringData ( key : string , value : string ) key Required \u00b6 Type: string Key. value Required \u00b6 Type: string Value. getStringData \u00b6 public getStringData ( key : string ) key Required \u00b6 Type: string Key. Static Functions \u00b6 fromSecretName \u00b6 import { Secret } from 'cdk8s-plus-17' Secret . fromSecretName ( name : string ) name Required \u00b6 Type: string The name of the secret to reference. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializer \u00b6 import { Service } from 'cdk8s-plus-17' new Service ( scope : Construct , id : string , props? : ServiceProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.ServiceProps Methods \u00b6 addDeployment \u00b6 public addDeployment ( deployment : Deployment , port : number , options? : ServicePortOptions ) deployment Required \u00b6 Type: cdk8s-plus-17.Deployment The deployment to expose. port Required \u00b6 Type: number The external port. options Optional \u00b6 Type: cdk8s-plus-17.ServicePortOptions Optional settings for the port. addSelector \u00b6 public addSelector ( label : string , value : string ) label Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. serve \u00b6 public serve ( port : number , options? : ServicePortOptions ) port Required \u00b6 Type: number The port definition. options Optional \u00b6 Type: cdk8s-plus-17.ServicePortOptions Properties \u00b6 ports Required \u00b6 Type: cdk8s-plus-17.ServicePort [] Ports for this service. Use serve() to expose additional service ports. selector Required \u00b6 Type: {[ key: string ]: string } Returns the labels which are used to select pods for this service. type Required \u00b6 Type: cdk8s-plus-17.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 Type: string The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 Type: string The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s-plus-17.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializer \u00b6 import { ServiceAccount } from 'cdk8s-plus-17' new ServiceAccount ( scope : Construct , id : string , props? : ServiceAccountProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.ServiceAccountProps Methods \u00b6 addSecret \u00b6 public addSecret ( secret : ISecret ) secret Required \u00b6 Type: cdk8s-plus-17.ISecret The secret. Static Functions \u00b6 fromServiceAccountName \u00b6 import { ServiceAccount } from 'cdk8s-plus-17' ServiceAccount . fromServiceAccountName ( name : string ) name Required \u00b6 Type: string The name of the service account resource. Properties \u00b6 secrets Required \u00b6 Type: cdk8s-plus-17.ISecret [] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . StatefulSet \u00b6 Implements: cdk8s-plus-17.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializer \u00b6 import { StatefulSet } from 'cdk8s-plus-17' new StatefulSet ( scope : Construct , id : string , props : StatefulSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-17.StatefulSetProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume selectByLabel \u00b6 public selectByLabel ( key : string , value : string ) key Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. Properties \u00b6 containers Required \u00b6 Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 Type: {[ key: string ]: string } The labels this statefulset will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podManagementPolicy Required \u00b6 Type: cdk8s-plus-17.PodManagementPolicy Management policy to use for the set. podMetadata Required \u00b6 Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 Type: number Number of desired pods. volumes Required \u00b6 Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. Structs \u00b6 AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import { AddDirectoryOptions } from 'cdk8s-plus-17' const addDirectoryOptions : AddDirectoryOptions = { ... } exclude Optional \u00b6 Type: string [] Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 Type: string Default: \u201c\u201d A prefix to add to all keys in the config map. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import { CommandProbeOptions } from 'cdk8s-plus-17' const commandProbeOptions : CommandProbeOptions = { ... } failureThreshold Optional \u00b6 Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import { ConfigMapProps } from 'cdk8s-plus-17' const configMapProps : ConfigMapProps = { ... } metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 Type: {[ key: string ]: string } BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: {[ key: string ]: string } Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import { ConfigMapVolumeOptions } from 'cdk8s-plus-17' const configMapVolumeOptions : ConfigMapVolumeOptions = { ... } defaultMode Optional \u00b6 Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: {[ key: string ]: cdk8s-plus-17.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: string Default: auto-generated The volume name. optional Optional \u00b6 Type: boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import { ContainerProps } from 'cdk8s-plus-17' const containerProps : ContainerProps = { ... } image Required \u00b6 Type: string Docker image name. args Optional \u00b6 Type: string [] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: string [] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: {[ key: string ]: cdk8s-plus-17.EnvValue } Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 Type: cdk8s-plus-17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s-plus-17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: string Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s-plus-17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s-plus-17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 Type: cdk8s-plus-17.VolumeMount [] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 Type: string Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. DeploymentProps \u00b6 Properties for initialization of Deployment . Initializer \u00b6 import { DeploymentProps } from 'cdk8s-plus-17' const deploymentProps : DeploymentProps = { ... } metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. defaultSelector Optional \u00b6 Type: boolean Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 Type: number Default: 1 Number of desired pods. EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import { EmptyDirVolumeOptions } from 'cdk8s-plus-17' const emptyDirVolumeOptions : EmptyDirVolumeOptions = { ... } medium Optional \u00b6 Type: cdk8s-plus-17.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import { EnvValueFromConfigMapOptions } from 'cdk8s-plus-17' const envValueFromConfigMapOptions : EnvValueFromConfigMapOptions = { ... } optional Optional \u00b6 Type: boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import { EnvValueFromProcessOptions } from 'cdk8s-plus-17' const envValueFromProcessOptions : EnvValueFromProcessOptions = { ... } required Optional \u00b6 Type: boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import { EnvValueFromSecretOptions } from 'cdk8s-plus-17' const envValueFromSecretOptions : EnvValueFromSecretOptions = { ... } optional Optional \u00b6 Type: boolean Default: false Specify whether the Secret or its key must be defined. ExposeOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import { ExposeOptions } from 'cdk8s-plus-17' const exposeOptions : ExposeOptions = { ... } name Optional \u00b6 Type: string Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL protocol Optional \u00b6 Type: cdk8s-plus-17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 Type: cdk8s-plus-17.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 Type: number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import { HttpGetProbeOptions } from 'cdk8s-plus-17' const httpGetProbeOptions : HttpGetProbeOptions = { ... } failureThreshold Optional \u00b6 Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import { IngressV1Beta1Props } from 'cdk8s-plus-17' const ingressV1Beta1Props : IngressV1Beta1Props = { ... } metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Rule [] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Tls [] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import { IngressV1Beta1Rule } from 'cdk8s-plus-17' const ingressV1Beta1Rule : IngressV1Beta1Rule = { ... } backend Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 Type: string Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 Type: string Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import { IngressV1Beta1Tls } from 'cdk8s-plus-17' const ingressV1Beta1Tls : IngressV1Beta1Tls = { ... } hosts Optional \u00b6 Type: string [] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 Type: cdk8s-plus-17.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for initialization of Job . Initializer \u00b6 import { JobProps } from 'cdk8s-plus-17' const jobProps : JobProps = { ... } metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. activeDeadline Optional \u00b6 Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 Type: number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. MountOptions \u00b6 Options for mounts. Initializer \u00b6 import { MountOptions } from 'cdk8s-plus-17' const mountOptions : MountOptions = { ... } propagation Optional \u00b6 Type: cdk8s-plus-17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import { PathMapping } from 'cdk8s-plus-17' const pathMapping : PathMapping = { ... } path Required \u00b6 Type: string The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 Type: number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PodProps \u00b6 Properties for initialization of Pod . Initializer \u00b6 import { PodProps } from 'cdk8s-plus-17' const podProps : PodProps = { ... } metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSpecProps \u00b6 Properties of a PodSpec . Initializer \u00b6 import { PodSpecProps } from 'cdk8s-plus-17' const podSpecProps : PodSpecProps = { ... } containers Optional \u00b6 Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Initializer \u00b6 import { PodTemplateProps } from 'cdk8s-plus-17' const podTemplateProps : PodTemplateProps = { ... } containers Optional \u00b6 Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import { ProbeOptions } from 'cdk8s-plus-17' const probeOptions : ProbeOptions = { ... } failureThreshold Optional \u00b6 Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import { ResourceProps } from 'cdk8s-plus-17' const resourceProps : ResourceProps = { ... } metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. SecretProps \u00b6 Initializer \u00b6 import { SecretProps } from 'cdk8s-plus-17' const secretProps : SecretProps = { ... } metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. stringData Optional \u00b6 Type: {[ key: string ]: string } stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: string Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import { SecretValue } from 'cdk8s-plus-17' const secretValue : SecretValue = { ... } key Required \u00b6 Type: string The JSON key. secret Required \u00b6 Type: cdk8s-plus-17.ISecret The secret. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Initializer \u00b6 import { ServiceAccountProps } from 'cdk8s-plus-17' const serviceAccountProps : ServiceAccountProps = { ... } metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 Type: cdk8s-plus-17.ISecret [] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import { ServiceIngressV1BetaBackendOptions } from 'cdk8s-plus-17' const serviceIngressV1BetaBackendOptions : ServiceIngressV1BetaBackendOptions = { ... } port Optional \u00b6 Type: number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import { ServicePort } from 'cdk8s-plus-17' const servicePort : ServicePort = { ... } name Optional \u00b6 Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 Type: number Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s-plus-17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 Type: number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 Type: number The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import { ServicePortOptions } from 'cdk8s-plus-17' const servicePortOptions : ServicePortOptions = { ... } name Optional \u00b6 Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 Type: number Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s-plus-17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 Type: number Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import { ServiceProps } from 'cdk8s-plus-17' const serviceProps : ServiceProps = { ... } metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 Type: string Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 Type: string [] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 Type: string Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 Type: string [] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: cdk8s-plus-17.ServicePort [] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: cdk8s-plus-17.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import { StatefulSetProps } from 'cdk8s-plus-17' const statefulSetProps : StatefulSetProps = { ... } metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 Type: cdk8s-plus-17.Service Service to associate with the statefulset. defaultSelector Optional \u00b6 Type: boolean Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . podManagementPolicy Optional \u00b6 Type: cdk8s-plus-17.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: number Default: 1 Number of desired pods. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import { VolumeMount } from 'cdk8s-plus-17' const volumeMount : VolumeMount = { ... } propagation Optional \u00b6 Type: cdk8s-plus-17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. path Required \u00b6 Type: string Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 Type: cdk8s-plus-17.Volume The volume to mount. Classes \u00b6 Container \u00b6 A single application container that you want to run within a pod. Initializer \u00b6 import { Container } from 'cdk8s-plus-17' new Container ( props : ContainerProps ) props Required \u00b6 Type: cdk8s-plus-17.ContainerProps Methods \u00b6 addEnv \u00b6 public addEnv ( name : string , value : EnvValue ) name Required \u00b6 Type: string The variable name. value Required \u00b6 Type: cdk8s-plus-17.EnvValue The variable value. mount \u00b6 public mount ( path : string , volume : Volume , options? : MountOptions ) path Required \u00b6 Type: string The desired path in the container. volume Required \u00b6 Type: cdk8s-plus-17.Volume The volume to mount. options Optional \u00b6 Type: cdk8s-plus-17.MountOptions Properties \u00b6 env Required \u00b6 Type: {[ key: string ]: cdk8s-plus-17.EnvValue } The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 Type: string The container image. imagePullPolicy Required \u00b6 Type: cdk8s-plus-17.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 Type: cdk8s-plus-17.VolumeMount [] Volume mounts configured for this container. name Required \u00b6 Type: string The name of the container. args Optional \u00b6 Type: string [] Arguments to the entrypoint. command Optional \u00b6 Type: string [] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 Type: number The port this container exposes. workingDir Optional \u00b6 Type: string The working directory inside the container. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import { EnvValue } from 'cdk8s-plus-17' EnvValue . fromConfigMap ( configMap : IConfigMap , key : string , options? : EnvValueFromConfigMapOptions ) configMap Required \u00b6 Type: cdk8s-plus-17.IConfigMap The config map. key Required \u00b6 Type: string The key to extract the value from. options Optional \u00b6 Type: cdk8s-plus-17.EnvValueFromConfigMapOptions Additional options. fromProcess \u00b6 import { EnvValue } from 'cdk8s-plus-17' EnvValue . fromProcess ( key : string , options? : EnvValueFromProcessOptions ) key Required \u00b6 Type: string The key to read. options Optional \u00b6 Type: cdk8s-plus-17.EnvValueFromProcessOptions Additional options. fromSecretValue \u00b6 import { EnvValue } from 'cdk8s-plus-17' EnvValue . fromSecretValue ( secretValue : SecretValue , options? : EnvValueFromSecretOptions ) secretValue Required \u00b6 Type: cdk8s-plus-17.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: cdk8s-plus-17.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import { EnvValue } from 'cdk8s-plus-17' EnvValue . fromValue ( value : string ) value Required \u00b6 Type: string The value. Properties \u00b6 value Optional \u00b6 Type: any valueFrom Optional \u00b6 Type: any IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromService \u00b6 import { IngressV1Beta1Backend } from 'cdk8s-plus-17' IngressV1Beta1Backend . fromService ( service : Service , options? : ServiceIngressV1BetaBackendOptions ) service Required \u00b6 Type: cdk8s-plus-17.Service The service object. options Optional \u00b6 Type: cdk8s-plus-17.ServiceIngressV1BetaBackendOptions PodSpec \u00b6 Implements: cdk8s-plus-17.IPodSpec Provides read/write capabilities ontop of a PodSpecProps . Initializer \u00b6 import { PodSpec } from 'cdk8s-plus-17' new PodSpec ( props? : PodSpecProps ) props Optional \u00b6 Type: cdk8s-plus-17.PodSpecProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume Properties \u00b6 containers Required \u00b6 Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. PodTemplate \u00b6 Implements: cdk8s-plus-17.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Initializer \u00b6 import { PodTemplate } from 'cdk8s-plus-17' new PodTemplate ( props? : PodTemplateProps ) props Optional \u00b6 Type: cdk8s-plus-17.PodTemplateProps Properties \u00b6 podMetadata Required \u00b6 Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializer \u00b6 import { Probe } from 'cdk8s-plus-17' new Probe () Static Functions \u00b6 fromCommand \u00b6 import { Probe } from 'cdk8s-plus-17' Probe . fromCommand ( command : string [], options? : CommandProbeOptions ) command Required \u00b6 Type: string [] The command to execute. options Optional \u00b6 Type: cdk8s-plus-17.CommandProbeOptions Options. fromHttpGet \u00b6 import { Probe } from 'cdk8s-plus-17' Probe . fromHttpGet ( path : string , options? : HttpGetProbeOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-17.HttpGetProbeOptions Options. Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializer \u00b6 import { Volume } from 'cdk8s-plus-17' new Volume ( name : string , config : any ) name Required \u00b6 Type: string config Required \u00b6 Type: any Static Functions \u00b6 fromConfigMap \u00b6 import { Volume } from 'cdk8s-plus-17' Volume . fromConfigMap ( configMap : IConfigMap , options? : ConfigMapVolumeOptions ) configMap Required \u00b6 Type: cdk8s-plus-17.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-17.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import { Volume } from 'cdk8s-plus-17' Volume . fromEmptyDir ( name : string , options? : EmptyDirVolumeOptions ) name Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-17.EmptyDirVolumeOptions Additional options. Properties \u00b6 name Required \u00b6 Type: string Protocols \u00b6 IConfigMap \u00b6 Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.ConfigMap , cdk8s-plus-17.IConfigMap Represents a config map. Properties \u00b6 name Required \u00b6 Type: string The Kubernetes name of this resource. IPodSpec \u00b6 Implemented By: cdk8s-plus-17.Deployment , cdk8s-plus-17.Job , cdk8s-plus-17.Pod , cdk8s-plus-17.PodSpec , cdk8s-plus-17.PodTemplate , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IPodSpec , cdk8s-plus-17.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps The container. addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume The volume. Properties \u00b6 containers Required \u00b6 Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. IPodTemplate \u00b6 Extends: cdk8s-plus-17.IPodSpec Implemented By: cdk8s-plus-17.Deployment , cdk8s-plus-17.Job , cdk8s-plus-17.PodTemplate , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 containers Required \u00b6 Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. podMetadata Required \u00b6 Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. IResource \u00b6 Implemented By: cdk8s-plus-17.ConfigMap , cdk8s-plus-17.Deployment , cdk8s-plus-17.IngressV1Beta1 , cdk8s-plus-17.Job , cdk8s-plus-17.Pod , cdk8s-plus-17.Resource , cdk8s-plus-17.Secret , cdk8s-plus-17.Service , cdk8s-plus-17.ServiceAccount , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IConfigMap , cdk8s-plus-17.IResource , cdk8s-plus-17.ISecret , cdk8s-plus-17.IServiceAccount Represents a resource. Properties \u00b6 name Required \u00b6 Type: string The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.Secret , cdk8s-plus-17.ISecret Properties \u00b6 name Required \u00b6 Type: string The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.ServiceAccount , cdk8s-plus-17.IServiceAccount Properties \u00b6 name Required \u00b6 Type: string The Kubernetes name of this resource. Enums \u00b6 EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"TypeScript"},{"location":"reference/cdk8s-plus-17/typescript/#cdk8s-plus-17-typescript","text":"","title":"cdk8s-plus-17 (TypeScript) "},{"location":"reference/cdk8s-plus-17/typescript/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-17/typescript/#configmap","text":"Implements: cdk8s-plus-17.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-17/typescript/#deployment","text":"Implements: cdk8s-plus-17.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-17/typescript/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-17/typescript/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-17/typescript/#job","text":"Implements: cdk8s-plus-17.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-17/typescript/#pod","text":"Implements: cdk8s-plus-17.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-17/typescript/#resource","text":"Implements: cdk8s-plus-17.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-17/typescript/#secret","text":"Implements: cdk8s-plus-17.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-17/typescript/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-17/typescript/#serviceaccount","text":"Implements: cdk8s-plus-17.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-17/typescript/#statefulset","text":"Implements: cdk8s-plus-17.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-17/typescript/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-17/typescript/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-17/typescript/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-17/typescript/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-17/typescript/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-17/typescript/#deploymentprops","text":"Properties for initialization of Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-17/typescript/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-17/typescript/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-17/typescript/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-17/typescript/#exposeoptions","text":"Options for exposing a deployment via a service.","title":"ExposeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-17/typescript/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-17/typescript/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-17/typescript/#jobprops","text":"Properties for initialization of Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-17/typescript/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-17/typescript/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-17/typescript/#podprops","text":"Properties for initialization of Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-17/typescript/#podspecprops","text":"Properties of a PodSpec .","title":"PodSpecProps "},{"location":"reference/cdk8s-plus-17/typescript/#podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec.","title":"PodTemplateProps "},{"location":"reference/cdk8s-plus-17/typescript/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-17/typescript/#secretprops","text":"","title":"SecretProps "},{"location":"reference/cdk8s-plus-17/typescript/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-17/typescript/#serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-17/typescript/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-17/typescript/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-17/typescript/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-17/typescript/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-17/typescript/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-17/typescript/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-17/typescript/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-17/typescript/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-17/typescript/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-17/typescript/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-17/typescript/#podspec","text":"Implements: cdk8s-plus-17.IPodSpec Provides read/write capabilities ontop of a PodSpecProps .","title":"PodSpec "},{"location":"reference/cdk8s-plus-17/typescript/#podtemplate","text":"Implements: cdk8s-plus-17.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps .","title":"PodTemplate "},{"location":"reference/cdk8s-plus-17/typescript/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-17/typescript/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-17/typescript/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-17/typescript/#iconfigmap","text":"Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.ConfigMap , cdk8s-plus-17.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-17/typescript/#ipodspec","text":"Implemented By: cdk8s-plus-17.Deployment , cdk8s-plus-17.Job , cdk8s-plus-17.Pod , cdk8s-plus-17.PodSpec , cdk8s-plus-17.PodTemplate , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IPodSpec , cdk8s-plus-17.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"IPodSpec "},{"location":"reference/cdk8s-plus-17/typescript/#ipodtemplate","text":"Extends: cdk8s-plus-17.IPodSpec Implemented By: cdk8s-plus-17.Deployment , cdk8s-plus-17.Job , cdk8s-plus-17.PodTemplate , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"IPodTemplate "},{"location":"reference/cdk8s-plus-17/typescript/#iresource","text":"Implemented By: cdk8s-plus-17.ConfigMap , cdk8s-plus-17.Deployment , cdk8s-plus-17.IngressV1Beta1 , cdk8s-plus-17.Job , cdk8s-plus-17.Pod , cdk8s-plus-17.Resource , cdk8s-plus-17.Secret , cdk8s-plus-17.Service , cdk8s-plus-17.ServiceAccount , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IConfigMap , cdk8s-plus-17.IResource , cdk8s-plus-17.ISecret , cdk8s-plus-17.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-17/typescript/#isecret","text":"Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.Secret , cdk8s-plus-17.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-17/typescript/#iserviceaccount","text":"Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.ServiceAccount , cdk8s-plus-17.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-17/typescript/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-17/typescript/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-17/typescript/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-17/typescript/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-17/typescript/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-17/typescript/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-17/typescript/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-17/typescript/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "}]}