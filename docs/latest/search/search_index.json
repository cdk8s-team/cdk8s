{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Overview \u00b6 CDK8s is a software development framework for defining Kubernetes applications and reusable abstractions using familiar programming languages and rich object-oriented APIs. CDK8s generates pure Kubernetes YAML - you can use CDK8s to define applications for any Kubernetes cluster running anywhere. Read our blog or watch our CNCF webinar to learn more and see a live demo of CDK8s in action. How does it work \u00b6 CDK8s apps are programs written in one of the supported programming languages. They are structured as a tree of constructs . The root of the tree is an App construct. Within an app, users define any number of charts (classes that extend the Chart class). Each chart is synthesized into a separate Kubernetes manifest file. Charts are, in turn, composed of any number of constructs, and eventually from resources, which represent any Kubernetes resource, such as Pod , Service , Deployment , ReplicaSet , etc. CDK8s apps only define Kubernetes applications, they don\u2019t actually apply them to the cluster. When an app is executed, it synthesizes all the charts defined within the app into the dist directory, and then those charts can be applied to any Kubernetes cluster using kubectl apply -f dist/chart.k8s.yaml or a GitOps tool like Flux . CDK8s is based on the design concepts and technologies behind the AWS Cloud Development Kit , and can interoperate with AWS CDK constructs to define cloud-native applications that include both Kubernetes resources and other CDK constructs as first class citizens.","title":"Overview"},{"location":"index.html#overview","text":"CDK8s is a software development framework for defining Kubernetes applications and reusable abstractions using familiar programming languages and rich object-oriented APIs. CDK8s generates pure Kubernetes YAML - you can use CDK8s to define applications for any Kubernetes cluster running anywhere. Read our blog or watch our CNCF webinar to learn more and see a live demo of CDK8s in action.","title":"Overview"},{"location":"index.html#how-does-it-work","text":"CDK8s apps are programs written in one of the supported programming languages. They are structured as a tree of constructs . The root of the tree is an App construct. Within an app, users define any number of charts (classes that extend the Chart class). Each chart is synthesized into a separate Kubernetes manifest file. Charts are, in turn, composed of any number of constructs, and eventually from resources, which represent any Kubernetes resource, such as Pod , Service , Deployment , ReplicaSet , etc. CDK8s apps only define Kubernetes applications, they don\u2019t actually apply them to the cluster. When an app is executed, it synthesizes all the charts defined within the app into the dist directory, and then those charts can be applied to any Kubernetes cluster using kubectl apply -f dist/chart.k8s.yaml or a GitOps tool like Flux . CDK8s is based on the design concepts and technologies behind the AWS Cloud Development Kit , and can interoperate with AWS CDK constructs to define cloud-native applications that include both Kubernetes resources and other CDK constructs as first class citizens.","title":"How does it work"},{"location":"getting-started.html","text":"Getting Started \u00b6 This guide will walk you through the following steps: Installing the CDK8s CLI. Creating a new CDK8s project in one of the supported programming languages. Define & deploy your first CDK8s application. Define a custom CDK8s construct. Prerequisites \u00b6 TypeScript Node.js >= 10.x Your favorite editor/IDE yarn (optional) Python Python >= 3.7.7 pipenv version 2018.11.26 or above. Java Maven >= 3.6.3 Install the CLI \u00b6 CDK8s has a cute little CLI that has a few useful commands. Let\u2019s start by installing the CDK8s CLI globally. We have two options for this. npm $ npm install -g cdk8s-cli yarn $ yarn global add cdk8s-cli New Project \u00b6 Now, we\u2019ll use the cdk8s init command to create a new CDK8s app: TypeScript $ mkdir hello $ cd hello $ cdk8s init typescript-app Initializing a project from the typescript-app template ... Since TypeScript is a compiled language, we will need to compile .ts files to .js in order to execute our CDK app. You can do that continuously in the background like this: $ npm run watch Python $ mkdir hello $ cd hello $ cdk8s init python-app Initializing a project from the python-app template ... Java $ mkdir hello $ cd hello $ cdk8s init java-app Initializing a project from the java-app template ... This will perform the following: Create a new project directory Install CDK8s as a dependency Import all Kubernetes API objects Apps & Charts \u00b6 At this point, if you will see something like this: TypeScript main.ts import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); // define resources here } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Python main.py #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here app = App () MyChart ( app , \"hello\" ) app . synth () Java src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // define resources here } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } Apps are structured as a tree of constructs , which are composable units of abstraction. We will learn more about constructs soon. This initial code created by cdk8s init defines an app with a single, empty, chart. When you run cdk8s synth , a Kubernetes manifest YAML will be synthesized for each Chart in your app and will write it to the dist directory. You can try: $ cdk8s synth dist/hello.k8s.yaml $ cat dist/hello.k8s.yaml <EMPTY> Importing Constructs for the Kubernetes API \u00b6 OK, now let\u2019s define some Kubernetes API objects inside our chart. Similarly to charts and apps , Kubernetes API Objects are also represented in CDK8s as constructs . These constructs are imported to your project using the cdk8s import command which will add source files to your project that include constructs that represent the Kubernetes API. Info When cdk8s init created your project it already executed cdk8s import for you, so you should see an imports directory already there. You can either commit this directory to source-control or generate it as part of your build process. Now, let\u2019s use these constructs to define a simple Kubernetes application which contains Service and a Deployment resources inspired by paulbouwer \u2018s hello-kubernetes project. TypeScript import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; // imported constructs import { KubeDeployment , KubeService , IntOrString } from './imports/k8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); const label = { app : 'hello-k8s' }; new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port : 80 , targetPort : IntOrString.fromNumber ( 8080 ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas : 2 , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'hello-kubernetes' , image : 'paulbouwer/hello-kubernetes:1.7' , ports : [ { containerPort : 8080 } ] } ] } } } }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Python #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from imports import k8s class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here label = { \"app\" : \"hello-k8s\" } k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = 80 , target_port = k8s . IntOrString . from_number ( 8080 ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = 2 , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'hello-kubernetes' , image = 'paulbouwer/hello-kubernetes:1.7' , ports = [ k8s . ContainerPort ( container_port = 8080 )])])))) app = App () MyChart ( app , \"hello\" ) app . synth () Java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( 80 ) . targetPort ( IntOrString . fromNumber ( 8080 )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( 8080 ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"hello-kubernetes\" ) . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( 1 ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } Now, compile & synth this project: cdk8s synth Notice In compiled languages, like Java and TypeScript, you\u2019ll need to compile your program before running cdk8s synth . This will be contents of hello.k8s.yaml : apiVersion : \"v1\" kind : \"Service\" metadata : name : \"hello-service-c8c17160\" spec : ports : - port : 80 targetPort : 8080 selector : app : \"hello-k8s\" type : \"LoadBalancer\" --- apiVersion : \"apps/v1\" kind : \"Deployment\" metadata : name : \"hello-deployment-c8c7fda7\" spec : replicas : 2 selector : matchLabels : app : \"hello-k8s\" template : metadata : labels : app : \"hello-k8s\" spec : containers : - image : \"paulbouwer/hello-kubernetes:1.7\" name : \"hello-kubernetes\" ports : - containerPort : 8080 The manifest synthesized by your app is ready to be applied to any Kubernetes cluster using standard tools like kubectl apply : kubectl apply -f dist/hello.k8s.yaml Abstraction through Constructs \u00b6 Constructs are the basic building block of CDK8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years. So let\u2019s create our first Kubernetes construct. We\u2019ll call it WebService and it will basically be a generalization of the hello world program. It\u2019s actually quite useful. For example, this one line will add a hello world service to our chart: TypeScript new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' }); It can also be customized through an API: new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' , containerPort : 8080 , replicas : 10 }); Python WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' ) It can also be customized through an API: WebService ( self , 'hello-k8s' , image = 'paulbouwer/hello-kubernetes:1.7' , container_port = 8080 , replicas = 10 ) Java new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . build ()); It can also be customized through an API: new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); Here\u2019s how to implement WebService : TypeScript Create a file lib/web-service.ts (the convention is to use lib for reusable components): import { Construct } from 'constructs' ; import { Names } from 'cdk8s' ; import { KubeDeployment , KubeService , IntOrString } from '../imports/k8s' ; export interface WebServiceProps { /** * The Docker image to use for this service. */ readonly image : string ; /** * Number of replicas. * * @default 1 */ readonly replicas? : number ; /** * External port. * * @default 80 */ readonly port? : number ; /** * Internal port. * * @default 8080 */ readonly containerPort? : number ; } export class WebService extends Construct { constructor ( scope : Construct , id : string , props : WebServiceProps ) { super ( scope , id ); const port = props . port || 80 ; const containerPort = props . containerPort || 8080 ; const label = { app : Names.toDnsLabel ( this ) }; const replicas = props . replicas ?? 1 ; new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port , targetPort : IntOrString.fromNumber ( containerPort ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'app' , image : props.image , ports : [ { containerPort } ] } ] } } } }); } } Now, let\u2019s edit main.ts and use our new construct: import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; import { WebService } from './lib/web-service' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); new WebService ( this , 'hello' , { image : 'paulbouwer/hello-kubernetes:1.7' , replicas : 2 }); new WebService ( this , 'ghost' , { image : 'ghost' , containerPort : 2368 }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Python Create a file webservice.py with the following content: from constructs import Construct , Node from imports import k8s class WebService ( Construct ): def __init__ ( self , scope : Construct , id : str , * , image : str , replicas : int = 1 , port : int = 80 , container_port : int = 8080 ): super () . __init__ ( scope , id ) label = { 'app' : Node . of ( self ) . unique_id } k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = port , target_port = k8s . IntOrString . from_number ( container_port ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = replicas , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'app' , image = image , ports = [ k8s . ContainerPort ( container_port = container_port )])])))) Now, let\u2019s edit main.py and use our new construct: #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from webservice import WebService class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' , replicas = 2 ) WebService ( self , 'ghost' , image = 'ghost' , container_port = 2368 ) app = App () MyChart ( app , \"hello\" ) app . synth () Java src/main/java/com/mycompany/app/WebService.java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import java.util.Optional ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class WebService extends Construct { public WebService ( final Construct scope , final String id ) { this ( scope , id , null ); } public WebService ( final Construct scope , final String id , final WebServiceProps options ) { super ( scope , id ); final int portNumber = Optional . of ( options . getPort ()). orElse ( 80 ); final int containerPortNumber = Optional . of ( options . getContainerPort ()). orElse ( 8080 ); final int replicas = Optional . of ( options . getReplicas ()). orElse ( 1 ); final String image = options . getImage (); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( portNumber ) . targetPort ( IntOrString . fromNumber ( containerPortNumber )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( containerPortNumber ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"web\" ) . image ( image ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( replicas ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } } src/main/java/com/mycompany/app/WebServiceProps.java package com.mycompany.app ; public class WebServiceProps { private String image ; private int replicas ; private int port ; private int containerPort ; public WebServiceProps ( final String image , final int replicas , final int port , final int containerPort ) { this . image = image ; this . replicas = replicas ; this . port = port ; this . containerPort = containerPort ; } public String getImage () { return this . image ; } public int getReplicas () { return this . replicas ; } public int getPort () { return this . port ; } public int getContainerPort () { return this . containerPort ; } public static final class Builder { private String image ; private int replicas = 1 ; private int port = 80 ; private int containerPort = 8080 ; public Builder image ( String image ) { this . image = image ; return this ; } public Builder replicas ( int replicas ) { this . replicas = replicas ; return this ; } public Builder port ( int port ) { this . port = port ; return this ; } public Builder containerPort ( int containerPort ) { this . containerPort = containerPort ; return this ; } public WebServiceProps build () { return new WebServiceProps ( image , replicas , port , containerPort ); } } } src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); new WebService ( this , \"hello\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); new WebService ( this , \"ghost\" , new WebServiceProps . Builder () . image ( \"ghost\" ) . containerPort ( 2368 ) . build ()); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"web-service-java\" ); app . synth (); } } As you can see, we now add define WebService constructs inside our chart: one that runs the paulbouwer/hello-kubernetes image and one with an installation of ghost .","title":"Getting Started"},{"location":"getting-started.html#getting-started","text":"This guide will walk you through the following steps: Installing the CDK8s CLI. Creating a new CDK8s project in one of the supported programming languages. Define & deploy your first CDK8s application. Define a custom CDK8s construct.","title":"Getting Started"},{"location":"getting-started.html#prerequisites","text":"TypeScript Node.js >= 10.x Your favorite editor/IDE yarn (optional) Python Python >= 3.7.7 pipenv version 2018.11.26 or above. Java Maven >= 3.6.3","title":"Prerequisites"},{"location":"getting-started.html#install-the-cli","text":"CDK8s has a cute little CLI that has a few useful commands. Let\u2019s start by installing the CDK8s CLI globally. We have two options for this. npm $ npm install -g cdk8s-cli yarn $ yarn global add cdk8s-cli","title":"Install the CLI"},{"location":"getting-started.html#new-project","text":"Now, we\u2019ll use the cdk8s init command to create a new CDK8s app: TypeScript $ mkdir hello $ cd hello $ cdk8s init typescript-app Initializing a project from the typescript-app template ... Since TypeScript is a compiled language, we will need to compile .ts files to .js in order to execute our CDK app. You can do that continuously in the background like this: $ npm run watch Python $ mkdir hello $ cd hello $ cdk8s init python-app Initializing a project from the python-app template ... Java $ mkdir hello $ cd hello $ cdk8s init java-app Initializing a project from the java-app template ... This will perform the following: Create a new project directory Install CDK8s as a dependency Import all Kubernetes API objects","title":"New Project"},{"location":"getting-started.html#apps-charts","text":"At this point, if you will see something like this: TypeScript main.ts import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); // define resources here } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Python main.py #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here app = App () MyChart ( app , \"hello\" ) app . synth () Java src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // define resources here } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } Apps are structured as a tree of constructs , which are composable units of abstraction. We will learn more about constructs soon. This initial code created by cdk8s init defines an app with a single, empty, chart. When you run cdk8s synth , a Kubernetes manifest YAML will be synthesized for each Chart in your app and will write it to the dist directory. You can try: $ cdk8s synth dist/hello.k8s.yaml $ cat dist/hello.k8s.yaml <EMPTY>","title":"Apps &amp; Charts"},{"location":"getting-started.html#importing-constructs-for-the-kubernetes-api","text":"OK, now let\u2019s define some Kubernetes API objects inside our chart. Similarly to charts and apps , Kubernetes API Objects are also represented in CDK8s as constructs . These constructs are imported to your project using the cdk8s import command which will add source files to your project that include constructs that represent the Kubernetes API. Info When cdk8s init created your project it already executed cdk8s import for you, so you should see an imports directory already there. You can either commit this directory to source-control or generate it as part of your build process. Now, let\u2019s use these constructs to define a simple Kubernetes application which contains Service and a Deployment resources inspired by paulbouwer \u2018s hello-kubernetes project. TypeScript import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; // imported constructs import { KubeDeployment , KubeService , IntOrString } from './imports/k8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); const label = { app : 'hello-k8s' }; new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port : 80 , targetPort : IntOrString.fromNumber ( 8080 ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas : 2 , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'hello-kubernetes' , image : 'paulbouwer/hello-kubernetes:1.7' , ports : [ { containerPort : 8080 } ] } ] } } } }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Python #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from imports import k8s class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here label = { \"app\" : \"hello-k8s\" } k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = 80 , target_port = k8s . IntOrString . from_number ( 8080 ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = 2 , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'hello-kubernetes' , image = 'paulbouwer/hello-kubernetes:1.7' , ports = [ k8s . ContainerPort ( container_port = 8080 )])])))) app = App () MyChart ( app , \"hello\" ) app . synth () Java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( 80 ) . targetPort ( IntOrString . fromNumber ( 8080 )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( 8080 ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"hello-kubernetes\" ) . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( 1 ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } Now, compile & synth this project: cdk8s synth Notice In compiled languages, like Java and TypeScript, you\u2019ll need to compile your program before running cdk8s synth . This will be contents of hello.k8s.yaml : apiVersion : \"v1\" kind : \"Service\" metadata : name : \"hello-service-c8c17160\" spec : ports : - port : 80 targetPort : 8080 selector : app : \"hello-k8s\" type : \"LoadBalancer\" --- apiVersion : \"apps/v1\" kind : \"Deployment\" metadata : name : \"hello-deployment-c8c7fda7\" spec : replicas : 2 selector : matchLabels : app : \"hello-k8s\" template : metadata : labels : app : \"hello-k8s\" spec : containers : - image : \"paulbouwer/hello-kubernetes:1.7\" name : \"hello-kubernetes\" ports : - containerPort : 8080 The manifest synthesized by your app is ready to be applied to any Kubernetes cluster using standard tools like kubectl apply : kubectl apply -f dist/hello.k8s.yaml","title":"Importing Constructs for the Kubernetes API"},{"location":"getting-started.html#abstraction-through-constructs","text":"Constructs are the basic building block of CDK8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years. So let\u2019s create our first Kubernetes construct. We\u2019ll call it WebService and it will basically be a generalization of the hello world program. It\u2019s actually quite useful. For example, this one line will add a hello world service to our chart: TypeScript new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' }); It can also be customized through an API: new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' , containerPort : 8080 , replicas : 10 }); Python WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' ) It can also be customized through an API: WebService ( self , 'hello-k8s' , image = 'paulbouwer/hello-kubernetes:1.7' , container_port = 8080 , replicas = 10 ) Java new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . build ()); It can also be customized through an API: new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); Here\u2019s how to implement WebService : TypeScript Create a file lib/web-service.ts (the convention is to use lib for reusable components): import { Construct } from 'constructs' ; import { Names } from 'cdk8s' ; import { KubeDeployment , KubeService , IntOrString } from '../imports/k8s' ; export interface WebServiceProps { /** * The Docker image to use for this service. */ readonly image : string ; /** * Number of replicas. * * @default 1 */ readonly replicas? : number ; /** * External port. * * @default 80 */ readonly port? : number ; /** * Internal port. * * @default 8080 */ readonly containerPort? : number ; } export class WebService extends Construct { constructor ( scope : Construct , id : string , props : WebServiceProps ) { super ( scope , id ); const port = props . port || 80 ; const containerPort = props . containerPort || 8080 ; const label = { app : Names.toDnsLabel ( this ) }; const replicas = props . replicas ?? 1 ; new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port , targetPort : IntOrString.fromNumber ( containerPort ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'app' , image : props.image , ports : [ { containerPort } ] } ] } } } }); } } Now, let\u2019s edit main.ts and use our new construct: import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; import { WebService } from './lib/web-service' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); new WebService ( this , 'hello' , { image : 'paulbouwer/hello-kubernetes:1.7' , replicas : 2 }); new WebService ( this , 'ghost' , { image : 'ghost' , containerPort : 2368 }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Python Create a file webservice.py with the following content: from constructs import Construct , Node from imports import k8s class WebService ( Construct ): def __init__ ( self , scope : Construct , id : str , * , image : str , replicas : int = 1 , port : int = 80 , container_port : int = 8080 ): super () . __init__ ( scope , id ) label = { 'app' : Node . of ( self ) . unique_id } k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = port , target_port = k8s . IntOrString . from_number ( container_port ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = replicas , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'app' , image = image , ports = [ k8s . ContainerPort ( container_port = container_port )])])))) Now, let\u2019s edit main.py and use our new construct: #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from webservice import WebService class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' , replicas = 2 ) WebService ( self , 'ghost' , image = 'ghost' , container_port = 2368 ) app = App () MyChart ( app , \"hello\" ) app . synth () Java src/main/java/com/mycompany/app/WebService.java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import java.util.Optional ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class WebService extends Construct { public WebService ( final Construct scope , final String id ) { this ( scope , id , null ); } public WebService ( final Construct scope , final String id , final WebServiceProps options ) { super ( scope , id ); final int portNumber = Optional . of ( options . getPort ()). orElse ( 80 ); final int containerPortNumber = Optional . of ( options . getContainerPort ()). orElse ( 8080 ); final int replicas = Optional . of ( options . getReplicas ()). orElse ( 1 ); final String image = options . getImage (); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( portNumber ) . targetPort ( IntOrString . fromNumber ( containerPortNumber )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( containerPortNumber ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"web\" ) . image ( image ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( replicas ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } } src/main/java/com/mycompany/app/WebServiceProps.java package com.mycompany.app ; public class WebServiceProps { private String image ; private int replicas ; private int port ; private int containerPort ; public WebServiceProps ( final String image , final int replicas , final int port , final int containerPort ) { this . image = image ; this . replicas = replicas ; this . port = port ; this . containerPort = containerPort ; } public String getImage () { return this . image ; } public int getReplicas () { return this . replicas ; } public int getPort () { return this . port ; } public int getContainerPort () { return this . containerPort ; } public static final class Builder { private String image ; private int replicas = 1 ; private int port = 80 ; private int containerPort = 8080 ; public Builder image ( String image ) { this . image = image ; return this ; } public Builder replicas ( int replicas ) { this . replicas = replicas ; return this ; } public Builder port ( int port ) { this . port = port ; return this ; } public Builder containerPort ( int containerPort ) { this . containerPort = containerPort ; return this ; } public WebServiceProps build () { return new WebServiceProps ( image , replicas , port , containerPort ); } } } src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); new WebService ( this , \"hello\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); new WebService ( this , \"ghost\" , new WebServiceProps . Builder () . image ( \"ghost\" ) . containerPort ( 2368 ) . build ()); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"web-service-java\" ); app . synth (); } } As you can see, we now add define WebService constructs inside our chart: one that runs the paulbouwer/hello-kubernetes image and one with an installation of ghost .","title":"Abstraction through Constructs"},{"location":"support.html","text":"Support \u00b6 Interacting with the community and the development team is a great way to contribute to the project. Please consider the following venues (in order): Search open issues Stack Overflow: cdk8s File a new issue Mailing list: cdk8s Slack: #cdk8s channel in cdk.dev","title":"Support"},{"location":"support.html#support","text":"Interacting with the community and the development team is a great way to contribute to the project. Please consider the following venues (in order): Search open issues Stack Overflow: cdk8s File a new issue Mailing list: cdk8s Slack: #cdk8s channel in cdk.dev","title":"Support"},{"location":"assets/logos/readme.html","text":"CDK8s Logos \u00b6 PNG SVG horizontal stacked icon horizontal stacked icon color black white","title":"CDK8s Logos"},{"location":"assets/logos/readme.html#cdk8s-logos","text":"PNG SVG horizontal stacked icon horizontal stacked icon color black white","title":"CDK8s Logos"},{"location":"cli/index.html","text":"Overview \u00b6 CDK8s is shipped with a command-line interface called cdk8s which can be used to work with CDK8s apps. The CLI is not required to use CDK8s but it includes some useful utilities.","title":"Overview"},{"location":"cli/index.html#overview","text":"CDK8s is shipped with a command-line interface called cdk8s which can be used to work with CDK8s apps. The CLI is not required to use CDK8s but it includes some useful utilities.","title":"Overview"},{"location":"cli/import.html","text":"import \u00b6 The import command generates low-level (L1) constructs for Kubernetes API objects and Custom Resources (CRDs). General Options \u00b6 Target programming language ( --language ) \u00b6 You can specify your desired language with the --language flag. For example: CLI: cdk8s import --language typescript cdk8s.yaml : language : typescript Output directory ( --output ) \u00b6 The --output (or -o ) option can be used to specify the output directory for your imports. Class name prefix ( --class-prefix ) \u00b6 For k8s imports, all imported classes will have a Kube prefix to denote that those are core Kubernetes APIs. For CRD imports, the class name will match the resource kind. You can use the --class-prefix option to specify an alternative prefix or --no-class-prefix to disable this behavior for k8s imports. Module name \u00b6 You can also override the default behavior for cdk8s importing. This will be helpful to you if you would like to name your CRD imports differently from their kind. Here is how you do it: CLI: cdk8s import example: = my_crd.yaml cdk8s.yaml : imports : - example:=my_crd.yaml If your CRD contained two kinds, Cluster and Autoscaler , you would have two imports. You could use them in this fashion: Typescript import { Cluster } from './imports/example-cluster' ; import { Autoscaler } from './imports/example-autoscaler' ; Python not yet supported Import Types \u00b6 The import command supports two types of imports: k8s : generates constructs from the core Kubernetes API CRDs: generates constructs from custom resource definitions This section describes specific behavior related to each type of import. Kubernetes APIs \u00b6 To generate constructs for all Kubernetes API objects of a certain version, use: cdk8s import k8s The import command will generate files under an \u201cimports\u201d directory inside your project with constructs for each API object in the Kubernetes spec. Note It is recommended to commit these generated files into your source control. By default, generated class names will be named KubeXyz where Xyz is the API object kind (e.g. KubeDeployment ). Kubernetes Versions \u00b6 Use the @version notation to import a specific Kubernetes version: cdk8s import k8s@1.16.0 Alternatively, you can specify your k8s import in the cdk8s.yaml config file: imports : - k8s@1.17.0 API Object Versions \u00b6 When importing the core Kubernetes API objects, cdk8s import will generate constructs both for stable APIs (e.g. v1 ) and pre-stable APIs ( v1beta1 ). To ensure compatibility across Kubernetes versions, construct classes generated for non-stable resources will include a postfix with the API level. For example, the import for k8s@1.18 includes KubeIngressV1Beta1 as the only Ingress resource. This is because Ingress has not been stabilized yet. The import for k8s@1.19 will also include an Ingress construct which represents the v1 resource. CRDs \u00b6 You can import CRDs from local files or URLs: cdk8s import my_crd.yaml Or from cdk8s.yaml : imports : - my_crd.yaml A CRD with group mygroup.io and kind Foo will be imported to the following locations: TypeScript: imports/mygroup.io.ts Python: imports/mygroup/io Importing CRDs from a cluster \u00b6 If the imported YAML is a List of CRDs, all these CRDs will be imported. This is useful, for example, to import all the CRDs from a running cluster: kubectl get crds -o json | cdk8s import /dev/stdin Yes, this works!","title":"import"},{"location":"cli/import.html#import","text":"The import command generates low-level (L1) constructs for Kubernetes API objects and Custom Resources (CRDs).","title":"import"},{"location":"cli/import.html#general-options","text":"","title":"General Options"},{"location":"cli/import.html#target-programming-language-language","text":"You can specify your desired language with the --language flag. For example: CLI: cdk8s import --language typescript cdk8s.yaml : language : typescript","title":"Target programming language (--language)"},{"location":"cli/import.html#output-directory-output","text":"The --output (or -o ) option can be used to specify the output directory for your imports.","title":"Output directory (--output)"},{"location":"cli/import.html#class-name-prefix-class-prefix","text":"For k8s imports, all imported classes will have a Kube prefix to denote that those are core Kubernetes APIs. For CRD imports, the class name will match the resource kind. You can use the --class-prefix option to specify an alternative prefix or --no-class-prefix to disable this behavior for k8s imports.","title":"Class name prefix (--class-prefix)"},{"location":"cli/import.html#module-name","text":"You can also override the default behavior for cdk8s importing. This will be helpful to you if you would like to name your CRD imports differently from their kind. Here is how you do it: CLI: cdk8s import example: = my_crd.yaml cdk8s.yaml : imports : - example:=my_crd.yaml If your CRD contained two kinds, Cluster and Autoscaler , you would have two imports. You could use them in this fashion: Typescript import { Cluster } from './imports/example-cluster' ; import { Autoscaler } from './imports/example-autoscaler' ; Python not yet supported","title":"Module name"},{"location":"cli/import.html#import-types","text":"The import command supports two types of imports: k8s : generates constructs from the core Kubernetes API CRDs: generates constructs from custom resource definitions This section describes specific behavior related to each type of import.","title":"Import Types"},{"location":"cli/import.html#kubernetes-apis","text":"To generate constructs for all Kubernetes API objects of a certain version, use: cdk8s import k8s The import command will generate files under an \u201cimports\u201d directory inside your project with constructs for each API object in the Kubernetes spec. Note It is recommended to commit these generated files into your source control. By default, generated class names will be named KubeXyz where Xyz is the API object kind (e.g. KubeDeployment ).","title":"Kubernetes APIs"},{"location":"cli/import.html#kubernetes-versions","text":"Use the @version notation to import a specific Kubernetes version: cdk8s import k8s@1.16.0 Alternatively, you can specify your k8s import in the cdk8s.yaml config file: imports : - k8s@1.17.0","title":"Kubernetes Versions"},{"location":"cli/import.html#api-object-versions","text":"When importing the core Kubernetes API objects, cdk8s import will generate constructs both for stable APIs (e.g. v1 ) and pre-stable APIs ( v1beta1 ). To ensure compatibility across Kubernetes versions, construct classes generated for non-stable resources will include a postfix with the API level. For example, the import for k8s@1.18 includes KubeIngressV1Beta1 as the only Ingress resource. This is because Ingress has not been stabilized yet. The import for k8s@1.19 will also include an Ingress construct which represents the v1 resource.","title":"API Object Versions"},{"location":"cli/import.html#crds","text":"You can import CRDs from local files or URLs: cdk8s import my_crd.yaml Or from cdk8s.yaml : imports : - my_crd.yaml A CRD with group mygroup.io and kind Foo will be imported to the following locations: TypeScript: imports/mygroup.io.ts Python: imports/mygroup/io","title":"CRDs"},{"location":"cli/import.html#importing-crds-from-a-cluster","text":"If the imported YAML is a List of CRDs, all these CRDs will be imported. This is useful, for example, to import all the CRDs from a running cluster: kubectl get crds -o json | cdk8s import /dev/stdin Yes, this works!","title":"Importing CRDs from a cluster"},{"location":"cli/init.html","text":"init \u00b6 This command creates new cdk8s projects from built-in templates: cdk8s init TEMPLATE The following example will create a new TypeScript app project: mkdir my-fun-little-project cd my-fun-little-project cdk8s init typescript-app","title":"init"},{"location":"cli/init.html#init","text":"This command creates new cdk8s projects from built-in templates: cdk8s init TEMPLATE The following example will create a new TypeScript app project: mkdir my-fun-little-project cd my-fun-little-project cdk8s init typescript-app","title":"init"},{"location":"cli/installation.html","text":"Installation \u00b6 To install the CLI use one of the following methods: npm npm i -g cdk8s-cli yarn yarn global add cdk8s-cli Homebrew brew install cdk8s Note: the latest version of the cdk8s cli available via Homebrew is 0.33.0 because Homebrew does not accept beta versions. Once a stable 1.0.0 version is released it will be available on Homebrew as well. In the meantime, please use npm or yarn to install the latest cli.","title":"Installation"},{"location":"cli/installation.html#installation","text":"To install the CLI use one of the following methods: npm npm i -g cdk8s-cli yarn yarn global add cdk8s-cli Homebrew brew install cdk8s Note: the latest version of the cdk8s cli available via Homebrew is 0.33.0 because Homebrew does not accept beta versions. Once a stable 1.0.0 version is released it will be available on Homebrew as well. In the meantime, please use npm or yarn to install the latest cli.","title":"Installation"},{"location":"cli/synth.html","text":"synth \u00b6 The cdk8s synth command is a convenience command which will simply execute the application defined in cdk8s.yaml under app . For example, if your cdk8s.yaml file looks like this: app : node app.js Then, cdk8s synth will execute node app.js .","title":"synth"},{"location":"cli/synth.html#synth","text":"The cdk8s synth command is a convenience command which will simply execute the application defined in cdk8s.yaml under app . For example, if your cdk8s.yaml file looks like this: app : node app.js Then, cdk8s synth will execute node app.js .","title":"synth"},{"location":"concepts/index.html","text":"Overview \u00b6 This section discusses core concepts in CDK8s.","title":"Overview"},{"location":"concepts/index.html#overview","text":"This section discusses core concepts in CDK8s.","title":"Overview"},{"location":"concepts/api-object.html","text":"ApiObject \u00b6 An ApiObject is a construct that represents an entry in a Kubernetes manifest (level 0). In most cases, you won\u2019t use ApiObject directly but rather use classes that are imported through cdk8s import and which extend this base class.","title":"ApiObject"},{"location":"concepts/api-object.html#apiobject","text":"An ApiObject is a construct that represents an entry in a Kubernetes manifest (level 0). In most cases, you won\u2019t use ApiObject directly but rather use classes that are imported through cdk8s import and which extend this base class.","title":"ApiObject"},{"location":"concepts/chart.html","text":"Chart \u00b6 The Chart is a container that synthesizes a single Kubernetes manifest. class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns ); // add contents here } } During synthesis, charts collect all the ApiObject nodes (recursively) and emit a single YAML manifest that includes all these objects. When a chart is defined, you can specify chart-level namespace and labels . Those will be applied to all API objects defined within the chart (recursively): class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns , { namespace : 'my-namespace' , labels : { app : 'my-app' , }, }); new ApiObject ( this , 'my-object' , { apiVersion : 'v1' , kind : 'Foo' }); } } Will synthesize into: apiVersion : v1 kind : Foo metadata : namespace : my-namespace labels : app : my-app","title":"Chart"},{"location":"concepts/chart.html#chart","text":"The Chart is a container that synthesizes a single Kubernetes manifest. class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns ); // add contents here } } During synthesis, charts collect all the ApiObject nodes (recursively) and emit a single YAML manifest that includes all these objects. When a chart is defined, you can specify chart-level namespace and labels . Those will be applied to all API objects defined within the chart (recursively): class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns , { namespace : 'my-namespace' , labels : { app : 'my-app' , }, }); new ApiObject ( this , 'my-object' , { apiVersion : 'v1' , kind : 'Foo' }); } } Will synthesize into: apiVersion : v1 kind : Foo metadata : namespace : my-namespace labels : app : my-app","title":"Chart"},{"location":"concepts/constructs.html","text":"Constructs \u00b6 Constructs are the basic building block of CDK8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years.","title":"Constructs"},{"location":"concepts/constructs.html#constructs","text":"Constructs are the basic building block of CDK8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years.","title":"Constructs"},{"location":"concepts/deps.html","text":"Dependencies \u00b6 You can declare dependencies between any two cdk8s constructs using the addDependency() method. ApiObjects \u00b6 For example, you can force kubernetes to first apply a Namespace before applying the Service in the scope of that namespace: const namespace = new k8s . Namespace ( chart , 'backend' ); const service = new k8s . Service ( chart , 'Service' , { metadata : { namespace : namespace.name }}); // declare the dependency. this is just a syntactic sugar for Node.of(service).addDependency(namespace) service . addDependency ( namespace ); cdk8s will ensure that the Namespace object is placed before the Service object in the resulting manifest: apiVersion : v1 kind : Namespace metadata : name : chart-backend-a59d2e47 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 namespace : chart-backend-a59d2e47 Charts \u00b6 You can also specify dependencies between charts, in exactly the same manner. For example, if we have a chart that provisions our namespace , we need that chart to be applied first: const namespaceChart = new NamespaceChart ( app , 'namespace' ); const applicationChart = new ApplicationChart ( app , 'application' ); // declare the dependency. this is just a syntactic sugar for Node.of(applicationChart).addDependency(namespaceChart) applicationChart . addDependency ( namespaceChart ); Running cdk8s synth will produce the following dist directory: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml Notice that the namespace chart appears first with the 0000 prefix. This will ensure that a subsequent execution of kubectl apply -f dist/ will apply the namespace first, and the application second. Custom Constructs \u00b6 The behavior above applies in the same way to custom constructs that you create or use. class Database extends Construct { constructor ( scope : Construct , name : string ) { super ( scope , name ); new k8s . StatefulSet ( this , 'StatefulSet' ); new k8s . ConfigMap ( this , 'ConfigMap' ); } } const app = new App (); const chart = new Chart ( app , 'Chart' ); const service = new k8s . Service ( chart , 'Service' ) const database = new Database ( chart , 'Database' ); service . addDependency ( database ); Declaring such a dependency will cause each ApiObject in the source construct, to depend on every ApiObject in the target construct. Note that in the example above, the source construct is actually an ApiObject , which is also ok since it is essentially a construct with a single ApiObject . Note that if the source of your dependency is a custom construct, it won\u2019t have the addDependency syntactic sugar by default, so you\u2019ll have to use Node.of() . The resulting manifest will be: apiVersion : apps/v1 kind : StatefulSet metadata : name : chart-database-statefulset-4627f8e2 --- apiVersion : v1 kind : ConfigMap metadata : name : chart-database-configmap-676f8640 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 You can see that all ApiObject s of the Database construct, appear before the Service object. Things just got cool \u00b6 If you simply declare a dependency between two ApiObject s (or Constructs ), that belong to two different Chart s, cdk8s will create the chart dependency automatically for you. const namespaceChart = new NamespaceChart ( app , 'namespace' ); const applicationChart = new ApplicationChart ( app , 'application' ); const namespace = new k8s . Namespace ( namespaceChart , 'namespace' ); const deployment = new k8s . Deployment ( applicationChart , 'Deployment' ); // dependency between ApiObjects, not Charts! deployment . addDependency ( namespace ); Running cdk8s synth will produce the same result as if explicit chart dependencies were declared: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml This means you need not be bothered with managing chart dependencies, simply work with the ApiObject s you create, and let cdk8s infer the chart dependencies.","title":"Dependencies"},{"location":"concepts/deps.html#dependencies","text":"You can declare dependencies between any two cdk8s constructs using the addDependency() method.","title":"Dependencies"},{"location":"concepts/deps.html#apiobjects","text":"For example, you can force kubernetes to first apply a Namespace before applying the Service in the scope of that namespace: const namespace = new k8s . Namespace ( chart , 'backend' ); const service = new k8s . Service ( chart , 'Service' , { metadata : { namespace : namespace.name }}); // declare the dependency. this is just a syntactic sugar for Node.of(service).addDependency(namespace) service . addDependency ( namespace ); cdk8s will ensure that the Namespace object is placed before the Service object in the resulting manifest: apiVersion : v1 kind : Namespace metadata : name : chart-backend-a59d2e47 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 namespace : chart-backend-a59d2e47","title":"ApiObjects"},{"location":"concepts/deps.html#charts","text":"You can also specify dependencies between charts, in exactly the same manner. For example, if we have a chart that provisions our namespace , we need that chart to be applied first: const namespaceChart = new NamespaceChart ( app , 'namespace' ); const applicationChart = new ApplicationChart ( app , 'application' ); // declare the dependency. this is just a syntactic sugar for Node.of(applicationChart).addDependency(namespaceChart) applicationChart . addDependency ( namespaceChart ); Running cdk8s synth will produce the following dist directory: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml Notice that the namespace chart appears first with the 0000 prefix. This will ensure that a subsequent execution of kubectl apply -f dist/ will apply the namespace first, and the application second.","title":"Charts"},{"location":"concepts/deps.html#custom-constructs","text":"The behavior above applies in the same way to custom constructs that you create or use. class Database extends Construct { constructor ( scope : Construct , name : string ) { super ( scope , name ); new k8s . StatefulSet ( this , 'StatefulSet' ); new k8s . ConfigMap ( this , 'ConfigMap' ); } } const app = new App (); const chart = new Chart ( app , 'Chart' ); const service = new k8s . Service ( chart , 'Service' ) const database = new Database ( chart , 'Database' ); service . addDependency ( database ); Declaring such a dependency will cause each ApiObject in the source construct, to depend on every ApiObject in the target construct. Note that in the example above, the source construct is actually an ApiObject , which is also ok since it is essentially a construct with a single ApiObject . Note that if the source of your dependency is a custom construct, it won\u2019t have the addDependency syntactic sugar by default, so you\u2019ll have to use Node.of() . The resulting manifest will be: apiVersion : apps/v1 kind : StatefulSet metadata : name : chart-database-statefulset-4627f8e2 --- apiVersion : v1 kind : ConfigMap metadata : name : chart-database-configmap-676f8640 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 You can see that all ApiObject s of the Database construct, appear before the Service object.","title":"Custom Constructs"},{"location":"concepts/deps.html#things-just-got-cool","text":"If you simply declare a dependency between two ApiObject s (or Constructs ), that belong to two different Chart s, cdk8s will create the chart dependency automatically for you. const namespaceChart = new NamespaceChart ( app , 'namespace' ); const applicationChart = new ApplicationChart ( app , 'application' ); const namespace = new k8s . Namespace ( namespaceChart , 'namespace' ); const deployment = new k8s . Deployment ( applicationChart , 'Deployment' ); // dependency between ApiObjects, not Charts! deployment . addDependency ( namespace ); Running cdk8s synth will produce the same result as if explicit chart dependencies were declared: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml This means you need not be bothered with managing chart dependencies, simply work with the ApiObject s you create, and let cdk8s infer the chart dependencies.","title":"Things just got cool"},{"location":"concepts/escape-hatches.html","text":"Escape Hatches \u00b6 An \u201cescape hatch\u201d is an intentional leak in the abstraction layer. It allows users to \u201cescape the abstraction\u201d and reach out to a lower layer. Similarly, in CDKs, escape hatches are mechanisms that allow users to tweak the synthesized output when the abstraction they use does not \u201chold water\u201d. You may need to use an escape hatch in the following cases: You are using an imported API object (e.g. KubeDeployment ) and there is an issue with the schema or a bug in \u201cimport\u201d which results in an invalid manifest or missing fields (as an example see issue #140 ). You are using a high-level API (e.g. CDK8s+) which does not expose some functionality which exists in the lower-level resources. Patching API objects directly \u00b6 The ApiObject class, which is the base of all objects synthesized into a Kubernetes manifest offers an API for patching the synthesized output at the wire level using JSON Patch ( RFC-6902 ): import { JsonPatch } from 'cdk8s' ; apiObject . addJsonPatch ( JsonPatch . replace ( '/foo' , 'bar' )); apiObject . addJsonPatch ( JsonPatch . add ( '/foo/bar/0' , { bar : 123 })); During synthesis, patches are applied in-order after the API object synthesized itself. All classes generated using the CLI import command extend ApiObject , and therefore include the addJsonPatch() method. Patching API objects behind higher-level APIs \u00b6 The second use case for using escape hatches is when you are working against a higher-level construct which, for some reason, does not allow you to achieve what you need. For example, let\u2019s say you are using the Pod class from CDK8s+ and you wish to set [ enableServiceLinks ] to true . This feature is currently not supported in the CDK8s+ Pod API, so you\u2019ll want to patch the underlying KubePod and set this value. To do that, you will need to \u201cpeak\u201d into the construct tree and find the underlying API object, so you can apply the patch to it: import { Pod } from 'cdk8s-plus-17' ; import { ApiObject } from 'cdk8s' ; const pod = new Pod (...); const kubePod = ApiObject . of ( pod ); kubePod . addJsonPatch (...); The ApiObject.of() method uses capabilities of the constructs programming model to find the \u201cdefault child\u201d of a construct ( Node.of(c).defaultChild ). When a construct is initialized, it can either explicitly assign the value of Node.of(this).defaultChild = xxx or it can use the identity Default for one of its child constructs. This will automatically identify it as the default child. Tip The ApiObject.of() method recursively searches down the construct tree through child constructs called Default until it finds a child of type ApiObject . This means, for example, that ApiObject.of(apiObject) returns the same object. There could be situations where a default child is not recorded by a high-level construct. This still does not mean you are blocked from patching the underlying API objects. You can still use Node.of(x) to traverse the construct tree to obtain the child. For example, you can use Node.of(x).findChild(id) to retrieve any child by its ID.","title":"Escape Hatches"},{"location":"concepts/escape-hatches.html#escape-hatches","text":"An \u201cescape hatch\u201d is an intentional leak in the abstraction layer. It allows users to \u201cescape the abstraction\u201d and reach out to a lower layer. Similarly, in CDKs, escape hatches are mechanisms that allow users to tweak the synthesized output when the abstraction they use does not \u201chold water\u201d. You may need to use an escape hatch in the following cases: You are using an imported API object (e.g. KubeDeployment ) and there is an issue with the schema or a bug in \u201cimport\u201d which results in an invalid manifest or missing fields (as an example see issue #140 ). You are using a high-level API (e.g. CDK8s+) which does not expose some functionality which exists in the lower-level resources.","title":"Escape Hatches"},{"location":"concepts/escape-hatches.html#patching-api-objects-directly","text":"The ApiObject class, which is the base of all objects synthesized into a Kubernetes manifest offers an API for patching the synthesized output at the wire level using JSON Patch ( RFC-6902 ): import { JsonPatch } from 'cdk8s' ; apiObject . addJsonPatch ( JsonPatch . replace ( '/foo' , 'bar' )); apiObject . addJsonPatch ( JsonPatch . add ( '/foo/bar/0' , { bar : 123 })); During synthesis, patches are applied in-order after the API object synthesized itself. All classes generated using the CLI import command extend ApiObject , and therefore include the addJsonPatch() method.","title":"Patching API objects directly"},{"location":"concepts/escape-hatches.html#patching-api-objects-behind-higher-level-apis","text":"The second use case for using escape hatches is when you are working against a higher-level construct which, for some reason, does not allow you to achieve what you need. For example, let\u2019s say you are using the Pod class from CDK8s+ and you wish to set [ enableServiceLinks ] to true . This feature is currently not supported in the CDK8s+ Pod API, so you\u2019ll want to patch the underlying KubePod and set this value. To do that, you will need to \u201cpeak\u201d into the construct tree and find the underlying API object, so you can apply the patch to it: import { Pod } from 'cdk8s-plus-17' ; import { ApiObject } from 'cdk8s' ; const pod = new Pod (...); const kubePod = ApiObject . of ( pod ); kubePod . addJsonPatch (...); The ApiObject.of() method uses capabilities of the constructs programming model to find the \u201cdefault child\u201d of a construct ( Node.of(c).defaultChild ). When a construct is initialized, it can either explicitly assign the value of Node.of(this).defaultChild = xxx or it can use the identity Default for one of its child constructs. This will automatically identify it as the default child. Tip The ApiObject.of() method recursively searches down the construct tree through child constructs called Default until it finds a child of type ApiObject . This means, for example, that ApiObject.of(apiObject) returns the same object. There could be situations where a default child is not recorded by a high-level construct. This still does not mean you are blocked from patching the underlying API objects. You can still use Node.of(x) to traverse the construct tree to obtain the child. For example, you can use Node.of(x).findChild(id) to retrieve any child by its ID.","title":"Patching API objects behind higher-level APIs"},{"location":"concepts/helm.html","text":"Helm Support \u00b6 You can use the Helm construct in order to include Helm charts. In order to use this construct, you must have helm installed on your system. See Installing Helm in the Helm documentation for details. The following example adds the bitnami/redis Helm chart with sentinel containers enabled: The Bitnami helm repo needs to be added through: helm repo add bitnami https://charts.bitnami.com/bitnami class MyChart extends cdk8s . Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const redis = new Helm ( this , 'redis' , { chart : 'bitnami/redis' , values : { sentinel : { enabled : true } } }); } } The Helm construct will render the manifest from the specified chart by executing helm template . If values is specified, these values will override the default values included with the chart. The name option can be used to specify the chart\u2019s release name . If not specified, a valid and unique release name will be allocated based on the construct path. The Helm construct extends Include and inherits it\u2019s API. For example, you can use the apiObjects property to find and interact with included API objects. The following example shows how to add an annotation to the Redis master deployment: const master = redis . apiObjects . find ( o => o . name === 'foo-redis-master' ); master . metadata . addAnnotation ( 'my.annotation' , 'hey-there' );","title":"Helm Support"},{"location":"concepts/helm.html#helm-support","text":"You can use the Helm construct in order to include Helm charts. In order to use this construct, you must have helm installed on your system. See Installing Helm in the Helm documentation for details. The following example adds the bitnami/redis Helm chart with sentinel containers enabled: The Bitnami helm repo needs to be added through: helm repo add bitnami https://charts.bitnami.com/bitnami class MyChart extends cdk8s . Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const redis = new Helm ( this , 'redis' , { chart : 'bitnami/redis' , values : { sentinel : { enabled : true } } }); } } The Helm construct will render the manifest from the specified chart by executing helm template . If values is specified, these values will override the default values included with the chart. The name option can be used to specify the chart\u2019s release name . If not specified, a valid and unique release name will be allocated based on the construct path. The Helm construct extends Include and inherits it\u2019s API. For example, you can use the apiObjects property to find and interact with included API objects. The following example shows how to add an annotation to the Redis master deployment: const master = redis . apiObjects . find ( o => o . name === 'foo-redis-master' ); master . metadata . addAnnotation ( 'my.annotation' , 'hey-there' );","title":"Helm Support"},{"location":"concepts/include.html","text":"Include \u00b6 The Include construct can be used to include an existing manifest in a chart. The following example will include the Kubernetes Dashboard in MyChart : import { Include } from 'cdk8s' ; class MyChart extends Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const dashboard = new Include ( this , 'dashboard' , { url : 'https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml' , // or url : 'dashboard.yaml' }); // ...other resources } } All API objects defined in the included manifest will be added as children ApiObject s under the Include construct\u2019s scope and can be accessed through the apiObject property: The following example queries for all the Deployment resources in the dashboard: const deploymentApiObject = dashboard . apiObjects . find ( c => c . kind === ' Deployment ); NOTE: names of included objects ( metadata.name ) are preserved. This means that if you try to include the same manifest twice into the same chart, your manifest will have duplicate definitions of the same objects.","title":"Include"},{"location":"concepts/include.html#include","text":"The Include construct can be used to include an existing manifest in a chart. The following example will include the Kubernetes Dashboard in MyChart : import { Include } from 'cdk8s' ; class MyChart extends Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const dashboard = new Include ( this , 'dashboard' , { url : 'https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml' , // or url : 'dashboard.yaml' }); // ...other resources } } All API objects defined in the included manifest will be added as children ApiObject s under the Include construct\u2019s scope and can be accessed through the apiObject property: The following example queries for all the Deployment resources in the dashboard: const deploymentApiObject = dashboard . apiObjects . find ( c => c . kind === ' Deployment ); NOTE: names of included objects ( metadata.name ) are preserved. This means that if you try to include the same manifest twice into the same chart, your manifest will have duplicate definitions of the same objects.","title":"Include"},{"location":"concepts/testing.html","text":"Testing \u00b6 cdk8s bundles a set of test utilities under the Testing class: Testing.app() returns an App object bound to a temporary output directory. Testing.chart() returns a Chart object bound to a testing app. Testing.synth(chart) returns the Kubernetes manifest synthesized from a chart.","title":"Testing"},{"location":"concepts/testing.html#testing","text":"cdk8s bundles a set of test utilities under the Testing class: Testing.app() returns an App object bound to a temporary output directory. Testing.chart() returns a Chart object bound to a testing app. Testing.synth(chart) returns the Kubernetes manifest synthesized from a chart.","title":"Testing"},{"location":"examples/index.html","text":"CDK8s Examples Directory \u00b6 This section includes various examples for CDK8s and CDK8s+.","title":"Overview"},{"location":"examples/index.html#cdk8s-examples-directory","text":"This section includes various examples for CDK8s and CDK8s+.","title":"CDK8s Examples Directory"},{"location":"examples/crd.html","text":"CRDs \u00b6 Shows how to import and use Custom Resource Definitions TypeScript Python Java Note We try to maintain the same set of examples in all supported languages. Help us!","title":"CRDs"},{"location":"examples/crd.html#crds","text":"Shows how to import and use Custom Resource Definitions TypeScript Python Java Note We try to maintain the same set of examples in all supported languages. Help us!","title":"CRDs"},{"location":"examples/hello.html","text":"Hello, Kubernetes! \u00b6 Deploys hello-kubernetes as a Service behind a LoadBalancer. TypeScript Python Java Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Hello, Kubernetes!"},{"location":"examples/hello.html#hello-kubernetes","text":"Deploys hello-kubernetes as a Service behind a LoadBalancer. TypeScript Python Java Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Hello, Kubernetes!"},{"location":"examples/plus-elasticsearch.html","text":"Elasticsearch (CDK8s+) \u00b6 Creating a query service on top of Elasticsearch with CDK8s+ TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Elasticsearch (CDK8s+)"},{"location":"examples/plus-elasticsearch.html#elasticsearch-cdk8s","text":"Creating a query service on top of Elasticsearch with CDK8s+ TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Elasticsearch (CDK8s+)"},{"location":"examples/plus-ingress.html","text":"Ingress (CDK8s+) \u00b6 Example of using CDK8s+ Ingress resource. TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Ingress (CDK8s+)"},{"location":"examples/plus-ingress.html#ingress-cdk8s","text":"Example of using CDK8s+ Ingress resource. TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Ingress (CDK8s+)"},{"location":"examples/podinfo.html","text":"Podinfo \u00b6 Exploration of high-level APIs for Deployment , Service , AutoScaler and Ingress based on the podinfo project . TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Podinfo"},{"location":"examples/podinfo.html#podinfo","text":"Exploration of high-level APIs for Deployment , Service , AutoScaler and Ingress based on the podinfo project . TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Podinfo"},{"location":"examples/web-service.html","text":"WebService Abstraction \u00b6 Demonstrates how to make your first high-level construct which represents a web service which abstracts the hello example from earlier into a reusable piece of infrastructure. TypeScript Python Java Note We try to maintain the same set of examples in all supported languages. Help us!","title":"WebService Abstraction"},{"location":"examples/web-service.html#webservice-abstraction","text":"Demonstrates how to make your first high-level construct which represents a web service which abstracts the hello example from earlier into a reusable piece of infrastructure. TypeScript Python Java Note We try to maintain the same set of examples in all supported languages. Help us!","title":"WebService Abstraction"},{"location":"plus/index.html","text":"Overview \u00b6 cdk8s+ is a library with high level abstractions for authoring Kubernetes applications. Built on top of the auto-generated building blocks provided by CDK8s, this library includes a hand crafted construct for each native kubernetes object, exposing richer API\u2019s with reduced complexity. cdk8s+ is vended as a separate library for each kubernetes spec version. The documentation presented here represents version 1.17.0 and is vended as the cdk8s-plus-17 library. Naming conventions \u00b6 Stable resources are represented by a construct of the same kind . For example, the io.k8s.api.core.v1.Pod resource maps to the Pod construct . Non stable resources are suffixed with their api version . For example, the io.k8s.api.networking.v1beta1.Ingress maps to the IngressV1Beta1 construct . Spec Compatibility \u00b6 Per kubernetes compatibility guarantees , stable resources in this library are compatible with any spec version higher or equal to 1.17.0 . Non-stable resources are not guaranteed to be compatible, as they may be removed in future spec versions. Notice If you are deploying manifests produced by cdk8s-plus-17 onto clusters of a lower version, you might encounter some unsupported spec properties or invalid manifests. At a glance \u00b6 import * as kplus from 'cdk8s-plus-17' ; import * as cdk8s from 'cdk8s' ; import * as path from 'path' ; // our cdk app const app = new cdk8s . App (); // our kubernetes chart const chart = new cdk8s . Chart ( app , 'my-chart' ); // lets create a volume that contains our app. // we use a trick with a config map! const appData = new kplus . ConfigMap ( chart , 'AppData' ); appData . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appData ); // lets create a deployment to run a few instances of a pod const deployment = new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , }); // now we create a container that runs our app const appPath = '/var/lib/app' ; const port = 80 ; const container = deployment . addContainer ({ image : 'node:14.4.0-alpine3.12' , command : [ 'node' , 'index.js' , ` ${ port } ` ], port : port , workingDir : appPath , }); // make the app accessible to the container container . mount ( appPath , appVolume ); // finally, we expose the deployment as a load balancer service and make it run deployment . expose ( 8080 , { serviceType : kplus.ServiceType.LOAD_BALANCER }) // we are done, synth app . synth (); dist/my-chart.yaml apiVersion : v1 data : index.js : |- var http = require('http'); var port = process.argv[2]; //create a server object: http.createServer(function (req, res) { res.write('Hello World!'); //write a response to the client res.end(); //end the response }).listen(port); //the server object listens on port 80 kind : ConfigMap metadata : annotations : {} labels : {} name : chart-appdata-configmap-da4c63ab --- apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-deployment-pod-d4285cc9 spec : replicas : 3 selector : matchLabels : cdk8s.deployment : ChartDeploymentCFC2E30C template : metadata : annotations : {} labels : cdk8s.deployment : ChartDeploymentCFC2E30C spec : containers : - command : - node - index.js - \"80\" env : [] image : node:14.4.0-alpine3.12 name : main ports : - containerPort : 80 volumeMounts : - mountPath : /var/lib/app name : configmap-chart-appdata-configmap-da4c63ab workingDir : /var/lib/app volumes : - configMap : name : chart-appdata-configmap-da4c63ab name : configmap-chart-appdata-configmap-da4c63ab --- apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-deployment-service-pod-42f50c26 spec : externalIPs : [] ports : - port : 8080 targetPort : 80 selector : cdk8s.deployment : ChartDeploymentCFC2E30C type : LoadBalancer Getting Started \u00b6 TypeScript/JavaScript \u276f npm install cdk8s-plus-17 cdk8s import * as kplus from 'cdk8s-plus-17' ; import * as cdk8s from 'cdk8s' ; const app = new cdk8s . App (); const chart = new cdk8s . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , containers : [{ image : 'ubuntu' , }], }); Python \u276f pip install --pre cdk8s-plus-17 cdk8s import cdk8s_plus_17 as kplus import cdk8s app = cdk8s . App () chart = cdk8s . Chart ( app , 'Chart' ) kplus . Deployment ( chart , 'Deployment' , replicas = 1 , containers = [ kplus . Container ( image = 'ubuntu' )] )","title":"Overview"},{"location":"plus/index.html#overview","text":"cdk8s+ is a library with high level abstractions for authoring Kubernetes applications. Built on top of the auto-generated building blocks provided by CDK8s, this library includes a hand crafted construct for each native kubernetes object, exposing richer API\u2019s with reduced complexity. cdk8s+ is vended as a separate library for each kubernetes spec version. The documentation presented here represents version 1.17.0 and is vended as the cdk8s-plus-17 library.","title":"Overview"},{"location":"plus/index.html#naming-conventions","text":"Stable resources are represented by a construct of the same kind . For example, the io.k8s.api.core.v1.Pod resource maps to the Pod construct . Non stable resources are suffixed with their api version . For example, the io.k8s.api.networking.v1beta1.Ingress maps to the IngressV1Beta1 construct .","title":"Naming conventions"},{"location":"plus/index.html#spec-compatibility","text":"Per kubernetes compatibility guarantees , stable resources in this library are compatible with any spec version higher or equal to 1.17.0 . Non-stable resources are not guaranteed to be compatible, as they may be removed in future spec versions. Notice If you are deploying manifests produced by cdk8s-plus-17 onto clusters of a lower version, you might encounter some unsupported spec properties or invalid manifests.","title":"Spec Compatibility"},{"location":"plus/index.html#at-a-glance","text":"import * as kplus from 'cdk8s-plus-17' ; import * as cdk8s from 'cdk8s' ; import * as path from 'path' ; // our cdk app const app = new cdk8s . App (); // our kubernetes chart const chart = new cdk8s . Chart ( app , 'my-chart' ); // lets create a volume that contains our app. // we use a trick with a config map! const appData = new kplus . ConfigMap ( chart , 'AppData' ); appData . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appData ); // lets create a deployment to run a few instances of a pod const deployment = new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , }); // now we create a container that runs our app const appPath = '/var/lib/app' ; const port = 80 ; const container = deployment . addContainer ({ image : 'node:14.4.0-alpine3.12' , command : [ 'node' , 'index.js' , ` ${ port } ` ], port : port , workingDir : appPath , }); // make the app accessible to the container container . mount ( appPath , appVolume ); // finally, we expose the deployment as a load balancer service and make it run deployment . expose ( 8080 , { serviceType : kplus.ServiceType.LOAD_BALANCER }) // we are done, synth app . synth (); dist/my-chart.yaml apiVersion : v1 data : index.js : |- var http = require('http'); var port = process.argv[2]; //create a server object: http.createServer(function (req, res) { res.write('Hello World!'); //write a response to the client res.end(); //end the response }).listen(port); //the server object listens on port 80 kind : ConfigMap metadata : annotations : {} labels : {} name : chart-appdata-configmap-da4c63ab --- apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-deployment-pod-d4285cc9 spec : replicas : 3 selector : matchLabels : cdk8s.deployment : ChartDeploymentCFC2E30C template : metadata : annotations : {} labels : cdk8s.deployment : ChartDeploymentCFC2E30C spec : containers : - command : - node - index.js - \"80\" env : [] image : node:14.4.0-alpine3.12 name : main ports : - containerPort : 80 volumeMounts : - mountPath : /var/lib/app name : configmap-chart-appdata-configmap-da4c63ab workingDir : /var/lib/app volumes : - configMap : name : chart-appdata-configmap-da4c63ab name : configmap-chart-appdata-configmap-da4c63ab --- apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-deployment-service-pod-42f50c26 spec : externalIPs : [] ports : - port : 8080 targetPort : 80 selector : cdk8s.deployment : ChartDeploymentCFC2E30C type : LoadBalancer","title":"At a glance"},{"location":"plus/index.html#getting-started","text":"TypeScript/JavaScript \u276f npm install cdk8s-plus-17 cdk8s import * as kplus from 'cdk8s-plus-17' ; import * as cdk8s from 'cdk8s' ; const app = new cdk8s . App (); const chart = new cdk8s . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , containers : [{ image : 'ubuntu' , }], }); Python \u276f pip install --pre cdk8s-plus-17 cdk8s import cdk8s_plus_17 as kplus import cdk8s app = cdk8s . App () chart = cdk8s . Chart ( app , 'Chart' ) kplus . Deployment ( chart , 'Deployment' , replicas = 1 , containers = [ kplus . Container ( image = 'ubuntu' )] )","title":"Getting Started"},{"location":"plus/config-map.html","text":"ConfigMap \u00b6 ConfigMap are used to store configuration data. They provide a dictionary based data structure that can be consumed in various shapes and forms. API Reference Use an existing ConfigMap \u00b6 You can reference to an existing ConfigMap like so. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-17' ; const config : kplus.IConfigMap = kplus . ConfigMap . fromConfigMapName ( 'config' ); // the 'config' constant can later be used by API's that require an IConfigMap. // for example when creating a volume. const volume = kplus . Volume . fromConfigMap ( config ); Adding data \u00b6 You can create config maps and add some data to them like so: import * as kplus from 'cdk8s-plus-17' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const config = new new kplus . ConfigMap ( chart , 'Config' ); config . addData ( 'url' , 'https://my-endpoint:8080' ); Creating a volume from a directory \u00b6 Here is a nifty little trick you can use to create a volume that contains a directory on the client machine (machine that runs cdk8s synth ): import * as kplus from 'cdk8s-plus-17' ; import * as k from 'cdk8s' ; import * as path from 'path' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const appMap = new new kplus . ConfigMap ( chart , 'Config' ); // add the files in the directory to the config map. // this will create a key for each file. // note that only top level files will be included, sub-directories are not yet supported. appMap . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appMap ); const mountPath = '/var/app' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , command : [ 'node' , 'app.js' ], workingDir : mountPath , }); // from here, just mount the volume to a container, and run your app! container . mount ( mountPath , appVolume );","title":"ConfigMap"},{"location":"plus/config-map.html#configmap","text":"ConfigMap are used to store configuration data. They provide a dictionary based data structure that can be consumed in various shapes and forms. API Reference","title":"ConfigMap"},{"location":"plus/config-map.html#use-an-existing-configmap","text":"You can reference to an existing ConfigMap like so. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-17' ; const config : kplus.IConfigMap = kplus . ConfigMap . fromConfigMapName ( 'config' ); // the 'config' constant can later be used by API's that require an IConfigMap. // for example when creating a volume. const volume = kplus . Volume . fromConfigMap ( config );","title":"Use an existing ConfigMap"},{"location":"plus/config-map.html#adding-data","text":"You can create config maps and add some data to them like so: import * as kplus from 'cdk8s-plus-17' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const config = new new kplus . ConfigMap ( chart , 'Config' ); config . addData ( 'url' , 'https://my-endpoint:8080' );","title":"Adding data"},{"location":"plus/config-map.html#creating-a-volume-from-a-directory","text":"Here is a nifty little trick you can use to create a volume that contains a directory on the client machine (machine that runs cdk8s synth ): import * as kplus from 'cdk8s-plus-17' ; import * as k from 'cdk8s' ; import * as path from 'path' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const appMap = new new kplus . ConfigMap ( chart , 'Config' ); // add the files in the directory to the config map. // this will create a key for each file. // note that only top level files will be included, sub-directories are not yet supported. appMap . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appMap ); const mountPath = '/var/app' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , command : [ 'node' , 'app.js' ], workingDir : mountPath , }); // from here, just mount the volume to a container, and run your app! container . mount ( mountPath , appVolume );","title":"Creating a volume from a directory"},{"location":"plus/container.html","text":"Container \u00b6 Define containers that run in a pod using the Container class. API Reference Environment variables \u00b6 Environment variables can be added to containers using various sources, via semantically explicit API\u2019s: import * as kplus from 'cdk8s-plus-17' const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }); // explicitly use a value. container . addEnv ( 'endpoint' , kplus . EnvValue . fromValue ( 'value' )); // use a specific key from a config map. const backendsConfig = kplus . ConfigMap . fromConfigMapName ( 'backends' ); container . addEnv ( 'endpoint' , kplus . EnvValue . fromConfigMap ( backendsConfig , 'endpoint' )); // use a specific key from a secret. const credentials = kplus . Secret . fromSecretName ( 'credentials' ); container . addEnv ( 'password' , kplus . EnvValue . fromSecret ( credentials , 'password' )); Volume Mounts \u00b6 A very common capability is to mount a volume with some data onto a container. Using pure kubernetes API, this would require writing something like: kind : Pod apiVersion : v1 spec : containers : - name : main volumeMounts : - mountPath : /path/to/mount name : 'config-volume' volumes : - name : 'config-volume' configMap : name : 'config' Notice the apparent redundancy of having to specify the volume name twice. Also, if you happen to need the same mount in other pods, you would need to duplicate this configuration. This can get complex and cluttered very fast. In contrast, here is how to do this with cdk8s+ : import * as kplus from 'cdk8s-plus-17' ; const config = kplus . ConfigMap . fromConfigMapName ( 'config' ); const volume = kplus . Volume . fromConfigMap ( config ); const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }) // Cool alert: every pod that will later be configured with this container, // will automatically have access to this volume, so you don't need to explicitly add it to the pod spec!. container . mount ( '/path/to/mount' , volume ); Probes \u00b6 A Probe is a diagnostic performed periodically by the kubelet on a Container. To perform a diagnostic, the kubelet calls a Handler implemented by the container. A Probe instance can be created through one of the fromXxx static methods: Probe.fromHttpGet() Probe.fromCommand() Readiness, liveness, and startup probes can be configured at the container-level through the readiness , liveness , and startup options: new kplus . Pod ( this , 'Pod' , { containers : [ { // ... readiness : kplus.Probe.fromHttpGet ( '/ping' ), } ] }); See the API reference for details.","title":"Container"},{"location":"plus/container.html#container","text":"Define containers that run in a pod using the Container class. API Reference","title":"Container"},{"location":"plus/container.html#environment-variables","text":"Environment variables can be added to containers using various sources, via semantically explicit API\u2019s: import * as kplus from 'cdk8s-plus-17' const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }); // explicitly use a value. container . addEnv ( 'endpoint' , kplus . EnvValue . fromValue ( 'value' )); // use a specific key from a config map. const backendsConfig = kplus . ConfigMap . fromConfigMapName ( 'backends' ); container . addEnv ( 'endpoint' , kplus . EnvValue . fromConfigMap ( backendsConfig , 'endpoint' )); // use a specific key from a secret. const credentials = kplus . Secret . fromSecretName ( 'credentials' ); container . addEnv ( 'password' , kplus . EnvValue . fromSecret ( credentials , 'password' ));","title":"Environment variables"},{"location":"plus/container.html#volume-mounts","text":"A very common capability is to mount a volume with some data onto a container. Using pure kubernetes API, this would require writing something like: kind : Pod apiVersion : v1 spec : containers : - name : main volumeMounts : - mountPath : /path/to/mount name : 'config-volume' volumes : - name : 'config-volume' configMap : name : 'config' Notice the apparent redundancy of having to specify the volume name twice. Also, if you happen to need the same mount in other pods, you would need to duplicate this configuration. This can get complex and cluttered very fast. In contrast, here is how to do this with cdk8s+ : import * as kplus from 'cdk8s-plus-17' ; const config = kplus . ConfigMap . fromConfigMapName ( 'config' ); const volume = kplus . Volume . fromConfigMap ( config ); const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }) // Cool alert: every pod that will later be configured with this container, // will automatically have access to this volume, so you don't need to explicitly add it to the pod spec!. container . mount ( '/path/to/mount' , volume );","title":"Volume Mounts"},{"location":"plus/container.html#probes","text":"A Probe is a diagnostic performed periodically by the kubelet on a Container. To perform a diagnostic, the kubelet calls a Handler implemented by the container. A Probe instance can be created through one of the fromXxx static methods: Probe.fromHttpGet() Probe.fromCommand() Readiness, liveness, and startup probes can be configured at the container-level through the readiness , liveness , and startup options: new kplus . Pod ( this , 'Pod' , { containers : [ { // ... readiness : kplus.Probe.fromHttpGet ( '/ping' ), } ] }); See the API reference for details.","title":"Probes"},{"location":"plus/deployment.html","text":"Deployment \u00b6 Create a deployment to govern the lifecycle and orchestration of a set of identical pods. API Reference Automatic pod selection \u00b6 When you specify pods in a deployment, you normally have to configure the appropriate labels and selectors to make the deployment control the relevant pods. This construct does this automatically. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'FrontEnds' , { containers : [ { image : 'node' } ], }); Note the resulting manifest contains a special cdk8s.deployment label that is applied to the pods, and is used as the selector for the deployment. apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-frontends-pod-a48e7f2e spec : replicas : 1 selector : matchLabels : cdk8s.deployment : ChartFrontEndsDD8A97CE template : metadata : annotations : {} labels : cdk8s.deployment : ChartFrontEndsDD8A97CE Exposing via a service \u00b6 Following up on pod selection, you can also easily create a service that will select the pods relevant to the deployment. // store the deployment to created in a constant const frontends = new kplus . Deployment ( chart , 'FrontEnds' ); // create a ClusterIP service that listens on port 9000 and redirects to port 9000 on the containers. frontends . expose ( 9000 ) Notice the resulting manifest, will have the same cdk8s.deployment magic label as the selector. This will cause the service to attach to the pods that were configured as part of the said deployment. apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-frontends-service-pod-1f70150b spec : externalIPs : [] ports : - port : 9000 selector : cdk8s.deployment : ChartFrontEndsDD8A97CE type : ClusterIP","title":"Deployment"},{"location":"plus/deployment.html#deployment","text":"Create a deployment to govern the lifecycle and orchestration of a set of identical pods. API Reference","title":"Deployment"},{"location":"plus/deployment.html#automatic-pod-selection","text":"When you specify pods in a deployment, you normally have to configure the appropriate labels and selectors to make the deployment control the relevant pods. This construct does this automatically. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'FrontEnds' , { containers : [ { image : 'node' } ], }); Note the resulting manifest contains a special cdk8s.deployment label that is applied to the pods, and is used as the selector for the deployment. apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-frontends-pod-a48e7f2e spec : replicas : 1 selector : matchLabels : cdk8s.deployment : ChartFrontEndsDD8A97CE template : metadata : annotations : {} labels : cdk8s.deployment : ChartFrontEndsDD8A97CE","title":"Automatic pod selection"},{"location":"plus/deployment.html#exposing-via-a-service","text":"Following up on pod selection, you can also easily create a service that will select the pods relevant to the deployment. // store the deployment to created in a constant const frontends = new kplus . Deployment ( chart , 'FrontEnds' ); // create a ClusterIP service that listens on port 9000 and redirects to port 9000 on the containers. frontends . expose ( 9000 ) Notice the resulting manifest, will have the same cdk8s.deployment magic label as the selector. This will cause the service to attach to the pods that were configured as part of the said deployment. apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-frontends-service-pod-1f70150b spec : externalIPs : [] ports : - port : 9000 selector : cdk8s.deployment : ChartFrontEndsDD8A97CE type : ClusterIP","title":"Exposing via a service"},{"location":"plus/ingress.html","text":"Ingress \u00b6 Ingress manages external access to services in a cluster, typically through HTTP. Ingress may provide load balancing, SSL termination and name-based virtual hosting. API Reference You must have an Ingress controller to satisfy an Ingress. Only creating an Ingress resource has no effect. The following example will route HTTP requests sent to the /hello url prefix to a service associated with a deployment of the hashicorp/http-echo image. const helloDeployment = new kplus . Deployment ( this , text , { containers : [ { image : 'hashicorp/http-echo' , args : [ '-text' , 'hello ingress' ] } ] }); const helloService = helloDeployment . expose ( 5678 ); const ingress = new IngressV1Beta1 ( this , 'ingress' ); ingress . addRule ( '/hello' , kplus . IngressV1Beta1Backend . fromService ( helloService )); You can use addHostRule(host, path, backend) to define a route that will only apply to requests with this Host header. This can be used to implement virtual hosts. The addDefaultBackend(backend) and addHostDefaultBackend(host, backend) methods can be used to define backends that will accept all requests that do not match any other rules. The TCP port used to route requests to services will be determined based on which ports are exposed by the service (e.g. through serve() ). If the service exposes multiple ports, then a port must be specified via IngressBackend.fromService(service, { port } .","title":"Ingress"},{"location":"plus/ingress.html#ingress","text":"Ingress manages external access to services in a cluster, typically through HTTP. Ingress may provide load balancing, SSL termination and name-based virtual hosting. API Reference You must have an Ingress controller to satisfy an Ingress. Only creating an Ingress resource has no effect. The following example will route HTTP requests sent to the /hello url prefix to a service associated with a deployment of the hashicorp/http-echo image. const helloDeployment = new kplus . Deployment ( this , text , { containers : [ { image : 'hashicorp/http-echo' , args : [ '-text' , 'hello ingress' ] } ] }); const helloService = helloDeployment . expose ( 5678 ); const ingress = new IngressV1Beta1 ( this , 'ingress' ); ingress . addRule ( '/hello' , kplus . IngressV1Beta1Backend . fromService ( helloService )); You can use addHostRule(host, path, backend) to define a route that will only apply to requests with this Host header. This can be used to implement virtual hosts. The addDefaultBackend(backend) and addHostDefaultBackend(host, backend) methods can be used to define backends that will accept all requests that do not match any other rules. The TCP port used to route requests to services will be determined based on which ports are exposed by the service (e.g. through serve() ). If the service exposes multiple ports, then a port must be specified via IngressBackend.fromService(service, { port } .","title":"Ingress"},{"location":"plus/job.html","text":"Job \u00b6 Jobs are a very useful concept in kubernetes deployments. They can be used for add-hoc provisioning tasks, as well as long running processing jobs. In configuration, they don\u2019t differ much from regular pods, but offer some additional properties. API Reference Delete a Job after its finished \u00b6 You can configure a TTL for the job after it finished its execution successfully. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // let's define a job spec, and set a 1 second TTL. const load = new kplus . Job ( chart , 'LoadData' , { ttlAfterFinished : kplus.Duration.seconds ( 1 ) }); // now add a container to all the pods created by this job job . addContainer ({ image : 'loader' });","title":"Job"},{"location":"plus/job.html#job","text":"Jobs are a very useful concept in kubernetes deployments. They can be used for add-hoc provisioning tasks, as well as long running processing jobs. In configuration, they don\u2019t differ much from regular pods, but offer some additional properties. API Reference","title":"Job"},{"location":"plus/job.html#delete-a-job-after-its-finished","text":"You can configure a TTL for the job after it finished its execution successfully. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // let's define a job spec, and set a 1 second TTL. const load = new kplus . Job ( chart , 'LoadData' , { ttlAfterFinished : kplus.Duration.seconds ( 1 ) }); // now add a container to all the pods created by this job job . addContainer ({ image : 'loader' });","title":"Delete a Job after its finished"},{"location":"plus/pod.html","text":"Pod \u00b6 A pod is essentially a collection of containers. It is the most fundamental computation unit that can be provisioned. API Reference Adding Containers/Volumes \u00b6 Containers and volumes can be added to pod definition like so: import * as kplus from 'cdk8s-plus-17' ; const pod = new new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , }); const storage = kplus . Volume . fromEmptyDir ( 'storage' ); container . mount ( '/data' , storage ); const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // this will automatically add the volume as well. pod . addContainer ( container ); // but if you want to explicitly add it, simply use: pod . addVolume ( storage ); Applying a restart policy \u00b6 import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new new kplus . Pod ( chart , 'Pod' , { restartPolicy : kplus.RestartPolicy.NEVER , }); Assigning a ServiceAccount \u00b6 import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new new kplus . Pod ( chart , 'Pod' , { serviceAccount : kplus.ServiceAccount.fromServiceAccountName ( 'aws' ), });","title":"Pod"},{"location":"plus/pod.html#pod","text":"A pod is essentially a collection of containers. It is the most fundamental computation unit that can be provisioned. API Reference","title":"Pod"},{"location":"plus/pod.html#adding-containersvolumes","text":"Containers and volumes can be added to pod definition like so: import * as kplus from 'cdk8s-plus-17' ; const pod = new new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , }); const storage = kplus . Volume . fromEmptyDir ( 'storage' ); container . mount ( '/data' , storage ); const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // this will automatically add the volume as well. pod . addContainer ( container ); // but if you want to explicitly add it, simply use: pod . addVolume ( storage );","title":"Adding Containers/Volumes"},{"location":"plus/pod.html#applying-a-restart-policy","text":"import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new new kplus . Pod ( chart , 'Pod' , { restartPolicy : kplus.RestartPolicy.NEVER , });","title":"Applying a restart policy"},{"location":"plus/pod.html#assigning-a-serviceaccount","text":"import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new new kplus . Pod ( chart , 'Pod' , { serviceAccount : kplus.ServiceAccount.fromServiceAccountName ( 'aws' ), });","title":"Assigning a ServiceAccount"},{"location":"plus/secret.html","text":"Secret \u00b6 Secrets are used to store confidential information. Never store such information on the definition of the pod itself. API Reference Use an existing Secret \u00b6 To reference a secret created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-17' ; const secret = kplus . Secret . fromSecretName ( 'aws-creds' ); Adding data \u00b6 To create a new secret with some data, use: import * as kplus from 'cdk8s-plus-17' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const secret = new kplus . Secret ( chart , 'Secret' ); secret . addStringData ( 'password' , 'some-encrypted-data' );","title":"Secret"},{"location":"plus/secret.html#secret","text":"Secrets are used to store confidential information. Never store such information on the definition of the pod itself. API Reference","title":"Secret"},{"location":"plus/secret.html#use-an-existing-secret","text":"To reference a secret created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-17' ; const secret = kplus . Secret . fromSecretName ( 'aws-creds' );","title":"Use an existing Secret"},{"location":"plus/secret.html#adding-data","text":"To create a new secret with some data, use: import * as kplus from 'cdk8s-plus-17' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const secret = new kplus . Secret ( chart , 'Secret' ); secret . addStringData ( 'password' , 'some-encrypted-data' );","title":"Adding data"},{"location":"plus/service-account.html","text":"ServiceAccount \u00b6 Use service accounts to provide an identity for pods. API Reference Use an existing ServiceAccount \u00b6 To reference a service account created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-17' ; const serviceAccount = kplus . ServiceAccount . fromServiceAccountName ( 'aws-service' ); Allowing access to secrets \u00b6 To create a new service account, and give it access to some secrets, use the following: import * as kplus from 'cdk8s-plus-17' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const awsCreds = kplus . Secret . fromSecretName ( 'aws-creds' ); const awsService = new kplus . ServiceAccount ( chart , 'AWS' ); // give access to the aws creds secret. awsService . addSecret ( awsCreds );","title":"ServiceAccount"},{"location":"plus/service-account.html#serviceaccount","text":"Use service accounts to provide an identity for pods. API Reference","title":"ServiceAccount"},{"location":"plus/service-account.html#use-an-existing-serviceaccount","text":"To reference a service account created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-17' ; const serviceAccount = kplus . ServiceAccount . fromServiceAccountName ( 'aws-service' );","title":"Use an existing ServiceAccount"},{"location":"plus/service-account.html#allowing-access-to-secrets","text":"To create a new service account, and give it access to some secrets, use the following: import * as kplus from 'cdk8s-plus-17' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const awsCreds = kplus . Secret . fromSecretName ( 'aws-creds' ); const awsService = new kplus . ServiceAccount ( chart , 'AWS' ); // give access to the aws creds secret. awsService . addSecret ( awsCreds );","title":"Allowing access to secrets"},{"location":"plus/service.html","text":"Service \u00b6 Use services when you want to expose a set of pods using a stable network identity. They can also be used for externalizing endpoints to clients outside of the kubernetes cluster. API Reference Selectors \u00b6 Services must be configured with selectors that tell it which pods should it serve. The most common selector method is using labels. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // this will cause the service to select all pods with the 'run: frontend' label. frontends . selectByLabel ( 'run' , 'frontend' ) Ports \u00b6 Ports that the service will listen and redirect to can be configured like so: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // make the service bind to port 9000 and redirect to port 80 on the associated containers. frontends . serve ({ port : 9000 , targetPort : 80 )","title":"Service"},{"location":"plus/service.html#service","text":"Use services when you want to expose a set of pods using a stable network identity. They can also be used for externalizing endpoints to clients outside of the kubernetes cluster. API Reference","title":"Service"},{"location":"plus/service.html#selectors","text":"Services must be configured with selectors that tell it which pods should it serve. The most common selector method is using labels. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // this will cause the service to select all pods with the 'run: frontend' label. frontends . selectByLabel ( 'run' , 'frontend' )","title":"Selectors"},{"location":"plus/service.html#ports","text":"Ports that the service will listen and redirect to can be configured like so: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-17' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // make the service bind to port 9000 and redirect to port 80 on the associated containers. frontends . serve ({ port : 9000 , targetPort : 80 )","title":"Ports"},{"location":"plus/volume.html","text":"Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. API Reference Create from a ConfigMap \u00b6 A very useful operation is to create a volume from a ConfigMap . Kubernetes will translate every key in the config map to a file, who\u2019s content is the value of the key. import * as kplus from 'cdk8s-plus-17' ; const configMap = kplus . ConfigMap . fromConfigMapName ( 'redis-config' ); const configVolume = kplus . Volume . fromConfigMap ( configMap ); Create from an EmptyDir \u00b6 The easiest way to allocate some persistent storage to your container is to create a volume from an empty directory. This volume, as the name suggests, is initially empty, and can be written to by containers who mount it. The data in the volume is preserved throughout the lifecycle of the pod, but is deleted forever as soon as the pod itself is removed. import * as kplus from 'cdk8s-plus-17' ; const data = kplus . Volume . fromEmptyDir ( configMap ); const pod = new kplus . Pod ( this , 'Pod' ); const redis = pod . addContainer ({ image : 'redis' }) // mount to the redis container. redis . mount ( '/var/lib/redis' , data );","title":"Volume"},{"location":"plus/volume.html#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. API Reference","title":"Volume"},{"location":"plus/volume.html#create-from-a-configmap","text":"A very useful operation is to create a volume from a ConfigMap . Kubernetes will translate every key in the config map to a file, who\u2019s content is the value of the key. import * as kplus from 'cdk8s-plus-17' ; const configMap = kplus . ConfigMap . fromConfigMapName ( 'redis-config' ); const configVolume = kplus . Volume . fromConfigMap ( configMap );","title":"Create from a ConfigMap"},{"location":"plus/volume.html#create-from-an-emptydir","text":"The easiest way to allocate some persistent storage to your container is to create a volume from an empty directory. This volume, as the name suggests, is initially empty, and can be written to by containers who mount it. The data in the volume is preserved throughout the lifecycle of the pod, but is deleted forever as soon as the pod itself is removed. import * as kplus from 'cdk8s-plus-17' ; const data = kplus . Volume . fromEmptyDir ( configMap ); const pod = new kplus . Pod ( this , 'Pod' ); const redis = pod . addContainer ({ image : 'redis' }) // mount to the redis container. redis . mount ( '/var/lib/redis' , data );","title":"Create from an EmptyDir"},{"location":"project/CHANGELOG.html","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. See standard-version for commit guidelines. 1.0.0-beta.11 (2021-03-30) \u00b6 Dependency upgrades. 1.0.0-beta.10 (2021-03-02) \u00b6 Features \u00b6 Dependency upgrades. 1.0.0-beta.9 (2021-02-22) \u00b6 Features \u00b6 lib: flag to disable dictionary sort ( #534 ) ( a4eca40 ), closes #525 Bug Fixes \u00b6 lib: ENOBUFS for large helm charts ( #529 ) ( 4164f38 ), closes #454 1.0.0-beta.8 (2021-02-04) \u00b6 Bug Fixes \u00b6 go: invalid go module name ( 87af61b ) 1.0.0-beta.7 (2021-02-04) \u00b6 \u26a0 BREAKING CHANGES \u00b6 lib: the deprecated API Duration.toISOString() has been removed. Use Duration.toIsoString() instead. Features \u00b6 plus-17: add StatefulSet construct ( #400 ) ( 98aad99 ) plus-17: restrict CIDR IP addresses for a LoadBalancer ( #446 ) ( cf96ae2 ), closes #435 experimental golang bindings ( #523 ) ( 6737351 ) only publish doc site on release commits ( #507 ) ( 5acc54b ) Bug Fixes \u00b6 cli: allow any python 3 to be used ( #518 ) ( 2a49196 ) lib: deprecated toISOString() conflicts with toIsoString() ( #524 ) ( d4e0c3d ) not folding strings ( #495 ) ( 8dda8bd ), closes #494 1.0.0-beta.6 (2021-01-21) \u00b6 Features \u00b6 cli: new version notifications ( #454 ) ( 065756e ), closes #452 plus-17: Add type option for secrets in kplus. ( #425 ) ( 28d660f ) Bug Fixes \u00b6 set yaml default schema to 1.1 ( #505 ) ( 266c094 ) docs: correct logo paths ( #503 ) ( 9426047 ) plus-17: adds externalName to service props ( #424 ) ( b4b7c55 ) plus-17: multiple mounts per volume result in duplicate volumes for pod spec ( #489 ) ( 47c913e ) 1.0.0-beta.5 (2020-12-15) \u00b6 Features \u00b6 cli: enable using imported resources as raw manifests ( #447 ) ( aa2422e ) Bug Fixes \u00b6 cli: importing local files is broken on windows ( #427 ) ( 2c4a185 ) 1.0.0-beta.4 (2020-12-13) \u00b6 Features \u00b6 cli: import a single module per api group ( #402 ) ( ac295fe ), closes #378 #401 lib: allow hash to be optionally included in Names functions. ( #396 ) ( 2c86526 ) plus-17: additional options for the Job construct. ( #398 ) ( 17e8801 ) Bug Fixes \u00b6 lib: Lazy is not resolved in metadata ( #443 ) ( 914d4a8 ) cli: which command missing for windows ( #417 ) ( 38a7034 ) docs: align getting started with new code ( #410 ) ( c61e109 ) docs: WebService typescript example formatting ( #408 ) ( e2470f9 ) plus-17: don\u2019t allow containers to be contructed from containers ( #404 ) ( 5d11533 ) 1.0.0-beta.3 (2020-11-19) \u00b6 Features \u00b6 cli: stdout option for cdk8s synth ( #361 ) ( bbf116b ) add contributor instructions about using jsii docker image ( #397 ) ( bb0a5cc ) Bug Fixes \u00b6 cli: python init template doesn\u2019t install cdk8s-plus in the correct env ( #399 ) ( 0d3017b ) 1.0.0-beta.2 (2020-11-19) \u00b6 \u26a0 BREAKING CHANGES \u00b6 lib: CAUTION! Auto-generated resource names will change with this release. Resource names in manifests synthesized by a previous version of the CDK8s will be invalidated. Deploying new manifests will cause resources to be replaced . Temporarily, you can opt to use the legacy hashing mechanism by setting the environment variable CDK8S_LEGACY_HASH=1 . lib: Names.toDnsLabel() now accepts a construct scope instead of a string path, and a set of options instead of maxLen . lib: Names.toLabelValue() now accepts a construct scope instead of a string path, and a set of options instead of maxLen . Features \u00b6 cli: import from crds.dev ( #378 ) ( c62d0a4 ), closes #377 Bug Fixes \u00b6 cli: python init templates are broken ( #393 ) ( d786001 ) lib: names generated using non-FIPS compliant algorithm ( #392 ) ( a1acae7 ), closes #334 1.0.0-beta.1 (2020-11-18) \u00b6 \u26a0 BREAKING CHANGES \u00b6 plus-17: All L2 resource names will undergo a name change (e.g test-chart-config-configmap-233db8e7 -> test-chart-config-c3f7d3c0 ) cli: Construct input types generated by cdk8s import are now called XxxProps instead of XxxOptions to conform with the CDK ecosystem. lib: ApiObjectOptions is now called ApiObjectProps lib: AppOptions is now called AppProps lib: ChartOptions is now called ChartProps lib: HelmOptions is now called HelmProps lib: IncludeOptions is now called IncludeProps cli: when importing k8s api objects using cdk8s import , non-stable APIs will be have an API level postfix. For example, k8s@1.18 will have an IngressV1Beta1 API object. cli: The --include CLI option has been removed since all API objects are always imported. cli: When using the CLI to import the core Kubernetes API objects, the imported classes will now have a Kube prefix in order to make it easier to differentiate them from the classes offered by the high-level APIs in CDK8s+ (e.g. k8s.Deployment is now k8s.KubeDeployment ). You can disable through the --no-class-prefix option: cdk8s import --no-class-prefix k8s . plus-17: Containers now need to be inputed as interfaces rather than classes. Instead of passing new kplus.Container(props) , simply pass in props . Features \u00b6 plus: renamed to cdk8s-plus-17 . The 17 marks the minimum supported version of the kubernetes spec. website: documentation website ( #367 ) ( 505f946 ), closes #366 cdk8s: escape hatches ( #372 ) ( 12b0f01 ), closes #144 cli: class prefix for imported constructs ( #370 ) ( 0b18df3 ), closes #140 cli: import constructs for all API levels ( #379 ) ( b0d7621 ), closes #380 plus-17: add liveness and startup probes to Container ( #358 ) ( f3f9a6a ) plus-17: Container is now inputed as an interface instead of class ( #376 ) ( 33bf97a ) plus-17: expose service options in expose() ( #357 ) ( 7137698 ) switch to 1.0.0-beta version line ( #384 ) ( ffce8c6 ) Bug Fixes \u00b6 cli: input type names are \u201cXxxOptions\u201d instead of \u201cXxxProps\u201d ( #381 ) ( b2bd34e ), closes #371 plus-17: L2 default child ( #389 ) ( a8337e8 ) 0.33.0 (2020-10-21) \u00b6 Features \u00b6 chart-level labels ( #355 ) ( c545c1e ) 0.32.0 (2020-10-20) \u00b6 \u26a0 BREAKING CHANGES \u00b6 lib: EnvValue.fromSecret(secret, key) has been removed in favor of EnvValue.fromSecretValue({ secret, key }) . Features \u00b6 lib: SecretValue ( #351 ) ( dd7cf58 ) plus: readiness probes ( #353 ) ( a57e466 ) Bug Fixes \u00b6 lib: corrupted manifests when including large files ( #350 ) ( 649f41b ) lib: fail to import octal numbers via include (and helm) ( #349 ) ( bed9eed ), closes #348 0.31.0 (2020-10-19) \u00b6 \u26a0 BREAKING CHANGES \u00b6 plus: spec was removed from all cdk8s+ constructs and that now have a flat structure. See Example for new usage. plus : Construct id\u2019s for deployment will change due to a latent bug that appended the word pod to them. plus: deployment.expose() now takes port as a positional argument (before: deployment.expose({ port }) , now: deployment.expose(port) ). lib: auto-generated resource names that included duplicate hyphens will change will be replaced when applied. lib: cdk8s-plus\u2019s value of a label cdk8s.deployment of Pods are changed Features \u00b6 lib: helm construct ( #346 ) ( 6ee449f ), closes #65 plus: Ingress ( #340 ) ( 14ac668 ), closes #125 plus: service.addDeployment() ( #342 ) ( 5413b3b ) migrate to cdk.dev slack workspace ( #336 ) ( b203e5a ) Bug Fixes \u00b6 lib: uniqueId is not compatible with the k8s labels ( #326 ) ( 161f368 ), closes #323 lib: duplicate hyphens in generated resource names ( #341 ) ( 6f6366a ) allow tests to run without write access to os.tmpdir parent ( #338 ) ( dc17022 ) Fix yaml quote serialization 325 ( #327 ) ( 6b1f662 ), closes #325 plus: Remove the spec nesting level on both input and output ( #347 ) ( 5e34850 ) 0.30.0 (2020-10-04) \u00b6 Features \u00b6 plus: Bump k8s imports to use spec version 1.17.0 ( #331 ) ( 23fea73 ) Features \u00b6 lib: Expose DependecyGraph for upstream use ( #329 ) ( ee88402 ), closes #328 0.29.0 (2020-09-27) \u00b6 Features \u00b6 lib: Upgrade constructs ( #324 ) ( 070b600 ) 0.28.0 (2020-09-14) \u00b6 Features \u00b6 plus: ImagePullPolicy support for cdk8s-plus Container ( #313 ) ( 8307757 ) Bug Fixes \u00b6 examples: Add missing dependencies on python examples. ( #290 ) ( 36e6fab ), closes #289 plus: support node ports for cdk8s-plus service ( #315 ) ( 85ec225 ), closes #296 website: doc links are broken due to wrong version number ( #312 ) ( f2f9402 ), closes #307 0.27.0 (2020-08-05) \u00b6 \u26a0 BREAKING CHANGES \u00b6 lib: resource names will now be rendered differently, omitting adjacent duplicate components. Features \u00b6 examples: Elasticsearch query using CDK8s+ and CRD ( #281 ) ( 3be1a96 ) lib: omit duplicate components in generated names ( #258 ) ( 473b5ef ) Bug Fixes \u00b6 cli: Conform python and java package names to language standards (no hyphens) ( #283 ) ( f0b33c0 ) cli: java importing crd fails ( #257 ) ( f0ef3b4 ) 0.26.0 (2020-06-29) \u00b6 Features \u00b6 cli: cdk8s init template for java ( #245 ) ( 2bec62a ) Introducing \u201ccdk8s+\u201d: high-level APIs for Kubernetes ( #239 ) ( 1b991f6 ) Bug Fixes \u00b6 move output of java imports into /src/main/java ( #240 ) ( 9445358 ) 0.25.0 (2020-06-09) \u00b6 \u26a0 BREAKING CHANGES \u00b6 lib: cdk8s discontinues support for the onPrepare and onSynthesis construct hooks. These methods will eventually be removed from the constructs programming model. Features \u00b6 cli: java import support ( #226 ) ( 9619a73 ) lib: dependencies and ordering of charts and objects ( #223 ) ( 701579e ), closes #111 Bug Fixes \u00b6 cli: options type not generated for certain CRDs ( #229 ) ( 0cbaf19 ), closes #219 0.24.0 (2020-05-27) \u00b6 \u26a0 BREAKING CHANGES \u00b6 cli: enum string values are now proper enums instead of just string s. Features \u00b6 cli: import - support enum string fields ( #210 ) ( 8b8ad44 ), closes #196 Bug Fixes \u00b6 cli: unable to import CRDs with non-trivial \u201cxxxOf\u201d constraints ( #212 ) ( 18136ed ), closes #171 cli: unable to import types with all-caps TLAs ( #211 ) ( a11d0e8 ), closes #209 0.23.0 (2020-05-26) \u00b6 \u26a0 BREAKING CHANGES \u00b6 cli : the generated module names of imported CRDs now include the resource\u2019s group and not just its kind in order to ensure uniqueness. For example, when importing the Jenkins CRD, instead of \u2018imports/jenkins.ts , we now have imports/jenkins.io/jenkins.ts`. cli : class names of imported apis are now normalized to PascalCase . Features \u00b6 cli: import CRDs from a running cluster ( #207 ) ( 5153422 ), closes #197 lib: introduce \u201cinclude\u201d ( #202 ) ( 75d13e8 ), closes #199 lib: yaml utility functions ( #198 ) ( 9e0f030 ) Bug Fixes \u00b6 cli: impossible to import two crds with the same kind ( #203 ) ( f6248ce ) docs: do not mark arguments as optional in python getting-started ( #191 ) ( be090d0 ) lib: unable to express empty objects and array ( #200 ) ( 9ae5efb ) 0.22.0 (2020-05-22) \u00b6 Features \u00b6 cli: jest tests in typescript-app template ( b6aed5a ) cli: support CRDs with apiVersion \u201capiextensions.k8s.io/v1\u201d ( #142 ) ( f5111b0 ) cli: support import module name overriding in python ( #107 ) ( 327ba47 ) docs: add python and pipenv prerequisites ( db23fa1 ), closes #166 examples: central readme for all examples ( #176 ) ( 9cab302 ), closes #174 examples: reorganize examples by language ( #138 ) ( 85cf631 ) readme: add link to \u201cawesome cdk8s\u201d ( 0889a6e ) 0.21.0 (2020-05-14) \u00b6 Features \u00b6 new website ( #143 ) ( fcc59b0 ) example: python hello example ( #101 ) ( e792d2b ) website: add reference docs links ( 2034ec0 ) Bug Fixes \u00b6 cli: unable to import a crd that has no schema ( #132 ) ( b8115cb ) crd: Ensure yaml doc is defined before casting to CustomResourceApiObject ( #130 ) ( 03e6d84 ) redirect: Handle 302 redirect case when importing from remote url ( #131 ) ( 1ed88ca ) 0.20.0 (2020-04-27) \u00b6 Features \u00b6 surface cdk8s in awscdk.io ( 45e188e ) Bug Fixes \u00b6 docs: top-level \u201cgetting started\u201d page not found ( #120 ) ( eb9d2ad ), closes #106 readme: missing information about imports in cdk8s-cli readme ( #108 ) ( e9f291e ) 0.19.0 (2020-04-12) \u00b6 Bug Fixes \u00b6 cli-import: unable to import a CRD from an insecure server ( #102 ) ( 4dde096 ), closes #94 homebrew: homebrew release trigger is broken ( 5ecb143 ) Features \u00b6 cli-import: allow overriding module name in imports ( #84 ) ( 63daf78 ) 0.18.0 (2020-04-10) \u00b6 Features \u00b6 cdk8s website ( #89 ) ( 430d9b7 ) cli: ignore hidden files in \u201ccdk8s init\u201d ( #99 ) ( 5681e14 ) Bug Fixes \u00b6 crd: fix multi-resource importing of CRDs ( #78 ) ( fd8f753 ) examples: \u201creplicas\u201d option is not respected in the web-service example ( #87 ) ( 97ca582 ) gha: prevent gha from running on forks ( 26eb407 ) 0.17.0 (2020-03-21) \u00b6 \u26a0 BREAKING CHANGES \u00b6 please upgrade your dependency requirement for \u201cconstructs\u201d to ^2.0.0 Bug Fixes \u00b6 gh_actions: fix release-next script to use correct npx publishing ( 27c7f9d ) readme: hello example link is broken #74 ( 0b858cf ) upgrade jsii & constructs ( #80 ) ( f917e0a ) 0.16.0 (2020-03-17) \u00b6 Features \u00b6 cli: cdk8s import crd.yaml ( #70 ) ( 5d1c278 ), closes #27 0.15.1 (2020-03-13) \u00b6 Bug Fixes \u00b6 cli-init: install \u201cconstructs\u201d instead of \u201c@aws-cdk/core\u201d ( 6ccc03f ) 0.15.0 (2020-03-12) \u00b6 Features \u00b6 default chart namespaces ( #68 ) ( 36b9ff1 ) peer-depend on \u201cconstructs\u201d instead of \u201c@aws-cdk/core\u201d ( #66 ) ( c336c95 ) sort keys of ApiObject manifests ( #67 ) ( 1fe89bd ), closes #17 0.14.0 (2020-03-10) \u00b6 Features \u00b6 allow arbitrary construct names ( #64 ) ( 1309960 ), closes #48 chart.toJson() and apiObject.toJson() ( #63 ) ( 80e8402 ), closes #48 0.13.1 (2020-03-09) \u00b6 Bug Fixes \u00b6 cli: init could not find a version that matches cdk8s0-13-0 ( e1267f6 ) 0.13.0 (2020-03-09) \u00b6 This release adds Python support for cdk8s and includes; - The cdk8s library is released to PyPI - cdk8s init python-app creates new Python apps - cdk8s import generates python classes for Kubernetes API objects \u26a0 BREAKING CHANGES \u00b6 cli: cdk8s import now generates a single file with all types, which means you will have to modify TypeScript code to import { Deployment, Pod, ... } from './imports/k8s' instead of importing multiple files. cli: cdk8s gen is now cdk8s import k8s and output goes to imports/k8s.ts instead of .gen/index.ts . Features \u00b6 cli: \u201ccdk8s gen\u201d is now \u201ccdk8s import k8s\u201d ( #43 ) ( fb9e0b5 ), closes #31 #40 cli: \u201ccdk8s synth\u201d ( #44 ) ( d457ea9 ), closes #41 cli: cdk8s.yaml ( #52 ) ( e6834d3 ), closes #42 cli: import only one class for every api object ( #39 ) ( 2db4cfb ) cli: python project template ( #36 ) ( 30f3bb7 ) cli: python support for \u201cimport\u201d ( #47 ) ( 3b93d64 ) cli: typescript project - \u201cnpm run upgrade\u201d & \u201cupgrade:next\u201d ( 735e840 ) cli: typescript project - \u201cnpm run build\u201d now includes \u201csynth\u201d ( 7b15e3a ) docs: getting started in python ( #60 ) ( 27d3bac ) examples: updates to hello-world example and directory reorganization ( #33 ) ( 1c8f694 ) Bug Fixes \u00b6 cli: new typescript apps cannot be created with @next versions ( #55 ) ( 119d95c ) 0.12.0 (2020-03-03) \u00b6 Bug Fixes \u00b6 yaml not found in jsii languages ( 39ef409 ) 0.11.0 (2020-03-03) \u00b6 Bug Fixes \u00b6 yaml not found in jsii languages ( 39ef409 ) 0.10.0 (2020-02-28) \u00b6 Bug Fixes \u00b6 cdk8s: autogenerated names fail validation for some resource types ( #18 ) ( b70e4fe ), closes #16 0.9.0 (2020-02-27) \u00b6 Features \u00b6 cdk8s: the App root construct ( #15 ) ( c595240 ) 0.8.0 (2020-02-27) \u00b6 Features \u00b6 cli: remove the cookiecutter prerequisite ( #13 ) ( 10ab259 ) 0.7.0 (2020-02-26) \u00b6 Bug Fixes \u00b6 cli: typescript-app does not include main.ts ( 43b435a ) 0.6.0 (2020-02-26) \u00b6 Bug Fixes \u00b6 cli does not work when used from a symlink ( #11 ) ( 4bd3a37 ) 0.5.0 (2020-02-26) \u00b6 Features \u00b6 cli: project templates with \u201ccdk8s init\u201d ( #10 ) ( 4aa59d9 ) cookiecutter template for typescript app projects ( #9 ) ( 55087e2 ) 0.4.0 (2020-02-23) \u00b6 Features \u00b6 podinfo: allow containers to bind to deployment ( 45237c0 ) 0.3.0 (2020-02-23) \u00b6 Features \u00b6 chart.generateObjectName ( 03a1d26 ) Chart.of(node) ( d6a9dc0 ) 0.1.2 (2020-02-12) \u00b6 Features \u00b6 getting started documentation ( 2616372 )","title":"Changelog"},{"location":"project/CHANGELOG.html#changelog","text":"All notable changes to this project will be documented in this file. See standard-version for commit guidelines.","title":"Changelog"},{"location":"project/CHANGELOG.html#100-beta11-2021-03-30","text":"Dependency upgrades.","title":"1.0.0-beta.11 (2021-03-30)"},{"location":"project/CHANGELOG.html#100-beta10-2021-03-02","text":"","title":"1.0.0-beta.10 (2021-03-02)"},{"location":"project/CHANGELOG.html#features","text":"Dependency upgrades.","title":"Features"},{"location":"project/CHANGELOG.html#100-beta9-2021-02-22","text":"","title":"1.0.0-beta.9 (2021-02-22)"},{"location":"project/CHANGELOG.html#features_1","text":"lib: flag to disable dictionary sort ( #534 ) ( a4eca40 ), closes #525","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes","text":"lib: ENOBUFS for large helm charts ( #529 ) ( 4164f38 ), closes #454","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#100-beta8-2021-02-04","text":"","title":"1.0.0-beta.8 (2021-02-04)"},{"location":"project/CHANGELOG.html#bug-fixes_1","text":"go: invalid go module name ( 87af61b )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#100-beta7-2021-02-04","text":"","title":"1.0.0-beta.7 (2021-02-04)"},{"location":"project/CHANGELOG.html#breaking-changes","text":"lib: the deprecated API Duration.toISOString() has been removed. Use Duration.toIsoString() instead.","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG.html#features_2","text":"plus-17: add StatefulSet construct ( #400 ) ( 98aad99 ) plus-17: restrict CIDR IP addresses for a LoadBalancer ( #446 ) ( cf96ae2 ), closes #435 experimental golang bindings ( #523 ) ( 6737351 ) only publish doc site on release commits ( #507 ) ( 5acc54b )","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_2","text":"cli: allow any python 3 to be used ( #518 ) ( 2a49196 ) lib: deprecated toISOString() conflicts with toIsoString() ( #524 ) ( d4e0c3d ) not folding strings ( #495 ) ( 8dda8bd ), closes #494","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#100-beta6-2021-01-21","text":"","title":"1.0.0-beta.6 (2021-01-21)"},{"location":"project/CHANGELOG.html#features_3","text":"cli: new version notifications ( #454 ) ( 065756e ), closes #452 plus-17: Add type option for secrets in kplus. ( #425 ) ( 28d660f )","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_3","text":"set yaml default schema to 1.1 ( #505 ) ( 266c094 ) docs: correct logo paths ( #503 ) ( 9426047 ) plus-17: adds externalName to service props ( #424 ) ( b4b7c55 ) plus-17: multiple mounts per volume result in duplicate volumes for pod spec ( #489 ) ( 47c913e )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#100-beta5-2020-12-15","text":"","title":"1.0.0-beta.5 (2020-12-15)"},{"location":"project/CHANGELOG.html#features_4","text":"cli: enable using imported resources as raw manifests ( #447 ) ( aa2422e )","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_4","text":"cli: importing local files is broken on windows ( #427 ) ( 2c4a185 )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#100-beta4-2020-12-13","text":"","title":"1.0.0-beta.4 (2020-12-13)"},{"location":"project/CHANGELOG.html#features_5","text":"cli: import a single module per api group ( #402 ) ( ac295fe ), closes #378 #401 lib: allow hash to be optionally included in Names functions. ( #396 ) ( 2c86526 ) plus-17: additional options for the Job construct. ( #398 ) ( 17e8801 )","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_5","text":"lib: Lazy is not resolved in metadata ( #443 ) ( 914d4a8 ) cli: which command missing for windows ( #417 ) ( 38a7034 ) docs: align getting started with new code ( #410 ) ( c61e109 ) docs: WebService typescript example formatting ( #408 ) ( e2470f9 ) plus-17: don\u2019t allow containers to be contructed from containers ( #404 ) ( 5d11533 )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#100-beta3-2020-11-19","text":"","title":"1.0.0-beta.3 (2020-11-19)"},{"location":"project/CHANGELOG.html#features_6","text":"cli: stdout option for cdk8s synth ( #361 ) ( bbf116b ) add contributor instructions about using jsii docker image ( #397 ) ( bb0a5cc )","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_6","text":"cli: python init template doesn\u2019t install cdk8s-plus in the correct env ( #399 ) ( 0d3017b )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#100-beta2-2020-11-19","text":"","title":"1.0.0-beta.2 (2020-11-19)"},{"location":"project/CHANGELOG.html#breaking-changes_1","text":"lib: CAUTION! Auto-generated resource names will change with this release. Resource names in manifests synthesized by a previous version of the CDK8s will be invalidated. Deploying new manifests will cause resources to be replaced . Temporarily, you can opt to use the legacy hashing mechanism by setting the environment variable CDK8S_LEGACY_HASH=1 . lib: Names.toDnsLabel() now accepts a construct scope instead of a string path, and a set of options instead of maxLen . lib: Names.toLabelValue() now accepts a construct scope instead of a string path, and a set of options instead of maxLen .","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG.html#features_7","text":"cli: import from crds.dev ( #378 ) ( c62d0a4 ), closes #377","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_7","text":"cli: python init templates are broken ( #393 ) ( d786001 ) lib: names generated using non-FIPS compliant algorithm ( #392 ) ( a1acae7 ), closes #334","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#100-beta1-2020-11-18","text":"","title":"1.0.0-beta.1 (2020-11-18)"},{"location":"project/CHANGELOG.html#breaking-changes_2","text":"plus-17: All L2 resource names will undergo a name change (e.g test-chart-config-configmap-233db8e7 -> test-chart-config-c3f7d3c0 ) cli: Construct input types generated by cdk8s import are now called XxxProps instead of XxxOptions to conform with the CDK ecosystem. lib: ApiObjectOptions is now called ApiObjectProps lib: AppOptions is now called AppProps lib: ChartOptions is now called ChartProps lib: HelmOptions is now called HelmProps lib: IncludeOptions is now called IncludeProps cli: when importing k8s api objects using cdk8s import , non-stable APIs will be have an API level postfix. For example, k8s@1.18 will have an IngressV1Beta1 API object. cli: The --include CLI option has been removed since all API objects are always imported. cli: When using the CLI to import the core Kubernetes API objects, the imported classes will now have a Kube prefix in order to make it easier to differentiate them from the classes offered by the high-level APIs in CDK8s+ (e.g. k8s.Deployment is now k8s.KubeDeployment ). You can disable through the --no-class-prefix option: cdk8s import --no-class-prefix k8s . plus-17: Containers now need to be inputed as interfaces rather than classes. Instead of passing new kplus.Container(props) , simply pass in props .","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG.html#features_8","text":"plus: renamed to cdk8s-plus-17 . The 17 marks the minimum supported version of the kubernetes spec. website: documentation website ( #367 ) ( 505f946 ), closes #366 cdk8s: escape hatches ( #372 ) ( 12b0f01 ), closes #144 cli: class prefix for imported constructs ( #370 ) ( 0b18df3 ), closes #140 cli: import constructs for all API levels ( #379 ) ( b0d7621 ), closes #380 plus-17: add liveness and startup probes to Container ( #358 ) ( f3f9a6a ) plus-17: Container is now inputed as an interface instead of class ( #376 ) ( 33bf97a ) plus-17: expose service options in expose() ( #357 ) ( 7137698 ) switch to 1.0.0-beta version line ( #384 ) ( ffce8c6 )","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_8","text":"cli: input type names are \u201cXxxOptions\u201d instead of \u201cXxxProps\u201d ( #381 ) ( b2bd34e ), closes #371 plus-17: L2 default child ( #389 ) ( a8337e8 )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0330-2020-10-21","text":"","title":"0.33.0 (2020-10-21)"},{"location":"project/CHANGELOG.html#features_9","text":"chart-level labels ( #355 ) ( c545c1e )","title":"Features"},{"location":"project/CHANGELOG.html#0320-2020-10-20","text":"","title":"0.32.0 (2020-10-20)"},{"location":"project/CHANGELOG.html#breaking-changes_3","text":"lib: EnvValue.fromSecret(secret, key) has been removed in favor of EnvValue.fromSecretValue({ secret, key }) .","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG.html#features_10","text":"lib: SecretValue ( #351 ) ( dd7cf58 ) plus: readiness probes ( #353 ) ( a57e466 )","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_9","text":"lib: corrupted manifests when including large files ( #350 ) ( 649f41b ) lib: fail to import octal numbers via include (and helm) ( #349 ) ( bed9eed ), closes #348","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0310-2020-10-19","text":"","title":"0.31.0 (2020-10-19)"},{"location":"project/CHANGELOG.html#breaking-changes_4","text":"plus: spec was removed from all cdk8s+ constructs and that now have a flat structure. See Example for new usage. plus : Construct id\u2019s for deployment will change due to a latent bug that appended the word pod to them. plus: deployment.expose() now takes port as a positional argument (before: deployment.expose({ port }) , now: deployment.expose(port) ). lib: auto-generated resource names that included duplicate hyphens will change will be replaced when applied. lib: cdk8s-plus\u2019s value of a label cdk8s.deployment of Pods are changed","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG.html#features_11","text":"lib: helm construct ( #346 ) ( 6ee449f ), closes #65 plus: Ingress ( #340 ) ( 14ac668 ), closes #125 plus: service.addDeployment() ( #342 ) ( 5413b3b ) migrate to cdk.dev slack workspace ( #336 ) ( b203e5a )","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_10","text":"lib: uniqueId is not compatible with the k8s labels ( #326 ) ( 161f368 ), closes #323 lib: duplicate hyphens in generated resource names ( #341 ) ( 6f6366a ) allow tests to run without write access to os.tmpdir parent ( #338 ) ( dc17022 ) Fix yaml quote serialization 325 ( #327 ) ( 6b1f662 ), closes #325 plus: Remove the spec nesting level on both input and output ( #347 ) ( 5e34850 )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0300-2020-10-04","text":"","title":"0.30.0 (2020-10-04)"},{"location":"project/CHANGELOG.html#features_12","text":"plus: Bump k8s imports to use spec version 1.17.0 ( #331 ) ( 23fea73 )","title":"Features"},{"location":"project/CHANGELOG.html#features_13","text":"lib: Expose DependecyGraph for upstream use ( #329 ) ( ee88402 ), closes #328","title":"Features"},{"location":"project/CHANGELOG.html#0290-2020-09-27","text":"","title":"0.29.0 (2020-09-27)"},{"location":"project/CHANGELOG.html#features_14","text":"lib: Upgrade constructs ( #324 ) ( 070b600 )","title":"Features"},{"location":"project/CHANGELOG.html#0280-2020-09-14","text":"","title":"0.28.0 (2020-09-14)"},{"location":"project/CHANGELOG.html#features_15","text":"plus: ImagePullPolicy support for cdk8s-plus Container ( #313 ) ( 8307757 )","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_11","text":"examples: Add missing dependencies on python examples. ( #290 ) ( 36e6fab ), closes #289 plus: support node ports for cdk8s-plus service ( #315 ) ( 85ec225 ), closes #296 website: doc links are broken due to wrong version number ( #312 ) ( f2f9402 ), closes #307","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0270-2020-08-05","text":"","title":"0.27.0 (2020-08-05)"},{"location":"project/CHANGELOG.html#breaking-changes_5","text":"lib: resource names will now be rendered differently, omitting adjacent duplicate components.","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG.html#features_16","text":"examples: Elasticsearch query using CDK8s+ and CRD ( #281 ) ( 3be1a96 ) lib: omit duplicate components in generated names ( #258 ) ( 473b5ef )","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_12","text":"cli: Conform python and java package names to language standards (no hyphens) ( #283 ) ( f0b33c0 ) cli: java importing crd fails ( #257 ) ( f0ef3b4 )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0260-2020-06-29","text":"","title":"0.26.0 (2020-06-29)"},{"location":"project/CHANGELOG.html#features_17","text":"cli: cdk8s init template for java ( #245 ) ( 2bec62a ) Introducing \u201ccdk8s+\u201d: high-level APIs for Kubernetes ( #239 ) ( 1b991f6 )","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_13","text":"move output of java imports into /src/main/java ( #240 ) ( 9445358 )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0250-2020-06-09","text":"","title":"0.25.0 (2020-06-09)"},{"location":"project/CHANGELOG.html#breaking-changes_6","text":"lib: cdk8s discontinues support for the onPrepare and onSynthesis construct hooks. These methods will eventually be removed from the constructs programming model.","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG.html#features_18","text":"cli: java import support ( #226 ) ( 9619a73 ) lib: dependencies and ordering of charts and objects ( #223 ) ( 701579e ), closes #111","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_14","text":"cli: options type not generated for certain CRDs ( #229 ) ( 0cbaf19 ), closes #219","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0240-2020-05-27","text":"","title":"0.24.0 (2020-05-27)"},{"location":"project/CHANGELOG.html#breaking-changes_7","text":"cli: enum string values are now proper enums instead of just string s.","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG.html#features_19","text":"cli: import - support enum string fields ( #210 ) ( 8b8ad44 ), closes #196","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_15","text":"cli: unable to import CRDs with non-trivial \u201cxxxOf\u201d constraints ( #212 ) ( 18136ed ), closes #171 cli: unable to import types with all-caps TLAs ( #211 ) ( a11d0e8 ), closes #209","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0230-2020-05-26","text":"","title":"0.23.0 (2020-05-26)"},{"location":"project/CHANGELOG.html#breaking-changes_8","text":"cli : the generated module names of imported CRDs now include the resource\u2019s group and not just its kind in order to ensure uniqueness. For example, when importing the Jenkins CRD, instead of \u2018imports/jenkins.ts , we now have imports/jenkins.io/jenkins.ts`. cli : class names of imported apis are now normalized to PascalCase .","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG.html#features_20","text":"cli: import CRDs from a running cluster ( #207 ) ( 5153422 ), closes #197 lib: introduce \u201cinclude\u201d ( #202 ) ( 75d13e8 ), closes #199 lib: yaml utility functions ( #198 ) ( 9e0f030 )","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_16","text":"cli: impossible to import two crds with the same kind ( #203 ) ( f6248ce ) docs: do not mark arguments as optional in python getting-started ( #191 ) ( be090d0 ) lib: unable to express empty objects and array ( #200 ) ( 9ae5efb )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0220-2020-05-22","text":"","title":"0.22.0 (2020-05-22)"},{"location":"project/CHANGELOG.html#features_21","text":"cli: jest tests in typescript-app template ( b6aed5a ) cli: support CRDs with apiVersion \u201capiextensions.k8s.io/v1\u201d ( #142 ) ( f5111b0 ) cli: support import module name overriding in python ( #107 ) ( 327ba47 ) docs: add python and pipenv prerequisites ( db23fa1 ), closes #166 examples: central readme for all examples ( #176 ) ( 9cab302 ), closes #174 examples: reorganize examples by language ( #138 ) ( 85cf631 ) readme: add link to \u201cawesome cdk8s\u201d ( 0889a6e )","title":"Features"},{"location":"project/CHANGELOG.html#0210-2020-05-14","text":"","title":"0.21.0 (2020-05-14)"},{"location":"project/CHANGELOG.html#features_22","text":"new website ( #143 ) ( fcc59b0 ) example: python hello example ( #101 ) ( e792d2b ) website: add reference docs links ( 2034ec0 )","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_17","text":"cli: unable to import a crd that has no schema ( #132 ) ( b8115cb ) crd: Ensure yaml doc is defined before casting to CustomResourceApiObject ( #130 ) ( 03e6d84 ) redirect: Handle 302 redirect case when importing from remote url ( #131 ) ( 1ed88ca )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0200-2020-04-27","text":"","title":"0.20.0 (2020-04-27)"},{"location":"project/CHANGELOG.html#features_23","text":"surface cdk8s in awscdk.io ( 45e188e )","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_18","text":"docs: top-level \u201cgetting started\u201d page not found ( #120 ) ( eb9d2ad ), closes #106 readme: missing information about imports in cdk8s-cli readme ( #108 ) ( e9f291e )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0190-2020-04-12","text":"","title":"0.19.0 (2020-04-12)"},{"location":"project/CHANGELOG.html#bug-fixes_19","text":"cli-import: unable to import a CRD from an insecure server ( #102 ) ( 4dde096 ), closes #94 homebrew: homebrew release trigger is broken ( 5ecb143 )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#features_24","text":"cli-import: allow overriding module name in imports ( #84 ) ( 63daf78 )","title":"Features"},{"location":"project/CHANGELOG.html#0180-2020-04-10","text":"","title":"0.18.0 (2020-04-10)"},{"location":"project/CHANGELOG.html#features_25","text":"cdk8s website ( #89 ) ( 430d9b7 ) cli: ignore hidden files in \u201ccdk8s init\u201d ( #99 ) ( 5681e14 )","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_20","text":"crd: fix multi-resource importing of CRDs ( #78 ) ( fd8f753 ) examples: \u201creplicas\u201d option is not respected in the web-service example ( #87 ) ( 97ca582 ) gha: prevent gha from running on forks ( 26eb407 )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0170-2020-03-21","text":"","title":"0.17.0 (2020-03-21)"},{"location":"project/CHANGELOG.html#breaking-changes_9","text":"please upgrade your dependency requirement for \u201cconstructs\u201d to ^2.0.0","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG.html#bug-fixes_21","text":"gh_actions: fix release-next script to use correct npx publishing ( 27c7f9d ) readme: hello example link is broken #74 ( 0b858cf ) upgrade jsii & constructs ( #80 ) ( f917e0a )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0160-2020-03-17","text":"","title":"0.16.0 (2020-03-17)"},{"location":"project/CHANGELOG.html#features_26","text":"cli: cdk8s import crd.yaml ( #70 ) ( 5d1c278 ), closes #27","title":"Features"},{"location":"project/CHANGELOG.html#0151-2020-03-13","text":"","title":"0.15.1 (2020-03-13)"},{"location":"project/CHANGELOG.html#bug-fixes_22","text":"cli-init: install \u201cconstructs\u201d instead of \u201c@aws-cdk/core\u201d ( 6ccc03f )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0150-2020-03-12","text":"","title":"0.15.0 (2020-03-12)"},{"location":"project/CHANGELOG.html#features_27","text":"default chart namespaces ( #68 ) ( 36b9ff1 ) peer-depend on \u201cconstructs\u201d instead of \u201c@aws-cdk/core\u201d ( #66 ) ( c336c95 ) sort keys of ApiObject manifests ( #67 ) ( 1fe89bd ), closes #17","title":"Features"},{"location":"project/CHANGELOG.html#0140-2020-03-10","text":"","title":"0.14.0 (2020-03-10)"},{"location":"project/CHANGELOG.html#features_28","text":"allow arbitrary construct names ( #64 ) ( 1309960 ), closes #48 chart.toJson() and apiObject.toJson() ( #63 ) ( 80e8402 ), closes #48","title":"Features"},{"location":"project/CHANGELOG.html#0131-2020-03-09","text":"","title":"0.13.1 (2020-03-09)"},{"location":"project/CHANGELOG.html#bug-fixes_23","text":"cli: init could not find a version that matches cdk8s0-13-0 ( e1267f6 )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0130-2020-03-09","text":"This release adds Python support for cdk8s and includes; - The cdk8s library is released to PyPI - cdk8s init python-app creates new Python apps - cdk8s import generates python classes for Kubernetes API objects","title":"0.13.0 (2020-03-09)"},{"location":"project/CHANGELOG.html#breaking-changes_10","text":"cli: cdk8s import now generates a single file with all types, which means you will have to modify TypeScript code to import { Deployment, Pod, ... } from './imports/k8s' instead of importing multiple files. cli: cdk8s gen is now cdk8s import k8s and output goes to imports/k8s.ts instead of .gen/index.ts .","title":"\u26a0 BREAKING CHANGES"},{"location":"project/CHANGELOG.html#features_29","text":"cli: \u201ccdk8s gen\u201d is now \u201ccdk8s import k8s\u201d ( #43 ) ( fb9e0b5 ), closes #31 #40 cli: \u201ccdk8s synth\u201d ( #44 ) ( d457ea9 ), closes #41 cli: cdk8s.yaml ( #52 ) ( e6834d3 ), closes #42 cli: import only one class for every api object ( #39 ) ( 2db4cfb ) cli: python project template ( #36 ) ( 30f3bb7 ) cli: python support for \u201cimport\u201d ( #47 ) ( 3b93d64 ) cli: typescript project - \u201cnpm run upgrade\u201d & \u201cupgrade:next\u201d ( 735e840 ) cli: typescript project - \u201cnpm run build\u201d now includes \u201csynth\u201d ( 7b15e3a ) docs: getting started in python ( #60 ) ( 27d3bac ) examples: updates to hello-world example and directory reorganization ( #33 ) ( 1c8f694 )","title":"Features"},{"location":"project/CHANGELOG.html#bug-fixes_24","text":"cli: new typescript apps cannot be created with @next versions ( #55 ) ( 119d95c )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0120-2020-03-03","text":"","title":"0.12.0 (2020-03-03)"},{"location":"project/CHANGELOG.html#bug-fixes_25","text":"yaml not found in jsii languages ( 39ef409 )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0110-2020-03-03","text":"","title":"0.11.0 (2020-03-03)"},{"location":"project/CHANGELOG.html#bug-fixes_26","text":"yaml not found in jsii languages ( 39ef409 )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#0100-2020-02-28","text":"","title":"0.10.0 (2020-02-28)"},{"location":"project/CHANGELOG.html#bug-fixes_27","text":"cdk8s: autogenerated names fail validation for some resource types ( #18 ) ( b70e4fe ), closes #16","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#090-2020-02-27","text":"","title":"0.9.0 (2020-02-27)"},{"location":"project/CHANGELOG.html#features_30","text":"cdk8s: the App root construct ( #15 ) ( c595240 )","title":"Features"},{"location":"project/CHANGELOG.html#080-2020-02-27","text":"","title":"0.8.0 (2020-02-27)"},{"location":"project/CHANGELOG.html#features_31","text":"cli: remove the cookiecutter prerequisite ( #13 ) ( 10ab259 )","title":"Features"},{"location":"project/CHANGELOG.html#070-2020-02-26","text":"","title":"0.7.0 (2020-02-26)"},{"location":"project/CHANGELOG.html#bug-fixes_28","text":"cli: typescript-app does not include main.ts ( 43b435a )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#060-2020-02-26","text":"","title":"0.6.0 (2020-02-26)"},{"location":"project/CHANGELOG.html#bug-fixes_29","text":"cli does not work when used from a symlink ( #11 ) ( 4bd3a37 )","title":"Bug Fixes"},{"location":"project/CHANGELOG.html#050-2020-02-26","text":"","title":"0.5.0 (2020-02-26)"},{"location":"project/CHANGELOG.html#features_32","text":"cli: project templates with \u201ccdk8s init\u201d ( #10 ) ( 4aa59d9 ) cookiecutter template for typescript app projects ( #9 ) ( 55087e2 )","title":"Features"},{"location":"project/CHANGELOG.html#040-2020-02-23","text":"","title":"0.4.0 (2020-02-23)"},{"location":"project/CHANGELOG.html#features_33","text":"podinfo: allow containers to bind to deployment ( 45237c0 )","title":"Features"},{"location":"project/CHANGELOG.html#030-2020-02-23","text":"","title":"0.3.0 (2020-02-23)"},{"location":"project/CHANGELOG.html#features_34","text":"chart.generateObjectName ( 03a1d26 ) Chart.of(node) ( d6a9dc0 )","title":"Features"},{"location":"project/CHANGELOG.html#012-2020-02-12","text":"","title":"0.1.2 (2020-02-12)"},{"location":"project/CHANGELOG.html#features_35","text":"getting started documentation ( 2616372 )","title":"Features"},{"location":"project/CONTRIBUTING.html","text":"Contribution Guide \u00b6 cdk8s is licensed under Apache 2.0 and accepts contributions via GitHub pull requests. This document outlines some of the conventions on commit message formatting, contact points for developers, and other resources to help get contributions into cdk8s. You can contribute to cdk8s in many ways. Contributions of all shapes and sizes are welcome and celebrated: Reporting Issues Code Contributions RFCs For Maintainers We follows the CNCF Community Code of Conduct Reporting Issues \u00b6 If any part of the project has bugs or documentation mistakes, please let us know by raising an issue . We treat bugs and mistakes very seriously and believe no issue is too small. Before creating a bug report, please check that an issue reporting the same problem does not already exist. An issue can either be a bug report or a suggestion . If you wish to ask a question or seek guidance, please consider one of the other support channels . Bug reports \u00b6 To make the bug report accurate and easy to understand, please try to create bug reports that are: Specific : Include as much details as possible: which version, what environment, what configuration, etc. Reproducible : Include the steps to reproduce the problem. We understand some issues might be hard to reproduce, please includes the steps that might lead to the problem. If possible, please provide a minimal code snippet that reproduces the bug. Isolated : Please try to isolate and reproduce the bug with minimum dependencies. It would significantly slow down the speed to fix a bug if too many dependencies are involved in a bug report. Unique : Do not duplicate existing bug report. Scoped : One bug per report. Do not follow up with another bug inside one report. We might ask for further information to locate a bug. A duplicated bug report will be closed. Submit a bug report here . Suggestions \u00b6 We also accept suggestions for new features or missing capabilities as GitHub issues. The most important aspect of a suggestion issue is to provide as many details as possible about your use case and less focus on the solution. It is usually possible to support different use cases in many different ways, and we need to understand the motivation before we dive into a solution. If you wish to suggest a major change to the project, please consider to submit an RFC instead of a simple issue. An RFC also starts with a GitHub issue. Submit a suggestion here Code Contributions \u00b6 The general workflow for code contributions: Submit/find an issue in this repository Clone the relevant repo Make your code change Write tests & update docs Build & test locally Submit a pull request (Iterate) Your PR will be approved and merged Tracking issue \u00b6 All pull requests should be tracked with a GitHub issue. You should search for an existing issue or raise a new bug or suggestion . Add a comment indicating you are willing to pick it up in order to ensure no one else is currently working on it. If this is a major contribution, consider submitting an RFC to obtain feedback from the community and maintainers. Repositories \u00b6 This project consists of multiple modules, maintained and released via the following repositories: cdk8s-cli : command-line interface cdk8s-core : core library cdk8s-plus-17 : high-level constructs for Kubernetes core 1.17 and above. Development environment \u00b6 Prerequisites: Node.js >= 12.14.0 yarn >= 1.22.0 Prepare your environment: Fork the relevant repo and obtain a local clone. Install all dependencies: yarn install Run yarn build to build all modules. Unit tests \u00b6 Unit tests are located under the test/ directory within each module and use the jest framework. To run unit tests, execute yarn test either from the root of the repo (to unit test all modules) or from individual module directories: yarn test Out tests utilize jest snapshot testing . In case a snapshot needs to be updated, just run: yarn test -u Integration Tests \u00b6 Integration tests are executed against the latest published modules . This means that in order to execute integration tests against a development version, you\u2019lol need to yarn link your local version to this repository (all deps are at the root): $ cd cdk8s-core $ yarn link $ cd ../cdk8s $ yarn link cdk8s Now, you can run integration tests via: yarn integ Our integration tests also utilize snapshot testing. To update integration test snapshots, run: yarn integ:update Running Integration Tests \u00b6 The test directory contains integration tests for the cdk8s project. Each subdirectory represents a single test, with an entrypoint of test.sh . Tests are written as simple shell scripts and can simulate user activity. You can either run individual tests by executing their entrypoint directly (e.g. test-python-app/test.sh ) or run all tests by executing the script ./test-all.sh . Writing Integration Tests \u00b6 Create a new subdirectory with a test- prefix. Create a file named test.sh , make it executable. Test Environment: The script test.sh is executed within a temporary working directory under /tmp/xxxx/test (where xxxx is some random tmp file). See existing tests as examples on how to bring in auxiliary files to the test. Test MUST NOT install any dependencies or the cdk8s CLI. They can expect it to be available in the environment. To install dependencies from package managers, use yarn , npm , pipenv , mvn and nuget . Those programs will be shimmed to allow consuming local dependencies. Snapshot Testing \u00b6 Some integration tests utilize a simple snapshot testing mechanism. To update snapshots, run tests with: UPDATE_SNAPSHOTS=1 Or, run this from the root of the repo: yarn integ:update Docker environment for integration tests \u00b6 Due to the polyglot nature of the jsii tools used by cdk8s, the toolchain requirements are somewhat more complicated than for most projects. To help with this, you can use the jsii/superchain docker image that includes all the required tools. In order to get an interactive shell within a superchain container you can use the following command. docker run --rm --net=host -it -v $PWD:$PWD -w $PWD jsii/superchain Then once in the docker shell, you can package and execute the tests as normal. $ pip install pipenv # Currently not included in jsii docker image $ yarn build $ yarn run package $ yarn integ:update Note: this may leave some files owned as the docker root user id. These will need to be cleaned up manually. Pull Requests \u00b6 We use the PR title when we automatically generate the change log for each release. Therefore please following these guidelines to the letter: PR title : Must adhere to conventional commits . All lowercase with no period at the end of the title If this is a fix (bug) the title should describe the bug If this is a feat (feature) the title should describe the feature PR description : Describe how did you fix the bug or what changes you had to make in order to implement the feature Indicate fixes #NNN or resolves #NNN with the tracking issue number. If you had to test your change manually, describe how you tested it and paste the test results. If this is a breaking change, the last paragraph should describe the breaking change with the prefix BREAKING CHANGE: xxxxxx . Documentation \u00b6 Documentation is rendered from markdown using mkdocs-material and sourced from the docs directory. API documentation for cdk8s and all cdk8s-plus-* packages is auto-generated from inline docstrings during build. To test locally, install python3 deps: $ pip3 install -r docs/requirements.txt And then: $ mkdocs serve This will serve a local web server with the website. A good reference for syntax and capabilities is the mkdocs-material website. Examples \u00b6 Examples are stored under examples and organized according to programming language. Every example also has an entry under docs/examples/xxx which describes the example and includes links to the source code (on the main branch). RFCs \u00b6 An RFC (request for comments) is a document that proposes and details a change or addition to cdk8s. It also is a process for reviewing and discussing the proposal and tracking its implementation. \u201cRequest for comments\u201d means a request for discussion and oversight about the future of cdk8s from contributors and users. It is an open forum for suggestions, questions, and feedback. To create an RFC follow this process: Create an issue which will be the tracking issue for this RFC. Title should represent the title of the RFC. Description should provide the motivation for the RFC. Create a markdown file based off of rfc/0000-template.md under the rfc/<nnnn>-<title-of-rfc> where <nnnn> is the tracking issue number and <title-of-rfc> is a symbolic name for the title. For example: rfc/0030-construct-operators.md . File a pull request with this markdown file. The title of the PR should indicate rfc: <nnnn> <same as issue title> . The RFC will be reviewed as a pull request and once merged it means it is ready for implementation. Community Meeting \u00b6 Join us for the CDK8s community meeting which takes place the 2nd Monday of the month at 9:00am Pacific Time . Meeting link: https://chime.aws/7929414778 Agenda For Maintainers \u00b6 This section includes information that is relevant for the maintainers of the project. Version \u00b6 The current version of the project is mastered in the root lerna.json file. All other package.json files use 0.0.0 . This allows bumping a new version without needing to modify multiple files and avoid merge conflicts in post-release rebases. Release Protocol \u00b6 To release a new version of cdk8s following these steps: $ yarn bump This will create a new CHANGELOG entry (from conventional commits), bump the version in package.json and create a bump commit. Now, push to master (in the future we will release from a release branch, but in the meantime we release directly from master): $ git push origin master This will trigger the release workflow which will release to all package managers and will also create a GitHub release with a tag. Portions of this guide were adopted from the contribution guides of the AWS CDK and etcd .","title":"Contribution Guide"},{"location":"project/CONTRIBUTING.html#contribution-guide","text":"cdk8s is licensed under Apache 2.0 and accepts contributions via GitHub pull requests. This document outlines some of the conventions on commit message formatting, contact points for developers, and other resources to help get contributions into cdk8s. You can contribute to cdk8s in many ways. Contributions of all shapes and sizes are welcome and celebrated: Reporting Issues Code Contributions RFCs For Maintainers We follows the CNCF Community Code of Conduct","title":"Contribution Guide"},{"location":"project/CONTRIBUTING.html#reporting-issues","text":"If any part of the project has bugs or documentation mistakes, please let us know by raising an issue . We treat bugs and mistakes very seriously and believe no issue is too small. Before creating a bug report, please check that an issue reporting the same problem does not already exist. An issue can either be a bug report or a suggestion . If you wish to ask a question or seek guidance, please consider one of the other support channels .","title":"Reporting Issues"},{"location":"project/CONTRIBUTING.html#bug-reports","text":"To make the bug report accurate and easy to understand, please try to create bug reports that are: Specific : Include as much details as possible: which version, what environment, what configuration, etc. Reproducible : Include the steps to reproduce the problem. We understand some issues might be hard to reproduce, please includes the steps that might lead to the problem. If possible, please provide a minimal code snippet that reproduces the bug. Isolated : Please try to isolate and reproduce the bug with minimum dependencies. It would significantly slow down the speed to fix a bug if too many dependencies are involved in a bug report. Unique : Do not duplicate existing bug report. Scoped : One bug per report. Do not follow up with another bug inside one report. We might ask for further information to locate a bug. A duplicated bug report will be closed. Submit a bug report here .","title":"Bug reports"},{"location":"project/CONTRIBUTING.html#suggestions","text":"We also accept suggestions for new features or missing capabilities as GitHub issues. The most important aspect of a suggestion issue is to provide as many details as possible about your use case and less focus on the solution. It is usually possible to support different use cases in many different ways, and we need to understand the motivation before we dive into a solution. If you wish to suggest a major change to the project, please consider to submit an RFC instead of a simple issue. An RFC also starts with a GitHub issue. Submit a suggestion here","title":"Suggestions"},{"location":"project/CONTRIBUTING.html#code-contributions","text":"The general workflow for code contributions: Submit/find an issue in this repository Clone the relevant repo Make your code change Write tests & update docs Build & test locally Submit a pull request (Iterate) Your PR will be approved and merged","title":"Code Contributions"},{"location":"project/CONTRIBUTING.html#tracking-issue","text":"All pull requests should be tracked with a GitHub issue. You should search for an existing issue or raise a new bug or suggestion . Add a comment indicating you are willing to pick it up in order to ensure no one else is currently working on it. If this is a major contribution, consider submitting an RFC to obtain feedback from the community and maintainers.","title":"Tracking issue"},{"location":"project/CONTRIBUTING.html#repositories","text":"This project consists of multiple modules, maintained and released via the following repositories: cdk8s-cli : command-line interface cdk8s-core : core library cdk8s-plus-17 : high-level constructs for Kubernetes core 1.17 and above.","title":"Repositories"},{"location":"project/CONTRIBUTING.html#development-environment","text":"Prerequisites: Node.js >= 12.14.0 yarn >= 1.22.0 Prepare your environment: Fork the relevant repo and obtain a local clone. Install all dependencies: yarn install Run yarn build to build all modules.","title":"Development environment"},{"location":"project/CONTRIBUTING.html#unit-tests","text":"Unit tests are located under the test/ directory within each module and use the jest framework. To run unit tests, execute yarn test either from the root of the repo (to unit test all modules) or from individual module directories: yarn test Out tests utilize jest snapshot testing . In case a snapshot needs to be updated, just run: yarn test -u","title":"Unit tests"},{"location":"project/CONTRIBUTING.html#integration-tests","text":"Integration tests are executed against the latest published modules . This means that in order to execute integration tests against a development version, you\u2019lol need to yarn link your local version to this repository (all deps are at the root): $ cd cdk8s-core $ yarn link $ cd ../cdk8s $ yarn link cdk8s Now, you can run integration tests via: yarn integ Our integration tests also utilize snapshot testing. To update integration test snapshots, run: yarn integ:update","title":"Integration Tests"},{"location":"project/CONTRIBUTING.html#running-integration-tests","text":"The test directory contains integration tests for the cdk8s project. Each subdirectory represents a single test, with an entrypoint of test.sh . Tests are written as simple shell scripts and can simulate user activity. You can either run individual tests by executing their entrypoint directly (e.g. test-python-app/test.sh ) or run all tests by executing the script ./test-all.sh .","title":"Running Integration Tests"},{"location":"project/CONTRIBUTING.html#writing-integration-tests","text":"Create a new subdirectory with a test- prefix. Create a file named test.sh , make it executable. Test Environment: The script test.sh is executed within a temporary working directory under /tmp/xxxx/test (where xxxx is some random tmp file). See existing tests as examples on how to bring in auxiliary files to the test. Test MUST NOT install any dependencies or the cdk8s CLI. They can expect it to be available in the environment. To install dependencies from package managers, use yarn , npm , pipenv , mvn and nuget . Those programs will be shimmed to allow consuming local dependencies.","title":"Writing Integration Tests"},{"location":"project/CONTRIBUTING.html#snapshot-testing","text":"Some integration tests utilize a simple snapshot testing mechanism. To update snapshots, run tests with: UPDATE_SNAPSHOTS=1 Or, run this from the root of the repo: yarn integ:update","title":"Snapshot Testing"},{"location":"project/CONTRIBUTING.html#docker-environment-for-integration-tests","text":"Due to the polyglot nature of the jsii tools used by cdk8s, the toolchain requirements are somewhat more complicated than for most projects. To help with this, you can use the jsii/superchain docker image that includes all the required tools. In order to get an interactive shell within a superchain container you can use the following command. docker run --rm --net=host -it -v $PWD:$PWD -w $PWD jsii/superchain Then once in the docker shell, you can package and execute the tests as normal. $ pip install pipenv # Currently not included in jsii docker image $ yarn build $ yarn run package $ yarn integ:update Note: this may leave some files owned as the docker root user id. These will need to be cleaned up manually.","title":"Docker environment for integration tests"},{"location":"project/CONTRIBUTING.html#pull-requests","text":"We use the PR title when we automatically generate the change log for each release. Therefore please following these guidelines to the letter: PR title : Must adhere to conventional commits . All lowercase with no period at the end of the title If this is a fix (bug) the title should describe the bug If this is a feat (feature) the title should describe the feature PR description : Describe how did you fix the bug or what changes you had to make in order to implement the feature Indicate fixes #NNN or resolves #NNN with the tracking issue number. If you had to test your change manually, describe how you tested it and paste the test results. If this is a breaking change, the last paragraph should describe the breaking change with the prefix BREAKING CHANGE: xxxxxx .","title":"Pull Requests"},{"location":"project/CONTRIBUTING.html#documentation","text":"Documentation is rendered from markdown using mkdocs-material and sourced from the docs directory. API documentation for cdk8s and all cdk8s-plus-* packages is auto-generated from inline docstrings during build. To test locally, install python3 deps: $ pip3 install -r docs/requirements.txt And then: $ mkdocs serve This will serve a local web server with the website. A good reference for syntax and capabilities is the mkdocs-material website.","title":"Documentation"},{"location":"project/CONTRIBUTING.html#examples","text":"Examples are stored under examples and organized according to programming language. Every example also has an entry under docs/examples/xxx which describes the example and includes links to the source code (on the main branch).","title":"Examples"},{"location":"project/CONTRIBUTING.html#rfcs","text":"An RFC (request for comments) is a document that proposes and details a change or addition to cdk8s. It also is a process for reviewing and discussing the proposal and tracking its implementation. \u201cRequest for comments\u201d means a request for discussion and oversight about the future of cdk8s from contributors and users. It is an open forum for suggestions, questions, and feedback. To create an RFC follow this process: Create an issue which will be the tracking issue for this RFC. Title should represent the title of the RFC. Description should provide the motivation for the RFC. Create a markdown file based off of rfc/0000-template.md under the rfc/<nnnn>-<title-of-rfc> where <nnnn> is the tracking issue number and <title-of-rfc> is a symbolic name for the title. For example: rfc/0030-construct-operators.md . File a pull request with this markdown file. The title of the PR should indicate rfc: <nnnn> <same as issue title> . The RFC will be reviewed as a pull request and once merged it means it is ready for implementation.","title":"RFCs"},{"location":"project/CONTRIBUTING.html#community-meeting","text":"Join us for the CDK8s community meeting which takes place the 2nd Monday of the month at 9:00am Pacific Time . Meeting link: https://chime.aws/7929414778 Agenda","title":"Community Meeting"},{"location":"project/CONTRIBUTING.html#for-maintainers","text":"This section includes information that is relevant for the maintainers of the project.","title":"For Maintainers"},{"location":"project/CONTRIBUTING.html#version","text":"The current version of the project is mastered in the root lerna.json file. All other package.json files use 0.0.0 . This allows bumping a new version without needing to modify multiple files and avoid merge conflicts in post-release rebases.","title":"Version"},{"location":"project/CONTRIBUTING.html#release-protocol","text":"To release a new version of cdk8s following these steps: $ yarn bump This will create a new CHANGELOG entry (from conventional commits), bump the version in package.json and create a bump commit. Now, push to master (in the future we will release from a release branch, but in the meantime we release directly from master): $ git push origin master This will trigger the release workflow which will release to all package managers and will also create a GitHub release with a tag. Portions of this guide were adopted from the contribution guides of the AWS CDK and etcd .","title":"Release Protocol"},{"location":"project/ROADMAP.html","text":"Roadmap \u00b6 cdk8s is in alpha. To see items we are working on, visit the roadmap . You can submit an idea here .","title":"Roadmap"},{"location":"project/ROADMAP.html#roadmap","text":"cdk8s is in alpha. To see items we are working on, visit the roadmap . You can submit an idea here .","title":"Roadmap"},{"location":"reference/index.html","text":"Overview \u00b6 This section includes API reference for the various components of CDK8s: cdk8s : Core library cdk8s-plus-17 : Intent-based APIs for Kubernetes resources. (spec version 1.17.0 )","title":"Overview"},{"location":"reference/index.html#overview","text":"This section includes API reference for the various components of CDK8s: cdk8s : Core library cdk8s-plus-17 : Intent-based APIs for Kubernetes resources. (spec version 1.17.0 )","title":"Overview"},{"location":"reference/cdk8s-plus-17.html","text":"cdk8s-plus-17 \u00b6 Classes Name Description ConfigMap ConfigMap holds configuration data for pods to consume. Container A single application container that you want to run within a pod. Deployment A Deployment provides declarative updates for Pods and ReplicaSets. EnvValue Utility class for creating reading env values from various sources. IngressV1Beta1 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. IngressV1Beta1Backend The backend for an ingress path. Job A Job creates one or more Pods and ensures that a specified number of them successfully terminate. Pod Pod is a collection of containers that can run on a host. PodSpec Provides read/write capabilities ontop of a PodSpecProps . PodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Probe Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Resource Base class for all Kubernetes objects in stdk8s. Secret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Service An abstract way to expose an application running on a set of Pods as a network service. ServiceAccount A service account provides an identity for processes that run in a Pod. StatefulSet StatefulSet is the workload API object used to manage stateful applications. Volume Volume represents a named volume in a pod that may be accessed by any container in the pod. Structs Name Description AddDirectoryOptions Options for configmap.addDirectory() . CommandProbeOptions Options for Probe.fromCommand() . ConfigMapProps Properties for initialization of ConfigMap . ConfigMapVolumeOptions Options for the ConfigMap-based volume. ContainerProps Properties for creating a container. DeploymentProps Properties for initialization of Deployment . EmptyDirVolumeOptions Options for volumes populated with an empty directory. EnvValueFromConfigMapOptions Options to specify an envionment variable value from a ConfigMap key. EnvValueFromProcessOptions Options to specify an environment variable value from the process environment. EnvValueFromSecretOptions Options to specify an environment variable value from a Secret. ExposeOptions Options for exposing a deployment via a service. HttpGetProbeOptions Options for Probe.fromHttpGet() . IngressV1Beta1Props Properties for Ingress . IngressV1Beta1Rule Represents the rules mapping the paths under a specified host to the related backend services. JobProps Properties for initialization of Job . MountOptions Options for mounts. PathMapping Maps a string key to a path within a volume. PodProps Properties for initialization of Pod . PodSpecProps Properties of a PodSpec . PodTemplateProps Properties of a PodTemplate . ProbeOptions Probe options. ResourceProps Initialization properties for resources. SecretProps No description SecretValue Represents a specific value in JSON secret. ServiceAccountProps Properties for initialization of ServiceAccount . ServiceIngressV1BetaBackendOptions Options for setting up backends for ingress rules. ServicePort Definition of a service port. ServicePortOptions No description ServiceProps Properties for initialization of Service . StatefulSetProps Properties for initialization of StatefulSet . VolumeMount Mount a volume from the pod to the container. Interfaces Name Description IConfigMap Represents a config map. IPodSpec Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). IResource Represents a resource. ISecret No description IServiceAccount No description Enums Name Description EmptyDirMedium The medium on which to store the volume. ImagePullPolicy No description MountPropagation No description PodManagementPolicy Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. Protocol No description RestartPolicy Restart policy for all containers within the pod. ServiceType For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. class ConfigMap \u00b6 ConfigMap holds configuration data for pods to consume. Implements : IConstruct , IResource , IConfigMap , IResource Extends : Resource Initializer \u00b6 new ConfigMap ( scope : Construct , id : string , props? : ConfigMapProps ) scope ( Construct ) No description id ( string ) No description props ( ConfigMapProps ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional binaryData ( Map ) BinaryData contains the binary data. Optional data ( Map ) Data contains the configuration data. Optional Properties \u00b6 Name Type Description apiObject ApiObject The underlying cdk8s API object. binaryData Map The binary data associated with this config map. data Map The data associated with this config map. Methods \u00b6 addBinaryData(key, value) \u00b6 Adds a binary data entry to the config map. BinaryData can contain byte sequences that are not in the UTF-8 range. addBinaryData ( key : string , value : string ) : void key ( string ) The key. value ( string ) The value. addData(key, value) \u00b6 Adds a data entry to the config map. addData ( key : string , value : string ) : void key ( string ) The key. value ( string ) The value. addDirectory(localDir, options?) \u00b6 Adds a directory to the ConfigMap. addDirectory ( localDir : string , options? : AddDirectoryOptions ) : void localDir ( string ) A path to a local directory. options ( AddDirectoryOptions ) Options. exclude ( Array ) Glob patterns to exclude when adding files. Default : include all files keyPrefix ( string ) A prefix to add to all keys in the config map. Default : \u201c\u201d addFile(localFile, key?) \u00b6 Adds a file to the ConfigMap. addFile ( localFile : string , key? : string ) : void localFile ( string ) The path to the local file. key ( string ) The ConfigMap key (default to the file name). static fromConfigMapName(name) \u00b6 Represents a ConfigMap created elsewhere. static fromConfigMapName ( name : string ) : IConfigMap name ( string ) The name of the config map to import. Returns : * IConfigMap class Container \u00b6 A single application container that you want to run within a pod. Initializer \u00b6 new Container ( props : ContainerProps ) props ( ContainerProps ) No description image ( string ) Docker image name. args ( Array ) Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ( Array ) Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ( Map EnvValue > ) List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ( ImagePullPolicy ) Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ( Probe ) Periodic probe of container liveness. Default : no liveness probe is defined name ( string ) Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ( number ) Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ( Probe ) Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ( Probe ) StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ( Array< VolumeMount > ) Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ( string ) Container\u2019s working directory. Default : The container runtime\u2019s default. Properties \u00b6 Name Type Description env Map EnvValue > The environment variables for this container. image string The container image. imagePullPolicy ImagePullPolicy Image pull policy for this container. mounts Array< VolumeMount > Volume mounts configured for this container. name string The name of the container. args ? Array Arguments to the entrypoint. Optional command ? Array Entrypoint array (the command to execute when the container starts). Optional port ? number The port this container exposes. Optional workingDir ? string The working directory inside the container. Optional Methods \u00b6 addEnv(name, value) \u00b6 Add an environment value to the container. The variable value can come from various dynamic sources such a secrets of config maps. addEnv ( name : string , value : EnvValue ) : void name ( string ) - The variable name. value ( EnvValue ) - The variable value. mount(path, volume, options?) \u00b6 Mount a volume to a specific path so that it is accessible by the container. Every pod that is configured to use this container will autmoatically have access to the volume. mount ( path : string , volume : Volume , options? : MountOptions ) : void path ( string ) - The desired path in the container. volume ( Volume ) - The volume to mount. options ( MountOptions ) No description propagation ( MountPropagation ) Determines how mounts are propagated from the host to container and the other way around. Default : MountPropagation.NONE readOnly ( boolean ) Mounted read-only if true, read-write otherwise (false or unspecified). Default : false subPath ( string ) Path within the volume from which the container\u2019s volume should be mounted.). Default : \u201c\u201d the volume\u2019s root subPathExpr ( string ) Expanded path within the volume from which the container\u2019s volume should be mounted. Default : \u201c\u201d volume\u2019s root. class Deployment \u00b6 A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Implements : IConstruct , IResource , IPodTemplate , IPodSpec Extends : Resource Initializer \u00b6 new Deployment ( scope : Construct , id : string , props? : DeploymentProps ) scope ( Construct ) No description id ( string ) No description props ( DeploymentProps ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional containers ( Array< ContainerProps > ) List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. restartPolicy ( RestartPolicy ) Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ( IServiceAccount ) A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ( Array< Volume > ) List of volumes that can be mounted by containers belonging to the pod. Default : No volumes. podMetadata ( ApiObjectMetadata ) The pod metadata. Optional defaultSelector ( boolean ) Automatically allocates a pod selector for this deployment. Default : true replicas ( number ) Number of desired pods. Default : 1 Properties \u00b6 Name Type Description apiObject ApiObject The underlying cdk8s API object. containers Array< Container > The containers belonging to the pod. labelSelector Map The labels this deployment will match against in order to select pods. podMetadata ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas number Number of desired pods. volumes Array< Volume > The volumes associated with this pod. restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Optional serviceAccount ? IServiceAccount The service account used to run this pod. Optional Methods \u00b6 addContainer(container) \u00b6 Add a container to the pod. addContainer ( container : ContainerProps ) : Container container ( ContainerProps ) No description image ( string ) Docker image name. args ( Array ) Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ( Array ) Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ( Map EnvValue > ) List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ( ImagePullPolicy ) Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ( Probe ) Periodic probe of container liveness. Default : no liveness probe is defined name ( string ) Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ( number ) Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ( Probe ) Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ( Probe ) StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ( Array< VolumeMount > ) Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ( string ) Container\u2019s working directory. Default : The container runtime\u2019s default. Returns : * Container addVolume(volume) \u00b6 Add a volume to the pod. addVolume ( volume : Volume ) : void volume ( Volume ) No description expose(port, options?) \u00b6 Expose a deployment via a service. This is equivalent to running kubectl expose deployment <deployment-name> . expose ( port : number , options? : ExposeOptions ) : Service port ( number ) The port number the service will bind to. options ( ExposeOptions ) Options to determine details of the service and port exposed. name ( string ) The name of the service to expose. Default : undefined Uses the system generated name. protocol ( Protocol ) The IP protocol for this port. Default : Protocol.TCP serviceType ( ServiceType ) The type of the exposed service. Default : ClusterIP. targetPort ( number ) The port number the service will redirect to. Default : The port of the first container in the deployment (ie. containers[0].port) Returns : * Service selectByLabel(key, value) \u00b6 Configure a label selector to this deployment. Pods that have the label will be selected by deployments configured with this spec. selectByLabel ( key : string , value : string ) : void key ( string ) - The label key. value ( string ) - The label value. class EnvValue \u00b6 Utility class for creating reading env values from various sources. Properties \u00b6 Name Type Description value ? any Optional valueFrom ? any Optional Methods \u00b6 static fromConfigMap(configMap, key, options?) \u00b6 Create a value by reading a specific key inside a config map. static fromConfigMap ( configMap : IConfigMap , key : string , options? : EnvValueFromConfigMapOptions ) : EnvValue configMap ( IConfigMap ) - The config map. key ( string ) - The key to extract the value from. options ( EnvValueFromConfigMapOptions ) - Additional options. optional ( boolean ) Specify whether the ConfigMap or its key must be defined. Default : false Returns : * EnvValue static fromProcess(key, options?) \u00b6 Create a value from a key in the current process environment. static fromProcess ( key : string , options? : EnvValueFromProcessOptions ) : EnvValue key ( string ) - The key to read. options ( EnvValueFromProcessOptions ) - Additional options. required ( boolean ) Specify whether the key must exist in the environment. Default : false Returns : * EnvValue static fromSecretValue(secretValue, options?) \u00b6 Defines an environment value from a secret JSON value. static fromSecretValue ( secretValue : SecretValue , options? : EnvValueFromSecretOptions ) : EnvValue secretValue ( SecretValue ) The secret value (secrent + key). options ( EnvValueFromSecretOptions ) Additional options. optional ( boolean ) Specify whether the Secret or its key must be defined. Default : false Returns : * EnvValue static fromValue(value) \u00b6 Create a value from the given argument. static fromValue ( value : string ) : EnvValue value ( string ) - The value. Returns : * EnvValue class IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Implements : IConstruct , IResource Extends : Resource Initializer \u00b6 new IngressV1Beta1 ( scope : Construct , id : string , props? : IngressV1Beta1Props ) scope ( Construct ) No description id ( string ) No description props ( IngressV1Beta1Props ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional defaultBackend ( IngressV1Beta1Backend ) The default backend services requests that do not match any rule. Optional rules ( Array< IngressV1Beta1Rule > ) Routing rules for this ingress. Optional Properties \u00b6 Name Type Description apiObject ApiObject The underlying cdk8s API object. Methods \u00b6 addDefaultBackend(backend) \u00b6 Defines the default backend for this ingress. A default backend capable of servicing requests that don\u2019t match any rule. addDefaultBackend ( backend : IngressV1Beta1Backend ) : void backend ( IngressV1Beta1Backend ) The backend to use for requests that do not match any rule. addHostDefaultBackend(host, backend) \u00b6 Specify a default backend for a specific host name. This backend will be used as a catch-all for requests targeted to this host name (the Host header matches this value). addHostDefaultBackend ( host : string , backend : IngressV1Beta1Backend ) : void host ( string ) The host name to match. backend ( IngressV1Beta1Backend ) The backend to route to. addHostRule(host, path, backend) \u00b6 Adds an ingress rule applied to requests to a specific host and a specific HTTP path (the Host header matches this value). addHostRule ( host : string , path : string , backend : IngressV1Beta1Backend ) : void host ( string ) The host name. path ( string ) The HTTP path. backend ( IngressV1Beta1Backend ) The backend to route requests to. addRule(path, backend) \u00b6 Adds an ingress rule applied to requests sent to a specific HTTP path. addRule ( path : string , backend : IngressV1Beta1Backend ) : void path ( string ) The HTTP path. backend ( IngressV1Beta1Backend ) The backend to route requests to. addRules(\u2026rules) \u00b6 Adds rules to this ingress. addRules (... rules : IngressV1Beta1Rule []) : void rules ( IngressV1Beta1Rule ) The rules to add. backend ( IngressV1Beta1Backend ) Backend defines the referenced service endpoint to which the traffic will be forwarded to. host ( string ) Host is the fully qualified domain name of a network host, as defined by RFC 3986. Default : If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. path ( string ) Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. Default : If unspecified, the path defaults to a catch all sending traffic to the backend. protected onValidate() \u00b6 (deprecated) Validate the current construct. This method can be implemented by derived constructs in order to perform validation logic. It is called on all constructs before synthesis. protected onValidate () : Array < string > Returns : * Array class IngressV1Beta1Backend \u00b6 The backend for an ingress path. Methods \u00b6 static fromService(service, options?) \u00b6 A Kubernetes Service to use as the backend for this path. static fromService ( service : Service , options? : ServiceIngressV1BetaBackendOptions ) : IngressV1Beta1Backend service ( Service ) The service object. options ( ServiceIngressV1BetaBackendOptions ) No description port ( number ) The port to use to access the service. Default : if the service exposes a single port, this port will be used. Returns : * IngressV1Beta1Backend class Job \u00b6 A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Implements : IConstruct , IResource , IPodTemplate , IPodSpec Extends : Resource Initializer \u00b6 new Job ( scope : Construct , id : string , props? : JobProps ) scope ( Construct ) No description id ( string ) No description props ( JobProps ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional containers ( Array< ContainerProps > ) List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. restartPolicy ( RestartPolicy ) Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ( IServiceAccount ) A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ( Array< Volume > ) List of volumes that can be mounted by containers belonging to the pod. Default : No volumes. podMetadata ( ApiObjectMetadata ) The pod metadata. Optional activeDeadline ( Duration ) Specifies the duration the job may be active before the system tries to terminate it. Default : If unset, then there is no deadline. backoffLimit ( number ) Specifies the number of retries before marking this job failed. Default : If not set, system defaults to 6. ttlAfterFinished ( Duration ) Limits the lifetime of a Job that has finished execution (either Complete or Failed). Default : If this field is unset, the Job won\u2019t be automatically deleted. Properties \u00b6 Name Type Description apiObject ApiObject The underlying cdk8s API object. containers Array< Container > The containers belonging to the pod. podMetadata ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Array< Volume > The volumes associated with this pod. activeDeadline ? Duration Duration before job is terminated. Optional backoffLimit ? number Number of retries before marking failed. Optional restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Optional serviceAccount ? IServiceAccount The service account used to run this pod. Optional ttlAfterFinished ? Duration TTL before the job is deleted after it is finished. Optional Methods \u00b6 addContainer(container) \u00b6 Add a container to the pod. addContainer ( container : ContainerProps ) : Container container ( ContainerProps ) No description image ( string ) Docker image name. args ( Array ) Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ( Array ) Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ( Map EnvValue > ) List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ( ImagePullPolicy ) Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ( Probe ) Periodic probe of container liveness. Default : no liveness probe is defined name ( string ) Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ( number ) Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ( Probe ) Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ( Probe ) StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ( Array< VolumeMount > ) Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ( string ) Container\u2019s working directory. Default : The container runtime\u2019s default. Returns : * Container addVolume(volume) \u00b6 Add a volume to the pod. addVolume ( volume : Volume ) : void volume ( Volume ) No description class Pod \u00b6 Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Implements : IConstruct , IResource , IPodSpec Extends : Resource Initializer \u00b6 new Pod ( scope : Construct , id : string , props? : PodProps ) scope ( Construct ) No description id ( string ) No description props ( PodProps ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional containers ( Array< ContainerProps > ) List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. restartPolicy ( RestartPolicy ) Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ( IServiceAccount ) A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ( Array< Volume > ) List of volumes that can be mounted by containers belonging to the pod. Default : No volumes. Properties \u00b6 Name Type Description apiObject ApiObject The underlying cdk8s API object. containers Array< Container > The containers belonging to the pod. volumes Array< Volume > The volumes associated with this pod. restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Optional serviceAccount ? IServiceAccount The service account used to run this pod. Optional Methods \u00b6 addContainer(container) \u00b6 Add a container to the pod. addContainer ( container : ContainerProps ) : Container container ( ContainerProps ) No description image ( string ) Docker image name. args ( Array ) Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ( Array ) Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ( Map EnvValue > ) List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ( ImagePullPolicy ) Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ( Probe ) Periodic probe of container liveness. Default : no liveness probe is defined name ( string ) Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ( number ) Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ( Probe ) Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ( Probe ) StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ( Array< VolumeMount > ) Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ( string ) Container\u2019s working directory. Default : The container runtime\u2019s default. Returns : * Container addVolume(volume) \u00b6 Add a volume to the pod. addVolume ( volume : Volume ) : void volume ( Volume ) No description class PodSpec \u00b6 Provides read/write capabilities ontop of a PodSpecProps . Implements : IPodSpec Initializer \u00b6 new PodSpec ( props? : PodSpecProps ) props ( PodSpecProps ) No description containers ( Array< ContainerProps > ) List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. restartPolicy ( RestartPolicy ) Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ( IServiceAccount ) A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ( Array< Volume > ) List of volumes that can be mounted by containers belonging to the pod. Default : No volumes. Properties \u00b6 Name Type Description containers Array< Container > The containers belonging to the pod. volumes Array< Volume > The volumes associated with this pod. restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Optional serviceAccount ? IServiceAccount The service account used to run this pod. Optional Methods \u00b6 addContainer(container) \u00b6 Add a container to the pod. addContainer ( container : ContainerProps ) : Container container ( ContainerProps ) No description image ( string ) Docker image name. args ( Array ) Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ( Array ) Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ( Map EnvValue > ) List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ( ImagePullPolicy ) Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ( Probe ) Periodic probe of container liveness. Default : no liveness probe is defined name ( string ) Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ( number ) Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ( Probe ) Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ( Probe ) StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ( Array< VolumeMount > ) Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ( string ) Container\u2019s working directory. Default : The container runtime\u2019s default. Returns : * Container addVolume(volume) \u00b6 Add a volume to the pod. addVolume ( volume : Volume ) : void volume ( Volume ) No description class PodTemplate \u00b6 Provides read/write capabilities ontop of a PodTemplateProps . Implements : IPodSpec , IPodTemplate , IPodSpec Extends : PodSpec Initializer \u00b6 new PodTemplate ( props? : PodTemplateProps ) props ( PodTemplateProps ) No description containers ( Array< ContainerProps > ) List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. restartPolicy ( RestartPolicy ) Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ( IServiceAccount ) A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ( Array< Volume > ) List of volumes that can be mounted by containers belonging to the pod. Default : No volumes. podMetadata ( ApiObjectMetadata ) The pod metadata. Optional Properties \u00b6 Name Type Description podMetadata ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. class Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializer \u00b6 new Probe () Methods \u00b6 static fromCommand(command, options?) \u00b6 Defines a probe based on a command which is executed within the container. static fromCommand ( command : Array < string > , options? : CommandProbeOptions ) : Probe command ( Array ) The command to execute. options ( CommandProbeOptions ) Options. failureThreshold ( number ) Minimum consecutive failures for the probe to be considered failed after having succeeded. Default : 3 initialDelaySeconds ( Duration ) Number of seconds after the container has started before liveness probes are initiated. Default : immediate periodSeconds ( Duration ) How often (in seconds) to perform the probe. Default : Duration.seconds(10) Minimum value is 1. successThreshold ( number ) Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Default : 1 Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds ( Duration ) Number of seconds after which the probe times out. Default : Duration.seconds(1) Returns : * Probe static fromHttpGet(path, options?) \u00b6 Defines a probe based on an HTTP GET request to the IP address of the container. static fromHttpGet ( path : string , options? : HttpGetProbeOptions ) : Probe path ( string ) The URL path to hit. options ( HttpGetProbeOptions ) Options. failureThreshold ( number ) Minimum consecutive failures for the probe to be considered failed after having succeeded. Default : 3 initialDelaySeconds ( Duration ) Number of seconds after the container has started before liveness probes are initiated. Default : immediate periodSeconds ( Duration ) How often (in seconds) to perform the probe. Default : Duration.seconds(10) Minimum value is 1. successThreshold ( number ) Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Default : 1 Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds ( Duration ) Number of seconds after which the probe times out. Default : Duration.seconds(1) port ( number ) The TCP port to use when sending the GET request. Default : defaults to container.port . Returns : * Probe class Resource \u00b6 Base class for all Kubernetes objects in stdk8s. Represents a single resource. Implements : IConstruct , IResource Extends : Construct Implemented by : ConfigMap , Deployment , IngressV1Beta1 , Job , Pod , Secret , Service , ServiceAccount , StatefulSet Initializer \u00b6 Creates a new construct node. new Resource ( scope : Construct , id : string , options? : ConstructOptions ) scope ( Construct ) The scope in which to define this construct. id ( string ) The scoped construct ID. options ( ConstructOptions ) Options. nodeFactory ( INodeFactory ) A factory for attaching Node s to the construct. Default : the default Node is associated Properties \u00b6 Name Type Description apiObject ApiObject The underlying cdk8s API object. metadata ApiObjectMetadataDefinition name string The name of this API object. class Secret \u00b6 Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. Implements : IConstruct , IResource , ISecret , IResource Extends : Resource Initializer \u00b6 new Secret ( scope : Construct , id : string , props? : SecretProps ) scope ( Construct ) No description id ( string ) No description props ( SecretProps ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional stringData ( Map ) stringData allows specifying non-binary secret data in string form. Optional type ( string ) Optional type associated with the secret. Default : undefined - Don\u2019t set a type. Properties \u00b6 Name Type Description apiObject ApiObject The underlying cdk8s API object. Methods \u00b6 addStringData(key, value) \u00b6 Adds a string data field to the secert. addStringData ( key : string , value : string ) : void key ( string ) Key. value ( string ) Value. getStringData(key) \u00b6 Gets a string data by key or undefined. getStringData ( key : string ) : string key ( string ) Key. Returns : * string static fromSecretName(name) \u00b6 Imports a secret from the cluster as a reference. static fromSecretName ( name : string ) : ISecret name ( string ) The name of the secret to reference. Returns : * ISecret class Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Implements : IConstruct , IResource Extends : Resource Initializer \u00b6 new Service ( scope : Construct , id : string , props? : ServiceProps ) scope ( Construct ) No description id ( string ) No description props ( ServiceProps ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional clusterIP ( string ) The IP address of the service and is usually assigned randomly by the master. Default : Automatically assigned. externalIPs ( Array ) A list of IP addresses for which nodes in the cluster will also accept traffic for this service. Default : No external IPs. externalName ( string ) The externalName to be used when ServiceType.EXTERNAL_NAME is set. Default : No external name. loadBalancerSourceRanges ( Array ) A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. Optional ports ( Array< ServicePort > ) The port exposed by this service. Optional type ( ServiceType ) Determines how the Service is exposed. Default : ServiceType.ClusterIP Properties \u00b6 Name Type Description apiObject ApiObject The underlying cdk8s API object. ports Array< ServicePort > Ports for this service. selector Map Returns the labels which are used to select pods for this service. type ServiceType Determines how the Service is exposed. clusterIP ? string The IP address of the service and is usually assigned randomly by the master. Optional externalName ? string The externalName to be used for EXTERNAL_NAME types. Optional Methods \u00b6 addDeployment(deployment, port, options?) \u00b6 Associate a deployment to this service. If not targetPort is specific in the portOptions, then requests will be routed to the port exposed by the first container in the deployment\u2019s pods. The deployment\u2019s labelSelector will be used to select pods. addDeployment ( deployment : Deployment , port : number , options? : ServicePortOptions ) : void deployment ( Deployment ) The deployment to expose. port ( number ) The external port. options ( ServicePortOptions ) Optional settings for the port. name ( string ) The name of this port within the service. Optional nodePort ( number ) The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Default : to auto-allocate a port if the ServiceType of this Service requires one. protocol ( Protocol ) The IP protocol for this port. Default : Protocol.TCP targetPort ( number ) The port number the service will redirect to. Default : The value of port will be used. addSelector(label, value) \u00b6 Services defined using this spec will select pods according the provided label. addSelector ( label : string , value : string ) : void label ( string ) The label key. value ( string ) The label value. serve(port, options?) \u00b6 Configure a port the service will bind to. This method can be called multiple times. serve ( port : number , options? : ServicePortOptions ) : void port ( number ) The port definition. options ( ServicePortOptions ) No description name ( string ) The name of this port within the service. Optional nodePort ( number ) The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Default : to auto-allocate a port if the ServiceType of this Service requires one. protocol ( Protocol ) The IP protocol for this port. Default : Protocol.TCP targetPort ( number ) The port number the service will redirect to. Default : The value of port will be used. class ServiceAccount \u00b6 A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). Implements : IConstruct , IResource , IServiceAccount , IResource Extends : Resource Initializer \u00b6 new ServiceAccount ( scope : Construct , id : string , props? : ServiceAccountProps ) scope ( Construct ) No description id ( string ) No description props ( ServiceAccountProps ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional secrets ( Array< ISecret > ) List of secrets allowed to be used by pods running using this ServiceAccount. Optional Properties \u00b6 Name Type Description apiObject ApiObject The underlying cdk8s API object. secrets Array< ISecret > List of secrets allowed to be used by pods running using this service account. Methods \u00b6 addSecret(secret) \u00b6 Allow a secret to be accessed by pods using this service account. addSecret ( secret : ISecret ) : void secret ( ISecret ) The secret. static fromServiceAccountName(name) \u00b6 Imports a service account from the cluster as a reference. static fromServiceAccountName ( name : string ) : IServiceAccount name ( string ) The name of the service account resource. Returns : * IServiceAccount class StatefulSet \u00b6 StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Implements : IConstruct , IResource , IPodTemplate , IPodSpec Extends : Resource Initializer \u00b6 new StatefulSet ( scope : Construct , id : string , props : StatefulSetProps ) scope ( Construct ) No description id ( string ) No description props ( StatefulSetProps ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional containers ( Array< ContainerProps > ) List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. restartPolicy ( RestartPolicy ) Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ( IServiceAccount ) A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ( Array< Volume > ) List of volumes that can be mounted by containers belonging to the pod. Default : No volumes. podMetadata ( ApiObjectMetadata ) The pod metadata. Optional service ( Service ) Service to associate with the statefulset. defaultSelector ( boolean ) Automatically allocates a pod selector for this statefulset. Default : true podManagementPolicy ( PodManagementPolicy ) Pod management policy to use for this statefulset. Default : PodManagementPolicy.ORDERED_READY replicas ( number ) Number of desired pods. Default : 1 Properties \u00b6 Name Type Description apiObject ApiObject The underlying cdk8s API object. containers Array< Container > The containers belonging to the pod. labelSelector Map The labels this statefulset will match against in order to select pods. podManagementPolicy PodManagementPolicy Management policy to use for the set. podMetadata ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas number Number of desired pods. volumes Array< Volume > The volumes associated with this pod. restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Optional serviceAccount ? IServiceAccount The service account used to run this pod. Optional Methods \u00b6 addContainer(container) \u00b6 Add a container to the pod. addContainer ( container : ContainerProps ) : Container container ( ContainerProps ) No description image ( string ) Docker image name. args ( Array ) Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ( Array ) Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ( Map EnvValue > ) List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ( ImagePullPolicy ) Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ( Probe ) Periodic probe of container liveness. Default : no liveness probe is defined name ( string ) Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ( number ) Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ( Probe ) Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ( Probe ) StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ( Array< VolumeMount > ) Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ( string ) Container\u2019s working directory. Default : The container runtime\u2019s default. Returns : * Container addVolume(volume) \u00b6 Add a volume to the pod. addVolume ( volume : Volume ) : void volume ( Volume ) No description selectByLabel(key, value) \u00b6 Configure a label selector to this deployment. Pods that have the label will be selected by deployments configured with this spec. selectByLabel ( key : string , value : string ) : void key ( string ) - The label key. value ( string ) - The label value. class Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializer \u00b6 new Volume ( name : string , config : any ) name ( string ) No description config ( any ) No description Properties \u00b6 Name Type Description name string Methods \u00b6 static fromConfigMap(configMap, options?) \u00b6 Populate the volume from a ConfigMap. The configMap resource provides a way to inject configuration data into Pods. The data stored in a ConfigMap object can be referenced in a volume of type configMap and then consumed by containerized applications running in a Pod. When referencing a configMap object, you can simply provide its name in the volume to reference it. You can also customize the path to use for a specific entry in the ConfigMap. static fromConfigMap ( configMap : IConfigMap , options? : ConfigMapVolumeOptions ) : Volume configMap ( IConfigMap ) The config map to use to populate the volume. options ( ConfigMapVolumeOptions ) Options. defaultMode ( number ) Mode bits to use on created files by default. Default : 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items ( Map PathMapping > ) If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. Default : no mapping name ( string ) The volume name. Default : auto-generated optional ( boolean ) Specify whether the ConfigMap or its keys must be defined. Default : undocumented Returns : * Volume static fromEmptyDir(name, options?) \u00b6 An emptyDir volume is first created when a Pod is assigned to a Node, and exists as long as that Pod is running on that node. As the name says, it is initially empty. Containers in the Pod can all read and write the same files in the emptyDir volume, though that volume can be mounted at the same or different paths in each Container. When a Pod is removed from a node for any reason, the data in the emptyDir is deleted forever. static fromEmptyDir ( name : string , options? : EmptyDirVolumeOptions ) : Volume name ( string ) No description options ( EmptyDirVolumeOptions ) - Additional options. medium ( EmptyDirMedium ) By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. Default : EmptyDirMedium.DEFAULT sizeLimit ( Size ) Total amount of local storage required for this EmptyDir volume. Default : limit is undefined Returns : * Volume struct AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Name Type Description exclude ? Array Glob patterns to exclude when adding files. Default : include all files keyPrefix ? string A prefix to add to all keys in the config map. Default : \u201c\u201d struct CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Name Type Description failureThreshold ? number Minimum consecutive failures for the probe to be considered failed after having succeeded. Default : 3 initialDelaySeconds ? Duration Number of seconds after the container has started before liveness probes are initiated. Default : immediate periodSeconds ? Duration How often (in seconds) to perform the probe. Default : Duration.seconds(10) Minimum value is 1. successThreshold ? number Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Default : 1 Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds ? Duration Number of seconds after which the probe times out. Default : Duration.seconds(1) struct ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Name Type Description binaryData ? Map BinaryData contains the binary data. Optional data ? Map Data contains the configuration data. Optional metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional struct ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Name Type Description defaultMode ? number Mode bits to use on created files by default. Default : 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items ? Map PathMapping > If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. Default : no mapping name ? string The volume name. Default : auto-generated optional ? boolean Specify whether the ConfigMap or its keys must be defined. Default : undocumented struct ContainerProps \u00b6 Properties for creating a container. Name Type Description image string Docker image name. args ? Array Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ? Array Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ? Map EnvValue > List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ? ImagePullPolicy Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ? Probe Periodic probe of container liveness. Default : no liveness probe is defined name ? string Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ? number Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ? Probe Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ? Probe StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ? Array< VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ? string Container\u2019s working directory. Default : The container runtime\u2019s default. struct DeploymentProps \u00b6 Properties for initialization of Deployment . Name Type Description containers ? Array< ContainerProps > List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. defaultSelector ? boolean Automatically allocates a pod selector for this deployment. Default : true metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional podMetadata ? ApiObjectMetadata The pod metadata. Optional replicas ? number Number of desired pods. Default : 1 restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ? IServiceAccount A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ? Array< Volume > List of volumes that can be mounted by containers belonging to the pod. Default : No volumes. struct EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Name Type Description medium ? EmptyDirMedium By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. Default : EmptyDirMedium.DEFAULT sizeLimit ? Size Total amount of local storage required for this EmptyDir volume. Default : limit is undefined struct EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Name Type Description optional ? boolean Specify whether the ConfigMap or its key must be defined. Default : false struct EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Name Type Description required ? boolean Specify whether the key must exist in the environment. Default : false struct EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Name Type Description optional ? boolean Specify whether the Secret or its key must be defined. Default : false struct ExposeOptions \u00b6 Options for exposing a deployment via a service. Name Type Description name ? string The name of the service to expose. Default : undefined Uses the system generated name. protocol ? Protocol The IP protocol for this port. Default : Protocol.TCP serviceType ? ServiceType The type of the exposed service. Default : ClusterIP. targetPort ? number The port number the service will redirect to. Default : The port of the first container in the deployment (ie. containers[0].port) struct HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Name Type Description failureThreshold ? number Minimum consecutive failures for the probe to be considered failed after having succeeded. Default : 3 initialDelaySeconds ? Duration Number of seconds after the container has started before liveness probes are initiated. Default : immediate periodSeconds ? Duration How often (in seconds) to perform the probe. Default : Duration.seconds(10) Minimum value is 1. port ? number The TCP port to use when sending the GET request. Default : defaults to container.port . successThreshold ? number Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Default : 1 Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds ? Duration Number of seconds after which the probe times out. Default : Duration.seconds(1) interface IConfigMap \u00b6 Implemented by : ConfigMap Obtainable from : ConfigMap . fromConfigMapName () Represents a config map. Properties \u00b6 Name Type Description name string The Kubernetes name of this resource. interface IPodSpec \u00b6 Implemented by : Deployment , Job , Pod , PodSpec , PodTemplate , StatefulSet Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Properties \u00b6 Name Type Description containers Array< Container > The containers belonging to the pod. volumes Array< Volume > The volumes associated with this pod. restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Optional serviceAccount ? IServiceAccount The service account used to run this pod. Optional Methods \u00b6 addContainer(container) \u00b6 Add a container to the pod. addContainer ( container : ContainerProps ) : Container container ( ContainerProps ) The container. image ( string ) Docker image name. args ( Array ) Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ( Array ) Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ( Map EnvValue > ) List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ( ImagePullPolicy ) Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ( Probe ) Periodic probe of container liveness. Default : no liveness probe is defined name ( string ) Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ( number ) Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ( Probe ) Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ( Probe ) StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ( Array< VolumeMount > ) Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ( string ) Container\u2019s working directory. Default : The container runtime\u2019s default. Returns : * Container addVolume(volume) \u00b6 Add a volume to the pod. addVolume ( volume : Volume ) : void volume ( Volume ) The volume. interface IPodTemplate \u00b6 Implemented by : Deployment , Job , PodTemplate , StatefulSet Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 Name Type Description containers Array< Container > The containers belonging to the pod. podMetadata ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Array< Volume > The volumes associated with this pod. restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Optional serviceAccount ? IServiceAccount The service account used to run this pod. Optional Methods \u00b6 addContainer(container) \u00b6 Add a container to the pod. addContainer ( container : ContainerProps ) : Container container ( ContainerProps ) The container. image ( string ) Docker image name. args ( Array ) Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ( Array ) Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ( Map EnvValue > ) List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ( ImagePullPolicy ) Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ( Probe ) Periodic probe of container liveness. Default : no liveness probe is defined name ( string ) Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ( number ) Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ( Probe ) Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ( Probe ) StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ( Array< VolumeMount > ) Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ( string ) Container\u2019s working directory. Default : The container runtime\u2019s default. Returns : * Container addVolume(volume) \u00b6 Add a volume to the pod. addVolume ( volume : Volume ) : void volume ( Volume ) The volume. interface IResource \u00b6 Implemented by : ConfigMap , Deployment , IngressV1Beta1 , Job , Pod , Secret , Service , ServiceAccount , StatefulSet Represents a resource. Properties \u00b6 Name Type Description name string The Kubernetes name of this resource. interface ISecret \u00b6 Implemented by : Secret Obtainable from : Secret . fromSecretName () Properties \u00b6 Name Type Description name string The Kubernetes name of this resource. interface IServiceAccount \u00b6 Implemented by : ServiceAccount Obtainable from : ServiceAccount . fromServiceAccountName () Properties \u00b6 Name Type Description name string The Kubernetes name of this resource. struct IngressV1Beta1Props \u00b6 Properties for Ingress . Name Type Description defaultBackend ? IngressV1Beta1Backend The default backend services requests that do not match any rule. Optional metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional rules ? Array< IngressV1Beta1Rule > Routing rules for this ingress. Optional struct IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Name Type Description backend IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host ? string Host is the fully qualified domain name of a network host, as defined by RFC 3986. Default : If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. path ? string Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. Default : If unspecified, the path defaults to a catch all sending traffic to the backend. struct JobProps \u00b6 Properties for initialization of Job . Name Type Description activeDeadline ? Duration Specifies the duration the job may be active before the system tries to terminate it. Default : If unset, then there is no deadline. backoffLimit ? number Specifies the number of retries before marking this job failed. Default : If not set, system defaults to 6. containers ? Array< ContainerProps > List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional podMetadata ? ApiObjectMetadata The pod metadata. Optional restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ? IServiceAccount A service account provides an identity for processes that run in a Pod. Default : No service account. ttlAfterFinished ? Duration Limits the lifetime of a Job that has finished execution (either Complete or Failed). Default : If this field is unset, the Job won\u2019t be automatically deleted. volumes ? Array< Volume > List of volumes that can be mounted by containers belonging to the pod. Default : No volumes. struct MountOptions \u00b6 Options for mounts. Name Type Description propagation ? MountPropagation Determines how mounts are propagated from the host to container and the other way around. Default : MountPropagation.NONE readOnly ? boolean Mounted read-only if true, read-write otherwise (false or unspecified). Default : false subPath ? string Path within the volume from which the container\u2019s volume should be mounted.). Default : \u201c\u201d the volume\u2019s root subPathExpr ? string Expanded path within the volume from which the container\u2019s volume should be mounted. Default : \u201c\u201d volume\u2019s root. struct PathMapping \u00b6 Maps a string key to a path within a volume. Name Type Description path string The relative path of the file to map the key to. mode ? number Optional: mode bits to use on this file, must be a value between 0 and 0777. Optional struct PodProps \u00b6 Properties for initialization of Pod . Name Type Description containers ? Array< ContainerProps > List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ? IServiceAccount A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ? Array< Volume > List of volumes that can be mounted by containers belonging to the pod. Default : No volumes. struct PodSpecProps \u00b6 Properties of a PodSpec . Name Type Description containers ? Array< ContainerProps > List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ? IServiceAccount A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ? Array< Volume > List of volumes that can be mounted by containers belonging to the pod. Default : No volumes. struct PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Name Type Description containers ? Array< ContainerProps > List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. podMetadata ? ApiObjectMetadata The pod metadata. Optional restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ? IServiceAccount A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ? Array< Volume > List of volumes that can be mounted by containers belonging to the pod. Default : No volumes. struct ProbeOptions \u00b6 Probe options. Name Type Description failureThreshold ? number Minimum consecutive failures for the probe to be considered failed after having succeeded. Default : 3 initialDelaySeconds ? Duration Number of seconds after the container has started before liveness probes are initiated. Default : immediate periodSeconds ? Duration How often (in seconds) to perform the probe. Default : Duration.seconds(10) Minimum value is 1. successThreshold ? number Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Default : 1 Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds ? Duration Number of seconds after which the probe times out. Default : Duration.seconds(1) struct ResourceProps \u00b6 Initialization properties for resources. Name Type Description metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional struct SecretProps \u00b6 Name Type Description metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional stringData ? Map stringData allows specifying non-binary secret data in string form. Optional type ? string Optional type associated with the secret. Default : undefined - Don\u2019t set a type. struct SecretValue \u00b6 Represents a specific value in JSON secret. Name Type Description key string The JSON key. secret ISecret The secret. struct ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Name Type Description metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional secrets ? Array< ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. Optional struct ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Name Type Description port ? number The port to use to access the service. Default : if the service exposes a single port, this port will be used. struct ServicePort \u00b6 Definition of a service port. Name Type Description port number The port number the service will bind to. name ? string The name of this port within the service. Optional nodePort ? number The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Default : to auto-allocate a port if the ServiceType of this Service requires one. protocol ? Protocol The IP protocol for this port. Default : Protocol.TCP targetPort ? number The port number the service will redirect to. Default : The value of port will be used. struct ServicePortOptions \u00b6 Name Type Description name ? string The name of this port within the service. Optional nodePort ? number The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Default : to auto-allocate a port if the ServiceType of this Service requires one. protocol ? Protocol The IP protocol for this port. Default : Protocol.TCP targetPort ? number The port number the service will redirect to. Default : The value of port will be used. struct ServiceProps \u00b6 Properties for initialization of Service . Name Type Description clusterIP ? string The IP address of the service and is usually assigned randomly by the master. Default : Automatically assigned. externalIPs ? Array A list of IP addresses for which nodes in the cluster will also accept traffic for this service. Default : No external IPs. externalName ? string The externalName to be used when ServiceType.EXTERNAL_NAME is set. Default : No external name. loadBalancerSourceRanges ? Array A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. Optional metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional ports ? Array< ServicePort > The port exposed by this service. Optional type ? ServiceType Determines how the Service is exposed. Default : ServiceType.ClusterIP struct StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Name Type Description service Service Service to associate with the statefulset. containers ? Array< ContainerProps > List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. defaultSelector ? boolean Automatically allocates a pod selector for this statefulset. Default : true metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional podManagementPolicy ? PodManagementPolicy Pod management policy to use for this statefulset. Default : PodManagementPolicy.ORDERED_READY podMetadata ? ApiObjectMetadata The pod metadata. Optional replicas ? number Number of desired pods. Default : 1 restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ? IServiceAccount A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ? Array< Volume > List of volumes that can be mounted by containers belonging to the pod. Default : No volumes. struct VolumeMount \u00b6 Mount a volume from the pod to the container. Name Type Description path string Path within the container at which the volume should be mounted. volume Volume The volume to mount. propagation ? MountPropagation Determines how mounts are propagated from the host to container and the other way around. Default : MountPropagation.NONE readOnly ? boolean Mounted read-only if true, read-write otherwise (false or unspecified). Default : false subPath ? string Path within the volume from which the container\u2019s volume should be mounted.). Default : \u201c\u201d the volume\u2019s root subPathExpr ? string Expanded path within the volume from which the container\u2019s volume should be mounted. Default : \u201c\u201d volume\u2019s root. enum EmptyDirMedium \u00b6 The medium on which to store the volume. Name Description DEFAULT The default volume of the backing node. MEMORY Mount a tmpfs (RAM-backed filesystem) for you instead. enum ImagePullPolicy \u00b6 Name Description ALWAYS Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. IF_NOT_PRESENT The image is pulled only if it is not already present locally. NEVER The image is assumed to exist locally. enum MountPropagation \u00b6 Name Description NONE This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. HOST_TO_CONTAINER This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. BIDIRECTIONAL This volume mount behaves the same the HostToContainer mount. enum PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. Name Description ORDERED_READY PARALLEL enum Protocol \u00b6 Name Description TCP UDP SCTP enum RestartPolicy \u00b6 Restart policy for all containers within the pod. Name Description ALWAYS Always restart the pod after it exits. ON_FAILURE Only restart if the pod exits with a non-zero exit code. NEVER Never restart the pod. enum ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. Name Description CLUSTER_IP Exposes the Service on a cluster-internal IP. NODE_PORT Exposes the Service on each Node\u2019s IP at a static port (the NodePort). LOAD_BALANCER Exposes the Service externally using a cloud provider\u2019s load balancer. EXTERNAL_NAME Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up.","title":"cdk8s-plus-17"},{"location":"reference/cdk8s-plus-17.html#cdk8s-plus-17","text":"Classes Name Description ConfigMap ConfigMap holds configuration data for pods to consume. Container A single application container that you want to run within a pod. Deployment A Deployment provides declarative updates for Pods and ReplicaSets. EnvValue Utility class for creating reading env values from various sources. IngressV1Beta1 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. IngressV1Beta1Backend The backend for an ingress path. Job A Job creates one or more Pods and ensures that a specified number of them successfully terminate. Pod Pod is a collection of containers that can run on a host. PodSpec Provides read/write capabilities ontop of a PodSpecProps . PodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Probe Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Resource Base class for all Kubernetes objects in stdk8s. Secret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Service An abstract way to expose an application running on a set of Pods as a network service. ServiceAccount A service account provides an identity for processes that run in a Pod. StatefulSet StatefulSet is the workload API object used to manage stateful applications. Volume Volume represents a named volume in a pod that may be accessed by any container in the pod. Structs Name Description AddDirectoryOptions Options for configmap.addDirectory() . CommandProbeOptions Options for Probe.fromCommand() . ConfigMapProps Properties for initialization of ConfigMap . ConfigMapVolumeOptions Options for the ConfigMap-based volume. ContainerProps Properties for creating a container. DeploymentProps Properties for initialization of Deployment . EmptyDirVolumeOptions Options for volumes populated with an empty directory. EnvValueFromConfigMapOptions Options to specify an envionment variable value from a ConfigMap key. EnvValueFromProcessOptions Options to specify an environment variable value from the process environment. EnvValueFromSecretOptions Options to specify an environment variable value from a Secret. ExposeOptions Options for exposing a deployment via a service. HttpGetProbeOptions Options for Probe.fromHttpGet() . IngressV1Beta1Props Properties for Ingress . IngressV1Beta1Rule Represents the rules mapping the paths under a specified host to the related backend services. JobProps Properties for initialization of Job . MountOptions Options for mounts. PathMapping Maps a string key to a path within a volume. PodProps Properties for initialization of Pod . PodSpecProps Properties of a PodSpec . PodTemplateProps Properties of a PodTemplate . ProbeOptions Probe options. ResourceProps Initialization properties for resources. SecretProps No description SecretValue Represents a specific value in JSON secret. ServiceAccountProps Properties for initialization of ServiceAccount . ServiceIngressV1BetaBackendOptions Options for setting up backends for ingress rules. ServicePort Definition of a service port. ServicePortOptions No description ServiceProps Properties for initialization of Service . StatefulSetProps Properties for initialization of StatefulSet . VolumeMount Mount a volume from the pod to the container. Interfaces Name Description IConfigMap Represents a config map. IPodSpec Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). IResource Represents a resource. ISecret No description IServiceAccount No description Enums Name Description EmptyDirMedium The medium on which to store the volume. ImagePullPolicy No description MountPropagation No description PodManagementPolicy Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. Protocol No description RestartPolicy Restart policy for all containers within the pod. ServiceType For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster.","title":"cdk8s-plus-17"},{"location":"reference/cdk8s-plus-17.html#class-configmap","text":"ConfigMap holds configuration data for pods to consume. Implements : IConstruct , IResource , IConfigMap , IResource Extends : Resource","title":"class ConfigMap  "},{"location":"reference/cdk8s-plus-17.html#initializer","text":"new ConfigMap ( scope : Construct , id : string , props? : ConfigMapProps ) scope ( Construct ) No description id ( string ) No description props ( ConfigMapProps ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional binaryData ( Map ) BinaryData contains the binary data. Optional data ( Map ) Data contains the configuration data. Optional","title":"Initializer"},{"location":"reference/cdk8s-plus-17.html#properties","text":"Name Type Description apiObject ApiObject The underlying cdk8s API object. binaryData Map The binary data associated with this config map. data Map The data associated with this config map.","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#methods","text":"","title":"Methods"},{"location":"reference/cdk8s-plus-17.html#addbinarydatakey-value","text":"Adds a binary data entry to the config map. BinaryData can contain byte sequences that are not in the UTF-8 range. addBinaryData ( key : string , value : string ) : void key ( string ) The key. value ( string ) The value.","title":"addBinaryData(key, value) "},{"location":"reference/cdk8s-plus-17.html#adddatakey-value","text":"Adds a data entry to the config map. addData ( key : string , value : string ) : void key ( string ) The key. value ( string ) The value.","title":"addData(key, value) "},{"location":"reference/cdk8s-plus-17.html#adddirectorylocaldir-options","text":"Adds a directory to the ConfigMap. addDirectory ( localDir : string , options? : AddDirectoryOptions ) : void localDir ( string ) A path to a local directory. options ( AddDirectoryOptions ) Options. exclude ( Array ) Glob patterns to exclude when adding files. Default : include all files keyPrefix ( string ) A prefix to add to all keys in the config map. Default : \u201c\u201d","title":"addDirectory(localDir, options?) "},{"location":"reference/cdk8s-plus-17.html#addfilelocalfile-key","text":"Adds a file to the ConfigMap. addFile ( localFile : string , key? : string ) : void localFile ( string ) The path to the local file. key ( string ) The ConfigMap key (default to the file name).","title":"addFile(localFile, key?) "},{"location":"reference/cdk8s-plus-17.html#static-fromconfigmapnamename","text":"Represents a ConfigMap created elsewhere. static fromConfigMapName ( name : string ) : IConfigMap name ( string ) The name of the config map to import. Returns : * IConfigMap","title":"static fromConfigMapName(name) "},{"location":"reference/cdk8s-plus-17.html#class-container","text":"A single application container that you want to run within a pod.","title":"class Container  "},{"location":"reference/cdk8s-plus-17.html#initializer_1","text":"new Container ( props : ContainerProps ) props ( ContainerProps ) No description image ( string ) Docker image name. args ( Array ) Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ( Array ) Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ( Map EnvValue > ) List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ( ImagePullPolicy ) Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ( Probe ) Periodic probe of container liveness. Default : no liveness probe is defined name ( string ) Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ( number ) Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ( Probe ) Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ( Probe ) StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ( Array< VolumeMount > ) Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ( string ) Container\u2019s working directory. Default : The container runtime\u2019s default.","title":"Initializer"},{"location":"reference/cdk8s-plus-17.html#properties_1","text":"Name Type Description env Map EnvValue > The environment variables for this container. image string The container image. imagePullPolicy ImagePullPolicy Image pull policy for this container. mounts Array< VolumeMount > Volume mounts configured for this container. name string The name of the container. args ? Array Arguments to the entrypoint. Optional command ? Array Entrypoint array (the command to execute when the container starts). Optional port ? number The port this container exposes. Optional workingDir ? string The working directory inside the container. Optional","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#methods_1","text":"","title":"Methods"},{"location":"reference/cdk8s-plus-17.html#addenvname-value","text":"Add an environment value to the container. The variable value can come from various dynamic sources such a secrets of config maps. addEnv ( name : string , value : EnvValue ) : void name ( string ) - The variable name. value ( EnvValue ) - The variable value.","title":"addEnv(name, value) "},{"location":"reference/cdk8s-plus-17.html#mountpath-volume-options","text":"Mount a volume to a specific path so that it is accessible by the container. Every pod that is configured to use this container will autmoatically have access to the volume. mount ( path : string , volume : Volume , options? : MountOptions ) : void path ( string ) - The desired path in the container. volume ( Volume ) - The volume to mount. options ( MountOptions ) No description propagation ( MountPropagation ) Determines how mounts are propagated from the host to container and the other way around. Default : MountPropagation.NONE readOnly ( boolean ) Mounted read-only if true, read-write otherwise (false or unspecified). Default : false subPath ( string ) Path within the volume from which the container\u2019s volume should be mounted.). Default : \u201c\u201d the volume\u2019s root subPathExpr ( string ) Expanded path within the volume from which the container\u2019s volume should be mounted. Default : \u201c\u201d volume\u2019s root.","title":"mount(path, volume, options?) "},{"location":"reference/cdk8s-plus-17.html#class-deployment","text":"A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"class Deployment  "},{"location":"reference/cdk8s-plus-17.html#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Implements : IConstruct , IResource , IPodTemplate , IPodSpec Extends : Resource","title":"Use Case"},{"location":"reference/cdk8s-plus-17.html#initializer_2","text":"new Deployment ( scope : Construct , id : string , props? : DeploymentProps ) scope ( Construct ) No description id ( string ) No description props ( DeploymentProps ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional containers ( Array< ContainerProps > ) List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. restartPolicy ( RestartPolicy ) Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ( IServiceAccount ) A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ( Array< Volume > ) List of volumes that can be mounted by containers belonging to the pod. Default : No volumes. podMetadata ( ApiObjectMetadata ) The pod metadata. Optional defaultSelector ( boolean ) Automatically allocates a pod selector for this deployment. Default : true replicas ( number ) Number of desired pods. Default : 1","title":"Initializer"},{"location":"reference/cdk8s-plus-17.html#properties_2","text":"Name Type Description apiObject ApiObject The underlying cdk8s API object. containers Array< Container > The containers belonging to the pod. labelSelector Map The labels this deployment will match against in order to select pods. podMetadata ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas number Number of desired pods. volumes Array< Volume > The volumes associated with this pod. restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Optional serviceAccount ? IServiceAccount The service account used to run this pod. Optional","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#methods_2","text":"","title":"Methods"},{"location":"reference/cdk8s-plus-17.html#addcontainercontainer","text":"Add a container to the pod. addContainer ( container : ContainerProps ) : Container container ( ContainerProps ) No description image ( string ) Docker image name. args ( Array ) Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ( Array ) Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ( Map EnvValue > ) List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ( ImagePullPolicy ) Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ( Probe ) Periodic probe of container liveness. Default : no liveness probe is defined name ( string ) Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ( number ) Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ( Probe ) Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ( Probe ) StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ( Array< VolumeMount > ) Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ( string ) Container\u2019s working directory. Default : The container runtime\u2019s default. Returns : * Container","title":"addContainer(container) "},{"location":"reference/cdk8s-plus-17.html#addvolumevolume","text":"Add a volume to the pod. addVolume ( volume : Volume ) : void volume ( Volume ) No description","title":"addVolume(volume) "},{"location":"reference/cdk8s-plus-17.html#exposeport-options","text":"Expose a deployment via a service. This is equivalent to running kubectl expose deployment <deployment-name> . expose ( port : number , options? : ExposeOptions ) : Service port ( number ) The port number the service will bind to. options ( ExposeOptions ) Options to determine details of the service and port exposed. name ( string ) The name of the service to expose. Default : undefined Uses the system generated name. protocol ( Protocol ) The IP protocol for this port. Default : Protocol.TCP serviceType ( ServiceType ) The type of the exposed service. Default : ClusterIP. targetPort ( number ) The port number the service will redirect to. Default : The port of the first container in the deployment (ie. containers[0].port) Returns : * Service","title":"expose(port, options?) "},{"location":"reference/cdk8s-plus-17.html#selectbylabelkey-value","text":"Configure a label selector to this deployment. Pods that have the label will be selected by deployments configured with this spec. selectByLabel ( key : string , value : string ) : void key ( string ) - The label key. value ( string ) - The label value.","title":"selectByLabel(key, value) "},{"location":"reference/cdk8s-plus-17.html#class-envvalue","text":"Utility class for creating reading env values from various sources.","title":"class EnvValue  "},{"location":"reference/cdk8s-plus-17.html#properties_3","text":"Name Type Description value ? any Optional valueFrom ? any Optional","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#methods_3","text":"","title":"Methods"},{"location":"reference/cdk8s-plus-17.html#static-fromconfigmapconfigmap-key-options","text":"Create a value by reading a specific key inside a config map. static fromConfigMap ( configMap : IConfigMap , key : string , options? : EnvValueFromConfigMapOptions ) : EnvValue configMap ( IConfigMap ) - The config map. key ( string ) - The key to extract the value from. options ( EnvValueFromConfigMapOptions ) - Additional options. optional ( boolean ) Specify whether the ConfigMap or its key must be defined. Default : false Returns : * EnvValue","title":"static fromConfigMap(configMap, key, options?) "},{"location":"reference/cdk8s-plus-17.html#static-fromprocesskey-options","text":"Create a value from a key in the current process environment. static fromProcess ( key : string , options? : EnvValueFromProcessOptions ) : EnvValue key ( string ) - The key to read. options ( EnvValueFromProcessOptions ) - Additional options. required ( boolean ) Specify whether the key must exist in the environment. Default : false Returns : * EnvValue","title":"static fromProcess(key, options?) "},{"location":"reference/cdk8s-plus-17.html#static-fromsecretvaluesecretvalue-options","text":"Defines an environment value from a secret JSON value. static fromSecretValue ( secretValue : SecretValue , options? : EnvValueFromSecretOptions ) : EnvValue secretValue ( SecretValue ) The secret value (secrent + key). options ( EnvValueFromSecretOptions ) Additional options. optional ( boolean ) Specify whether the Secret or its key must be defined. Default : false Returns : * EnvValue","title":"static fromSecretValue(secretValue, options?) "},{"location":"reference/cdk8s-plus-17.html#static-fromvaluevalue","text":"Create a value from the given argument. static fromValue ( value : string ) : EnvValue value ( string ) - The value. Returns : * EnvValue","title":"static fromValue(value) "},{"location":"reference/cdk8s-plus-17.html#class-ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Implements : IConstruct , IResource Extends : Resource","title":"class IngressV1Beta1  "},{"location":"reference/cdk8s-plus-17.html#initializer_3","text":"new IngressV1Beta1 ( scope : Construct , id : string , props? : IngressV1Beta1Props ) scope ( Construct ) No description id ( string ) No description props ( IngressV1Beta1Props ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional defaultBackend ( IngressV1Beta1Backend ) The default backend services requests that do not match any rule. Optional rules ( Array< IngressV1Beta1Rule > ) Routing rules for this ingress. Optional","title":"Initializer"},{"location":"reference/cdk8s-plus-17.html#properties_4","text":"Name Type Description apiObject ApiObject The underlying cdk8s API object.","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#methods_4","text":"","title":"Methods"},{"location":"reference/cdk8s-plus-17.html#adddefaultbackendbackend","text":"Defines the default backend for this ingress. A default backend capable of servicing requests that don\u2019t match any rule. addDefaultBackend ( backend : IngressV1Beta1Backend ) : void backend ( IngressV1Beta1Backend ) The backend to use for requests that do not match any rule.","title":"addDefaultBackend(backend) "},{"location":"reference/cdk8s-plus-17.html#addhostdefaultbackendhost-backend","text":"Specify a default backend for a specific host name. This backend will be used as a catch-all for requests targeted to this host name (the Host header matches this value). addHostDefaultBackend ( host : string , backend : IngressV1Beta1Backend ) : void host ( string ) The host name to match. backend ( IngressV1Beta1Backend ) The backend to route to.","title":"addHostDefaultBackend(host, backend) "},{"location":"reference/cdk8s-plus-17.html#addhostrulehost-path-backend","text":"Adds an ingress rule applied to requests to a specific host and a specific HTTP path (the Host header matches this value). addHostRule ( host : string , path : string , backend : IngressV1Beta1Backend ) : void host ( string ) The host name. path ( string ) The HTTP path. backend ( IngressV1Beta1Backend ) The backend to route requests to.","title":"addHostRule(host, path, backend) "},{"location":"reference/cdk8s-plus-17.html#addrulepath-backend","text":"Adds an ingress rule applied to requests sent to a specific HTTP path. addRule ( path : string , backend : IngressV1Beta1Backend ) : void path ( string ) The HTTP path. backend ( IngressV1Beta1Backend ) The backend to route requests to.","title":"addRule(path, backend) "},{"location":"reference/cdk8s-plus-17.html#addrulesrules","text":"Adds rules to this ingress. addRules (... rules : IngressV1Beta1Rule []) : void rules ( IngressV1Beta1Rule ) The rules to add. backend ( IngressV1Beta1Backend ) Backend defines the referenced service endpoint to which the traffic will be forwarded to. host ( string ) Host is the fully qualified domain name of a network host, as defined by RFC 3986. Default : If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. path ( string ) Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. Default : If unspecified, the path defaults to a catch all sending traffic to the backend.","title":"addRules(...rules) "},{"location":"reference/cdk8s-plus-17.html#protected-onvalidate","text":"(deprecated) Validate the current construct. This method can be implemented by derived constructs in order to perform validation logic. It is called on all constructs before synthesis. protected onValidate () : Array < string > Returns : * Array","title":"protected onValidate() "},{"location":"reference/cdk8s-plus-17.html#class-ingressv1beta1backend","text":"The backend for an ingress path.","title":"class IngressV1Beta1Backend  "},{"location":"reference/cdk8s-plus-17.html#methods_5","text":"","title":"Methods"},{"location":"reference/cdk8s-plus-17.html#static-fromserviceservice-options","text":"A Kubernetes Service to use as the backend for this path. static fromService ( service : Service , options? : ServiceIngressV1BetaBackendOptions ) : IngressV1Beta1Backend service ( Service ) The service object. options ( ServiceIngressV1BetaBackendOptions ) No description port ( number ) The port to use to access the service. Default : if the service exposes a single port, this port will be used. Returns : * IngressV1Beta1Backend","title":"static fromService(service, options?) "},{"location":"reference/cdk8s-plus-17.html#class-job","text":"A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Implements : IConstruct , IResource , IPodTemplate , IPodSpec Extends : Resource","title":"class Job  "},{"location":"reference/cdk8s-plus-17.html#initializer_4","text":"new Job ( scope : Construct , id : string , props? : JobProps ) scope ( Construct ) No description id ( string ) No description props ( JobProps ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional containers ( Array< ContainerProps > ) List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. restartPolicy ( RestartPolicy ) Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ( IServiceAccount ) A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ( Array< Volume > ) List of volumes that can be mounted by containers belonging to the pod. Default : No volumes. podMetadata ( ApiObjectMetadata ) The pod metadata. Optional activeDeadline ( Duration ) Specifies the duration the job may be active before the system tries to terminate it. Default : If unset, then there is no deadline. backoffLimit ( number ) Specifies the number of retries before marking this job failed. Default : If not set, system defaults to 6. ttlAfterFinished ( Duration ) Limits the lifetime of a Job that has finished execution (either Complete or Failed). Default : If this field is unset, the Job won\u2019t be automatically deleted.","title":"Initializer"},{"location":"reference/cdk8s-plus-17.html#properties_5","text":"Name Type Description apiObject ApiObject The underlying cdk8s API object. containers Array< Container > The containers belonging to the pod. podMetadata ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Array< Volume > The volumes associated with this pod. activeDeadline ? Duration Duration before job is terminated. Optional backoffLimit ? number Number of retries before marking failed. Optional restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Optional serviceAccount ? IServiceAccount The service account used to run this pod. Optional ttlAfterFinished ? Duration TTL before the job is deleted after it is finished. Optional","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#methods_6","text":"","title":"Methods"},{"location":"reference/cdk8s-plus-17.html#addcontainercontainer_1","text":"Add a container to the pod. addContainer ( container : ContainerProps ) : Container container ( ContainerProps ) No description image ( string ) Docker image name. args ( Array ) Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ( Array ) Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ( Map EnvValue > ) List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ( ImagePullPolicy ) Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ( Probe ) Periodic probe of container liveness. Default : no liveness probe is defined name ( string ) Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ( number ) Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ( Probe ) Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ( Probe ) StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ( Array< VolumeMount > ) Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ( string ) Container\u2019s working directory. Default : The container runtime\u2019s default. Returns : * Container","title":"addContainer(container) "},{"location":"reference/cdk8s-plus-17.html#addvolumevolume_1","text":"Add a volume to the pod. addVolume ( volume : Volume ) : void volume ( Volume ) No description","title":"addVolume(volume) "},{"location":"reference/cdk8s-plus-17.html#class-pod","text":"Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Implements : IConstruct , IResource , IPodSpec Extends : Resource","title":"class Pod  "},{"location":"reference/cdk8s-plus-17.html#initializer_5","text":"new Pod ( scope : Construct , id : string , props? : PodProps ) scope ( Construct ) No description id ( string ) No description props ( PodProps ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional containers ( Array< ContainerProps > ) List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. restartPolicy ( RestartPolicy ) Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ( IServiceAccount ) A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ( Array< Volume > ) List of volumes that can be mounted by containers belonging to the pod. Default : No volumes.","title":"Initializer"},{"location":"reference/cdk8s-plus-17.html#properties_6","text":"Name Type Description apiObject ApiObject The underlying cdk8s API object. containers Array< Container > The containers belonging to the pod. volumes Array< Volume > The volumes associated with this pod. restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Optional serviceAccount ? IServiceAccount The service account used to run this pod. Optional","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#methods_7","text":"","title":"Methods"},{"location":"reference/cdk8s-plus-17.html#addcontainercontainer_2","text":"Add a container to the pod. addContainer ( container : ContainerProps ) : Container container ( ContainerProps ) No description image ( string ) Docker image name. args ( Array ) Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ( Array ) Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ( Map EnvValue > ) List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ( ImagePullPolicy ) Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ( Probe ) Periodic probe of container liveness. Default : no liveness probe is defined name ( string ) Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ( number ) Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ( Probe ) Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ( Probe ) StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ( Array< VolumeMount > ) Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ( string ) Container\u2019s working directory. Default : The container runtime\u2019s default. Returns : * Container","title":"addContainer(container) "},{"location":"reference/cdk8s-plus-17.html#addvolumevolume_2","text":"Add a volume to the pod. addVolume ( volume : Volume ) : void volume ( Volume ) No description","title":"addVolume(volume) "},{"location":"reference/cdk8s-plus-17.html#class-podspec","text":"Provides read/write capabilities ontop of a PodSpecProps . Implements : IPodSpec","title":"class PodSpec  "},{"location":"reference/cdk8s-plus-17.html#initializer_6","text":"new PodSpec ( props? : PodSpecProps ) props ( PodSpecProps ) No description containers ( Array< ContainerProps > ) List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. restartPolicy ( RestartPolicy ) Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ( IServiceAccount ) A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ( Array< Volume > ) List of volumes that can be mounted by containers belonging to the pod. Default : No volumes.","title":"Initializer"},{"location":"reference/cdk8s-plus-17.html#properties_7","text":"Name Type Description containers Array< Container > The containers belonging to the pod. volumes Array< Volume > The volumes associated with this pod. restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Optional serviceAccount ? IServiceAccount The service account used to run this pod. Optional","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#methods_8","text":"","title":"Methods"},{"location":"reference/cdk8s-plus-17.html#addcontainercontainer_3","text":"Add a container to the pod. addContainer ( container : ContainerProps ) : Container container ( ContainerProps ) No description image ( string ) Docker image name. args ( Array ) Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ( Array ) Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ( Map EnvValue > ) List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ( ImagePullPolicy ) Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ( Probe ) Periodic probe of container liveness. Default : no liveness probe is defined name ( string ) Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ( number ) Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ( Probe ) Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ( Probe ) StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ( Array< VolumeMount > ) Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ( string ) Container\u2019s working directory. Default : The container runtime\u2019s default. Returns : * Container","title":"addContainer(container) "},{"location":"reference/cdk8s-plus-17.html#addvolumevolume_3","text":"Add a volume to the pod. addVolume ( volume : Volume ) : void volume ( Volume ) No description","title":"addVolume(volume) "},{"location":"reference/cdk8s-plus-17.html#class-podtemplate","text":"Provides read/write capabilities ontop of a PodTemplateProps . Implements : IPodSpec , IPodTemplate , IPodSpec Extends : PodSpec","title":"class PodTemplate  "},{"location":"reference/cdk8s-plus-17.html#initializer_7","text":"new PodTemplate ( props? : PodTemplateProps ) props ( PodTemplateProps ) No description containers ( Array< ContainerProps > ) List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. restartPolicy ( RestartPolicy ) Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ( IServiceAccount ) A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ( Array< Volume > ) List of volumes that can be mounted by containers belonging to the pod. Default : No volumes. podMetadata ( ApiObjectMetadata ) The pod metadata. Optional","title":"Initializer"},{"location":"reference/cdk8s-plus-17.html#properties_8","text":"Name Type Description podMetadata ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource.","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#class-probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"class Probe  "},{"location":"reference/cdk8s-plus-17.html#initializer_8","text":"new Probe ()","title":"Initializer"},{"location":"reference/cdk8s-plus-17.html#methods_9","text":"","title":"Methods"},{"location":"reference/cdk8s-plus-17.html#static-fromcommandcommand-options","text":"Defines a probe based on a command which is executed within the container. static fromCommand ( command : Array < string > , options? : CommandProbeOptions ) : Probe command ( Array ) The command to execute. options ( CommandProbeOptions ) Options. failureThreshold ( number ) Minimum consecutive failures for the probe to be considered failed after having succeeded. Default : 3 initialDelaySeconds ( Duration ) Number of seconds after the container has started before liveness probes are initiated. Default : immediate periodSeconds ( Duration ) How often (in seconds) to perform the probe. Default : Duration.seconds(10) Minimum value is 1. successThreshold ( number ) Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Default : 1 Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds ( Duration ) Number of seconds after which the probe times out. Default : Duration.seconds(1) Returns : * Probe","title":"static fromCommand(command, options?) "},{"location":"reference/cdk8s-plus-17.html#static-fromhttpgetpath-options","text":"Defines a probe based on an HTTP GET request to the IP address of the container. static fromHttpGet ( path : string , options? : HttpGetProbeOptions ) : Probe path ( string ) The URL path to hit. options ( HttpGetProbeOptions ) Options. failureThreshold ( number ) Minimum consecutive failures for the probe to be considered failed after having succeeded. Default : 3 initialDelaySeconds ( Duration ) Number of seconds after the container has started before liveness probes are initiated. Default : immediate periodSeconds ( Duration ) How often (in seconds) to perform the probe. Default : Duration.seconds(10) Minimum value is 1. successThreshold ( number ) Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Default : 1 Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds ( Duration ) Number of seconds after which the probe times out. Default : Duration.seconds(1) port ( number ) The TCP port to use when sending the GET request. Default : defaults to container.port . Returns : * Probe","title":"static fromHttpGet(path, options?) "},{"location":"reference/cdk8s-plus-17.html#class-resource","text":"Base class for all Kubernetes objects in stdk8s. Represents a single resource. Implements : IConstruct , IResource Extends : Construct Implemented by : ConfigMap , Deployment , IngressV1Beta1 , Job , Pod , Secret , Service , ServiceAccount , StatefulSet","title":"class Resource  "},{"location":"reference/cdk8s-plus-17.html#initializer_9","text":"Creates a new construct node. new Resource ( scope : Construct , id : string , options? : ConstructOptions ) scope ( Construct ) The scope in which to define this construct. id ( string ) The scoped construct ID. options ( ConstructOptions ) Options. nodeFactory ( INodeFactory ) A factory for attaching Node s to the construct. Default : the default Node is associated","title":"Initializer"},{"location":"reference/cdk8s-plus-17.html#properties_9","text":"Name Type Description apiObject ApiObject The underlying cdk8s API object. metadata ApiObjectMetadataDefinition name string The name of this API object.","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#class-secret","text":"Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. Implements : IConstruct , IResource , ISecret , IResource Extends : Resource","title":"class Secret  "},{"location":"reference/cdk8s-plus-17.html#initializer_10","text":"new Secret ( scope : Construct , id : string , props? : SecretProps ) scope ( Construct ) No description id ( string ) No description props ( SecretProps ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional stringData ( Map ) stringData allows specifying non-binary secret data in string form. Optional type ( string ) Optional type associated with the secret. Default : undefined - Don\u2019t set a type.","title":"Initializer"},{"location":"reference/cdk8s-plus-17.html#properties_10","text":"Name Type Description apiObject ApiObject The underlying cdk8s API object.","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#methods_10","text":"","title":"Methods"},{"location":"reference/cdk8s-plus-17.html#addstringdatakey-value","text":"Adds a string data field to the secert. addStringData ( key : string , value : string ) : void key ( string ) Key. value ( string ) Value.","title":"addStringData(key, value) "},{"location":"reference/cdk8s-plus-17.html#getstringdatakey","text":"Gets a string data by key or undefined. getStringData ( key : string ) : string key ( string ) Key. Returns : * string","title":"getStringData(key) "},{"location":"reference/cdk8s-plus-17.html#static-fromsecretnamename","text":"Imports a secret from the cluster as a reference. static fromSecretName ( name : string ) : ISecret name ( string ) The name of the secret to reference. Returns : * ISecret","title":"static fromSecretName(name) "},{"location":"reference/cdk8s-plus-17.html#class-service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Implements : IConstruct , IResource Extends : Resource","title":"class Service  "},{"location":"reference/cdk8s-plus-17.html#initializer_11","text":"new Service ( scope : Construct , id : string , props? : ServiceProps ) scope ( Construct ) No description id ( string ) No description props ( ServiceProps ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional clusterIP ( string ) The IP address of the service and is usually assigned randomly by the master. Default : Automatically assigned. externalIPs ( Array ) A list of IP addresses for which nodes in the cluster will also accept traffic for this service. Default : No external IPs. externalName ( string ) The externalName to be used when ServiceType.EXTERNAL_NAME is set. Default : No external name. loadBalancerSourceRanges ( Array ) A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. Optional ports ( Array< ServicePort > ) The port exposed by this service. Optional type ( ServiceType ) Determines how the Service is exposed. Default : ServiceType.ClusterIP","title":"Initializer"},{"location":"reference/cdk8s-plus-17.html#properties_11","text":"Name Type Description apiObject ApiObject The underlying cdk8s API object. ports Array< ServicePort > Ports for this service. selector Map Returns the labels which are used to select pods for this service. type ServiceType Determines how the Service is exposed. clusterIP ? string The IP address of the service and is usually assigned randomly by the master. Optional externalName ? string The externalName to be used for EXTERNAL_NAME types. Optional","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#methods_11","text":"","title":"Methods"},{"location":"reference/cdk8s-plus-17.html#adddeploymentdeployment-port-options","text":"Associate a deployment to this service. If not targetPort is specific in the portOptions, then requests will be routed to the port exposed by the first container in the deployment\u2019s pods. The deployment\u2019s labelSelector will be used to select pods. addDeployment ( deployment : Deployment , port : number , options? : ServicePortOptions ) : void deployment ( Deployment ) The deployment to expose. port ( number ) The external port. options ( ServicePortOptions ) Optional settings for the port. name ( string ) The name of this port within the service. Optional nodePort ( number ) The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Default : to auto-allocate a port if the ServiceType of this Service requires one. protocol ( Protocol ) The IP protocol for this port. Default : Protocol.TCP targetPort ( number ) The port number the service will redirect to. Default : The value of port will be used.","title":"addDeployment(deployment, port, options?) "},{"location":"reference/cdk8s-plus-17.html#addselectorlabel-value","text":"Services defined using this spec will select pods according the provided label. addSelector ( label : string , value : string ) : void label ( string ) The label key. value ( string ) The label value.","title":"addSelector(label, value) "},{"location":"reference/cdk8s-plus-17.html#serveport-options","text":"Configure a port the service will bind to. This method can be called multiple times. serve ( port : number , options? : ServicePortOptions ) : void port ( number ) The port definition. options ( ServicePortOptions ) No description name ( string ) The name of this port within the service. Optional nodePort ( number ) The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Default : to auto-allocate a port if the ServiceType of this Service requires one. protocol ( Protocol ) The IP protocol for this port. Default : Protocol.TCP targetPort ( number ) The port number the service will redirect to. Default : The value of port will be used.","title":"serve(port, options?) "},{"location":"reference/cdk8s-plus-17.html#class-serviceaccount","text":"A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). Implements : IConstruct , IResource , IServiceAccount , IResource Extends : Resource","title":"class ServiceAccount  "},{"location":"reference/cdk8s-plus-17.html#initializer_12","text":"new ServiceAccount ( scope : Construct , id : string , props? : ServiceAccountProps ) scope ( Construct ) No description id ( string ) No description props ( ServiceAccountProps ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional secrets ( Array< ISecret > ) List of secrets allowed to be used by pods running using this ServiceAccount. Optional","title":"Initializer"},{"location":"reference/cdk8s-plus-17.html#properties_12","text":"Name Type Description apiObject ApiObject The underlying cdk8s API object. secrets Array< ISecret > List of secrets allowed to be used by pods running using this service account.","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#methods_12","text":"","title":"Methods"},{"location":"reference/cdk8s-plus-17.html#addsecretsecret","text":"Allow a secret to be accessed by pods using this service account. addSecret ( secret : ISecret ) : void secret ( ISecret ) The secret.","title":"addSecret(secret) "},{"location":"reference/cdk8s-plus-17.html#static-fromserviceaccountnamename","text":"Imports a service account from the cluster as a reference. static fromServiceAccountName ( name : string ) : IServiceAccount name ( string ) The name of the service account resource. Returns : * IServiceAccount","title":"static fromServiceAccountName(name) "},{"location":"reference/cdk8s-plus-17.html#class-statefulset","text":"StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"class StatefulSet  "},{"location":"reference/cdk8s-plus-17.html#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Implements : IConstruct , IResource , IPodTemplate , IPodSpec Extends : Resource","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-17.html#initializer_13","text":"new StatefulSet ( scope : Construct , id : string , props : StatefulSetProps ) scope ( Construct ) No description id ( string ) No description props ( StatefulSetProps ) No description metadata ( ApiObjectMetadata ) Metadata that all persisted resources must have, which includes all objects users must create. Optional containers ( Array< ContainerProps > ) List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. restartPolicy ( RestartPolicy ) Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ( IServiceAccount ) A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ( Array< Volume > ) List of volumes that can be mounted by containers belonging to the pod. Default : No volumes. podMetadata ( ApiObjectMetadata ) The pod metadata. Optional service ( Service ) Service to associate with the statefulset. defaultSelector ( boolean ) Automatically allocates a pod selector for this statefulset. Default : true podManagementPolicy ( PodManagementPolicy ) Pod management policy to use for this statefulset. Default : PodManagementPolicy.ORDERED_READY replicas ( number ) Number of desired pods. Default : 1","title":"Initializer"},{"location":"reference/cdk8s-plus-17.html#properties_13","text":"Name Type Description apiObject ApiObject The underlying cdk8s API object. containers Array< Container > The containers belonging to the pod. labelSelector Map The labels this statefulset will match against in order to select pods. podManagementPolicy PodManagementPolicy Management policy to use for the set. podMetadata ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas number Number of desired pods. volumes Array< Volume > The volumes associated with this pod. restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Optional serviceAccount ? IServiceAccount The service account used to run this pod. Optional","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#methods_13","text":"","title":"Methods"},{"location":"reference/cdk8s-plus-17.html#addcontainercontainer_4","text":"Add a container to the pod. addContainer ( container : ContainerProps ) : Container container ( ContainerProps ) No description image ( string ) Docker image name. args ( Array ) Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ( Array ) Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ( Map EnvValue > ) List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ( ImagePullPolicy ) Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ( Probe ) Periodic probe of container liveness. Default : no liveness probe is defined name ( string ) Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ( number ) Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ( Probe ) Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ( Probe ) StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ( Array< VolumeMount > ) Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ( string ) Container\u2019s working directory. Default : The container runtime\u2019s default. Returns : * Container","title":"addContainer(container) "},{"location":"reference/cdk8s-plus-17.html#addvolumevolume_4","text":"Add a volume to the pod. addVolume ( volume : Volume ) : void volume ( Volume ) No description","title":"addVolume(volume) "},{"location":"reference/cdk8s-plus-17.html#selectbylabelkey-value_1","text":"Configure a label selector to this deployment. Pods that have the label will be selected by deployments configured with this spec. selectByLabel ( key : string , value : string ) : void key ( string ) - The label key. value ( string ) - The label value.","title":"selectByLabel(key, value) "},{"location":"reference/cdk8s-plus-17.html#class-volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"class Volume  "},{"location":"reference/cdk8s-plus-17.html#initializer_14","text":"new Volume ( name : string , config : any ) name ( string ) No description config ( any ) No description","title":"Initializer"},{"location":"reference/cdk8s-plus-17.html#properties_14","text":"Name Type Description name string","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#methods_14","text":"","title":"Methods"},{"location":"reference/cdk8s-plus-17.html#static-fromconfigmapconfigmap-options","text":"Populate the volume from a ConfigMap. The configMap resource provides a way to inject configuration data into Pods. The data stored in a ConfigMap object can be referenced in a volume of type configMap and then consumed by containerized applications running in a Pod. When referencing a configMap object, you can simply provide its name in the volume to reference it. You can also customize the path to use for a specific entry in the ConfigMap. static fromConfigMap ( configMap : IConfigMap , options? : ConfigMapVolumeOptions ) : Volume configMap ( IConfigMap ) The config map to use to populate the volume. options ( ConfigMapVolumeOptions ) Options. defaultMode ( number ) Mode bits to use on created files by default. Default : 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items ( Map PathMapping > ) If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. Default : no mapping name ( string ) The volume name. Default : auto-generated optional ( boolean ) Specify whether the ConfigMap or its keys must be defined. Default : undocumented Returns : * Volume","title":"static fromConfigMap(configMap, options?) "},{"location":"reference/cdk8s-plus-17.html#static-fromemptydirname-options","text":"An emptyDir volume is first created when a Pod is assigned to a Node, and exists as long as that Pod is running on that node. As the name says, it is initially empty. Containers in the Pod can all read and write the same files in the emptyDir volume, though that volume can be mounted at the same or different paths in each Container. When a Pod is removed from a node for any reason, the data in the emptyDir is deleted forever. static fromEmptyDir ( name : string , options? : EmptyDirVolumeOptions ) : Volume name ( string ) No description options ( EmptyDirVolumeOptions ) - Additional options. medium ( EmptyDirMedium ) By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. Default : EmptyDirMedium.DEFAULT sizeLimit ( Size ) Total amount of local storage required for this EmptyDir volume. Default : limit is undefined Returns : * Volume","title":"static fromEmptyDir(name, options?) "},{"location":"reference/cdk8s-plus-17.html#struct-adddirectoryoptions","text":"Options for configmap.addDirectory() . Name Type Description exclude ? Array Glob patterns to exclude when adding files. Default : include all files keyPrefix ? string A prefix to add to all keys in the config map. Default : \u201c\u201d","title":"struct AddDirectoryOptions  "},{"location":"reference/cdk8s-plus-17.html#struct-commandprobeoptions","text":"Options for Probe.fromCommand() . Name Type Description failureThreshold ? number Minimum consecutive failures for the probe to be considered failed after having succeeded. Default : 3 initialDelaySeconds ? Duration Number of seconds after the container has started before liveness probes are initiated. Default : immediate periodSeconds ? Duration How often (in seconds) to perform the probe. Default : Duration.seconds(10) Minimum value is 1. successThreshold ? number Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Default : 1 Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds ? Duration Number of seconds after which the probe times out. Default : Duration.seconds(1)","title":"struct CommandProbeOptions  "},{"location":"reference/cdk8s-plus-17.html#struct-configmapprops","text":"Properties for initialization of ConfigMap . Name Type Description binaryData ? Map BinaryData contains the binary data. Optional data ? Map Data contains the configuration data. Optional metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional","title":"struct ConfigMapProps  "},{"location":"reference/cdk8s-plus-17.html#struct-configmapvolumeoptions","text":"Options for the ConfigMap-based volume. Name Type Description defaultMode ? number Mode bits to use on created files by default. Default : 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items ? Map PathMapping > If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. Default : no mapping name ? string The volume name. Default : auto-generated optional ? boolean Specify whether the ConfigMap or its keys must be defined. Default : undocumented","title":"struct ConfigMapVolumeOptions  "},{"location":"reference/cdk8s-plus-17.html#struct-containerprops","text":"Properties for creating a container. Name Type Description image string Docker image name. args ? Array Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ? Array Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ? Map EnvValue > List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ? ImagePullPolicy Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ? Probe Periodic probe of container liveness. Default : no liveness probe is defined name ? string Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ? number Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ? Probe Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ? Probe StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ? Array< VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ? string Container\u2019s working directory. Default : The container runtime\u2019s default.","title":"struct ContainerProps  "},{"location":"reference/cdk8s-plus-17.html#struct-deploymentprops","text":"Properties for initialization of Deployment . Name Type Description containers ? Array< ContainerProps > List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. defaultSelector ? boolean Automatically allocates a pod selector for this deployment. Default : true metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional podMetadata ? ApiObjectMetadata The pod metadata. Optional replicas ? number Number of desired pods. Default : 1 restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ? IServiceAccount A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ? Array< Volume > List of volumes that can be mounted by containers belonging to the pod. Default : No volumes.","title":"struct DeploymentProps  "},{"location":"reference/cdk8s-plus-17.html#struct-emptydirvolumeoptions","text":"Options for volumes populated with an empty directory. Name Type Description medium ? EmptyDirMedium By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. Default : EmptyDirMedium.DEFAULT sizeLimit ? Size Total amount of local storage required for this EmptyDir volume. Default : limit is undefined","title":"struct EmptyDirVolumeOptions  "},{"location":"reference/cdk8s-plus-17.html#struct-envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key. Name Type Description optional ? boolean Specify whether the ConfigMap or its key must be defined. Default : false","title":"struct EnvValueFromConfigMapOptions  "},{"location":"reference/cdk8s-plus-17.html#struct-envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment. Name Type Description required ? boolean Specify whether the key must exist in the environment. Default : false","title":"struct EnvValueFromProcessOptions  "},{"location":"reference/cdk8s-plus-17.html#struct-envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret. Name Type Description optional ? boolean Specify whether the Secret or its key must be defined. Default : false","title":"struct EnvValueFromSecretOptions  "},{"location":"reference/cdk8s-plus-17.html#struct-exposeoptions","text":"Options for exposing a deployment via a service. Name Type Description name ? string The name of the service to expose. Default : undefined Uses the system generated name. protocol ? Protocol The IP protocol for this port. Default : Protocol.TCP serviceType ? ServiceType The type of the exposed service. Default : ClusterIP. targetPort ? number The port number the service will redirect to. Default : The port of the first container in the deployment (ie. containers[0].port)","title":"struct ExposeOptions  "},{"location":"reference/cdk8s-plus-17.html#struct-httpgetprobeoptions","text":"Options for Probe.fromHttpGet() . Name Type Description failureThreshold ? number Minimum consecutive failures for the probe to be considered failed after having succeeded. Default : 3 initialDelaySeconds ? Duration Number of seconds after the container has started before liveness probes are initiated. Default : immediate periodSeconds ? Duration How often (in seconds) to perform the probe. Default : Duration.seconds(10) Minimum value is 1. port ? number The TCP port to use when sending the GET request. Default : defaults to container.port . successThreshold ? number Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Default : 1 Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds ? Duration Number of seconds after which the probe times out. Default : Duration.seconds(1)","title":"struct HttpGetProbeOptions  "},{"location":"reference/cdk8s-plus-17.html#interface-iconfigmap","text":"Implemented by : ConfigMap Obtainable from : ConfigMap . fromConfigMapName () Represents a config map.","title":"interface IConfigMap  "},{"location":"reference/cdk8s-plus-17.html#properties_15","text":"Name Type Description name string The Kubernetes name of this resource.","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#interface-ipodspec","text":"Implemented by : Deployment , Job , Pod , PodSpec , PodTemplate , StatefulSet Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"interface IPodSpec  "},{"location":"reference/cdk8s-plus-17.html#properties_16","text":"Name Type Description containers Array< Container > The containers belonging to the pod. volumes Array< Volume > The volumes associated with this pod. restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Optional serviceAccount ? IServiceAccount The service account used to run this pod. Optional","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#methods_15","text":"","title":"Methods"},{"location":"reference/cdk8s-plus-17.html#addcontainercontainer_5","text":"Add a container to the pod. addContainer ( container : ContainerProps ) : Container container ( ContainerProps ) The container. image ( string ) Docker image name. args ( Array ) Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ( Array ) Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ( Map EnvValue > ) List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ( ImagePullPolicy ) Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ( Probe ) Periodic probe of container liveness. Default : no liveness probe is defined name ( string ) Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ( number ) Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ( Probe ) Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ( Probe ) StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ( Array< VolumeMount > ) Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ( string ) Container\u2019s working directory. Default : The container runtime\u2019s default. Returns : * Container","title":"addContainer(container) "},{"location":"reference/cdk8s-plus-17.html#addvolumevolume_5","text":"Add a volume to the pod. addVolume ( volume : Volume ) : void volume ( Volume ) The volume.","title":"addVolume(volume) "},{"location":"reference/cdk8s-plus-17.html#interface-ipodtemplate","text":"Implemented by : Deployment , Job , PodTemplate , StatefulSet Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"interface IPodTemplate  "},{"location":"reference/cdk8s-plus-17.html#properties_17","text":"Name Type Description containers Array< Container > The containers belonging to the pod. podMetadata ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Array< Volume > The volumes associated with this pod. restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Optional serviceAccount ? IServiceAccount The service account used to run this pod. Optional","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#methods_16","text":"","title":"Methods"},{"location":"reference/cdk8s-plus-17.html#addcontainercontainer_6","text":"Add a container to the pod. addContainer ( container : ContainerProps ) : Container container ( ContainerProps ) The container. image ( string ) Docker image name. args ( Array ) Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Default : [] command ( Array ) Entrypoint array. Default : The docker image\u2019s ENTRYPOINT. env ( Map EnvValue > ) List of environment variables to set in the container. Default : No environment variables. imagePullPolicy ( ImagePullPolicy ) Image pull policy for this container. Default : ImagePullPolicy.ALWAYS liveness ( Probe ) Periodic probe of container liveness. Default : no liveness probe is defined name ( string ) Name of the container specified as a DNS_LABEL. Default : \u2018main\u2019 port ( number ) Number of port to expose on the pod\u2019s IP address. Default : No port is exposed. readiness ( Probe ) Determines when the container is ready to serve traffic. Default : no readiness probe is defined startup ( Probe ) StartupProbe indicates that the Pod has successfully initialized. Default : no startup probe is defined. volumeMounts ( Array< VolumeMount > ) Pod volumes to mount into the container\u2019s filesystem. Optional workingDir ( string ) Container\u2019s working directory. Default : The container runtime\u2019s default. Returns : * Container","title":"addContainer(container) "},{"location":"reference/cdk8s-plus-17.html#addvolumevolume_6","text":"Add a volume to the pod. addVolume ( volume : Volume ) : void volume ( Volume ) The volume.","title":"addVolume(volume) "},{"location":"reference/cdk8s-plus-17.html#interface-iresource","text":"Implemented by : ConfigMap , Deployment , IngressV1Beta1 , Job , Pod , Secret , Service , ServiceAccount , StatefulSet Represents a resource.","title":"interface IResource  "},{"location":"reference/cdk8s-plus-17.html#properties_18","text":"Name Type Description name string The Kubernetes name of this resource.","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#interface-isecret","text":"Implemented by : Secret Obtainable from : Secret . fromSecretName ()","title":"interface ISecret  "},{"location":"reference/cdk8s-plus-17.html#properties_19","text":"Name Type Description name string The Kubernetes name of this resource.","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#interface-iserviceaccount","text":"Implemented by : ServiceAccount Obtainable from : ServiceAccount . fromServiceAccountName ()","title":"interface IServiceAccount  "},{"location":"reference/cdk8s-plus-17.html#properties_20","text":"Name Type Description name string The Kubernetes name of this resource.","title":"Properties"},{"location":"reference/cdk8s-plus-17.html#struct-ingressv1beta1props","text":"Properties for Ingress . Name Type Description defaultBackend ? IngressV1Beta1Backend The default backend services requests that do not match any rule. Optional metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional rules ? Array< IngressV1Beta1Rule > Routing rules for this ingress. Optional","title":"struct IngressV1Beta1Props  "},{"location":"reference/cdk8s-plus-17.html#struct-ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Name Type Description backend IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host ? string Host is the fully qualified domain name of a network host, as defined by RFC 3986. Default : If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. path ? string Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. Default : If unspecified, the path defaults to a catch all sending traffic to the backend.","title":"struct IngressV1Beta1Rule  "},{"location":"reference/cdk8s-plus-17.html#struct-jobprops","text":"Properties for initialization of Job . Name Type Description activeDeadline ? Duration Specifies the duration the job may be active before the system tries to terminate it. Default : If unset, then there is no deadline. backoffLimit ? number Specifies the number of retries before marking this job failed. Default : If not set, system defaults to 6. containers ? Array< ContainerProps > List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional podMetadata ? ApiObjectMetadata The pod metadata. Optional restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ? IServiceAccount A service account provides an identity for processes that run in a Pod. Default : No service account. ttlAfterFinished ? Duration Limits the lifetime of a Job that has finished execution (either Complete or Failed). Default : If this field is unset, the Job won\u2019t be automatically deleted. volumes ? Array< Volume > List of volumes that can be mounted by containers belonging to the pod. Default : No volumes.","title":"struct JobProps  "},{"location":"reference/cdk8s-plus-17.html#struct-mountoptions","text":"Options for mounts. Name Type Description propagation ? MountPropagation Determines how mounts are propagated from the host to container and the other way around. Default : MountPropagation.NONE readOnly ? boolean Mounted read-only if true, read-write otherwise (false or unspecified). Default : false subPath ? string Path within the volume from which the container\u2019s volume should be mounted.). Default : \u201c\u201d the volume\u2019s root subPathExpr ? string Expanded path within the volume from which the container\u2019s volume should be mounted. Default : \u201c\u201d volume\u2019s root.","title":"struct MountOptions  "},{"location":"reference/cdk8s-plus-17.html#struct-pathmapping","text":"Maps a string key to a path within a volume. Name Type Description path string The relative path of the file to map the key to. mode ? number Optional: mode bits to use on this file, must be a value between 0 and 0777. Optional","title":"struct PathMapping  "},{"location":"reference/cdk8s-plus-17.html#struct-podprops","text":"Properties for initialization of Pod . Name Type Description containers ? Array< ContainerProps > List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ? IServiceAccount A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ? Array< Volume > List of volumes that can be mounted by containers belonging to the pod. Default : No volumes.","title":"struct PodProps  "},{"location":"reference/cdk8s-plus-17.html#struct-podspecprops","text":"Properties of a PodSpec . Name Type Description containers ? Array< ContainerProps > List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ? IServiceAccount A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ? Array< Volume > List of volumes that can be mounted by containers belonging to the pod. Default : No volumes.","title":"struct PodSpecProps  "},{"location":"reference/cdk8s-plus-17.html#struct-podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec. Name Type Description containers ? Array< ContainerProps > List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. podMetadata ? ApiObjectMetadata The pod metadata. Optional restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ? IServiceAccount A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ? Array< Volume > List of volumes that can be mounted by containers belonging to the pod. Default : No volumes.","title":"struct PodTemplateProps  "},{"location":"reference/cdk8s-plus-17.html#struct-probeoptions","text":"Probe options. Name Type Description failureThreshold ? number Minimum consecutive failures for the probe to be considered failed after having succeeded. Default : 3 initialDelaySeconds ? Duration Number of seconds after the container has started before liveness probes are initiated. Default : immediate periodSeconds ? Duration How often (in seconds) to perform the probe. Default : Duration.seconds(10) Minimum value is 1. successThreshold ? number Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Default : 1 Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds ? Duration Number of seconds after which the probe times out. Default : Duration.seconds(1)","title":"struct ProbeOptions  "},{"location":"reference/cdk8s-plus-17.html#struct-resourceprops","text":"Initialization properties for resources. Name Type Description metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional","title":"struct ResourceProps  "},{"location":"reference/cdk8s-plus-17.html#struct-secretprops","text":"Name Type Description metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional stringData ? Map stringData allows specifying non-binary secret data in string form. Optional type ? string Optional type associated with the secret. Default : undefined - Don\u2019t set a type.","title":"struct SecretProps  "},{"location":"reference/cdk8s-plus-17.html#struct-secretvalue","text":"Represents a specific value in JSON secret. Name Type Description key string The JSON key. secret ISecret The secret.","title":"struct SecretValue  "},{"location":"reference/cdk8s-plus-17.html#struct-serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Name Type Description metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional secrets ? Array< ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. Optional","title":"struct ServiceAccountProps  "},{"location":"reference/cdk8s-plus-17.html#struct-serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules. Name Type Description port ? number The port to use to access the service. Default : if the service exposes a single port, this port will be used.","title":"struct ServiceIngressV1BetaBackendOptions  "},{"location":"reference/cdk8s-plus-17.html#struct-serviceport","text":"Definition of a service port. Name Type Description port number The port number the service will bind to. name ? string The name of this port within the service. Optional nodePort ? number The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Default : to auto-allocate a port if the ServiceType of this Service requires one. protocol ? Protocol The IP protocol for this port. Default : Protocol.TCP targetPort ? number The port number the service will redirect to. Default : The value of port will be used.","title":"struct ServicePort  "},{"location":"reference/cdk8s-plus-17.html#struct-serviceportoptions","text":"Name Type Description name ? string The name of this port within the service. Optional nodePort ? number The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Default : to auto-allocate a port if the ServiceType of this Service requires one. protocol ? Protocol The IP protocol for this port. Default : Protocol.TCP targetPort ? number The port number the service will redirect to. Default : The value of port will be used.","title":"struct ServicePortOptions  "},{"location":"reference/cdk8s-plus-17.html#struct-serviceprops","text":"Properties for initialization of Service . Name Type Description clusterIP ? string The IP address of the service and is usually assigned randomly by the master. Default : Automatically assigned. externalIPs ? Array A list of IP addresses for which nodes in the cluster will also accept traffic for this service. Default : No external IPs. externalName ? string The externalName to be used when ServiceType.EXTERNAL_NAME is set. Default : No external name. loadBalancerSourceRanges ? Array A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. Optional metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional ports ? Array< ServicePort > The port exposed by this service. Optional type ? ServiceType Determines how the Service is exposed. Default : ServiceType.ClusterIP","title":"struct ServiceProps  "},{"location":"reference/cdk8s-plus-17.html#struct-statefulsetprops","text":"Properties for initialization of StatefulSet . Name Type Description service Service Service to associate with the statefulset. containers ? Array< ContainerProps > List of containers belonging to the pod. Default : No containers. Note that a pod spec must include at least one container. defaultSelector ? boolean Automatically allocates a pod selector for this statefulset. Default : true metadata ? ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. Optional podManagementPolicy ? PodManagementPolicy Pod management policy to use for this statefulset. Default : PodManagementPolicy.ORDERED_READY podMetadata ? ApiObjectMetadata The pod metadata. Optional replicas ? number Number of desired pods. Default : 1 restartPolicy ? RestartPolicy Restart policy for all containers within the pod. Default : RestartPolicy.ALWAYS serviceAccount ? IServiceAccount A service account provides an identity for processes that run in a Pod. Default : No service account. volumes ? Array< Volume > List of volumes that can be mounted by containers belonging to the pod. Default : No volumes.","title":"struct StatefulSetProps  "},{"location":"reference/cdk8s-plus-17.html#struct-volumemount","text":"Mount a volume from the pod to the container. Name Type Description path string Path within the container at which the volume should be mounted. volume Volume The volume to mount. propagation ? MountPropagation Determines how mounts are propagated from the host to container and the other way around. Default : MountPropagation.NONE readOnly ? boolean Mounted read-only if true, read-write otherwise (false or unspecified). Default : false subPath ? string Path within the volume from which the container\u2019s volume should be mounted.). Default : \u201c\u201d the volume\u2019s root subPathExpr ? string Expanded path within the volume from which the container\u2019s volume should be mounted. Default : \u201c\u201d volume\u2019s root.","title":"struct VolumeMount  "},{"location":"reference/cdk8s-plus-17.html#enum-emptydirmedium","text":"The medium on which to store the volume. Name Description DEFAULT The default volume of the backing node. MEMORY Mount a tmpfs (RAM-backed filesystem) for you instead.","title":"enum EmptyDirMedium  "},{"location":"reference/cdk8s-plus-17.html#enum-imagepullpolicy","text":"Name Description ALWAYS Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. IF_NOT_PRESENT The image is pulled only if it is not already present locally. NEVER The image is assumed to exist locally.","title":"enum ImagePullPolicy  "},{"location":"reference/cdk8s-plus-17.html#enum-mountpropagation","text":"Name Description NONE This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. HOST_TO_CONTAINER This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. BIDIRECTIONAL This volume mount behaves the same the HostToContainer mount.","title":"enum MountPropagation  "},{"location":"reference/cdk8s-plus-17.html#enum-podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. Name Description ORDERED_READY PARALLEL","title":"enum PodManagementPolicy  "},{"location":"reference/cdk8s-plus-17.html#enum-protocol","text":"Name Description TCP UDP SCTP","title":"enum Protocol  "},{"location":"reference/cdk8s-plus-17.html#enum-restartpolicy","text":"Restart policy for all containers within the pod. Name Description ALWAYS Always restart the pod after it exits. ON_FAILURE Only restart if the pod exits with a non-zero exit code. NEVER Never restart the pod.","title":"enum RestartPolicy  "},{"location":"reference/cdk8s-plus-17.html#enum-servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. Name Description CLUSTER_IP Exposes the Service on a cluster-internal IP. NODE_PORT Exposes the Service on each Node\u2019s IP at a static port (the NodePort). LOAD_BALANCER Exposes the Service externally using a cloud provider\u2019s load balancer. EXTERNAL_NAME Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up.","title":"enum ServiceType  "},{"location":"reference/cdk8s.html","text":"cdk8s \u00b6 Classes Name Description ApiObject No description ApiObjectMetadataDefinition Object metadata. App Represents a cdk8s application. Chart No description DependencyGraph Represents the dependency graph for a given Node. DependencyVertex Represents a vertex in the graph. Duration Represents a length of time. Helm Represents a Helm deployment. Include Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. JsonPatch Utility for applying RFC-6902 JSON-Patch to a document. Lazy No description Names Utilities for generating unique and stable names. Size Represents the amount of digital storage. Testing Testing utilities for cdk8s applications. Yaml YAML utilities. Structs Name Description ApiObjectMetadata Metadata associated with this object. ApiObjectProps Options for defining API objects. AppProps No description ChartProps No description GroupVersionKind No description HelmProps Options for Helm . IncludeProps No description NameOptions Options for name generation. SizeConversionOptions Options for how to convert time to a different unit. TimeConversionOptions Options for how to convert time to a different unit. Interfaces Name Description IAnyProducer No description Enums Name Description SizeRoundingBehavior Rounding behaviour when converting between units of Size . class ApiObject \u00b6 Implements : IConstruct Extends : Construct Initializer \u00b6 Defines an API object. new ApiObject ( scope : Construct , id : string , props : ApiObjectProps ) scope ( Construct ) the construct scope. id ( string ) namespace. props ( ApiObjectProps ) options. apiVersion ( string ) API version. kind ( string ) Resource kind. metadata ( ApiObjectMetadata ) Object metadata. Optional Properties \u00b6 Name Type Description apiGroup string The group portion of the API version (e.g. authorization.k8s.io ). apiVersion string The object\u2019s API version (e.g. authorization.k8s.io/v1 ). chart Chart The chart in which this object is defined. kind string The object kind. metadata ApiObjectMetadataDefinition Metadata associated with this API object. name string The name of the API object. Methods \u00b6 addDependency(\u2026dependencies) \u00b6 Create a dependency between this ApiObject and other constructs. These can be other ApiObjects, Charts, or custom. addDependency (... dependencies : IConstruct []) : void dependencies ( IConstruct ) the dependencies to add. addJsonPatch(\u2026ops) \u00b6 Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object. addJsonPatch (... ops : JsonPatch []) : void ops ( JsonPatch ) The JSON-Patch operations to apply. toJson() \u00b6 Renders the object to Kubernetes JSON. To disable sorting of dictionary keys in output object set the CDK8S_DISABLE_SORT environment variable to any non-empty value. toJson () : any Returns : * any static of(c) \u00b6 Returns the ApiObject named Resource which is a child of the given construct. If c is an ApiObject , it is returned directly. Throws an exception if the construct does not have a child named Default or if this child is not an ApiObject . static of ( c : IConstruct ) : ApiObject c ( IConstruct ) The higher-level construct. Returns : * ApiObject class ApiObjectMetadataDefinition \u00b6 Object metadata. Initializer \u00b6 new ApiObjectMetadataDefinition ( options? : ApiObjectMetadata ) options ( ApiObjectMetadata ) No description annotations ( Map ) Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. Default : No annotations. labels ( Map ) Map of string keys and values that can be used to organize and categorize (scope and select) objects. Default : No labels. name ( string ) The unique, namespace-global, name of this object inside the Kubernetes cluster. Default : an app-unique name generated by the chart namespace ( string ) Namespace defines the space within each name must be unique. Default : undefined (will be assigned to the \u2018default\u2019 namespace) Properties \u00b6 Name Type Description name ? string The name of the API object. Optional namespace ? string The object\u2019s namespace. Optional Methods \u00b6 add(key, value) \u00b6 Adds an arbitrary key/value to the object metadata. add ( key : string , value : any ) : void key ( string ) Metadata key. value ( any ) Metadata value. addAnnotation(key, value) \u00b6 Add an annotation. addAnnotation ( key : string , value : string ) : void key ( string ) - The key. value ( string ) - The value. addLabel(key, value) \u00b6 Add a label. addLabel ( key : string , value : string ) : void key ( string ) - The key. value ( string ) - The value. getLabel(key) \u00b6 getLabel ( key : string ) : string key ( string ) the label. Returns : * string toJson() \u00b6 Synthesizes a k8s ObjectMeta for this metadata set. toJson () : any Returns : * any class App \u00b6 Represents a cdk8s application. Implements : IConstruct Extends : Construct Initializer \u00b6 Defines an app. new App ( props? : AppProps ) props ( AppProps ) configuration options. outdir ( string ) The directory to output Kubernetes manifests. Default : CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d Properties \u00b6 Name Type Description outdir string The output directory into which manifests will be synthesized. Methods \u00b6 synth() \u00b6 Synthesizes all manifests to the output directory. synth () : void class Chart \u00b6 Implements : IConstruct Extends : Construct Initializer \u00b6 new Chart ( scope : Construct , id : string , props? : ChartProps ) scope ( Construct ) No description id ( string ) No description props ( ChartProps ) No description labels ( Map ) Labels to apply to all resources in this chart. Default : no common labels namespace ( string ) The default namespace for all objects defined in this chart (directly or indirectly). Default : no namespace is synthesized (usually this implies \u201cdefault\u201d) Properties \u00b6 Name Type Description labels Map Labels applied to all resources in this chart. namespace ? string The default namespace for all objects in this chart. Optional Methods \u00b6 addDependency(\u2026dependencies) \u00b6 Create a dependency between this Chart and other constructs. These can be other ApiObjects, Charts, or custom. addDependency (... dependencies : IConstruct []) : void dependencies ( IConstruct ) the dependencies to add. generateObjectName(apiObject) \u00b6 Generates a app-unique name for an object given it\u2019s construct node path. Different resource types may have different constraints on names ( metadata.name ). The previous version of the name generator was compatible with DNS_SUBDOMAIN but not with DNS_LABEL. For example, Deployment names must comply with DNS_SUBDOMAIN while Service names must comply with DNS_LABEL. Since there is no formal specification for this, the default name generation scheme for kubernetes objects in cdk8s was changed to DNS_LABEL, since it\u2019s the common denominator for all kubernetes resources (supposedly). You can override this method if you wish to customize object names at the chart level. generateObjectName ( apiObject : ApiObject ) : string apiObject ( ApiObject ) The API object to generate a name for. Returns : * string toJson() \u00b6 Renders this chart to a set of Kubernetes JSON resources. toJson () : Array < any > Returns : * Array static of(c) \u00b6 Finds the chart in which a node is defined. static of ( c : IConstruct ) : Chart c ( IConstruct ) a construct node. Returns : * Chart class DependencyGraph \u00b6 Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph. Initializer \u00b6 new DependencyGraph ( node : Node ) node ( Node ) No description Properties \u00b6 Name Type Description root DependencyVertex Returns the root of the graph. Methods \u00b6 topology() \u00b6 topology () : Array < IConstruct > Returns : * Array< IConstruct > class DependencyVertex \u00b6 Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter. Initializer \u00b6 new DependencyVertex ( value? : IConstruct ) value ( IConstruct ) No description Properties \u00b6 Name Type Description inbound Array< DependencyVertex > Returns the parents of the vertex (i.e dependants). outbound Array< DependencyVertex > Returns the children of the vertex (i.e dependencies). value ? IConstruct Returns the IConstruct this graph vertex represents. Optional Methods \u00b6 addChild(dep) \u00b6 Adds a vertex as a dependency of the current node. Also updates the parents of dep , so that it contains this node as a parent. This operation will fail in case it creates a cycle in the graph. addChild ( dep : DependencyVertex ) : void dep ( DependencyVertex ) The dependency. topology() \u00b6 Returns a topologically sorted array of the constructs in the sub-graph. topology () : Array < IConstruct > Returns : * Array< IConstruct > class Duration \u00b6 Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. Methods \u00b6 toDays(opts?) \u00b6 Return the total number of days in this Duration. toDays ( opts? : TimeConversionOptions ) : number opts ( TimeConversionOptions ) No description integral ( boolean ) If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Default : true Returns : * number toHours(opts?) \u00b6 Return the total number of hours in this Duration. toHours ( opts? : TimeConversionOptions ) : number opts ( TimeConversionOptions ) No description integral ( boolean ) If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Default : true Returns : * number toHumanString() \u00b6 Turn this duration into a human-readable string. toHumanString () : string Returns : * string toIsoString() \u00b6 Return an ISO 8601 representation of this period. toIsoString () : string Returns : * string toMilliseconds(opts?) \u00b6 Return the total number of milliseconds in this Duration. toMilliseconds ( opts? : TimeConversionOptions ) : number opts ( TimeConversionOptions ) No description integral ( boolean ) If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Default : true Returns : * number toMinutes(opts?) \u00b6 Return the total number of minutes in this Duration. toMinutes ( opts? : TimeConversionOptions ) : number opts ( TimeConversionOptions ) No description integral ( boolean ) If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Default : true Returns : * number toSeconds(opts?) \u00b6 Return the total number of seconds in this Duration. toSeconds ( opts? : TimeConversionOptions ) : number opts ( TimeConversionOptions ) No description integral ( boolean ) If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Default : true Returns : * number static days(amount) \u00b6 Create a Duration representing an amount of days. static days ( amount : number ) : Duration amount ( number ) the amount of Days the Duration will represent. Returns : * Duration static hours(amount) \u00b6 Create a Duration representing an amount of hours. static hours ( amount : number ) : Duration amount ( number ) the amount of Hours the Duration will represent. Returns : * Duration static millis(amount) \u00b6 Create a Duration representing an amount of milliseconds. static millis ( amount : number ) : Duration amount ( number ) the amount of Milliseconds the Duration will represent. Returns : * Duration static minutes(amount) \u00b6 Create a Duration representing an amount of minutes. static minutes ( amount : number ) : Duration amount ( number ) the amount of Minutes the Duration will represent. Returns : * Duration static parse(duration) \u00b6 Parse a period formatted according to the ISO 8601 standard. static parse ( duration : string ) : Duration duration ( string ) an ISO-formtted duration to be parsed. Returns : * Duration static seconds(amount) \u00b6 Create a Duration representing an amount of seconds. static seconds ( amount : number ) : Duration amount ( number ) the amount of Seconds the Duration will represent. Returns : * Duration class Helm \u00b6 Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs. Implements : IConstruct Extends : Include Initializer \u00b6 new Helm ( scope : Construct , id : string , props : HelmProps ) scope ( Construct ) No description id ( string ) No description props ( HelmProps ) No description chart ( string ) The chart name to use. It can be a chart from a helm repository or a local directory. helmExecutable ( string ) The local helm executable to use in order to create the manifest the chart. Default : \u201chelm\u201d helmFlags ( Array ) Additional flags to add to the helm execution. Default : [] releaseName ( string ) The release name. Default : if unspecified, a name will be allocated based on the construct path values ( Map ) Values to pass to the chart. Default : If no values are specified, chart will use the defaults. Properties \u00b6 Name Type Description releaseName string The helm release name. class Include \u00b6 Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest. Implements : IConstruct Extends : Construct Initializer \u00b6 new Include ( scope : Construct , id : string , props : IncludeProps ) scope ( Construct ) No description id ( string ) No description props ( IncludeProps ) No description url ( string ) Local file path or URL which includes a Kubernetes YAML manifest. Properties \u00b6 Name Type Description apiObjects Array< ApiObject > Returns all the included API objects. class JsonPatch \u00b6 Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc. Methods \u00b6 static add(path, value) \u00b6 Adds a value to an object or inserts it into an array. In the case of an array, the value is inserted before the given index. The - character can be used instead of an index to insert at the end of an array. static add ( path : string , value : any ) : JsonPatch path ( string ) No description value ( any ) No description Returns : * JsonPatch static apply(document, \u2026ops) \u00b6 Applies a set of JSON-Patch (RFC-6902) operations to document and returns the result. static apply ( document : any , ... ops : JsonPatch []) : any document ( any ) The document to patch. ops ( JsonPatch ) The operations to apply. Returns : * any static copy(from, path) \u00b6 Copies a value from one location to another within the JSON document. Both from and path are JSON Pointers. static copy ( from : string , path : string ) : JsonPatch from ( string ) No description path ( string ) No description Returns : * JsonPatch static move(from, path) \u00b6 Moves a value from one location to the other. Both from and path are JSON Pointers. static move ( from : string , path : string ) : JsonPatch from ( string ) No description path ( string ) No description Returns : * JsonPatch static remove(path) \u00b6 Removes a value from an object or array. static remove ( path : string ) : JsonPatch path ( string ) No description Returns : * JsonPatch static replace(path, value) \u00b6 Replaces a value. Equivalent to a \u201cremove\u201d followed by an \u201cadd\u201d. static replace ( path : string , value : any ) : JsonPatch path ( string ) No description value ( any ) No description Returns : * JsonPatch static test(path, value) \u00b6 Tests that the specified value is set in the document. If the test fails, then the patch as a whole should not apply. static test ( path : string , value : any ) : JsonPatch path ( string ) No description value ( any ) No description Returns : * JsonPatch class Lazy \u00b6 Methods \u00b6 produce() \u00b6 produce () : any Returns : * any static any(producer) \u00b6 static any ( producer : IAnyProducer ) : any producer ( IAnyProducer ) No description Returns : * any class Names \u00b6 Utilities for generating unique and stable names. Methods \u00b6 static toDnsLabel(scope, options?) \u00b6 Generates a unique and stable name compatible DNS_LABEL from RFC-1123 from a path. The generated name will: - contain at most 63 characters - contain only lowercase alphanumeric characters or \u2018-\u2019 - start with an alphanumeric character - end with an alphanumeric character The generated name will have the form: - -..- - Where are the path components (assuming they are is separated by \u201c/\u201d). Note that if the total length is longer than 63 characters, we will trim the first components since the last components usually encode more meaning. static toDnsLabel ( scope : Construct , options? : NameOptions ) : string scope ( Construct ) The construct for which to render the DNS label. options ( NameOptions ) Name options. delimiter ( string ) Delimiter to use between components. Default : \u201c-\u201c extra ( Array ) Extra components to include in the name. Default : [] use the construct path components includeHash ( boolean ) Include a short hash as last part of the name. Default : true maxLen ( number ) Maximum allowed length for the name. Default : 63 Returns : * string static toLabelValue(scope, options?) \u00b6 Generates a unique and stable name compatible label key name segment and label value from a path. The name segment is required and must be 63 characters or less, beginning and ending with an alphanumeric character ([a-z0-9A-Z]) with dashes (-), underscores (_), dots (.), and alphanumerics between. Valid label values must be 63 characters or less and must be empty or begin and end with an alphanumeric character ([a-z0-9A-Z]) with dashes (-), underscores (_), dots (.), and alphanumerics between. The generated name will have the form: .. Where are the path components (assuming they are is separated by \u201c/\u201d). Note that if the total length is longer than 63 characters, we will trim the first components since the last components usually encode more meaning. static toLabelValue ( scope : Construct , options? : NameOptions ) : string scope ( Construct ) The construct for which to render the DNS label. options ( NameOptions ) Name options. delimiter ( string ) Delimiter to use between components. Default : \u201c-\u201c extra ( Array ) Extra components to include in the name. Default : [] use the construct path components includeHash ( boolean ) Include a short hash as last part of the name. Default : true maxLen ( number ) Maximum allowed length for the name. Default : 63 Returns : * string class Size \u00b6 Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible. Methods \u00b6 toGibibytes(opts?) \u00b6 Return this storage as a total number of gibibytes. toGibibytes ( opts? : SizeConversionOptions ) : number opts ( SizeConversionOptions ) No description rounding ( SizeRoundingBehavior ) How conversions should behave when it encounters a non-integer result. Default : SizeRoundingBehavior.FAIL Returns : * number toKibibytes(opts?) \u00b6 Return this storage as a total number of kibibytes. toKibibytes ( opts? : SizeConversionOptions ) : number opts ( SizeConversionOptions ) No description rounding ( SizeRoundingBehavior ) How conversions should behave when it encounters a non-integer result. Default : SizeRoundingBehavior.FAIL Returns : * number toMebibytes(opts?) \u00b6 Return this storage as a total number of mebibytes. toMebibytes ( opts? : SizeConversionOptions ) : number opts ( SizeConversionOptions ) No description rounding ( SizeRoundingBehavior ) How conversions should behave when it encounters a non-integer result. Default : SizeRoundingBehavior.FAIL Returns : * number toPebibytes(opts?) \u00b6 Return this storage as a total number of pebibytes. toPebibytes ( opts? : SizeConversionOptions ) : number opts ( SizeConversionOptions ) No description rounding ( SizeRoundingBehavior ) How conversions should behave when it encounters a non-integer result. Default : SizeRoundingBehavior.FAIL Returns : * number toTebibytes(opts?) \u00b6 Return this storage as a total number of tebibytes. toTebibytes ( opts? : SizeConversionOptions ) : number opts ( SizeConversionOptions ) No description rounding ( SizeRoundingBehavior ) How conversions should behave when it encounters a non-integer result. Default : SizeRoundingBehavior.FAIL Returns : * number static gibibytes(amount) \u00b6 Create a Storage representing an amount gibibytes. 1 GiB = 1024 MiB static gibibytes ( amount : number ) : Size amount ( number ) No description Returns : * Size static kibibytes(amount) \u00b6 Create a Storage representing an amount kibibytes. 1 KiB = 1024 bytes static kibibytes ( amount : number ) : Size amount ( number ) No description Returns : * Size static mebibytes(amount) \u00b6 Create a Storage representing an amount mebibytes. 1 MiB = 1024 KiB static mebibytes ( amount : number ) : Size amount ( number ) No description Returns : * Size static pebibyte(amount) \u00b6 Create a Storage representing an amount pebibytes. 1 PiB = 1024 TiB static pebibyte ( amount : number ) : Size amount ( number ) No description Returns : * Size static tebibytes(amount) \u00b6 Create a Storage representing an amount tebibytes. 1 TiB = 1024 GiB static tebibytes ( amount : number ) : Size amount ( number ) No description Returns : * Size class Testing \u00b6 Testing utilities for cdk8s applications. Methods \u00b6 static app() \u00b6 Returns an app for testing with the following properties: - Output directory is a temp dir. static app () : App Returns : * App static chart() \u00b6 static chart () : Chart Returns : * Chart static synth(chart) \u00b6 Returns the Kubernetes manifest synthesized from this chart. static synth ( chart : Chart ) : Array < any > chart ( Chart ) No description Returns : * Array class Yaml \u00b6 YAML utilities. Methods \u00b6 static load(urlOrFile) \u00b6 Downloads a set of YAML documents (k8s manifest for example) from a URL or a file and returns them as javascript objects. Empty documents are filtered out. static load ( urlOrFile : string ) : Array < any > urlOrFile ( string ) a URL of a file path to load from. Returns : * Array static save(filePath, docs) \u00b6 Saves a set of objects as a multi-document YAML file. static save ( filePath : string , docs : Array < any > ) : void filePath ( string ) The output path. docs ( Array ) The set of objects. static stringify(doc) \u00b6 Stringify a document into yaml. static stringify ( doc : any ) : string doc ( any ) An object. Returns : * string static tmp(docs) \u00b6 Saves a set of YAML documents into a temp file (in /tmp). static tmp ( docs : Array < any > ) : string docs ( Array ) the set of documents to save. Returns : * string struct ApiObjectMetadata \u00b6 Metadata associated with this object. Name Type Description annotations ? Map Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. Default : No annotations. labels ? Map Map of string keys and values that can be used to organize and categorize (scope and select) objects. Default : No labels. name ? string The unique, namespace-global, name of this object inside the Kubernetes cluster. Default : an app-unique name generated by the chart namespace ? string Namespace defines the space within each name must be unique. Default : undefined (will be assigned to the \u2018default\u2019 namespace) struct ApiObjectProps \u00b6 Options for defining API objects. Name Type Description apiVersion string API version. kind string Resource kind. metadata ? ApiObjectMetadata Object metadata. Optional struct AppProps \u00b6 Name Type Description outdir ? string The directory to output Kubernetes manifests. Default : CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d struct ChartProps \u00b6 Name Type Description labels ? Map Labels to apply to all resources in this chart. Default : no common labels namespace ? string The default namespace for all objects defined in this chart (directly or indirectly). Default : no namespace is synthesized (usually this implies \u201cdefault\u201d) struct GroupVersionKind \u00b6 Name Type Description apiVersion string The object\u2019s API version (e.g. authorization.k8s.io/v1 ). kind string The object kind. struct HelmProps \u00b6 Options for Helm . Name Type Description chart string The chart name to use. It can be a chart from a helm repository or a local directory. helmExecutable ? string The local helm executable to use in order to create the manifest the chart. Default : \u201chelm\u201d helmFlags ? Array Additional flags to add to the helm execution. Default : [] releaseName ? string The release name. Default : if unspecified, a name will be allocated based on the construct path values ? Map Values to pass to the chart. Default : If no values are specified, chart will use the defaults. interface IAnyProducer \u00b6 Methods \u00b6 produce() \u00b6 produce () : any Returns : * any struct IncludeProps \u00b6 Name Type Description url string Local file path or URL which includes a Kubernetes YAML manifest. struct NameOptions \u00b6 Options for name generation. Name Type Description delimiter ? string Delimiter to use between components. Default : \u201c-\u201c extra ? Array Extra components to include in the name. Default : [] use the construct path components includeHash ? boolean Include a short hash as last part of the name. Default : true maxLen ? number Maximum allowed length for the name. Default : 63 struct SizeConversionOptions \u00b6 Options for how to convert time to a different unit. Name Type Description rounding ? SizeRoundingBehavior How conversions should behave when it encounters a non-integer result. Default : SizeRoundingBehavior.FAIL struct TimeConversionOptions \u00b6 Options for how to convert time to a different unit. Name Type Description integral ? boolean If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Default : true enum SizeRoundingBehavior \u00b6 Rounding behaviour when converting between units of Size . Name Description FAIL Fail the conversion if the result is not an integer. FLOOR If the result is not an integer, round it to the closest integer less than the result. NONE Don\u2019t round.","title":"cdk8s"},{"location":"reference/cdk8s.html#cdk8s","text":"Classes Name Description ApiObject No description ApiObjectMetadataDefinition Object metadata. App Represents a cdk8s application. Chart No description DependencyGraph Represents the dependency graph for a given Node. DependencyVertex Represents a vertex in the graph. Duration Represents a length of time. Helm Represents a Helm deployment. Include Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. JsonPatch Utility for applying RFC-6902 JSON-Patch to a document. Lazy No description Names Utilities for generating unique and stable names. Size Represents the amount of digital storage. Testing Testing utilities for cdk8s applications. Yaml YAML utilities. Structs Name Description ApiObjectMetadata Metadata associated with this object. ApiObjectProps Options for defining API objects. AppProps No description ChartProps No description GroupVersionKind No description HelmProps Options for Helm . IncludeProps No description NameOptions Options for name generation. SizeConversionOptions Options for how to convert time to a different unit. TimeConversionOptions Options for how to convert time to a different unit. Interfaces Name Description IAnyProducer No description Enums Name Description SizeRoundingBehavior Rounding behaviour when converting between units of Size .","title":"cdk8s"},{"location":"reference/cdk8s.html#class-apiobject","text":"Implements : IConstruct Extends : Construct","title":"class ApiObject  "},{"location":"reference/cdk8s.html#initializer","text":"Defines an API object. new ApiObject ( scope : Construct , id : string , props : ApiObjectProps ) scope ( Construct ) the construct scope. id ( string ) namespace. props ( ApiObjectProps ) options. apiVersion ( string ) API version. kind ( string ) Resource kind. metadata ( ApiObjectMetadata ) Object metadata. Optional","title":"Initializer"},{"location":"reference/cdk8s.html#properties","text":"Name Type Description apiGroup string The group portion of the API version (e.g. authorization.k8s.io ). apiVersion string The object\u2019s API version (e.g. authorization.k8s.io/v1 ). chart Chart The chart in which this object is defined. kind string The object kind. metadata ApiObjectMetadataDefinition Metadata associated with this API object. name string The name of the API object.","title":"Properties"},{"location":"reference/cdk8s.html#methods","text":"","title":"Methods"},{"location":"reference/cdk8s.html#adddependencydependencies","text":"Create a dependency between this ApiObject and other constructs. These can be other ApiObjects, Charts, or custom. addDependency (... dependencies : IConstruct []) : void dependencies ( IConstruct ) the dependencies to add.","title":"addDependency(...dependencies) "},{"location":"reference/cdk8s.html#addjsonpatchops","text":"Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object. addJsonPatch (... ops : JsonPatch []) : void ops ( JsonPatch ) The JSON-Patch operations to apply.","title":"addJsonPatch(...ops) "},{"location":"reference/cdk8s.html#tojson","text":"Renders the object to Kubernetes JSON. To disable sorting of dictionary keys in output object set the CDK8S_DISABLE_SORT environment variable to any non-empty value. toJson () : any Returns : * any","title":"toJson() "},{"location":"reference/cdk8s.html#static-ofc","text":"Returns the ApiObject named Resource which is a child of the given construct. If c is an ApiObject , it is returned directly. Throws an exception if the construct does not have a child named Default or if this child is not an ApiObject . static of ( c : IConstruct ) : ApiObject c ( IConstruct ) The higher-level construct. Returns : * ApiObject","title":"static of(c) "},{"location":"reference/cdk8s.html#class-apiobjectmetadatadefinition","text":"Object metadata.","title":"class ApiObjectMetadataDefinition  "},{"location":"reference/cdk8s.html#initializer_1","text":"new ApiObjectMetadataDefinition ( options? : ApiObjectMetadata ) options ( ApiObjectMetadata ) No description annotations ( Map ) Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. Default : No annotations. labels ( Map ) Map of string keys and values that can be used to organize and categorize (scope and select) objects. Default : No labels. name ( string ) The unique, namespace-global, name of this object inside the Kubernetes cluster. Default : an app-unique name generated by the chart namespace ( string ) Namespace defines the space within each name must be unique. Default : undefined (will be assigned to the \u2018default\u2019 namespace)","title":"Initializer"},{"location":"reference/cdk8s.html#properties_1","text":"Name Type Description name ? string The name of the API object. Optional namespace ? string The object\u2019s namespace. Optional","title":"Properties"},{"location":"reference/cdk8s.html#methods_1","text":"","title":"Methods"},{"location":"reference/cdk8s.html#addkey-value","text":"Adds an arbitrary key/value to the object metadata. add ( key : string , value : any ) : void key ( string ) Metadata key. value ( any ) Metadata value.","title":"add(key, value) "},{"location":"reference/cdk8s.html#addannotationkey-value","text":"Add an annotation. addAnnotation ( key : string , value : string ) : void key ( string ) - The key. value ( string ) - The value.","title":"addAnnotation(key, value) "},{"location":"reference/cdk8s.html#addlabelkey-value","text":"Add a label. addLabel ( key : string , value : string ) : void key ( string ) - The key. value ( string ) - The value.","title":"addLabel(key, value) "},{"location":"reference/cdk8s.html#getlabelkey","text":"getLabel ( key : string ) : string key ( string ) the label. Returns : * string","title":"getLabel(key) "},{"location":"reference/cdk8s.html#tojson_1","text":"Synthesizes a k8s ObjectMeta for this metadata set. toJson () : any Returns : * any","title":"toJson() "},{"location":"reference/cdk8s.html#class-app","text":"Represents a cdk8s application. Implements : IConstruct Extends : Construct","title":"class App  "},{"location":"reference/cdk8s.html#initializer_2","text":"Defines an app. new App ( props? : AppProps ) props ( AppProps ) configuration options. outdir ( string ) The directory to output Kubernetes manifests. Default : CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d","title":"Initializer"},{"location":"reference/cdk8s.html#properties_2","text":"Name Type Description outdir string The output directory into which manifests will be synthesized.","title":"Properties"},{"location":"reference/cdk8s.html#methods_2","text":"","title":"Methods"},{"location":"reference/cdk8s.html#synth","text":"Synthesizes all manifests to the output directory. synth () : void","title":"synth() "},{"location":"reference/cdk8s.html#class-chart","text":"Implements : IConstruct Extends : Construct","title":"class Chart  "},{"location":"reference/cdk8s.html#initializer_3","text":"new Chart ( scope : Construct , id : string , props? : ChartProps ) scope ( Construct ) No description id ( string ) No description props ( ChartProps ) No description labels ( Map ) Labels to apply to all resources in this chart. Default : no common labels namespace ( string ) The default namespace for all objects defined in this chart (directly or indirectly). Default : no namespace is synthesized (usually this implies \u201cdefault\u201d)","title":"Initializer"},{"location":"reference/cdk8s.html#properties_3","text":"Name Type Description labels Map Labels applied to all resources in this chart. namespace ? string The default namespace for all objects in this chart. Optional","title":"Properties"},{"location":"reference/cdk8s.html#methods_3","text":"","title":"Methods"},{"location":"reference/cdk8s.html#adddependencydependencies_1","text":"Create a dependency between this Chart and other constructs. These can be other ApiObjects, Charts, or custom. addDependency (... dependencies : IConstruct []) : void dependencies ( IConstruct ) the dependencies to add.","title":"addDependency(...dependencies) "},{"location":"reference/cdk8s.html#generateobjectnameapiobject","text":"Generates a app-unique name for an object given it\u2019s construct node path. Different resource types may have different constraints on names ( metadata.name ). The previous version of the name generator was compatible with DNS_SUBDOMAIN but not with DNS_LABEL. For example, Deployment names must comply with DNS_SUBDOMAIN while Service names must comply with DNS_LABEL. Since there is no formal specification for this, the default name generation scheme for kubernetes objects in cdk8s was changed to DNS_LABEL, since it\u2019s the common denominator for all kubernetes resources (supposedly). You can override this method if you wish to customize object names at the chart level. generateObjectName ( apiObject : ApiObject ) : string apiObject ( ApiObject ) The API object to generate a name for. Returns : * string","title":"generateObjectName(apiObject) "},{"location":"reference/cdk8s.html#tojson_2","text":"Renders this chart to a set of Kubernetes JSON resources. toJson () : Array < any > Returns : * Array","title":"toJson() "},{"location":"reference/cdk8s.html#static-ofc_1","text":"Finds the chart in which a node is defined. static of ( c : IConstruct ) : Chart c ( IConstruct ) a construct node. Returns : * Chart","title":"static of(c) "},{"location":"reference/cdk8s.html#class-dependencygraph","text":"Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph.","title":"class DependencyGraph  "},{"location":"reference/cdk8s.html#initializer_4","text":"new DependencyGraph ( node : Node ) node ( Node ) No description","title":"Initializer"},{"location":"reference/cdk8s.html#properties_4","text":"Name Type Description root DependencyVertex Returns the root of the graph.","title":"Properties"},{"location":"reference/cdk8s.html#methods_4","text":"","title":"Methods"},{"location":"reference/cdk8s.html#topology","text":"topology () : Array < IConstruct > Returns : * Array< IConstruct >","title":"topology() "},{"location":"reference/cdk8s.html#class-dependencyvertex","text":"Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter.","title":"class DependencyVertex  "},{"location":"reference/cdk8s.html#initializer_5","text":"new DependencyVertex ( value? : IConstruct ) value ( IConstruct ) No description","title":"Initializer"},{"location":"reference/cdk8s.html#properties_5","text":"Name Type Description inbound Array< DependencyVertex > Returns the parents of the vertex (i.e dependants). outbound Array< DependencyVertex > Returns the children of the vertex (i.e dependencies). value ? IConstruct Returns the IConstruct this graph vertex represents. Optional","title":"Properties"},{"location":"reference/cdk8s.html#methods_5","text":"","title":"Methods"},{"location":"reference/cdk8s.html#addchilddep","text":"Adds a vertex as a dependency of the current node. Also updates the parents of dep , so that it contains this node as a parent. This operation will fail in case it creates a cycle in the graph. addChild ( dep : DependencyVertex ) : void dep ( DependencyVertex ) The dependency.","title":"addChild(dep) "},{"location":"reference/cdk8s.html#topology_1","text":"Returns a topologically sorted array of the constructs in the sub-graph. topology () : Array < IConstruct > Returns : * Array< IConstruct >","title":"topology() "},{"location":"reference/cdk8s.html#class-duration","text":"Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative.","title":"class Duration  "},{"location":"reference/cdk8s.html#methods_6","text":"","title":"Methods"},{"location":"reference/cdk8s.html#todaysopts","text":"Return the total number of days in this Duration. toDays ( opts? : TimeConversionOptions ) : number opts ( TimeConversionOptions ) No description integral ( boolean ) If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Default : true Returns : * number","title":"toDays(opts?) "},{"location":"reference/cdk8s.html#tohoursopts","text":"Return the total number of hours in this Duration. toHours ( opts? : TimeConversionOptions ) : number opts ( TimeConversionOptions ) No description integral ( boolean ) If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Default : true Returns : * number","title":"toHours(opts?) "},{"location":"reference/cdk8s.html#tohumanstring","text":"Turn this duration into a human-readable string. toHumanString () : string Returns : * string","title":"toHumanString() "},{"location":"reference/cdk8s.html#toisostring","text":"Return an ISO 8601 representation of this period. toIsoString () : string Returns : * string","title":"toIsoString() "},{"location":"reference/cdk8s.html#tomillisecondsopts","text":"Return the total number of milliseconds in this Duration. toMilliseconds ( opts? : TimeConversionOptions ) : number opts ( TimeConversionOptions ) No description integral ( boolean ) If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Default : true Returns : * number","title":"toMilliseconds(opts?) "},{"location":"reference/cdk8s.html#tominutesopts","text":"Return the total number of minutes in this Duration. toMinutes ( opts? : TimeConversionOptions ) : number opts ( TimeConversionOptions ) No description integral ( boolean ) If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Default : true Returns : * number","title":"toMinutes(opts?) "},{"location":"reference/cdk8s.html#tosecondsopts","text":"Return the total number of seconds in this Duration. toSeconds ( opts? : TimeConversionOptions ) : number opts ( TimeConversionOptions ) No description integral ( boolean ) If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Default : true Returns : * number","title":"toSeconds(opts?) "},{"location":"reference/cdk8s.html#static-daysamount","text":"Create a Duration representing an amount of days. static days ( amount : number ) : Duration amount ( number ) the amount of Days the Duration will represent. Returns : * Duration","title":"static days(amount) "},{"location":"reference/cdk8s.html#static-hoursamount","text":"Create a Duration representing an amount of hours. static hours ( amount : number ) : Duration amount ( number ) the amount of Hours the Duration will represent. Returns : * Duration","title":"static hours(amount) "},{"location":"reference/cdk8s.html#static-millisamount","text":"Create a Duration representing an amount of milliseconds. static millis ( amount : number ) : Duration amount ( number ) the amount of Milliseconds the Duration will represent. Returns : * Duration","title":"static millis(amount) "},{"location":"reference/cdk8s.html#static-minutesamount","text":"Create a Duration representing an amount of minutes. static minutes ( amount : number ) : Duration amount ( number ) the amount of Minutes the Duration will represent. Returns : * Duration","title":"static minutes(amount) "},{"location":"reference/cdk8s.html#static-parseduration","text":"Parse a period formatted according to the ISO 8601 standard. static parse ( duration : string ) : Duration duration ( string ) an ISO-formtted duration to be parsed. Returns : * Duration","title":"static parse(duration) "},{"location":"reference/cdk8s.html#static-secondsamount","text":"Create a Duration representing an amount of seconds. static seconds ( amount : number ) : Duration amount ( number ) the amount of Seconds the Duration will represent. Returns : * Duration","title":"static seconds(amount) "},{"location":"reference/cdk8s.html#class-helm","text":"Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs. Implements : IConstruct Extends : Include","title":"class Helm  "},{"location":"reference/cdk8s.html#initializer_6","text":"new Helm ( scope : Construct , id : string , props : HelmProps ) scope ( Construct ) No description id ( string ) No description props ( HelmProps ) No description chart ( string ) The chart name to use. It can be a chart from a helm repository or a local directory. helmExecutable ( string ) The local helm executable to use in order to create the manifest the chart. Default : \u201chelm\u201d helmFlags ( Array ) Additional flags to add to the helm execution. Default : [] releaseName ( string ) The release name. Default : if unspecified, a name will be allocated based on the construct path values ( Map ) Values to pass to the chart. Default : If no values are specified, chart will use the defaults.","title":"Initializer"},{"location":"reference/cdk8s.html#properties_6","text":"Name Type Description releaseName string The helm release name.","title":"Properties"},{"location":"reference/cdk8s.html#class-include","text":"Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest. Implements : IConstruct Extends : Construct","title":"class Include  "},{"location":"reference/cdk8s.html#initializer_7","text":"new Include ( scope : Construct , id : string , props : IncludeProps ) scope ( Construct ) No description id ( string ) No description props ( IncludeProps ) No description url ( string ) Local file path or URL which includes a Kubernetes YAML manifest.","title":"Initializer"},{"location":"reference/cdk8s.html#properties_7","text":"Name Type Description apiObjects Array< ApiObject > Returns all the included API objects.","title":"Properties"},{"location":"reference/cdk8s.html#class-jsonpatch","text":"Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc.","title":"class JsonPatch  "},{"location":"reference/cdk8s.html#methods_7","text":"","title":"Methods"},{"location":"reference/cdk8s.html#static-addpath-value","text":"Adds a value to an object or inserts it into an array. In the case of an array, the value is inserted before the given index. The - character can be used instead of an index to insert at the end of an array. static add ( path : string , value : any ) : JsonPatch path ( string ) No description value ( any ) No description Returns : * JsonPatch","title":"static add(path, value) "},{"location":"reference/cdk8s.html#static-applydocument-ops","text":"Applies a set of JSON-Patch (RFC-6902) operations to document and returns the result. static apply ( document : any , ... ops : JsonPatch []) : any document ( any ) The document to patch. ops ( JsonPatch ) The operations to apply. Returns : * any","title":"static apply(document, ...ops) "},{"location":"reference/cdk8s.html#static-copyfrom-path","text":"Copies a value from one location to another within the JSON document. Both from and path are JSON Pointers. static copy ( from : string , path : string ) : JsonPatch from ( string ) No description path ( string ) No description Returns : * JsonPatch","title":"static copy(from, path) "},{"location":"reference/cdk8s.html#static-movefrom-path","text":"Moves a value from one location to the other. Both from and path are JSON Pointers. static move ( from : string , path : string ) : JsonPatch from ( string ) No description path ( string ) No description Returns : * JsonPatch","title":"static move(from, path) "},{"location":"reference/cdk8s.html#static-removepath","text":"Removes a value from an object or array. static remove ( path : string ) : JsonPatch path ( string ) No description Returns : * JsonPatch","title":"static remove(path) "},{"location":"reference/cdk8s.html#static-replacepath-value","text":"Replaces a value. Equivalent to a \u201cremove\u201d followed by an \u201cadd\u201d. static replace ( path : string , value : any ) : JsonPatch path ( string ) No description value ( any ) No description Returns : * JsonPatch","title":"static replace(path, value) "},{"location":"reference/cdk8s.html#static-testpath-value","text":"Tests that the specified value is set in the document. If the test fails, then the patch as a whole should not apply. static test ( path : string , value : any ) : JsonPatch path ( string ) No description value ( any ) No description Returns : * JsonPatch","title":"static test(path, value) "},{"location":"reference/cdk8s.html#class-lazy","text":"","title":"class Lazy  "},{"location":"reference/cdk8s.html#methods_8","text":"","title":"Methods"},{"location":"reference/cdk8s.html#produce","text":"produce () : any Returns : * any","title":"produce() "},{"location":"reference/cdk8s.html#static-anyproducer","text":"static any ( producer : IAnyProducer ) : any producer ( IAnyProducer ) No description Returns : * any","title":"static any(producer) "},{"location":"reference/cdk8s.html#class-names","text":"Utilities for generating unique and stable names.","title":"class Names  "},{"location":"reference/cdk8s.html#methods_9","text":"","title":"Methods"},{"location":"reference/cdk8s.html#static-todnslabelscope-options","text":"Generates a unique and stable name compatible DNS_LABEL from RFC-1123 from a path. The generated name will: - contain at most 63 characters - contain only lowercase alphanumeric characters or \u2018-\u2019 - start with an alphanumeric character - end with an alphanumeric character The generated name will have the form: - -..- - Where are the path components (assuming they are is separated by \u201c/\u201d). Note that if the total length is longer than 63 characters, we will trim the first components since the last components usually encode more meaning. static toDnsLabel ( scope : Construct , options? : NameOptions ) : string scope ( Construct ) The construct for which to render the DNS label. options ( NameOptions ) Name options. delimiter ( string ) Delimiter to use between components. Default : \u201c-\u201c extra ( Array ) Extra components to include in the name. Default : [] use the construct path components includeHash ( boolean ) Include a short hash as last part of the name. Default : true maxLen ( number ) Maximum allowed length for the name. Default : 63 Returns : * string","title":"static toDnsLabel(scope, options?) "},{"location":"reference/cdk8s.html#static-tolabelvaluescope-options","text":"Generates a unique and stable name compatible label key name segment and label value from a path. The name segment is required and must be 63 characters or less, beginning and ending with an alphanumeric character ([a-z0-9A-Z]) with dashes (-), underscores (_), dots (.), and alphanumerics between. Valid label values must be 63 characters or less and must be empty or begin and end with an alphanumeric character ([a-z0-9A-Z]) with dashes (-), underscores (_), dots (.), and alphanumerics between. The generated name will have the form: .. Where are the path components (assuming they are is separated by \u201c/\u201d). Note that if the total length is longer than 63 characters, we will trim the first components since the last components usually encode more meaning. static toLabelValue ( scope : Construct , options? : NameOptions ) : string scope ( Construct ) The construct for which to render the DNS label. options ( NameOptions ) Name options. delimiter ( string ) Delimiter to use between components. Default : \u201c-\u201c extra ( Array ) Extra components to include in the name. Default : [] use the construct path components includeHash ( boolean ) Include a short hash as last part of the name. Default : true maxLen ( number ) Maximum allowed length for the name. Default : 63 Returns : * string","title":"static toLabelValue(scope, options?) "},{"location":"reference/cdk8s.html#class-size","text":"Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible.","title":"class Size  "},{"location":"reference/cdk8s.html#methods_10","text":"","title":"Methods"},{"location":"reference/cdk8s.html#togibibytesopts","text":"Return this storage as a total number of gibibytes. toGibibytes ( opts? : SizeConversionOptions ) : number opts ( SizeConversionOptions ) No description rounding ( SizeRoundingBehavior ) How conversions should behave when it encounters a non-integer result. Default : SizeRoundingBehavior.FAIL Returns : * number","title":"toGibibytes(opts?) "},{"location":"reference/cdk8s.html#tokibibytesopts","text":"Return this storage as a total number of kibibytes. toKibibytes ( opts? : SizeConversionOptions ) : number opts ( SizeConversionOptions ) No description rounding ( SizeRoundingBehavior ) How conversions should behave when it encounters a non-integer result. Default : SizeRoundingBehavior.FAIL Returns : * number","title":"toKibibytes(opts?) "},{"location":"reference/cdk8s.html#tomebibytesopts","text":"Return this storage as a total number of mebibytes. toMebibytes ( opts? : SizeConversionOptions ) : number opts ( SizeConversionOptions ) No description rounding ( SizeRoundingBehavior ) How conversions should behave when it encounters a non-integer result. Default : SizeRoundingBehavior.FAIL Returns : * number","title":"toMebibytes(opts?) "},{"location":"reference/cdk8s.html#topebibytesopts","text":"Return this storage as a total number of pebibytes. toPebibytes ( opts? : SizeConversionOptions ) : number opts ( SizeConversionOptions ) No description rounding ( SizeRoundingBehavior ) How conversions should behave when it encounters a non-integer result. Default : SizeRoundingBehavior.FAIL Returns : * number","title":"toPebibytes(opts?) "},{"location":"reference/cdk8s.html#totebibytesopts","text":"Return this storage as a total number of tebibytes. toTebibytes ( opts? : SizeConversionOptions ) : number opts ( SizeConversionOptions ) No description rounding ( SizeRoundingBehavior ) How conversions should behave when it encounters a non-integer result. Default : SizeRoundingBehavior.FAIL Returns : * number","title":"toTebibytes(opts?) "},{"location":"reference/cdk8s.html#static-gibibytesamount","text":"Create a Storage representing an amount gibibytes. 1 GiB = 1024 MiB static gibibytes ( amount : number ) : Size amount ( number ) No description Returns : * Size","title":"static gibibytes(amount) "},{"location":"reference/cdk8s.html#static-kibibytesamount","text":"Create a Storage representing an amount kibibytes. 1 KiB = 1024 bytes static kibibytes ( amount : number ) : Size amount ( number ) No description Returns : * Size","title":"static kibibytes(amount) "},{"location":"reference/cdk8s.html#static-mebibytesamount","text":"Create a Storage representing an amount mebibytes. 1 MiB = 1024 KiB static mebibytes ( amount : number ) : Size amount ( number ) No description Returns : * Size","title":"static mebibytes(amount) "},{"location":"reference/cdk8s.html#static-pebibyteamount","text":"Create a Storage representing an amount pebibytes. 1 PiB = 1024 TiB static pebibyte ( amount : number ) : Size amount ( number ) No description Returns : * Size","title":"static pebibyte(amount) "},{"location":"reference/cdk8s.html#static-tebibytesamount","text":"Create a Storage representing an amount tebibytes. 1 TiB = 1024 GiB static tebibytes ( amount : number ) : Size amount ( number ) No description Returns : * Size","title":"static tebibytes(amount) "},{"location":"reference/cdk8s.html#class-testing","text":"Testing utilities for cdk8s applications.","title":"class Testing  "},{"location":"reference/cdk8s.html#methods_11","text":"","title":"Methods"},{"location":"reference/cdk8s.html#static-app","text":"Returns an app for testing with the following properties: - Output directory is a temp dir. static app () : App Returns : * App","title":"static app() "},{"location":"reference/cdk8s.html#static-chart","text":"static chart () : Chart Returns : * Chart","title":"static chart() "},{"location":"reference/cdk8s.html#static-synthchart","text":"Returns the Kubernetes manifest synthesized from this chart. static synth ( chart : Chart ) : Array < any > chart ( Chart ) No description Returns : * Array","title":"static synth(chart) "},{"location":"reference/cdk8s.html#class-yaml","text":"YAML utilities.","title":"class Yaml  "},{"location":"reference/cdk8s.html#methods_12","text":"","title":"Methods"},{"location":"reference/cdk8s.html#static-loadurlorfile","text":"Downloads a set of YAML documents (k8s manifest for example) from a URL or a file and returns them as javascript objects. Empty documents are filtered out. static load ( urlOrFile : string ) : Array < any > urlOrFile ( string ) a URL of a file path to load from. Returns : * Array","title":"static load(urlOrFile) "},{"location":"reference/cdk8s.html#static-savefilepath-docs","text":"Saves a set of objects as a multi-document YAML file. static save ( filePath : string , docs : Array < any > ) : void filePath ( string ) The output path. docs ( Array ) The set of objects.","title":"static save(filePath, docs) "},{"location":"reference/cdk8s.html#static-stringifydoc","text":"Stringify a document into yaml. static stringify ( doc : any ) : string doc ( any ) An object. Returns : * string","title":"static stringify(doc) "},{"location":"reference/cdk8s.html#static-tmpdocs","text":"Saves a set of YAML documents into a temp file (in /tmp). static tmp ( docs : Array < any > ) : string docs ( Array ) the set of documents to save. Returns : * string","title":"static tmp(docs) "},{"location":"reference/cdk8s.html#struct-apiobjectmetadata","text":"Metadata associated with this object. Name Type Description annotations ? Map Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. Default : No annotations. labels ? Map Map of string keys and values that can be used to organize and categorize (scope and select) objects. Default : No labels. name ? string The unique, namespace-global, name of this object inside the Kubernetes cluster. Default : an app-unique name generated by the chart namespace ? string Namespace defines the space within each name must be unique. Default : undefined (will be assigned to the \u2018default\u2019 namespace)","title":"struct ApiObjectMetadata  "},{"location":"reference/cdk8s.html#struct-apiobjectprops","text":"Options for defining API objects. Name Type Description apiVersion string API version. kind string Resource kind. metadata ? ApiObjectMetadata Object metadata. Optional","title":"struct ApiObjectProps  "},{"location":"reference/cdk8s.html#struct-appprops","text":"Name Type Description outdir ? string The directory to output Kubernetes manifests. Default : CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d","title":"struct AppProps  "},{"location":"reference/cdk8s.html#struct-chartprops","text":"Name Type Description labels ? Map Labels to apply to all resources in this chart. Default : no common labels namespace ? string The default namespace for all objects defined in this chart (directly or indirectly). Default : no namespace is synthesized (usually this implies \u201cdefault\u201d)","title":"struct ChartProps  "},{"location":"reference/cdk8s.html#struct-groupversionkind","text":"Name Type Description apiVersion string The object\u2019s API version (e.g. authorization.k8s.io/v1 ). kind string The object kind.","title":"struct GroupVersionKind  "},{"location":"reference/cdk8s.html#struct-helmprops","text":"Options for Helm . Name Type Description chart string The chart name to use. It can be a chart from a helm repository or a local directory. helmExecutable ? string The local helm executable to use in order to create the manifest the chart. Default : \u201chelm\u201d helmFlags ? Array Additional flags to add to the helm execution. Default : [] releaseName ? string The release name. Default : if unspecified, a name will be allocated based on the construct path values ? Map Values to pass to the chart. Default : If no values are specified, chart will use the defaults.","title":"struct HelmProps  "},{"location":"reference/cdk8s.html#interface-ianyproducer","text":"","title":"interface IAnyProducer  "},{"location":"reference/cdk8s.html#methods_13","text":"","title":"Methods"},{"location":"reference/cdk8s.html#produce_1","text":"produce () : any Returns : * any","title":"produce() "},{"location":"reference/cdk8s.html#struct-includeprops","text":"Name Type Description url string Local file path or URL which includes a Kubernetes YAML manifest.","title":"struct IncludeProps  "},{"location":"reference/cdk8s.html#struct-nameoptions","text":"Options for name generation. Name Type Description delimiter ? string Delimiter to use between components. Default : \u201c-\u201c extra ? Array Extra components to include in the name. Default : [] use the construct path components includeHash ? boolean Include a short hash as last part of the name. Default : true maxLen ? number Maximum allowed length for the name. Default : 63","title":"struct NameOptions  "},{"location":"reference/cdk8s.html#struct-sizeconversionoptions","text":"Options for how to convert time to a different unit. Name Type Description rounding ? SizeRoundingBehavior How conversions should behave when it encounters a non-integer result. Default : SizeRoundingBehavior.FAIL","title":"struct SizeConversionOptions  "},{"location":"reference/cdk8s.html#struct-timeconversionoptions","text":"Options for how to convert time to a different unit. Name Type Description integral ? boolean If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Default : true","title":"struct TimeConversionOptions  "},{"location":"reference/cdk8s.html#enum-sizeroundingbehavior","text":"Rounding behaviour when converting between units of Size . Name Description FAIL Fail the conversion if the result is not an integer. FLOOR If the result is not an integer, round it to the closest integer less than the result. NONE Don\u2019t round.","title":"enum SizeRoundingBehavior  "}]}