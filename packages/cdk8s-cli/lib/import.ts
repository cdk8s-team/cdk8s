import * as https from 'https';
import * as fs from 'fs-extra';
import * as path from 'path';
import { promises } from 'fs';
import { emitConstructForApiObject, findApiObjectDefinitions, selectApiObjects } from '../lib/codegen-constructs';
import { CodeMaker } from 'codemaker';
import { JSONSchema4 } from 'json-schema';
import { TypeGenerator } from './codegen-types';
import { withTempDir, shell } from './util';
import { jsiiCompile } from './jsii';

export const DEFAULT_API_VERSION = '1.14.0';

export enum Language {
  TYPESCRIPT = 'typescript',
  PYTHON = 'python',
  DOTNET = 'dotnet',
  JAVA = 'java',
}

export const LANGUAGES = [ Language.TYPESCRIPT, Language.PYTHON ];

export interface Options {
  /**
   * Output programming language.
   */
  readonly language: Language;

  /**
   * The API version to generate.
   */
  readonly apiVersion?: string;

  /**
   * FQNs of API object types to select instead of selecting the latest stable
   * version.
   * 
   * @default - selects the latest stable version from each API object
   */
  readonly include?: string[];

  /**
   * Do not import these types. Instead, represent them as "any".
   * 
   * @default - include all types that derive from the root types.
   */
  readonly exclude?: string[];
}

export async function generateAllApiObjects(outdir: string, options: Options) {
  outdir = path.resolve(outdir);

  if (options.language === Language.TYPESCRIPT) {
    await generateApiObjectsTypeScript(outdir, options);
    console.log(`${outdir}/k8s.ts`);
    return;
  }

  // this is not typescript, so we generate in a staging directory and harvest the code
  await withTempDir('k8s', async () => {
    await generateApiObjectsTypeScript('.', options);
    await jsiiCompile('.');

    const pacmak = require.resolve('jsii-pacmak/bin/jsii-pacmak');
    await shell(pacmak, [ '--target', options.language, '--code-only' ]);
    await harvestCode(options.language, outdir);
  });
}

async function harvestCode(language: Language, outdir: string) {
  switch (language) {
    case Language.TYPESCRIPT:
      throw new Error('no op for typescript');

    case Language.PYTHON:
      await harvestPython();
      break;

    default:
      throw new Error(`unsupported language ${language} (yet)`);
  }

  async function harvestPython() {
    const target = path.join(outdir, 'k8s');
    await fs.move('dist/python/src/k8s', target, { overwrite: true });
    console.error(target);
  }
}

async function generateApiObjectsTypeScript(outdir: string, options: Options) {
  const code = new CodeMaker();
  code.indentation = 2;

  const schema = await downloadSchema(options.apiVersion ?? DEFAULT_API_VERSION);
  const map = findApiObjectDefinitions(schema);

  const topLevelObjects = selectApiObjects(map, { include: options.include });

  code.openFile('k8s.ts');
  code.line(`// generated by cdk8s`);
  code.line(`import { ApiObject } from 'cdk8s';`);
  code.line(`import { Construct } from '@aws-cdk/core';`);
  code.line();

  const typeGenerator = new TypeGenerator(schema, { exclude: options.exclude });

  for (const o of topLevelObjects) {
    emitConstructForApiObject(code, typeGenerator, o);
  }

  typeGenerator.generate(code);

  code.closeFile('k8s.ts');

  await promises.mkdir(outdir, { recursive: true });
  await code.save(outdir);  
}

async function downloadSchema(apiVersion: string) {
  const output = await httpsGet(`https://kubernetesjsonschema.dev/v${apiVersion}/_definitions.json`);
  return JSON.parse(output) as JSONSchema4;
}

async function httpsGet(url: string): Promise<string> {
  return new Promise((ok, ko) => {
    const req = https.get(url, res => {
      if (res.statusCode !== 200) {
        throw new Error(`${res.statusMessage}: ${url}`);
      }
      const data = new Array<Buffer>();
      res.on('data', chunk => data.push(chunk));
      res.once('end', () => ok(Buffer.concat(data).toString('utf-8')));
      res.once('error', ko);
    });

    req.once('error', ko);
    req.end();
  });
}
