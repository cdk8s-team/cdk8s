import { sanitizeValue } from './_util';
import { Construct, Node, IConstruct } from 'constructs';

// the id of the Metadata construct added to scopes in which metadata is defined.
const id = '$cdk8s.Metadata';

type Map = Record<string, string | undefined>;

/**
 * Metadata associated with this object.
 */
export interface ApiObjectMetadata {
  /**
   * The unique, namespace-global, name of this object inside the Kubernetes
   * cluster.
   *
   * Normally, you shouldn't specify names for objects and let the CDK generate
   * a name for you that is application-unique. The names CDK generates are
   * composed from the construct path components, separated by dots and a suffix
   * that is based on a hash of the entire path, to ensure uniqueness.
   *
   * You can supply custom name allocation logic by overriding the
   * `chart.generateObjectName` method.
   *
   * If you use an explicit name here, bear in mind that this reduces the
   * composability of your construct because it won't be possible to include
   * more than one instance in any app. Therefore it is highly recommended to
   * leave this unspecified.
   *
   * @default - an app-unique name generated by the chart
   */
  readonly name?: string;

  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be
   * preserved when modifying objects.
   *
   * @see http://kubernetes.io/docs/user-guide/annotations
   * @default - No annotations.
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects.
   * May match selectors of replication controllers and services.
   *
   * @see http://kubernetes.io/docs/user-guide/labels
   * @default - No labels.
   */
  readonly labels?: { [key: string]: string };

  /**
   * Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation.
   * Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
   *
   * @default undefined (will be assigned to the 'default' namespace)
   */
  readonly namespace?: string;

  /**
   * Additional metadata attributes.
   */
  readonly [key: string]: any;
}

/**
 * Scope-wide k8s metadata.
 *
 * Metadata is applied top-down. This means that API-object-level metadata will
 * override any metadata specified by it's parent, etc.
 *
  * @example For example, if you wish all API objects within a construct subtree
 * to have a set of labels:
 *
 * Metadata.of(scope).addLabels({
 *   app: 'my-app',
 *   foo: 'bar'
 * });
 */
export class Metadata extends Construct {
  /**
   * Returns a `Metadata` object associated with a specific scope.
   * @param scope The construct scope
   */
  public static of(scope: IConstruct): Metadata {
    return this.tryGetMetadata(scope) ?? new Metadata(scope as Construct, id);
  }

  /**
   * Returns the resolved metadata for a scope by looking up metadata defined
   * for this scope or parent scopes.
   *
   * @param scope The scope to resolve for.
   */
  public static resolve(scope: IConstruct): ApiObjectMetadata {
    const sanitize = (x: any) => sanitizeValue(x, { filterEmptyArrays: true, filterEmptyObjects: true });

    return sanitize({
      namespace: this.resolveNamespace(scope),
      labels: this.resolveLabels(scope),
      annotations: this.resolveAnnotations(scope),
    });
  }

  /**
   * Resolves the namespace that should be used for a specific scope.
   * @param scope The scope to resolve for
   */
  private static resolveNamespace(scope?: IConstruct): string | undefined {
    if (!scope) { return undefined; }

    const resolved = this.tryGetMetadata(scope)?.namespace ?? this.resolveNamespace(Node.of(scope).scope);

    // if we resolve to an empty string, then it means the namespace was deleted
    // so return "undefined".
    return resolved !== '' ? resolved : undefined;
  }

  /**
   * Resolves the labels which should be applied to a scope by merging all
   * labels from parent scopes.
   *
   * @param scope The scope to resolve for
   */
  private static resolveLabels(scope?: IConstruct): Record<string, string> {
    if (!scope) { return { }; }

    return filterUndefined({
      ...this.resolveLabels(Node.of(scope).scope),
      ...this.tryGetMetadata(scope)?.labels,
    });
  }

  private static resolveAnnotations(scope?: IConstruct): Record<string, string> {
    if (!scope) { return { }; }
    return filterUndefined({
      ...this.resolveAnnotations(Node.of(scope).scope),
      ...this.tryGetMetadata(scope)?.annotations,
    })
  }

  private static tryGetMetadata(scope: IConstruct): Metadata | undefined {
    return Node.of(scope).tryFindChild(id) as Metadata | undefined;
  }

  private labels?: Map;
  private namespace?: string;
  private annotations?: Map;

  /**
   * Additional metadata attributes passed through `options`.
   */
  private readonly _additionalAttributes: { [key: string]: any };

  private constructor(scope: Construct, id: string) {
    super(scope, id);

    this._additionalAttributes = { };
  }

  /**
   * Adds a labels to all the API objects within a scope.
   *
   * These labels will be added to all API objects within this scope unless the
   * same label is set within a narrower scope or at the API object itself.
   *
   * If the value is set to `undefined` the label is removed from the scope &
   * all API objects (equivalent to `removeLabel`).
   *
   * @param name The name of the label
   * @param value The value of the label, or `undefined` to remove the label
   * from the scope.
   */
  public addLabel(name: string, value: string | undefined) {
    // merge with existing
    this.labels = sortByKey({
      ...this.labels,
      [name]: value,
    });
  }

  /**
   * Removes a label from all API objects within the scope.
   *
   * @param label The label to remove
   */
  public removeLabel(label: string) {
    this.addLabel(label, undefined);
  }

  /**
   * Adds multiple labels to this scope.
   * 
   * @param labels The labels to add.
   */
  public addLabels(labels: { [name: string]: string }) {
    for (const [n, v] of Object.entries(labels)) {
      this.addLabel(n, v);
    }
  }

  /**
   * Adds an annotation to all API objects within this scope.
   * 
   * @param name The annotation
   * @param value Annotation value
   */
  public addAnnotation(name: string, value: string | undefined) {
    this.annotations = sortByKey({
      ...this.annotations,
      [name]: value,
    })
  }

  /**
   * Removes an annotation from all API objects within the scope.
   * 
   * @param name The annotation to remove
   */
  public removeAnnotation(name: string) {
    this.addAnnotation(name, undefined);
  }

  /**
   * Adds multiple annotations to this scope.
   * 
   * @param annotations Annotations to add.
   */
  public addAnnotations(annotations: { [name: string]: string }) {
    for (const [name, value] of Object.entries(annotations)) {
      this.addAnnotation(name, value);
    }
  }

  /**
   * Sets the namespace for this scope.
   *
   * All API objects within this scope will use this scope will use this
   * namespace unless a namespace is defined within a narrower scope (or at the
   * API object itself).
   */
  public addNamespace(value: string | undefined) {
    // treat undefined as an empty string, which represents a "deleted" namespace
    if (value === undefined) {
      value = '';
    }

    this.namespace  = value;
  }

  /**
   * Clears the namespace definition from the scope and all API objects within
   * this scope.
   */
  public removeNamespace() {
    this.addNamespace(undefined);
  }

  /**
   * Adds an arbitrary key/value to the object metadata.
   * @param key Metadata key
   * @param value Metadata value
   */
  public add(key: string, value: any) {
    this._additionalAttributes[key] = value;
  }
}

function sortByKey(obj: Map): Map {
  const result: Map = {};
  for (const key of Object.keys(obj).sort()) {
    result[key] = obj[key];
  }
  return result;
}

function filterUndefined(obj: Map): Record<string, string> {
  const result: Record<string, string> = { };
  for (const [ n, v ] of Object.entries(obj)) {
    if (v === undefined) { continue; }
    result[n] = v;
  }

  return result;
}